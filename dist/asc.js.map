{"version":3,"sources":["webpack://asc/webpack/universalModuleDefinition","webpack://asc/webpack/bootstrap","webpack://asc/external \"assemblyscript\"","webpack://asc/../node_modules/browser-process-hrtime/index.js","webpack://asc/../node_modules/near-bindgen-as/index.js","webpack://asc/../node_modules/node-libs-browser/mock/process.js","webpack://asc/../node_modules/path-browserify/index.js","webpack://asc/../node_modules/webpack/buildin/global.js","webpack://asc/. sync","webpack://asc/./asc.js","webpack://asc/./util/colors.js","webpack://asc/./util/find.js","webpack://asc/./util/mkdirp.js","webpack://asc/./util/options.js","webpack://asc/./util/utf8.js"],"names":[],"mappings":"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;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,oBAAoB;AAC9B;AACA;;AAEA;AACA,UAAU,UAAU;AACpB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,sBAAsB;AACrD;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7SA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA,6C;;;;;;;;;;;;ACRA,uDAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+CAA+C,YAAY;;AAE3D,WAAW,mBAAO,CAAC,2DAAI;AACvB,aAAa,mBAAO,CAAC,sDAAM;AAC3B,aAAa,mBAAO,CAAC,mCAAa;AAClC,mBAAmB,mBAAO,CAAC,uCAAe;AAC1C,oBAAoB,mBAAO,CAAC,yCAAgB;AAC5C,eAAe,mBAAO,CAAC,uCAAe;AACtC,aAAa,mBAAO,CAAC,mCAAa;AAClC;AACA;AACA,qBAAqB,mBAAO,CAAC,iEAAiB;;AAE9C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,qBAAqB,mBAAO,CAAC,4DAA2B;AACxD,GAAG;AACH,SAAS;AACT,MAAM,mBAAO,CAAC,iIAAS;AACvB,2BAA2B,GAAS;AACpC;AACA,0BAA0B;AAC1B,OAAO;AACP,MAAM,mBAAO,CAAC,wIAAgB;AAC9B,uBAAuB,mBAAO,CAAC,gIAAQ;AACvC;AACA,KAAK;AACL,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,mBAAmB,QAAqB;;AAExC;AACA;;AAEA;AACA,qCAAqC,OAAc,GAAG,mBAAO,CAAC,yIAAiB;;AAE/E;AACA,kBAAkB,mBAAO,CAAC,8BAAY;;AAEtC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,0CAA0C,m84gBAAc,WAAW;AACnE,2BAA2B,GAAS;AACpC;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,6CAA6C,q0/GAAkB,WAAW;AAC1E,2BAA2B,GAAS;AACpC;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA,QAAQ,mBAAO,CAAC,iIAAS,YAAY,2DAA2D,mBAAmB,EAAE;AACrH;AACA;AACA;AACA,8BAA8B,yCAAQ,wCAAO,oBAAoB,kCAAkC,CAAC,CAAC;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT,yCAAyC;AACzC;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO,OAAO;AAC3D;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B;AAC1B,0BAA0B;;AAE1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO,OAAO;AACd;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,uFAAuF;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8FAA8F,QAAQ;AACtG;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,kCAAkC,OAAO;AACzC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,mBAAmB;;AAE3C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,mBAAmB;AACzD,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,mBAAmB;AACvF,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mBAAmB;AACnD,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,sCAAsC,mBAAO,CAAC,+EAAwB;;AAEtE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,gDAAgD,+BAA+B;AAC/E,mBAAmB;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AChlCA;AACA,wCAAwC;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7BA,WAAW,mBAAO,CAAC,2DAAI;AACvB,aAAa,mBAAO,CAAC,sDAAM;;AAE3B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;;;;;;;;;;;;AClBA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,mBAAO,CAAC,sDAAM;AACzB,SAAS,mBAAO,CAAC,2DAAI;AACrB;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,mDAAmD,OAAO;AAC1D;AACA,sBAAsB,KAAK,OAAO;AAClC,8CAA8C,GAAG;AACjD;AACA,kDAAkD;AAClD,kCAAkC;AAClC;AACA;AACA,OAAO,6BAA6B;AACpC;AACA;AACA;AACA,KAAK;AACL,8DAA8D;AAC9D,YAAY,qBAAqB,UAAU,EAAE;AAC7C;AACA;AACA,0EAA0E;AAC1E;AACA,qEAAqE;AACrE;AACA,6DAA6D;AAC7D,0FAA0F;AAC1F,2DAA2D;AAC3D,wFAAwF;AACxF,uDAAuD;AACvD,uFAAuF;AACvF,uCAAuC;AACvC;AACA,SAAS,OAAO;AAChB;AACA;AACA,yDAAyD;AACzD,0DAA0D;AAC1D;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,yCAAyC;;AAEzC,UAAU;AACV;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,aAAa;AACpC;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;;AAEA;;;;;;;;;;;;AC3GA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,WAAW;AACtB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA,WAAW;AACX,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA","file":"asc.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"assemblyscript\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"assemblyscript\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"asc\"] = factory(require(\"assemblyscript\"));\n\telse\n\t\troot[\"asc\"] = factory(root[\"assemblyscript\"]);\n})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE__dist_assemblyscript_js__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__dist_assemblyscript_js__;","module.exports = process.hrtime || hrtime\n\n// polyfil for window.performance.now\nvar performance = global.performance || {}\nvar performanceNow =\n  performance.now        ||\n  performance.mozNow     ||\n  performance.msNow      ||\n  performance.oNow       ||\n  performance.webkitNow  ||\n  function(){ return (new Date()).getTime() }\n\n// generate timestamp or delta\n// see http://nodejs.org/api/process.html#process_process_hrtime\nfunction hrtime(previousTimestamp){\n  var clocktime = performanceNow.call(performance)*1e-3\n  var seconds = Math.floor(clocktime)\n  var nanoseconds = Math.floor((clocktime%1)*1e9)\n  if (previousTimestamp) {\n    seconds = seconds - previousTimestamp[0]\n    nanoseconds = nanoseconds - previousTimestamp[1]\n    if (nanoseconds<0) {\n      seconds--\n      nanoseconds += 1e9\n    }\n  }\n  return [seconds,nanoseconds]\n}","!function(t,e){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=e(require(\"assemblyscript\")):\"function\"==typeof define&&define.amd?define([\"assemblyscript\"],e):\"object\"==typeof exports?exports.transformer=e(require(\"assemblyscript\")):t.transformer=e(t.assemblyscript)}(\"undefined\"!=typeof self?self:this,(function(t){return function(t){var e={};function i(s){if(e[s])return e[s].exports;var n=e[s]={i:s,l:!1,exports:{}};return t[s].call(n.exports,n,n.exports,i),n.l=!0,n.exports}return i.m=t,i.c=e,i.d=function(t,e,s){i.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:s})},i.r=function(t){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(t,\"__esModule\",{value:!0})},i.t=function(t,e){if(1&e&&(t=i(t)),8&e)return t;if(4&e&&\"object\"==typeof t&&t&&t.__esModule)return t;var s=Object.create(null);if(i.r(s),Object.defineProperty(s,\"default\",{enumerable:!0,value:t}),2&e&&\"string\"!=typeof t)for(var n in t)i.d(s,n,function(e){return t[e]}.bind(null,n));return s},i.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return i.d(e,\"a\",e),e},i.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},i.p=\"\",i(i.s=3)}([function(t,e,i){\"use strict\";function s(t){for(var i in t)e.hasOwnProperty(i)||(e[i]=t[i])}Object.defineProperty(e,\"__esModule\",{value:!0}),s(i(1)),s(i(4))},function(e,i){e.exports=t},function(t,e,i){\"use strict\";var s,n=this&&this.__extends||(s=function(t,e){return(s=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i])})(t,e)},function(t,e){function i(){this.constructor=t}s(t,e),t.prototype=null===e?Object.create(e):(i.prototype=e.prototype,new i)}),r=this&&this.__values||function(t){var e=\"function\"==typeof Symbol&&Symbol.iterator,i=e&&t[e],s=0;if(i)return i.call(t);if(t&&\"number\"==typeof t.length)return{next:function(){return t&&s>=t.length&&(t=void 0),{value:t&&t[s++],done:!t}}};throw new TypeError(e?\"Object is not iterable.\":\"Symbol.iterator is not defined.\")};Object.defineProperty(e,\"__esModule\",{value:!0});var o=i(1),a=function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.depth=0,e}return n(e,t),e.prototype._visit=function(t){switch(t.kind){case o.NodeKind.SOURCE:this.visitSource(t);break;case o.NodeKind.NAMEDTYPE:this.visitNamedTypeNode(t);break;case o.NodeKind.FUNCTIONTYPE:this.visitFunctionTypeNode(t);break;case o.NodeKind.TYPENAME:this.visitTypeName(t);case o.NodeKind.TYPEPARAMETER:this.visitTypeParameter(t);break;case o.NodeKind.FALSE:case o.NodeKind.NULL:case o.NodeKind.SUPER:case o.NodeKind.THIS:case o.NodeKind.TRUE:case o.NodeKind.CONSTRUCTOR:case o.NodeKind.IDENTIFIER:this.visitIdentifierExpression(t);break;case o.NodeKind.ASSERTION:this.visitAssertionExpression(t);break;case o.NodeKind.BINARY:this.visitBinaryExpression(t);break;case o.NodeKind.CALL:this.visitCallExpression(t);break;case o.NodeKind.CLASS:this.visitClassExpression(t);break;case o.NodeKind.COMMA:this.visitCommaExpression(t);break;case o.NodeKind.ELEMENTACCESS:this.visitElementAccessExpression(t);break;case o.NodeKind.FUNCTION:this.visitFunctionExpression(t);break;case o.NodeKind.INSTANCEOF:this.visitInstanceOfExpression(t);break;case o.NodeKind.LITERAL:this.visitLiteralExpression(t);break;case o.NodeKind.NEW:this.visitNewExpression(t);break;case o.NodeKind.PARENTHESIZED:this.visitParenthesizedExpression(t);break;case o.NodeKind.PROPERTYACCESS:this.visitPropertyAccessExpression(t);break;case o.NodeKind.TERNARY:this.visitTernaryExpression(t);break;case o.NodeKind.UNARYPOSTFIX:this.visitUnaryPostfixExpression(t);break;case o.NodeKind.UNARYPREFIX:this.visitUnaryPrefixExpression(t);break;case o.NodeKind.BLOCK:this.visitBlockStatement(t);break;case o.NodeKind.BREAK:this.visitBreakStatement(t);break;case o.NodeKind.CONTINUE:this.visitContinueStatement(t);break;case o.NodeKind.DO:this.visitDoStatement(t);break;case o.NodeKind.EMPTY:this.visitEmptyStatement(t);break;case o.NodeKind.EXPORT:this.visitExportStatement(t);break;case o.NodeKind.EXPORTDEFAULT:this.visitExportDefaultStatement(t);break;case o.NodeKind.EXPORTIMPORT:this.visitExportImportStatement(t);break;case o.NodeKind.EXPRESSION:this.visitExpressionStatement(t);break;case o.NodeKind.FOR:this.visitForStatement(t);break;case o.NodeKind.IF:this.visitIfStatement(t);break;case o.NodeKind.IMPORT:this.visitImportStatement(t);break;case o.NodeKind.RETURN:this.visitReturnStatement(t);break;case o.NodeKind.SWITCH:this.visitSwitchStatement(t);break;case o.NodeKind.THROW:this.visitThrowStatement(t);break;case o.NodeKind.TRY:this.visitTryStatement(t);break;case o.NodeKind.VARIABLE:this.visitVariableStatement(t);break;case o.NodeKind.WHILE:this.visitWhileStatement(t);break;case o.NodeKind.CLASSDECLARATION:this.visitClassDeclaration(t);break;case o.NodeKind.ENUMDECLARATION:this.visitEnumDeclaration(t);break;case o.NodeKind.ENUMVALUEDECLARATION:this.visitEnumValueDeclaration(t);break;case o.NodeKind.FIELDDECLARATION:this.visitFieldDeclaration(t);break;case o.NodeKind.FUNCTIONDECLARATION:this.visitFunctionDeclaration(t);break;case o.NodeKind.IMPORTDECLARATION:this.visitImportDeclaration(t);break;case o.NodeKind.INDEXSIGNATUREDECLARATION:this.visitIndexSignatureDeclaration(t);break;case o.NodeKind.INTERFACEDECLARATION:this.visitInterfaceDeclaration(t);break;case o.NodeKind.METHODDECLARATION:this.visitMethodDeclaration(t);break;case o.NodeKind.NAMESPACEDECLARATION:this.visitNamespaceDeclaration(t);break;case o.NodeKind.TYPEDECLARATION:this.visitTypeDeclaration(t);break;case o.NodeKind.VARIABLEDECLARATION:this.visitVariableDeclaration(t);break;case o.NodeKind.DECORATOR:this.visitDecoratorNode(t);break;case o.NodeKind.EXPORTMEMBER:this.visitExportMember(t);break;case o.NodeKind.PARAMETER:this.visitParameter(t);break;case o.NodeKind.SWITCHCASE:this.visitSwitchCase(t);break;default:assert(!1)}},e.prototype.visitSource=function(t){var e,i;try{for(var s=r(t.statements),n=s.next();!n.done;n=s.next()){var o=n.value;this.depth++,this.visit(o),this.depth--}}catch(t){e={error:t}}finally{try{n&&!n.done&&(i=s.return)&&i.call(s)}finally{if(e)throw e.error}}},e.prototype.visitTypeNode=function(t){},e.prototype.visitTypeName=function(t){this.visit(t.identifier),t.next&&this.visit(t.next)},e.prototype.visitNamedTypeNode=function(t){this.visit(t.name),this.visit(t.typeArguments)},e.prototype.visitFunctionTypeNode=function(t){var e,i;try{for(var s=r(t.parameters),n=s.next();!n.done;n=s.next()){var o=n.value;this.visit(o)}}catch(t){e={error:t}}finally{try{n&&!n.done&&(i=s.return)&&i.call(s)}finally{if(e)throw e.error}}this.visit(t.returnType)},e.prototype.visitTypeParameter=function(t){this.visit(t.name),t.extendsType&&this.visit(t.extendsType),t.defaultType&&this.visit(t.defaultType)},e.prototype.visitIdentifierExpression=function(t){},e.prototype.visitArrayLiteralExpression=function(t){var e=this;t.elementExpressions.map((function(t){t&&e.visit(t)}))},e.prototype.visitObjectLiteralExpression=function(t){if(t.values&&t.names){assert(t.values.length==t.names.length);for(var e=0;e<t.values.length;e++)this.visit(t.names[e]),this.visit(t.values[e])}},e.prototype.visitAssertionExpression=function(t){t.toType&&this.visit(t.toType),this.visit(t.expression)},e.prototype.visitBinaryExpression=function(t){this.visit(t.left),this.visit(t.right)},e.prototype.visitCallExpression=function(t){this.visit(t.expression),this.visit(t.typeArguments),this.visit(t.arguments)},e.prototype.visitClassExpression=function(t){this.visit(t.declaration)},e.prototype.visitCommaExpression=function(t){this.visit(t.expressions)},e.prototype.visitElementAccessExpression=function(t){this.visit(t.elementExpression),this.visit(t.expression)},e.prototype.visitFunctionExpression=function(t){this.visit(t.declaration)},e.prototype.visitLiteralExpression=function(t){},e.prototype.visitFloatLiteralExpression=function(t){},e.prototype.visitInstanceOfExpression=function(t){this.visit(t.expression),this.visit(t.isType)},e.prototype.visitIntegerLiteralExpression=function(t){},e.prototype.visitStringLiteral=function(t,e){},e.prototype.visitStringLiteralExpression=function(t){},e.prototype.visitRegexpLiteralExpression=function(t){},e.prototype.visitNewExpression=function(t){this.visit(t.expression),this.visit(t.typeArguments),this.visit(t.arguments)},e.prototype.visitParenthesizedExpression=function(t){this.visit(t.expression)},e.prototype.visitPropertyAccessExpression=function(t){this.visit(t.property),this.visit(t.expression)},e.prototype.visitTernaryExpression=function(t){this.visit(t.condition),this.visit(t.ifThen),this.visit(t.ifElse)},e.prototype.visitUnaryExpression=function(t){this.visit(t.operand)},e.prototype.visitUnaryPostfixExpression=function(t){this.visit(t.operand)},e.prototype.visitUnaryPrefixExpression=function(t){this.visit(t.operand)},e.prototype.visitSuperExpression=function(t){},e.prototype.visitFalseExpression=function(t){},e.prototype.visitTrueExpression=function(t){},e.prototype.visitThisExpression=function(t){},e.prototype.visitNullExperssion=function(t){},e.prototype.visitConstructorExpression=function(t){},e.prototype.visitNodeAndTerminate=function(t){},e.prototype.visitBlockStatement=function(t){this.depth++,this.visit(t.statements),this.depth--},e.prototype.visitBreakStatement=function(t){t.label&&this.visit(t.label)},e.prototype.visitContinueStatement=function(t){t.label&&this.visit(t.label)},e.prototype.visitClassDeclaration=function(t,e){this.visit(t.name),this.depth++,this.visit(t.decorators),assert(t.isGeneric?null!=t.typeParameters:null==t.typeParameters),t.isGeneric&&this.visit(t.typeParameters),t.extendsType&&this.visit(t.extendsType),this.visit(t.implementsTypes),this.visit(t.members),this.depth--},e.prototype.visitDoStatement=function(t){this.visit(t.condition),this.visit(t.statement)},e.prototype.visitEmptyStatement=function(t){},e.prototype.visitEnumDeclaration=function(t,e){this.visit(t.name),this.visit(t.decorators),this.visit(t.values)},e.prototype.visitEnumValueDeclaration=function(t){this.visit(t.name),t.initializer&&this.visit(t.initializer)},e.prototype.visitExportImportStatement=function(t){this.visit(t.name),this.visit(t.externalName)},e.prototype.visitExportMember=function(t){this.visit(t.localName),this.visit(t.exportedName)},e.prototype.visitExportStatement=function(t){t.path&&this.visit(t.path),this.visit(t.members)},e.prototype.visitExportDefaultStatement=function(t){this.visit(t.declaration)},e.prototype.visitExpressionStatement=function(t){this.visit(t.expression)},e.prototype.visitFieldDeclaration=function(t){this.visit(t.name),t.type&&this.visit(t.type),t.initializer&&this.visit(t.initializer),this.visit(t.decorators)},e.prototype.visitForStatement=function(t){t.initializer&&this.visit(t.initializer),t.condition&&this.visit(t.condition),t.incrementor&&this.visit(t.incrementor),this.visit(t.statement)},e.prototype.visitFunctionDeclaration=function(t,e){this.visit(t.name),this.visit(t.decorators),t.isGeneric&&this.visit(t.typeParameters),this.visit(t.signature),this.depth++,t.body&&this.visit(t.body),this.depth--},e.prototype.visitFunctionCommon=function(t){},e.prototype.visitIfStatement=function(t){this.visit(t.condition),this.visit(t.ifTrue),t.ifFalse&&this.visit(t.ifFalse)},e.prototype.visitImportDeclaration=function(t){this.visit(t.foreignName),this.visit(t.name),this.visit(t.decorators)},e.prototype.visitImportStatement=function(t){t.namespaceName&&this.visit(t.namespaceName),this.visit(t.declarations)},e.prototype.visitIndexSignatureDeclaration=function(t){},e.prototype.visitInterfaceDeclaration=function(t,e){this.visit(t.name),t.isGeneric&&this.visit(t.typeParameters),this.visit(t.implementsTypes),t.extendsType&&this.visit(t.extendsType),this.depth++,this.visit(t.members),this.depth--},e.prototype.visitMethodDeclaration=function(t){this.visit(t.name),t.isGeneric&&this.visit(t.typeParameters),this.visit(t.signature),this.visit(t.decorators),this.depth++,t.body&&this.visit(t.body),this.depth--},e.prototype.visitNamespaceDeclaration=function(t,e){this.visit(t.name),this.visit(t.decorators),this.visit(t.members)},e.prototype.visitReturnStatement=function(t){t.value&&this.visit(t.value)},e.prototype.visitSwitchCase=function(t){t.label&&this.visit(t.label),this.visit(t.statements)},e.prototype.visitSwitchStatement=function(t){this.visit(t.condition),this.depth++,this.visit(t.cases),this.depth--},e.prototype.visitThrowStatement=function(t){this.visit(t.value)},e.prototype.visitTryStatement=function(t){this.visit(t.statements),t.catchVariable&&this.visit(t.catchVariable),this.visit(t.catchStatements),this.visit(t.finallyStatements)},e.prototype.visitTypeDeclaration=function(t){this.visit(t.name),this.visit(t.decorators),this.visit(t.type),this.visit(t.typeParameters)},e.prototype.visitVariableDeclaration=function(t){this.visit(t.name),t.type&&this.visit(t.type),t.initializer&&this.visit(t.initializer)},e.prototype.visitVariableStatement=function(t){this.visit(t.decorators),this.visit(t.declarations)},e.prototype.visitWhileStatement=function(t){this.visit(t.condition),this.depth++,this.visit(t.statement),this.depth--},e.prototype.visitVoidStatement=function(t){},e.prototype.visitComment=function(t){},e.prototype.visitDecoratorNode=function(t){this.visit(t.name),this.visit(t.arguments)},e.prototype.visitParameter=function(t){this.visit(t.name),t.implicitFieldDeclaration&&this.visit(t.implicitFieldDeclaration),t.initializer&&this.visit(t.initializer),this.visit(t.type)},e}(i(6).AbstractVisitor);e.BaseVisitor=a},function(t,e,i){\"use strict\";var s,n=this&&this.__extends||(s=function(t,e){return(s=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i])})(t,e)},function(t,e){function i(){this.constructor=t}s(t,e),t.prototype=null===e?Object.create(e):(i.prototype=e.prototype,new i)}),r=i(0),o=i(5),a=i(7);function p(t){return t.text.includes(\"@nearfile\")||u(t)}function h(t){return a.ASTBuilder.build(t)}function u(t){return(t.kind==r.NodeKind.SOURCE?t:t.range.source).sourceKind==r.SourceKind.USER_ENTRY}function l(t){return t.kind==r.NodeKind.CLASSDECLARATION}function c(t){return t.kind==r.NodeKind.FIELDDECLARATION}var d=function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.typeMapping={i32:\"Integer\",u32:\"Integer\",i64:\"String\",u64:\"String\",string:\"String\",bool:\"Boolean\",Uint8Array:\"String\"},e.nonNullableTypes=[\"i32\",\"u32\",\"i64\",\"u64\",\"bool\",\"boolean\"],e.sb=[],e.exportedClasses=new Map,e.wrappedFuncs=new Set,e}return n(e,t),e.build=function(t,i){return(new e).build(i)},e.nearFiles=function(t){return t.program.sources.filter(p)},e.prototype.visitClassDeclaration=function(e){this.exportedClasses.has(h(e.name))||this.exportedClasses.set(h(e.name),e),t.prototype.visitClassDeclaration.call(this,e)},e.prototype.visitFunctionDeclaration=function(e){!u(e)||this.wrappedFuncs.has(h(e.name))||!e.is(r.CommonFlags.EXPORT)||0==function(t){return t.signature.parameters.length}(e)&&function(t){return\"void\"===h(t.signature.returnType)}(e)?t.prototype.visitFunctionDeclaration.call(this,e):(this.generateWrapperFunction(e),e.flags=e.flags^r.CommonFlags.EXPORT,this.wrappedFuncs.add(h(e.name)),t.prototype.visit.call(this,e))},e.prototype.generateWrapperFunction=function(t){var e=t.signature,i=e.parameters,s=e.returnType,n=h(s).split(\"|\").filter((function(t){return\"null\"!==t.trim()})).join(\"|\"),r=h(s).includes(\"null\"),o=t.name.symbol;this.sb.push(\"\\n//@ts-ignore\\nfunction __wrapper_\"+o+\"(): void {\"),i.length>0&&this.sb.push(\" const json = getInput();\\n  read_register(0, <usize>json.buffer);\\n  const obj: Obj = JSON.parse(json);\"),\"void\"!==h(s)?this.sb.push(\"  let result: \"+h(s)+\" = \"+o+\"(\"):this.sb.push(\"  \"+o+\"(\"),i.length>0&&(this.sb[this.sb.length-1]+=i.map((function(t){return v(t)})).join(\", \")),this.sb[this.sb.length-1]+=\");\",\"void\"!==h(s)&&this.sb.push(\"\\n  let encoder = new JSONEncoder();\\n  let val: Uint8Array;\\n  if ((isString<\"+n+\">() || isNullable<\"+n+\">()) && result == null) {\\n    encoder.setNull(null);\\n    val = encoder.serialize();\\n  } else {\\n    val = encode<\"+n+\">(result\"+(r?\"!\":\"\")+\", null, encoder);\\n  }\\n  value_return(val.byteLength, <usize>val.buffer);\"),this.sb.push(\"}\\n\\nexport { __wrapper_\"+o+\" as \"+o+\" }\\n\")},e.prototype.typeName=function(t){if(!l(t))return a.ASTBuilder.build(t);var e=h((t=t).name);return t.isGeneric&&(e+=\"<\"+t.typeParameters.map(h).join(\", \")+\">\"),e},e.prototype.build=function(t){var e=this;this.sb=[m],this.visit(t);var i=t.statements.map((function(t){var i=a.ASTBuilder.build(t);if(l(t)){var s=t;if(i=i.slice(0,i.lastIndexOf(\"}\")),s.members.filter(c).map((function(t){return t})).some((function(t){return null==t.type})))throw new Error(\"All Fields must have explict type declaration.\");var n=e.typeName(s);i+=\"\\n  decode<V = Uint8Array>(buf: V): \"+n+' {\\n    let json: Obj;\\n    if (buf instanceof Uint8Array) {\\n      json = JSON.parse(buf);\\n    }else {\\n      assert(buf instanceof Obj, \"argument must be Uint8Array or Json Object\");\\n      json = <Obj> buf;\\n    }\\n    return this._decode(json);\\n  }\\n\\n  private _decode(obj: Obj): '+n+\" {\\n    \"+function(t){return t.members.filter(c).map((function(t){var e=h(t.name);return v(t,\"this.\"+e+' = obj.has(\"'+e+'\") ? ')+\": this.\"+e+\";\"}))}(s).join(\"\\n    \")+'\\n    return this;\\n  }\\n\\n  _encode(name: string | null = \"\", _encoder: JSONEncoder | null = null): JSONEncoder {\\n    let encoder = (_encoder != null ? _encoder : new JSONEncoder())!;\\n    encoder.pushObject(name);\\n    '+function(t){return t.members.filter(c).map((function(t){var e=h(t.type),i=h(t.name);return\"encode<\"+e+\", JSONEncoder>(this.\"+i+', \"'+i+'\", encoder);'}))}(s).join(\"\\n    \")+\"\\n    encoder.popObject();\\n    return encoder;\\n  }\\n  encode(): Uint8Array {\\n    return this._encode().serialize();\\n  }\\n\\n  serialize(): Uint8Array {\\n    return this.encode();\\n  }\\n\\n  toJSON(): string {\\n    return this._encode().toString();\\n  }\\n}\"}return i}));return this.sb.concat(i).join(\"\\n\")},e}(i(2).BaseVisitor);function v(t,e){return void 0===e&&(e=\"\"),e+\"decode<\"+h(t.type)+', Obj>(obj, \"'+h(t.name)+'\")'}var f=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return n(e,t),Object.defineProperty(e.prototype,\"program\",{get:function(){return this.parser.program},enumerable:!0,configurable:!0}),e.prototype.afterParse=function(t){this.parser=t;var i=this.writeFile,s=this.baseDir,n=d.nearFiles(t);e.isTest=n.map((function(t){return t.normalizedPath})).some((function(t){return t.includes(\"spec\")})),n.forEach((function(e){var n=e.text.substr(0,e.text.indexOf(\"\\n\")).includes(\"out\");t.donelog.delete(e.internalPath),t.seenlog.delete(e.internalPath),t.program.sources=t.program.sources.filter((function(t){return t!==e}));var r=d.build(t,e);n&&i(\"out/\"+e.normalizedPath,r,s),t.parseFile(r,(u(e)?\"\":\"./\")+e.normalizedPath,u(e))}));this.parser.parseFile('\\nimport { base64 } from \"near-runtime-ts\";\\nimport { JSONEncoder, JSONDecoder, ThrowingJSONHandler } from \"assemblyscript-json\";\\nimport { u128 } from \"bignum\";\\n// Runtime functions\\n// tslint:disable: no-unsafe-any\\n\\ntype Usize = u64;\\n//@ts-ignore\\n@global\\n@external(\"env\", \"read_register\")\\ndeclare function read_register(register_id: Usize, ptr: Usize): void;\\n//@ts-ignore\\n@global\\n@external(\"env\", \"register_len\")\\ndeclare function register_len(register_id: Usize): Usize;\\n\\n//@ts-ignore\\n@global\\n@external(\"env\", \"input\")\\ndeclare function input(register_id: Usize): void;\\n//@ts-ignore\\n@global\\n@external(\"env\", \"value_return\")\\ndeclare function value_return(value_len: Usize, value_ptr: Usize): void;\\n//@ts-ignore\\n@global\\n@external(\"env\", \"panic\")\\ndeclare function panic(): void;\\n//@ts-ignore\\n@global\\nfunction getInput(): Uint8Array { \\n  // Reading input bytes.\\n  input(0);\\n  let json_len = register_len(0);\\n  if (json_len == U32.MAX_VALUE) {\\n    panic();\\n  }\\n  let json = new Uint8Array(json_len as u32);\\n  //@ts-ignore\\n  read_register(0, <usize>json.buffer);\\n  return json;\\n}\\n\\nabstract class Value {\\n  static String(str: string): Value {\\n    return new Str(str);\\n  }\\n  static Number(num: i64): Value {\\n    return new Num(num);\\n  }\\n  static Bool(b: bool): Value {\\n    return new Bools(b);\\n  }\\n  static Null(): Value {\\n    return new Null();\\n  }\\n  static Array(): Value {\\n    return new Arr();\\n  }\\n  static Object(): Value {\\n    return new Obj();\\n  }\\n\\n  toString(): string {\\n    if (this instanceof Str) {\\n      return (<Str>this).toString();\\n    }\\n    if (this instanceof Num) {\\n      return (<Num>this).toString();\\n    }\\n    if (this instanceof Bools) {\\n      return (<Bools>this).toString();\\n    }\\n    if (this instanceof Null) {\\n      return (<Null>this).toString();\\n    }\\n    if (this instanceof Arr) {\\n      return (<Arr>this).toString();\\n    }\\n    if (this instanceof Obj) {\\n      return (<Obj>this).toString();\\n    }\\n    return \"Value\";\\n  }\\n}\\n//@ts-ignore\\n@global\\nclass Str extends Value {\\n  constructor(public _str: string) {\\n    super();\\n  }\\n\\n  toString(): string {\\n    return \"\\\\\"\" + this._str + \"\\\\\"\";\\n  }\\n}\\n//@ts-ignore\\n@global\\nclass Num extends Value {\\n  constructor(public _num: i64) {\\n    super();\\n  }\\n\\n  toString(): string {\\n    return this._num.toString();\\n  }\\n}\\n//@ts-ignore\\n@global\\nclass Null extends Value {\\n  constructor() {\\n    super();\\n  }\\n\\n  toString(): string {\\n    return \"null\";\\n  }\\n}\\n\\n//@ts-ignore\\n@global class Bools extends Value {\\n  constructor(public _bool: bool) {\\n    super();\\n  }\\n\\n  toString(): string {\\n    return this._bool.toString();\\n  }\\n}\\n\\n//@ts-ignore\\n@global\\nclass Arr extends Value {\\n  _arr: Array<Value>;\\n  constructor() {\\n    super();\\n    this._arr = new Array<Value>();\\n  }\\n\\n  push(obj: Value): void {\\n    this._arr.push(obj);\\n  }\\n\\n  toString(): string {\\n    return \"[\" + this._arr.map<string>((val: Value,i: i32,_arr: Value[]): string  => val.toString()).join(\",\") + \"]\";\\n  }\\n}\\n\\n//@ts-ignore\\n@global\\nclass Obj extends Value {\\n  _obj: Map<string, Value>;\\n  keys: Array<string>;\\n\\n  constructor() {\\n    super();\\n    this._obj = new Map();\\n    this.keys = new Array();\\n  }\\n\\n  set(key: string, value: Value): void {\\n    if (!this._obj.has(key)) {\\n      this.keys.push(key);\\n    }\\n    this._obj.set(key, value);\\n  }\\n\\n  get(key: string): Value | null {\\n    if (!this._obj.has(key)) {\\n      return null;\\n    }\\n    return this._obj.get(key);\\n  }\\n\\n  toString(): string {\\n    const objs: string[] = [];\\n    for (let i: i32 = 0; i < this.keys.length; i++) {\\n      objs.push(\"\\\\\"\" + this.keys[i] + \"\\\\\":\" + this._obj.get(this.keys[i]).toString());\\n    }\\n    return \"{\" + objs.join(\",\") + \"}\";\\n  }\\n\\n  has(key: string): bool {\\n    return this._obj.has(key);\\n  }\\n}\\n\\nclass Handler extends ThrowingJSONHandler {\\n  stack: Value[];\\n  constructor() {\\n    super();\\n    this.stack = new Array<Value>();\\n  }\\n\\n  reset(): void {\\n    while (this.stack.length > 0) {\\n      this.stack.pop();\\n    }\\n  }\\n\\n  get peek(): Value {\\n    return this.stack[this.stack.length - 1];\\n  }\\n\\n  setString(name: string, value: string): void {\\n    const obj: Value = Value.String(value);\\n    this.addValue(name, obj);\\n  }\\n\\n  setBoolean(name: string, value: bool): void {\\n    const obj = Value.Bool(value);\\n    this.addValue(name, obj);\\n  }\\n\\n  setNull(name: string): void {\\n    const obj = Value.Null();\\n    this.addValue(name, obj);\\n  }\\n\\n  setInteger(name: string, value: i64): void {\\n    const obj = Value.Number(value);\\n    this.addValue(name, obj);\\n  }\\n\\n  pushArray(name: string): bool {\\n    const obj: Value = Value.Array();\\n    this.addValue(name, obj);\\n    this.stack.push(obj);\\n    return true;\\n  }\\n\\n  popArray(): void {\\n    if (this.stack.length > 1) {\\n      this.stack.pop();\\n    }\\n  }\\n\\n  pushObject(name: string): bool {\\n    const obj: Value = Value.Object();\\n    this.addValue(name, obj);\\n    this.stack.push(obj);\\n    return true;\\n  }\\n\\n  popObject(): void {\\n    if (this.stack.length > 1) {\\n      this.stack.pop();\\n    }\\n  }\\n\\n  addValue(name: string, obj: Value): void {\\n    if (name.length == 0 && obj instanceof Obj && this.stack.length == 0) {\\n      this.stack.push(obj);\\n      return;\\n    }\\n    if (this.peek instanceof Obj) {\\n      (this.peek as Obj).set(name, obj);\\n    }\\n    else if (this.peek instanceof Arr) {\\n      (<Arr>this.peek).push(obj);\\n    }\\n  }\\n}\\n\\n//@ts-ignore\\n@global()\\nclass JSON {\\n  private static handler: Handler = new Handler();\\n  private static decoder: JSONDecoder<Handler> = new JSONDecoder<Handler>(JSON.handler);\\n  static parse(str: Uint8Array ): Obj {\\n    JSON.decoder.deserialize(str);\\n    const res = JSON.decoder.handler.peek as Obj;\\n    JSON.decoder.handler.reset();\\n    return res;\\n  }\\n}\\n\\n//@ts-ignore\\n@global\\nfunction encode<T, Output = Uint8Array>(value: T, name: string | null = \"\", encoder: JSONEncoder = new JSONEncoder()): Output {\\n  if (isBoolean<T>()) {\\n    //@ts-ignore\\n    encoder.setBoolean(name, value);\\n  } else if (isInteger<T>()) {\\n    if (value instanceof i64 || value instanceof u64) {\\n      //@ts-ignore\\n      encoder.setString(name, value.toString());\\n    } else {\\n    //@ts-ignore\\n      encoder.setInteger(name, value);\\n    }\\n    //@ts-ignore\\n  } else if (value == <T>null) {\\n    encoder.setNull(name);\\n  } else if (isString<T>()) {\\n    //@ts-ignore\\n    encoder.setString(name, value);\\n  } else if (isReference<T>()) {\\n    if (isArrayLike<T>(value)) {\\n      if (value instanceof Uint8Array) {\\n        //@ts-ignore\\n        encoder.setString(name, base64.encode(<Uint8Array> value));\\n      } else {\\n        encoder.pushArray(name);\\n        for (let i: i32 = 0; i < value.length; i++) {\\n          //@ts-ignore\\n          encode<valueof<T>, JSONEncoder>(value[i], null, encoder);\\n        }\\n        encoder.popArray();\\n      }\\n    } else { // Is an object\\n      if (value instanceof u128) {\\n        encoder.setString(name, value.toString());\\n      } else {\\n        //@ts-ignore\\n        value._encode(name, encoder);\\n      }\\n    }\\n  } else {\\n    throw new Error(\"Encoding failed\");\\n  }\\n  var output: Output;\\n  //@ts-ignore\\n  if (output instanceof Uint8Array) {\\n    //@ts-ignore\\n    return <Output>encoder.serialize();\\n  }\\n  //@ts-ignore\\n  assert( output instanceof JSONEncoder, \"Bad return type for encoder\");\\n  //@ts-ignore\\n  return <Output>encoder;\\n}\\n\\n//@ts-ignore\\n@inline\\nfunction getStr(val: Value, name: String): string {\\n  assert(val instanceof Str, \"Value with Key: \" + name + \" is not a string or null\");\\n  return (<Str>val)._str;\\n}\\n\\nfunction decodeArray<T>(val: Value, name: string): Array<T> {\\n  assert(val instanceof Arr, \"Value with Key: \" + name + \" is not an array or null.\");\\n  const res = new Array<T>();\\n  const arr = (<Arr>val)._arr;\\n  for (let i: i32 = 0; i < arr.length; i++) {\\n    let item: T = decode<T, Value>(arr[i]);\\n    res.push(item);\\n  }\\n  return res;\\n}\\n\\nfunction isNullable<T>(): bool {\\n  return isReference<T>() || isArrayLike<T>() || isNullable<T>() || isString<T>();\\n}\\n\\n//@ts-ignore\\n@global\\nfunction decode<T, V = Uint8Array>(buf: V, name: string = \"\"): T {\\n  const buffer = <Value>(buf instanceof Uint8Array ? JSON.parse(buf) : buf);\\n  var val: Value;\\n  if (buffer instanceof Obj && name != \"\") {\\n    const obj: Obj = <Obj>buffer;\\n    let res = obj.get(name);\\n    if (res == null) {\\n      //@ts-ignore\\n      return <T>null;\\n    }\\n    val = res;\\n  }else {\\n    val = <Value> buffer;\\n  }\\n  if (val instanceof Null) {\\n    assert(isNullable<T>(), \"Key: \" + name + \" with type \" + nameof<T>() + \"is not nullable.\");\\n    //@ts-ignore\\n    return <T>null;\\n  }\\n  if (isString<T>()) {\\n    //@ts-ignore\\n    return getStr(val, name);\\n  }\\n  if (isBoolean<T>()) {\\n    assert(val instanceof Bools, \"Value with Key: \" +  name + \" with type \" + nameof<T>()  + \" is not a string\");\\n    //@ts-ignore\\n    return (<Bools>val)._bool;\\n  }\\n  var value: T;\\n  if (isInteger<T>()) {\\n    //@ts-ignore\\n    if (value instanceof u64 || value instanceof i64) {\\n      assert(val instanceof Str, \"Value with Key: \" +  name + \" with type \" + nameof<T>()  + \" is an 64-bit integer and is expected to be encoded as a string\");\\n      let str = (<Str>val)._str;\\n      //@ts-ignore\\n      return <T>(val instanceof u64) ? U64.parseInt(str) : I64.parseInt(str);\\n    }\\n    assert(val instanceof Num, \"Value with Key: \" +  name + \" with type \" + nameof<T>()  + \" is not an Integer\");\\n    //@ts-ignore\\n    return <T>(<Num>val)._num;\\n  }\\n  assert(isReference<T>(), name + \" with type \" + nameof<T>() + \" must be an integer, boolean, string, object, or array\");\\n  if (isArrayLike<T>()) {\\n    //@ts-ignore\\n    if (value instanceof Uint8Array ) {\\n      //@ts-ignore\\n      return base64.decode(getStr(val, name));\\n    }\\n    //@ts-ignore\\n    // assert(val instanceof Arr, \"Value with Key: \" +  name + \" with type \" + nameof<T>()  + \" is expected to be an array\")\\n    //@ts-ignore only checking the instance\\n    return <T>decodeArray<valueof<T>>(val, name);\\n  }\\n  //@ts-ignore\\n  if (value instanceof u128) {\\n    assert(val instanceof Str);\\n    //@ts-ignore\\n    return u128.fromString(getStr(val, name));\\n  }\\n  assert(val instanceof Obj, \"Value with Key: \" +  name + \" with type \" + nameof<T>()  + \" is not an object or null\");\\n  value = instantiate<T>();\\n  //@ts-ignore\\n  return value.decode<Obj>(<Obj>val);\\n}\\n',\"nearFile\",!0),e.isTest||o.TypeChecker.check(t)},e.prototype.afterCompile=function(t){e.isTest||o.TypeChecker.checkBinary(t)},e.isTest=!1,e}(r.Transform),m='import { JSONEncoder } from \"assemblyscript-json\";';t.exports=f},function(t,e){e.Transform=function(){}},function(t,e,i){\"use strict\";var s,n=this&&this.__extends||(s=function(t,e){return(s=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i])})(t,e)},function(t,e){function i(){this.constructor=t}s(t,e),t.prototype=null===e?Object.create(e):(i.prototype=e.prototype,new i)});Object.defineProperty(e,\"__esModule\",{value:!0});var r=i(2),o=[\"builtin\",\".spec\",\"dataview\",\"date\",\"math\",\"number\",\"string\",\"typedarray\",\"bindings/Date\",\"bindings/Math\"],a=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return n(e,t),e.prototype.check=function(t){t.text.substring(0,t.text.indexOf(\"\\n\")).includes(\"ignore\")||o.some((function(e){return t.normalizedPath.includes(e)}))||this.visit(t)},e.check=function(t){for(var i=new e,s=0;s<t.program.sources.length;s++)i.check(t.program.sources[s])},e.prototype.visitTypeName=function(t){/f32|f64/.test(t.identifier.text)&&e.floatsFound.push(t.range.source.normalizedPath+\" line: \"+t.range.line+\" \"+t.range.source.text.split(\"\\n\")[t.range.line-1])},e.checkBinary=function(t){var i=t.toText();if(/f32|f64/.test(i))throw new Error(\"Floating point numbers are not allowed in smart contracts: Check\\n\"+e.floatsFound.join(\"\\n\"))},e.floatsFound=[],e}(r.BaseVisitor);e.TypeChecker=a},function(t,e,i){\"use strict\";var s=this&&this.__values||function(t){var e=\"function\"==typeof Symbol&&Symbol.iterator,i=e&&t[e],s=0;if(i)return i.call(t);if(t&&\"number\"==typeof t.length)return{next:function(){return t&&s>=t.length&&(t=void 0),{value:t&&t[s++],done:!t}}};throw new TypeError(e?\"Object is not iterable.\":\"Symbol.iterator is not defined.\")},n=this&&this.__read||function(t,e){var i=\"function\"==typeof Symbol&&t[Symbol.iterator];if(!i)return t;var s,n,r=i.call(t),o=[];try{for(;(void 0===e||e-- >0)&&!(s=r.next()).done;)o.push(s.value)}catch(t){n={error:t}}finally{try{s&&!s.done&&(i=r.return)&&i.call(r)}finally{if(n)throw n.error}}return o};Object.defineProperty(e,\"__esModule\",{value:!0});var r=function(){function t(){}return t.prototype.visit=function(t){var e,i,r,o,a,p=this;if(null!=t)if(t instanceof Array)t.map((function(t){p.visit(t)}));else if(t instanceof Map)try{for(var h=s(t.entries()),u=h.next();!u.done;u=h.next()){var l=n(u.value,2),c=(l[0],l[1]);this.visit(c)}}catch(t){e={error:t}}finally{try{u&&!u.done&&(i=h.return)&&i.call(h)}finally{if(e)throw e.error}}else if(null!=(a=t)&&\"function\"==typeof a[Symbol.iterator])try{for(var d=s(t),v=d.next();!v.done;v=d.next()){c=v.value;this.visit(c)}}catch(t){r={error:t}}finally{try{v&&!v.done&&(o=d.return)&&o.call(d)}finally{if(r)throw r.error}}else this._visit(t)},t}();e.AbstractVisitor=r},function(t,e,i){\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0});var s=i(0),n=function(){function t(){this.sb=[],this.indentLevel=0}return t.build=function(e){var i=new t;return i.visitNode(e),i.finish()},t.prototype.visitNode=function(t){switch(t.kind){case s.NodeKind.SOURCE:this.visitSource(t);break;case s.NodeKind.NAMEDTYPE:this.visitNamedTypeNode(t);break;case s.NodeKind.FUNCTIONTYPE:this.visitFunctionTypeNode(t);break;case s.NodeKind.TYPEPARAMETER:this.visitTypeParameter(t);break;case s.NodeKind.FALSE:case s.NodeKind.NULL:case s.NodeKind.SUPER:case s.NodeKind.THIS:case s.NodeKind.TRUE:case s.NodeKind.CONSTRUCTOR:case s.NodeKind.IDENTIFIER:this.visitIdentifierExpression(t);break;case s.NodeKind.ASSERTION:this.visitAssertionExpression(t);break;case s.NodeKind.BINARY:this.visitBinaryExpression(t);break;case s.NodeKind.CALL:this.visitCallExpression(t);break;case s.NodeKind.CLASS:this.visitClassExpression(t);break;case s.NodeKind.COMMA:this.visitCommaExpression(t);break;case s.NodeKind.ELEMENTACCESS:this.visitElementAccessExpression(t);break;case s.NodeKind.FUNCTION:this.visitFunctionExpression(t);break;case s.NodeKind.INSTANCEOF:this.visitInstanceOfExpression(t);break;case s.NodeKind.LITERAL:this.visitLiteralExpression(t);break;case s.NodeKind.NEW:this.visitNewExpression(t);break;case s.NodeKind.PARENTHESIZED:this.visitParenthesizedExpression(t);break;case s.NodeKind.PROPERTYACCESS:this.visitPropertyAccessExpression(t);break;case s.NodeKind.TERNARY:this.visitTernaryExpression(t);break;case s.NodeKind.UNARYPOSTFIX:this.visitUnaryPostfixExpression(t);break;case s.NodeKind.UNARYPREFIX:this.visitUnaryPrefixExpression(t);break;case s.NodeKind.BLOCK:this.visitBlockStatement(t);break;case s.NodeKind.BREAK:this.visitBreakStatement(t);break;case s.NodeKind.CONTINUE:this.visitContinueStatement(t);break;case s.NodeKind.DO:this.visitDoStatement(t);break;case s.NodeKind.EMPTY:this.visitEmptyStatement(t);break;case s.NodeKind.EXPORT:this.visitExportStatement(t);break;case s.NodeKind.EXPORTDEFAULT:this.visitExportDefaultStatement(t);break;case s.NodeKind.EXPORTIMPORT:this.visitExportImportStatement(t);break;case s.NodeKind.EXPRESSION:this.visitExpressionStatement(t);break;case s.NodeKind.FOR:this.visitForStatement(t);break;case s.NodeKind.IF:this.visitIfStatement(t);break;case s.NodeKind.IMPORT:this.visitImportStatement(t);break;case s.NodeKind.RETURN:this.visitReturnStatement(t);break;case s.NodeKind.SWITCH:this.visitSwitchStatement(t);break;case s.NodeKind.THROW:this.visitThrowStatement(t);break;case s.NodeKind.TRY:this.visitTryStatement(t);break;case s.NodeKind.VARIABLE:this.visitVariableStatement(t);break;case s.NodeKind.WHILE:this.visitWhileStatement(t);break;case s.NodeKind.CLASSDECLARATION:this.visitClassDeclaration(t);break;case s.NodeKind.ENUMDECLARATION:this.visitEnumDeclaration(t);break;case s.NodeKind.ENUMVALUEDECLARATION:this.visitEnumValueDeclaration(t);break;case s.NodeKind.FIELDDECLARATION:this.visitFieldDeclaration(t);break;case s.NodeKind.FUNCTIONDECLARATION:this.visitFunctionDeclaration(t);break;case s.NodeKind.IMPORTDECLARATION:this.visitImportDeclaration(t);break;case s.NodeKind.INDEXSIGNATUREDECLARATION:this.visitIndexSignatureDeclaration(t);break;case s.NodeKind.INTERFACEDECLARATION:this.visitInterfaceDeclaration(t);break;case s.NodeKind.METHODDECLARATION:this.visitMethodDeclaration(t);break;case s.NodeKind.NAMESPACEDECLARATION:this.visitNamespaceDeclaration(t);break;case s.NodeKind.TYPEDECLARATION:this.visitTypeDeclaration(t);break;case s.NodeKind.VARIABLEDECLARATION:this.visitVariableDeclaration(t);break;case s.NodeKind.DECORATOR:this.serializeDecorator(t);break;case s.NodeKind.EXPORTMEMBER:this.visitExportMember(t);break;case s.NodeKind.PARAMETER:this.serializeParameter(t);break;case s.NodeKind.SWITCHCASE:this.visitSwitchCase(t);break;default:assert(!1)}},t.prototype.visitSource=function(t){for(var e=t.statements,i=0,s=e.length;i<s;++i)this.visitNodeAndTerminate(e[i])},t.prototype.visitTypeNode=function(t){switch(t.kind){case s.NodeKind.NAMEDTYPE:this.visitNamedTypeNode(t);break;case s.NodeKind.FUNCTIONTYPE:this.visitFunctionTypeNode(t);break;default:assert(!1)}},t.prototype.visitTypeName=function(t){this.visitIdentifierExpression(t.identifier);for(var e=this.sb,i=t.next;i;)e.push(\".\"),this.visitIdentifierExpression(i.identifier),i=i.next},t.prototype.visitNamedTypeNode=function(t){this.visitTypeName(t.name);var e=t.typeArguments;if(e){var i=e.length,s=this.sb;if(i){s.push(\"<\"),this.visitTypeNode(e[0]);for(var n=1;n<i;++n)s.push(\", \"),this.visitTypeNode(e[n]);s.push(\">\")}t.isNullable&&s.push(\" | null\")}},t.prototype.visitFunctionTypeNode=function(t){var e=t.isNullable,i=this.sb;i.push(e?\"((\":\"(\");var s=t.explicitThisType;s&&(i.push(\"this: \"),this.visitTypeNode(s));var n=t.parameters,r=n.length;if(r){s&&i.push(\", \"),this.serializeParameter(n[0]);for(var o=1;o<r;++o)i.push(\", \"),this.serializeParameter(n[o])}var a=t.returnType;a?(i.push(\") => \"),this.visitTypeNode(a)):i.push(\") => void\"),e&&i.push(\") | null\")},t.prototype.visitTypeParameter=function(t){this.visitIdentifierExpression(t.name);var e=t.extendsType;e&&(this.sb.push(\" extends \"),this.visitTypeNode(e));var i=t.defaultType;i&&(this.sb.push(\"=\"),this.visitTypeNode(i))},t.prototype.visitIdentifierExpression=function(t){t.isQuoted?this.visitStringLiteral(t.text):this.sb.push(t.text)},t.prototype.visitArrayLiteralExpression=function(t){var e=this.sb;e.push(\"[\");var i=t.elementExpressions,s=i.length;if(s){i[0]&&this.visitNode(i[0]);for(var n=1;n<s;++n)e.push(\", \"),i[n]&&this.visitNode(i[n])}e.push(\"]\")},t.prototype.visitObjectLiteralExpression=function(t){var e=this.sb,i=t.names,n=t.values,r=i.length;if(assert(r==n.length),r){e.push(\"{\\n\"),s.indent(e,++this.indentLevel),this.visitNode(i[0]),e.push(\": \"),this.visitNode(n[0]);for(var o=1;o<r;++o){e.push(\",\\n\"),s.indent(e,this.indentLevel);var a=i[o],p=n[o];a===p?this.visitNode(a):(this.visitNode(a),e.push(\": \"),this.visitNode(p))}e.push(\"\\n\"),s.indent(e,--this.indentLevel),e.push(\"}\")}else e.push(\"{}\")},t.prototype.visitAssertionExpression=function(t){var e=this.sb;switch(t.assertionKind){case s.AssertionKind.PREFIX:e.push(\"<\"),this.visitTypeNode(assert(t.toType)),e.push(\">\"),this.visitNode(t.expression);break;case s.AssertionKind.AS:this.visitNode(t.expression),e.push(\" as \"),this.visitTypeNode(assert(t.toType));break;case s.AssertionKind.NONNULL:this.visitNode(t.expression),e.push(\"!\");break;default:assert(!1)}},t.prototype.visitBinaryExpression=function(t){var e=this.sb;this.visitNode(t.left),e.push(\" \"),e.push(s.operatorTokenToString(t.operator)),e.push(\" \"),this.visitNode(t.right)},t.prototype.visitCallExpression=function(t){var e=this.sb;this.visitNode(t.expression);var i=t.typeArguments;if(i){var s=i.length;if(s){e.push(\"<\"),this.visitTypeNode(i[0]);for(var n=1;n<s;++n)e.push(\", \"),this.visitTypeNode(i[n]);e.push(\">(\")}}else e.push(\"(\");var r=t.arguments,o=r.length;if(o){this.visitNode(r[0]);for(n=1;n<o;++n)e.push(\", \"),this.visitNode(r[n])}e.push(\")\")},t.prototype.visitClassExpression=function(t){var e=t.declaration;this.visitClassDeclaration(e)},t.prototype.visitCommaExpression=function(t){var e=t.expressions,i=assert(e.length);this.visitNode(e[0]);for(var s=this.sb,n=1;n<i;++n)s.push(\",\"),this.visitNode(e[n])},t.prototype.visitElementAccessExpression=function(t){var e=this.sb;this.visitNode(t.expression),e.push(\"[\"),this.visitNode(t.elementExpression),e.push(\"]\")},t.prototype.visitFunctionExpression=function(t){var e=t.declaration;e.arrowKind?assert(0==e.name.text.length):e.name.text.length?this.sb.push(\"function \"):this.sb.push(\"function\"),this.visitFunctionCommon(e)},t.prototype.visitLiteralExpression=function(t){switch(t.literalKind){case s.LiteralKind.FLOAT:this.visitFloatLiteralExpression(t);break;case s.LiteralKind.INTEGER:this.visitIntegerLiteralExpression(t);break;case s.LiteralKind.STRING:this.visitStringLiteralExpression(t);break;case s.LiteralKind.REGEXP:this.visitRegexpLiteralExpression(t);break;case s.LiteralKind.ARRAY:this.visitArrayLiteralExpression(t);break;case s.LiteralKind.OBJECT:this.visitObjectLiteralExpression(t);break;default:assert(!1)}},t.prototype.visitFloatLiteralExpression=function(t){this.sb.push(t.value.toString(10))},t.prototype.visitInstanceOfExpression=function(t){this.visitNode(t.expression),this.sb.push(\" instanceof \"),this.visitTypeNode(t.isType)},t.prototype.visitIntegerLiteralExpression=function(t){this.sb.push(i64_to_string(t.value))},t.prototype.visitStringLiteral=function(t,e){void 0===e&&(e=!1);var i=this.sb,s=0,n=e?\"'\":'\"';i.push(n);for(var r=0,o=t.length;r<o;)switch(t.charCodeAt(r)){case 0:r>s&&i.push(t.substring(s,s=r+1)),i.push(\"\\\\0\"),s=++r;break;case 8:r>s&&i.push(t.substring(s,r)),s=++r,i.push(\"\\\\b\");break;case 9:r>s&&i.push(t.substring(s,r)),s=++r,i.push(\"\\\\t\");break;case 10:r>s&&i.push(t.substring(s,r)),s=++r,i.push(\"\\\\n\");break;case 11:r>s&&i.push(t.substring(s,r)),s=++r,i.push(\"\\\\v\");break;case 12:r>s&&i.push(t.substring(s,r)),s=++r,i.push(\"\\\\f\");break;case 13:r>s&&i.push(t.substring(s,r)),i.push(\"\\\\r\"),s=++r;break;case 34:e?++r:(r>s&&i.push(t.substring(s,r)),i.push('\\\\\"'),s=++r);break;case 39:e?(r>s&&i.push(t.substring(s,r)),i.push(\"\\\\'\"),s=++r):++r;break;case 92:r>s&&i.push(t.substring(s,r)),i.push(\"\\\\\\\\\"),s=++r;break;default:++r}r>s&&i.push(t.substring(s,r)),i.push(n)},t.prototype.visitStringLiteralExpression=function(t){this.visitStringLiteral(t.value)},t.prototype.visitRegexpLiteralExpression=function(t){var e=this.sb;e.push(\"/\"),e.push(t.pattern),e.push(\"/\"),e.push(t.patternFlags)},t.prototype.visitNewExpression=function(t){this.sb.push(\"new \"),this.visitCallExpression(t)},t.prototype.visitParenthesizedExpression=function(t){var e=this.sb;e.push(\"(\"),this.visitNode(t.expression),e.push(\")\")},t.prototype.visitPropertyAccessExpression=function(t){this.visitNode(t.expression),this.sb.push(\".\"),this.visitIdentifierExpression(t.property)},t.prototype.visitTernaryExpression=function(t){var e=this.sb;this.visitNode(t.condition),e.push(\" ? \"),this.visitNode(t.ifThen),e.push(\" : \"),this.visitNode(t.ifElse)},t.prototype.visitUnaryExpression=function(t){switch(t.kind){case s.NodeKind.UNARYPOSTFIX:this.visitUnaryPostfixExpression(t);break;case s.NodeKind.UNARYPREFIX:this.visitUnaryPrefixExpression(t);break;default:assert(!1)}},t.prototype.visitUnaryPostfixExpression=function(t){this.visitNode(t.operand),this.sb.push(s.operatorTokenToString(t.operator))},t.prototype.visitUnaryPrefixExpression=function(t){this.sb.push(s.operatorTokenToString(t.operator)),this.visitNode(t.operand)},t.prototype.visitNodeAndTerminate=function(t){this.visitNode(t);var e=this.sb;if(e.length&&t.kind!=s.NodeKind.VARIABLE&&t.kind!=s.NodeKind.EXPRESSION){var i=e[e.length-1],n=i.length-1;n>=0&&(125==i.charCodeAt(n)||59==i.charCodeAt(n))?e.push(\"\\n\"):e.push(\";\\n\")}else e.push(\";\\n\")},t.prototype.visitBlockStatement=function(t){var e=this.sb,i=t.statements,n=i.length;if(n){e.push(\"{\\n\");for(var r=++this.indentLevel,o=0;o<n;++o)s.indent(e,r),this.visitNodeAndTerminate(i[o]);s.indent(e,--this.indentLevel),e.push(\"}\")}else e.push(\"{}\")},t.prototype.visitBreakStatement=function(t){var e=t.label;e?(this.sb.push(\"break \"),this.visitIdentifierExpression(e)):this.sb.push(\"break\")},t.prototype.visitContinueStatement=function(t){var e=t.label;e?(this.sb.push(\"continue \"),this.visitIdentifierExpression(e)):this.sb.push(\"continue\")},t.prototype.visitClassDeclaration=function(t,e){void 0===e&&(e=!1);var i=t.decorators;if(i)for(var n=0,r=i.length;n<r;++n)this.serializeDecorator(i[n]);var o=this.sb;e?o.push(\"export default \"):this.serializeExternalModifiers(t),t.is(s.CommonFlags.ABSTRACT)&&o.push(\"abstract \"),t.name.text.length?(o.push(\"class \"),this.visitIdentifierExpression(t.name)):o.push(\"class\");var a=t.typeParameters;if(a&&a.length){o.push(\"<\"),this.visitTypeParameter(a[0]);for(n=1,r=a.length;n<r;++n)o.push(\", \"),this.visitTypeParameter(a[n]);o.push(\">\")}var p=t.extendsType;p&&(o.push(\" extends \"),this.visitTypeNode(p));var h=t.implementsTypes;if(h){var u=h.length;if(u){o.push(\" implements \"),this.visitTypeNode(h[0]);for(n=1;n<u;++n)o.push(\", \"),this.visitTypeNode(h[n])}}var l=t.members;if(l.length){o.push(\" {\\n\");var c=++this.indentLevel;for(n=0,r=l.length;n<r;++n){var d=l[n];(d.kind!=s.NodeKind.FIELDDECLARATION||d.parameterIndex<0)&&(s.indent(o,c),this.visitNodeAndTerminate(d))}s.indent(o,--this.indentLevel),o.push(\"}\")}else o.push(\" {}\")},t.prototype.visitDoStatement=function(t){var e=this.sb;e.push(\"do \"),this.visitNode(t.statement),t.statement.kind==s.NodeKind.BLOCK?e.push(\" while (\"):(e.push(\";\\n\"),s.indent(e,this.indentLevel),e.push(\"while (\")),this.visitNode(t.condition),e.push(\")\")},t.prototype.visitEmptyStatement=function(t){},t.prototype.visitEnumDeclaration=function(t,e){void 0===e&&(e=!1);var i=this.sb;e?i.push(\"export default \"):this.serializeExternalModifiers(t),t.is(s.CommonFlags.CONST)&&i.push(\"const \"),i.push(\"enum \"),this.visitIdentifierExpression(t.name);var n=t.values.length;if(n){i.push(\" {\\n\");var r=++this.indentLevel;s.indent(i,r),this.visitEnumValueDeclaration(t.values[0]);for(var o=1;o<n;++o)i.push(\",\\n\"),s.indent(i,r),this.visitEnumValueDeclaration(t.values[o]);i.push(\"\\n\"),s.indent(i,--this.indentLevel),i.push(\"}\")}else i.push(\" {}\")},t.prototype.visitEnumValueDeclaration=function(t){this.visitIdentifierExpression(t.name),t.value&&(this.sb.push(\" = \"),this.visitNode(t.value))},t.prototype.visitExportImportStatement=function(t){var e=this.sb;e.push(\"export import \"),this.visitIdentifierExpression(t.externalName),e.push(\" = \"),this.visitIdentifierExpression(t.name)},t.prototype.visitExportMember=function(t){this.visitIdentifierExpression(t.localName),t.exportedName.text!=t.localName.text&&(this.sb.push(\" as \"),this.visitIdentifierExpression(t.exportedName))},t.prototype.visitExportStatement=function(t){var e=this.sb;t.isDeclare&&e.push(\"declare \");var i=t.members;if(i&&i.length){var n=i.length;e.push(\"export {\\n\");var r=++this.indentLevel;s.indent(e,r),this.visitExportMember(i[0]);for(var o=1;o<n;++o)e.push(\",\\n\"),s.indent(e,r),this.visitExportMember(i[o]);--this.indentLevel,e.push(\"\\n}\")}else e.push(\"export {}\");var a=t.path;a&&(e.push(\" from \"),this.visitStringLiteralExpression(a)),e.push(\";\")},t.prototype.visitExportDefaultStatement=function(t){var e=t.declaration;switch(e.kind){case s.NodeKind.ENUMDECLARATION:this.visitEnumDeclaration(e,!0);break;case s.NodeKind.FUNCTIONDECLARATION:this.visitFunctionDeclaration(e,!0);break;case s.NodeKind.CLASSDECLARATION:this.visitClassDeclaration(e,!0);break;case s.NodeKind.INTERFACEDECLARATION:this.visitInterfaceDeclaration(e,!0);break;case s.NodeKind.NAMESPACEDECLARATION:this.visitNamespaceDeclaration(e,!0);break;default:assert(!1)}},t.prototype.visitExpressionStatement=function(t){this.visitNode(t.expression)},t.prototype.visitFieldDeclaration=function(t){var e=t.decorators;if(e)for(var i=0,n=e.length;i<n;++i)this.serializeDecorator(e[i]);this.serializeAccessModifiers(t),this.visitIdentifierExpression(t.name);var r=this.sb;t.flags&s.CommonFlags.DEFINITE_ASSIGNMENT&&r.push(\"!\");var o=t.type;o&&(r.push(\": \"),this.visitTypeNode(o));var a=t.initializer;a&&(r.push(\" = \"),this.visitNode(a))},t.prototype.visitForStatement=function(t){var e=this.sb;e.push(\"for (\");var i=t.initializer;i&&this.visitNode(i);var s=t.condition;s?(e.push(\"; \"),this.visitNode(s)):e.push(\";\");var n=t.incrementor;n?(e.push(\"; \"),this.visitNode(n)):e.push(\";\"),e.push(\") \"),this.visitNode(t.statement)},t.prototype.visitFunctionDeclaration=function(t,e){void 0===e&&(e=!1);var i=this.sb,s=t.decorators;if(s)for(var n=0,r=s.length;n<r;++n)this.serializeDecorator(s[n]);e?i.push(\"export default \"):(this.serializeExternalModifiers(t),this.serializeAccessModifiers(t)),t.name.text.length?i.push(\"function \"):i.push(\"function\"),this.visitFunctionCommon(t)},t.prototype.visitFunctionCommon=function(t){var e=this.sb;this.visitIdentifierExpression(t.name);var i=t.signature,n=t.typeParameters;if(n){var r=n.length;if(r){e.push(\"<\"),this.visitTypeParameter(n[0]);for(var o=1;o<r;++o)e.push(\", \"),this.visitTypeParameter(n[o]);e.push(\">\")}}if(2==t.arrowKind){var a=i.parameters;assert(1==a.length),assert(!i.explicitThisType),this.serializeParameter(a[0])}else{e.push(\"(\");var p=(a=i.parameters).length,h=i.explicitThisType;if(h&&(e.push(\"this: \"),this.visitTypeNode(h)),p){h&&e.push(\", \"),this.serializeParameter(a[0]);for(o=1;o<p;++o)e.push(\", \"),this.serializeParameter(a[o])}}var u=t.body,l=i.returnType;t.arrowKind?u?(2==t.arrowKind?assert(s.isTypeOmitted(l)):s.isTypeOmitted(l)?e.push(\")\"):(e.push(\"): \"),this.visitTypeNode(l)),e.push(\" => \"),this.visitNode(u)):(assert(!s.isTypeOmitted(l)),e.push(\" => \"),this.visitTypeNode(l)):(s.isTypeOmitted(l)||t.isAny(s.CommonFlags.CONSTRUCTOR|s.CommonFlags.SET)?e.push(\")\"):(e.push(\"): \"),this.visitTypeNode(l)),u&&(e.push(\" \"),this.visitNode(u)))},t.prototype.visitIfStatement=function(t){var e=this.sb;e.push(\"if (\"),this.visitNode(t.condition),e.push(\") \");var i=t.ifTrue;this.visitNode(i),i.kind!=s.NodeKind.BLOCK&&e.push(\";\\n\");var n=t.ifFalse;n&&(i.kind==s.NodeKind.BLOCK?e.push(\" else \"):e.push(\"else \"),this.visitNode(n))},t.prototype.visitImportDeclaration=function(t){var e=t.foreignName,i=t.name;this.visitIdentifierExpression(e),e.text!=i.text&&(this.sb.push(\" as \"),this.visitIdentifierExpression(i))},t.prototype.visitImportStatement=function(t){var e=this.sb;e.push(\"import \");var i=t.declarations,n=t.namespaceName;if(i){var r=i.length;if(r){e.push(\"{\\n\");var o=++this.indentLevel;s.indent(e,o),this.visitImportDeclaration(i[0]);for(var a=1;a<r;++a)e.push(\",\\n\"),s.indent(e,o),this.visitImportDeclaration(i[a]);--this.indentLevel,e.push(\"\\n} from \")}else e.push(\"{} from \")}else n&&(e.push(\"* as \"),this.visitIdentifierExpression(n),e.push(\" from \"));this.visitStringLiteralExpression(t.path)},t.prototype.visitIndexSignatureDeclaration=function(t){var e=this.sb;e.push(\"[key: \"),this.visitTypeNode(t.keyType),e.push(\"]: \"),this.visitTypeNode(t.valueType)},t.prototype.visitInterfaceDeclaration=function(t,e){void 0===e&&(e=!1);var i=t.decorators;if(i)for(var n=0,r=i.length;n<r;++n)this.serializeDecorator(i[n]);var o=this.sb;e?o.push(\"export default \"):this.serializeExternalModifiers(t),o.push(\"interface \"),this.visitIdentifierExpression(t.name);var a=t.typeParameters;if(a&&a.length){o.push(\"<\"),this.visitTypeParameter(a[0]);for(n=1,r=a.length;n<r;++n)o.push(\", \"),this.visitTypeParameter(a[n]);o.push(\">\")}var p=t.extendsType;p&&(o.push(\" extends \"),this.visitTypeNode(p)),o.push(\" {\\n\");var h=++this.indentLevel,u=t.members;for(n=0,r=u.length;n<r;++n)s.indent(o,h),this.visitNodeAndTerminate(u[n]);--this.indentLevel,o.push(\"}\")},t.prototype.visitMethodDeclaration=function(t){var e=t.decorators;if(e)for(var i=0,n=e.length;i<n;++i)this.serializeDecorator(e[i]);this.serializeAccessModifiers(t),t.is(s.CommonFlags.GET)?this.sb.push(\"get \"):t.is(s.CommonFlags.SET)&&this.sb.push(\"set \"),this.visitFunctionCommon(t)},t.prototype.visitNamespaceDeclaration=function(t,e){void 0===e&&(e=!1);var i=t.decorators;if(i)for(var n=0,r=i.length;n<r;++n)this.serializeDecorator(i[n]);var o=this.sb;e?o.push(\"export default \"):this.serializeExternalModifiers(t),o.push(\"namespace \"),this.visitIdentifierExpression(t.name);var a=t.members;if(a.length){o.push(\" {\\n\");var p=++this.indentLevel;for(n=0,r=a.length;n<r;++n)s.indent(o,p),this.visitNodeAndTerminate(a[n]);s.indent(o,--this.indentLevel),o.push(\"}\")}else o.push(\" {}\")},t.prototype.visitReturnStatement=function(t){var e=t.value;e?(this.sb.push(\"return \"),this.visitNode(e)):this.sb.push(\"return\")},t.prototype.visitSwitchCase=function(t){var e=this.sb,i=t.label;i?(e.push(\"case \"),this.visitNode(i),e.push(\":\\n\")):e.push(\"default:\\n\");var n=t.statements,r=n.length;if(r){var o=++this.indentLevel;s.indent(e,o),this.visitNodeAndTerminate(n[0]);for(var a=1;a<r;++a)s.indent(e,o),this.visitNodeAndTerminate(n[a]);--this.indentLevel}},t.prototype.visitSwitchStatement=function(t){var e=this.sb;e.push(\"switch (\"),this.visitNode(t.condition),e.push(\") {\\n\");for(var i=++this.indentLevel,n=t.cases,r=0,o=n.length;r<o;++r)s.indent(e,i),this.visitSwitchCase(n[r]),e.push(\"\\n\");--this.indentLevel,e.push(\"}\")},t.prototype.visitThrowStatement=function(t){this.sb.push(\"throw \"),this.visitNode(t.value)},t.prototype.visitTryStatement=function(t){var e=this.sb;e.push(\"try {\\n\");for(var i=++this.indentLevel,n=t.statements,r=0,o=n.length;r<o;++r)s.indent(e,i),this.visitNodeAndTerminate(n[r]);var a=t.catchVariable;if(a){s.indent(e,i-1),e.push(\"} catch (\"),this.visitIdentifierExpression(a),e.push(\") {\\n\");var p=t.catchStatements;if(p)for(r=0,o=p.length;r<o;++r)s.indent(e,i),this.visitNodeAndTerminate(p[r])}var h=t.finallyStatements;if(h){s.indent(e,i-1),e.push(\"} finally {\\n\");for(r=0,o=h.length;r<o;++r)s.indent(e,i),this.visitNodeAndTerminate(h[r])}s.indent(e,i-1),e.push(\"}\")},t.prototype.visitTypeDeclaration=function(t){var e=t.decorators;if(e)for(var i=0,s=e.length;i<s;++i)this.serializeDecorator(e[i]);var n=this.sb;this.serializeExternalModifiers(t),n.push(\"type \"),this.visitIdentifierExpression(t.name);var r=t.typeParameters;if(r){var o=r.length;if(o){n.push(\"<\");for(i=0;i<o;++i)this.visitTypeParameter(r[i]);n.push(\">\")}}n.push(\" = \"),this.visitTypeNode(t.type)},t.prototype.visitVariableDeclaration=function(t){this.visitIdentifierExpression(t.name);var e=t.type,i=this.sb;t.flags&s.CommonFlags.DEFINITE_ASSIGNMENT&&i.push(\"!\"),e&&(i.push(\": \"),this.visitTypeNode(e));var n=t.initializer;n&&(i.push(\" = \"),this.visitNode(n))},t.prototype.visitVariableStatement=function(t){var e=t.decorators;if(e)for(var i=0,n=e.length;i<n;++i)this.serializeDecorator(e[i]);var r=this.sb,o=t.declarations,a=assert(o.length),p=o[0];this.serializeExternalModifiers(p),r.push(p.is(s.CommonFlags.CONST)?\"const \":p.is(s.CommonFlags.LET)?\"let \":\"var \"),this.visitVariableDeclaration(t.declarations[0]);for(i=1;i<a;++i)r.push(\", \"),this.visitVariableDeclaration(t.declarations[i])},t.prototype.visitWhileStatement=function(t){var e=this.sb;e.push(\"while (\"),this.visitNode(t.condition),t.statement.kind==s.NodeKind.EMPTY?e.push(\")\"):(e.push(\") \"),this.visitNode(t.statement))},t.prototype.serializeDecorator=function(t){var e=this.sb;e.push(\"@\"),this.visitNode(t.name);var i=t.arguments;if(i){e.push(\"(\");var n=i.length;if(n){this.visitNode(i[0]);for(var r=1;r<n;++r)e.push(\", \"),this.visitNode(i[r])}e.push(\")\\n\")}else e.push(\"\\n\");s.indent(e,this.indentLevel)},t.prototype.serializeParameter=function(t){var e=this.sb,i=t.parameterKind,n=t.implicitFieldDeclaration;n&&this.serializeAccessModifiers(n),i==s.ParameterKind.REST&&e.push(\"...\"),this.visitIdentifierExpression(t.name);var r=t.type,o=t.initializer;r&&(i!=s.ParameterKind.OPTIONAL||o||e.push(\"?\"),s.isTypeOmitted(r)||(e.push(\": \"),this.visitTypeNode(r))),o&&(e.push(\" = \"),this.visitNode(o))},t.prototype.serializeExternalModifiers=function(t){var e=this.sb;t.is(s.CommonFlags.EXPORT)?e.push(\"export \"):t.is(s.CommonFlags.IMPORT)?e.push(\"import \"):t.is(s.CommonFlags.DECLARE)&&e.push(\"declare \")},t.prototype.serializeAccessModifiers=function(t){var e=this.sb;t.is(s.CommonFlags.PUBLIC)?e.push(\"public \"):t.is(s.CommonFlags.PRIVATE)?e.push(\"private \"):t.is(s.CommonFlags.PROTECTED)&&e.push(\"protected \"),t.is(s.CommonFlags.STATIC)?e.push(\"static \"):t.is(s.CommonFlags.ABSTRACT)&&e.push(\"abstract \"),t.is(s.CommonFlags.READONLY)&&e.push(\"readonly \")},t.prototype.finish=function(){var t=this.sb.join(\"\");return this.sb=[],t},t}();e.ASTBuilder=n}])}));","exports.nextTick = function nextTick(fn) {\n    var args = Array.prototype.slice.call(arguments);\n    args.shift();\n    setTimeout(function () {\n        fn.apply(null, args);\n    }, 0);\n};\n\nexports.platform = exports.arch = \nexports.execPath = exports.title = 'browser';\nexports.pid = 1;\nexports.browser = true;\nexports.env = {};\nexports.argv = [];\n\nexports.binding = function (name) {\n\tthrow new Error('No such module. (Possibly not yet loaded)')\n};\n\n(function () {\n    var cwd = '/';\n    var path;\n    exports.cwd = function () { return cwd };\n    exports.chdir = function (dir) {\n        if (!path) path = require('path');\n        cwd = path.resolve(dir, cwd);\n    };\n})();\n\nexports.exit = exports.kill = \nexports.umask = exports.dlopen = \nexports.uptime = exports.memoryUsage = \nexports.uvCounters = function() {};\nexports.features = {};\n","// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,\n// backported and transplited with Babel, with backwards-compat fixes\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function (path) {\n  if (typeof path !== 'string') path = path + '';\n  if (path.length === 0) return '.';\n  var code = path.charCodeAt(0);\n  var hasRoot = code === 47 /*/*/;\n  var end = -1;\n  var matchedSlash = true;\n  for (var i = path.length - 1; i >= 1; --i) {\n    code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n      // We saw the first non-path separator\n      matchedSlash = false;\n    }\n  }\n\n  if (end === -1) return hasRoot ? '/' : '.';\n  if (hasRoot && end === 1) {\n    // return '//';\n    // Backwards-compat fix:\n    return '/';\n  }\n  return path.slice(0, end);\n};\n\nfunction basename(path) {\n  if (typeof path !== 'string') path = path + '';\n\n  var start = 0;\n  var end = -1;\n  var matchedSlash = true;\n  var i;\n\n  for (i = path.length - 1; i >= 0; --i) {\n    if (path.charCodeAt(i) === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // path component\n      matchedSlash = false;\n      end = i + 1;\n    }\n  }\n\n  if (end === -1) return '';\n  return path.slice(start, end);\n}\n\n// Uses a mixed approach for backwards-compatibility, as ext behavior changed\n// in new Node.js versions, so only basename() above is backported here\nexports.basename = function (path, ext) {\n  var f = basename(path);\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\nexports.extname = function (path) {\n  if (typeof path !== 'string') path = path + '';\n  var startDot = -1;\n  var startPart = 0;\n  var end = -1;\n  var matchedSlash = true;\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find\n  var preDotState = 0;\n  for (var i = path.length - 1; i >= 0; --i) {\n    var code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n    if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension\n      matchedSlash = false;\n      end = i + 1;\n    }\n    if (code === 46 /*.*/) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n    } else if (startDot !== -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension\n      preDotState = -1;\n    }\n  }\n\n  if (startDot === -1 || end === -1 ||\n      // We saw a non-dot character immediately before the dot\n      preDotState === 0 ||\n      // The (right-most) trimmed path component is exactly '..'\n      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n    return '';\n  }\n  return path.slice(startDot, end);\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = \"./ sync recursive\";","\"use strict\";\n/**\n * Compiler frontend for node.js\n *\n * Uses the low-level API exported from src/index.ts so it works with the compiler compiled to\n * JavaScript as well as the compiler compiled to WebAssembly (eventually). Runs the sources\n * directly through ts-node if distribution files are not present (indicated by a `-dev` version).\n *\n * Can also be packaged as a bundle suitable for in-browser use with the standard library injected\n * in the build step. See dist/asc.js for the bundle and webpack.config.js for building details.\n *\n * @module cli/asc\n */\n\n// Use \".\" instead of \"/\" as cwd in browsers\nif (process.browser) process.cwd = function() { return \".\"; };\n\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst utf8 = require(\"./util/utf8\");\nconst colorsUtil = require(\"./util/colors\");\nconst optionsUtil = require(\"./util/options\");\nconst mkdirp = require(\"./util/mkdirp\");\nconst find = require(\"./util/find\");\nconst EOL = process.platform === \"win32\" ? \"\\r\\n\" : \"\\n\";\nconst SEP = process.platform === \"win32\" ? \"\\\\\" : \"/\";\nconst nearBindings = require(\"near-bindgen-as\");\n\n// global.Binaryen = require(\"../lib/binaryen\");\n\n// Emscripten adds an `uncaughtException` listener to Binaryen that results in an additional\n// useless code fragment on top of an actual error. suppress this:\nif (process.removeAllListeners) process.removeAllListeners(\"uncaughtException\");\n\n// Use distribution files if present, otherwise run the sources directly\nvar assemblyscript, isDev = false;\n(() => {\n  try { // `asc` on the command line\n    assemblyscript = require(\"../dist/assemblyscript.js\");\n  } catch (e) {\n    try { // `asc` on the command line without dist files\n      require(\"ts-node\").register({\n        project: path.join(__dirname, \"..\", \"src\", \"tsconfig.json\"),\n        skipIgnore: true,\n        compilerOptions: { target: \"ES2016\" }\n      });\n      require(\"../src/glue/js\");\n      assemblyscript = require(\"../src\");\n      isDev = true;\n    } catch (e_ts) {\n      try { // `require(\"dist/asc.js\")` in explicit browser tests\n        assemblyscript = eval(\"require('./assemblyscript')\");\n      } catch (e) {\n        throw Error(e_ts.stack + \"\\n---\\n\" + e.stack);\n      }\n    }\n  }\n})();\n\n/** Whether this is a webpack bundle or not. */\nexports.isBundle = typeof BUNDLE_VERSION === \"string\";\n\n/** Whether asc runs the sources directly or not. */\nexports.isDev = isDev;\n\n/** AssemblyScript version. */\nexports.version = exports.isBundle ? BUNDLE_VERSION : require(\"../package.json\").version;\n\n/** Available CLI options. */\nexports.options = require(\"./asc.json\");\n\n/** Prefix used for library files. */\nexports.libraryPrefix = assemblyscript.LIBRARY_PREFIX;\n\n/** Default Binaryen optimization level. */\nexports.defaultOptimizeLevel = 3;\n\n/** Default Binaryen shrink level. */\nexports.defaultShrinkLevel = 1;\n\n/** Bundled library files. */\nexports.libraryFiles = exports.isBundle ? BUNDLE_LIBRARY : (() => { // set up if not a bundle\n  const libDir = path.join(__dirname, \"..\", \"std\", \"assembly\");\n  const bundled = {};\n  find.files(libDir, find.TS_EXCEPT_DTS)\n      .forEach(file => bundled[file.replace(/\\.ts$/, \"\")] = fs.readFileSync(path.join(libDir, file), \"utf8\" ));\n  return bundled;\n})();\n\n/** Bundled definition files. */\nexports.definitionFiles = exports.isBundle ? BUNDLE_DEFINITIONS : (() => { // set up if not a bundle\n  const stdDir = path.join(__dirname, \"..\", \"std\");\n  return {\n    \"assembly\": fs.readFileSync(path.join(stdDir, \"assembly\", \"index.d.ts\"), \"utf8\"),\n    \"portable\": fs.readFileSync(path.join(stdDir, \"portable\", \"index.d.ts\"), \"utf8\")\n  };\n})();\n\n/** Convenience function that parses and compiles source strings directly. */\nexports.compileString = (sources, options) => {\n  if (typeof sources === \"string\") sources = { \"input.ts\": sources };\n  const output = Object.create({\n    stdout: createMemoryStream(),\n    stderr: createMemoryStream()\n  });\n  var argv = [\n    \"--binaryFile\", \"binary\",\n    \"--textFile\", \"text\",\n  ];\n  Object.keys(options || {}).forEach(key => {\n    var val = options[key];\n    if (Array.isArray(val)) val.forEach(val => argv.push(\"--\" + key, String(val)));\n    else argv.push(\"--\" + key, String(val));\n  });\n  exports.main(argv.concat(Object.keys(sources)), {\n    stdout: output.stdout,\n    stderr: output.stderr,\n    readFile: name => sources.hasOwnProperty(name) ? sources[name] : null,\n    writeFile: (name, contents) => output[name] = contents,\n    listFiles: () => []\n  });\n  return output;\n}\n\n/** Runs the command line utility using the specified arguments array. */\nexports.main = function main(argv, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = {};\n  } else if (!options) {\n    options = {};\n  }\n\n  const stdout = options.stdout || process.stdout;\n  const stderr = options.stderr || process.stderr;\n  const readFile = options.readFile || readFileNode;\n  const writeFile = options.writeFile || writeFileNode;\n  const listFiles = options.listFiles || listFilesNode;\n  const stats = options.stats || createStats();\n\n  // Output must be specified if not present in the environment\n  if (!stdout) throw Error(\"'options.stdout' must be specified\");\n  if (!stderr) throw Error(\"'options.stderr' must be specified\");\n\n  const opts = optionsUtil.parse(argv, exports.options);\n  const args = opts.options;\n  argv = opts.arguments;\n  if (args.noColors) {\n    colorsUtil.stdout.supported =\n    colorsUtil.stderr.supported = false;\n  } else {\n    colorsUtil.stdout = colorsUtil.from(stdout);\n    colorsUtil.stderr = colorsUtil.from(stderr);\n  }\n\n  // Check for unknown arguments\n  if (opts.unknown.length) {\n    opts.unknown.forEach(arg => {\n      stderr.write(colorsUtil.stderr.yellow(\"WARN: \") + \"Unknown option '\" + arg + \"'\" + EOL);\n    });\n  }\n\n  // Check for trailing arguments\n  if (opts.trailing.length) {\n    stderr.write(colorsUtil.stderr.yellow(\"WARN: \") + \"Unsupported trailing arguments: \" + opts.trailing.join(\" \") + EOL);\n  }\n\n  // Use default callback if none is provided\n  if (!callback) callback = function defaultCallback(err) {\n    var code = 0;\n    if (err) {\n      stderr.write(colorsUtil.stderr.red(\"ERROR: \") + err.stack.replace(/^ERROR: /i, \"\") + EOL);\n      code = 1;\n    }\n    return code;\n  };\n\n  // Just print the version if requested\n  if (args.version) {\n    stdout.write(\"Version \" + exports.version + (isDev ? \"-dev\" : \"\") + EOL);\n    return callback(null);\n  }\n\n  // Print the help message if requested or no source files are provided\n  if (args.help || !argv.length) {\n    var out = args.help ? stdout : stderr;\n    var color = args.help ? colorsUtil.stdout : colorsUtil.stderr;\n    out.write([\n      color.white(\"SYNTAX\"),\n      \"  \" + color.cyan(\"asc\") + \" [entryFile ...] [options]\",\n      \"\",\n      color.white(\"EXAMPLES\"),\n      \"  \" + color.cyan(\"asc\") + \" hello.ts\",\n      \"  \" + color.cyan(\"asc\") + \" hello.ts -b hello.wasm -t hello.wat\",\n      \"  \" + color.cyan(\"asc\") + \" hello1.ts hello2.ts -b -O > hello.wasm\",\n      \"\",\n      color.white(\"OPTIONS\"),\n    ].concat(\n      optionsUtil.help(exports.options, 24, EOL)\n    ).join(EOL) + EOL);\n    return callback(null);\n  }\n\n  // I/O must be specified if not present in the environment\n  if (!fs.readFileSync) {\n    if (readFile === readFileNode) throw Error(\"'options.readFile' must be specified\");\n    if (writeFile === writeFileNode) throw Error(\"'options.writeFile' must be specified\");\n    if (listFiles === listFilesNode) throw Error(\"'options.listFiles' must be specified\");\n  }\n\n  // Set up base directory\n  const baseDir = args.baseDir ? path.resolve(args.baseDir) : \".\";\n\n  // Set up options\n  const compilerOptions = assemblyscript.newOptions();\n  assemblyscript.setTarget(compilerOptions, 0);\n  assemblyscript.setNoAssert(compilerOptions, args.noAssert);\n  assemblyscript.setImportMemory(compilerOptions, args.importMemory);\n  assemblyscript.setSharedMemory(compilerOptions, args.sharedMemory);\n  assemblyscript.setImportTable(compilerOptions, args.importTable);\n  assemblyscript.setExportTable(compilerOptions, args.exportTable);\n  assemblyscript.setExplicitStart(compilerOptions, args.explicitStart);\n  assemblyscript.setMemoryBase(compilerOptions, args.memoryBase >>> 0);\n  assemblyscript.setSourceMap(compilerOptions, args.sourceMap != null);\n  assemblyscript.setNoUnsafe(compilerOptions, args.noUnsafe);\n\n  // Initialize default aliases\n  assemblyscript.setGlobalAlias(compilerOptions, \"Math\", \"NativeMath\");\n  assemblyscript.setGlobalAlias(compilerOptions, \"Mathf\", \"NativeMathf\");\n  assemblyscript.setGlobalAlias(compilerOptions, \"abort\", \"~lib/builtins/abort\");\n  assemblyscript.setGlobalAlias(compilerOptions, \"trace\", \"~lib/builtins/trace\");\n\n  // Add or override aliases if specified\n  if (args.use) {\n    let aliases = args.use;\n    for (let i = 0, k = aliases.length; i < k; ++i) {\n      let part = aliases[i];\n      let p = part.indexOf(\"=\");\n      if (p < 0) return callback(Error(\"Global alias '\" + part + \"' is invalid.\"));\n      let alias = part.substring(0, p).trim();\n      let name = part.substring(p + 1).trim();\n      if (!alias.length) return callback(Error(\"Global alias '\" + part + \"' is invalid.\"));\n      assemblyscript.setGlobalAlias(compilerOptions, alias, name);\n    }\n  }\n\n  // Disable default features if specified\n  var features;\n  if ((features = args.disable) != null) {\n    if (typeof features === \"string\") features = features.split(\",\");\n    for (let i = 0, k = features.length; i < k; ++i) {\n      let name = features[i].trim();\n      let flag = assemblyscript[\"FEATURE_\" + name.replace(/\\-/g, \"_\").toUpperCase()];\n      if (!flag) return callback(Error(\"Feature '\" + name + \"' is unknown.\"));\n      assemblyscript.disableFeature(compilerOptions, flag);\n    }\n  }\n\n  // Enable experimental features if specified\n  if ((features = args.enable) != null) {\n    if (typeof features === \"string\") features = features.split(\",\");\n    for (let i = 0, k = features.length; i < k; ++i) {\n      let name = features[i].trim();\n      let flag = assemblyscript[\"FEATURE_\" + name.replace(/\\-/g, \"_\").toUpperCase()];\n      if (!flag) return callback(Error(\"Feature '\" + name + \"' is unknown.\"));\n      assemblyscript.enableFeature(compilerOptions, flag);\n    }\n  }\n\n  // Set up optimization levels\n  var optimizeLevel = 0;\n  var shrinkLevel = 0;\n  if (args.optimize) {\n    optimizeLevel = exports.defaultOptimizeLevel;\n    shrinkLevel = exports.defaultShrinkLevel;\n  }\n  if (typeof args.optimizeLevel === \"number\") optimizeLevel = args.optimizeLevel;\n  if (typeof args.shrinkLevel === \"number\") shrinkLevel = args.shrinkLevel;\n  optimizeLevel = Math.min(Math.max(optimizeLevel, 0), 3);\n  shrinkLevel = Math.min(Math.max(shrinkLevel, 0), 2);\n  assemblyscript.setOptimizeLevelHints(compilerOptions, optimizeLevel, shrinkLevel);\n\n  // Initialize the program\n  const program = assemblyscript.newProgram(compilerOptions);\n\n  // Set up transforms\n  const transforms = args.notNear ? [] :  [nearBindings];\n  //Add near's bindings by default\n  if (args.transform) {\n    let tsNodeRegistered = false;\n    let transformArgs = args.transform;\n    for (let i = 0, k = transformArgs.length; i < k; ++i) {\n      let filename = transformArgs[i].trim();\n      if (!tsNodeRegistered && filename.endsWith('.ts')) {\n        require(\"ts-node\").register({ transpileOnly: true, skipProject: true, compilerOptions: { target: \"ES2016\" } });\n        tsNodeRegistered = true;\n      }\n      try {\n        const classOrModule = require(require.resolve(filename, { paths: [baseDir, process.cwd()] }));\n        if (typeof classOrModule === \"function\") {\n          Object.assign(classOrModule.prototype, {\n            program,\n            baseDir,\n            stdout,\n            stderr,\n            log: console.error,\n            readFile,\n            writeFile,\n            listFiles\n          });\n          transforms.push(new classOrModule());\n        } else {\n          transforms.push(classOrModule); // legacy module\n        }\n      } catch (e) {\n        return callback(e);\n      }\n    }\n  }\n  function applyTransform(name, ...args) {\n    for (let i = 0, k = transforms.length; i < k; ++i) {\n      let transform = transforms[i];\n      if (typeof transform[name] === \"function\") {\n        try {\n          transform[name](...args);\n        } catch (e) {\n          return e;\n        }\n      }\n    }\n  }\n\n  // Parse library files\n  Object.keys(exports.libraryFiles).forEach(libPath => {\n    if (libPath.indexOf(\"/\") >= 0) return; // in sub-directory: imported on demand\n    stats.parseCount++;\n    stats.parseTime += measure(() => {\n      assemblyscript.parse(program, exports.libraryFiles[libPath], exports.libraryPrefix + libPath + \".ts\", false);\n    });\n  });\n  const customLibDirs = [];\n  if (args.lib) {\n    let lib = args.lib;\n    if (typeof lib === \"string\") lib = lib.split(\",\");\n    Array.prototype.push.apply(customLibDirs, lib.map(lib => lib.trim()));\n    for (let i = 0, k = customLibDirs.length; i < k; ++i) { // custom\n      let libDir = customLibDirs[i];\n      let libFiles;\n      if (libDir.endsWith(\".ts\")) {\n        libFiles = [ path.basename(libDir) ];\n        libDir = path.dirname(libDir);\n      } else {\n        libFiles = listFiles(libDir, baseDir) || [];\n      }\n      for (let j = 0, l = libFiles.length; j < l; ++j) {\n        let libPath = libFiles[j];\n        let libText = readFile(libPath, libDir);\n        if (libText === null) return callback(Error(\"Library file '\" + libPath + \"' not found.\"));\n        stats.parseCount++;\n        exports.libraryFiles[libPath.replace(/\\.ts$/, \"\")] = libText;\n        stats.parseTime += measure(() => {\n          assemblyscript.parse(program, libText, exports.libraryPrefix + libPath, false);\n        });\n      }\n    }\n  }\n  args.path = args.path || [];\n\n  // Maps package names to parent directory\n  var packageMains = new Map();\n  var packageBases = new Map();\n\n  // Gets the file matching the specified source path, imported at the given dependee path\n  function getFile(internalPath, dependeePath) {\n    var sourceText = null; // text reported back to the compiler\n    var sourcePath = null; // path reported back to the compiler\n\n    const libraryPrefix = exports.libraryPrefix;\n    const libraryFiles = exports.libraryFiles;\n\n    // Try file.ts, file/index.ts, file.d.ts\n    if (!internalPath.startsWith(libraryPrefix)) {\n      if ((sourceText = readFile(sourcePath = internalPath + \".ts\", baseDir)) == null) {\n        if ((sourceText = readFile(sourcePath = internalPath + \"/index.ts\", baseDir)) == null) {\n          // portable d.ts: uses the .js file next to it in JS or becomes an import in Wasm\n          sourceText = readFile(sourcePath = internalPath + \".d.ts\", baseDir);\n        }\n      }\n\n    // Search library in this order: stdlib, custom lib dirs, paths\n    } else {\n      const plainName = internalPath.substring(libraryPrefix.length);\n      const indexName = plainName + \"/index\";\n      if (libraryFiles.hasOwnProperty(plainName)) {\n        sourceText = libraryFiles[plainName];\n        sourcePath = libraryPrefix + plainName + \".ts\";\n      } else if (libraryFiles.hasOwnProperty(indexName)) {\n        sourceText = libraryFiles[indexName];\n        sourcePath = libraryPrefix + indexName + \".ts\";\n      } else { // custom lib dirs\n        for (const libDir of customLibDirs) {\n          if ((sourceText = readFile(plainName + \".ts\", libDir)) != null) {\n            sourcePath = libraryPrefix + plainName + \".ts\";\n            break;\n          } else {\n            if ((sourceText = readFile(indexName + \".ts\", libDir)) != null) {\n              sourcePath = libraryPrefix + indexName + \".ts\";\n              break;\n            }\n          }\n        }\n        if (sourceText == null) { // paths\n          const match = internalPath.match(/^~lib\\/((?:@[^\\/]+\\/)?[^\\/]+)(?:\\/(.+))?/); // ~lib/(pkg)/(path), ~lib/(@org/pkg)/(path)\n          if (match) {\n            const packageName = match[1];\n            const isPackageRoot = match[2] === undefined;\n            const filePath = isPackageRoot ? \"index\" : match[2];\n            const basePath = packageBases.has(dependeePath) ? packageBases.get(dependeePath) : \".\";\n            if (args.traceResolution) stderr.write(\"Looking for package '\" + packageName + \"' file '\" + filePath + \"' relative to '\" + basePath + \"'\" + EOL);\n            const absBasePath = path.isAbsolute(basePath) ? basePath : path.join(baseDir, basePath);\n            const paths = [];\n            for (let parts = absBasePath.split(SEP), i = parts.length, k = SEP == \"/\" ? 0 : 1; i >= k; --i) {\n              if (parts[i - 1] !== \"node_modules\") paths.push(parts.slice(0, i).join(SEP) + SEP + \"node_modules\");\n            }\n            for (const currentPath of paths.concat(...args.path).map(p => path.relative(baseDir, p))) {\n              if (args.traceResolution) stderr.write(\"  in \" + path.join(currentPath, packageName) + EOL);\n              let mainPath = \"assembly\";\n              if (packageMains.has(packageName)) { // use cached\n                mainPath = packageMains.get(packageName);\n              } else { // evaluate package.json\n                let jsonPath = path.join(currentPath, packageName, \"package.json\");\n                let jsonText = readFile(jsonPath, baseDir);\n                if (jsonText != null) {\n                  try {\n                    let json = JSON.parse(jsonText);\n                    if (typeof json.ascMain === \"string\") {\n                      mainPath = json.ascMain.replace(/[\\/\\\\]index\\.ts$/, \"\");\n                      packageMains.set(packageName, mainPath);\n                    }\n                  } catch (e) { }\n                }\n              }\n              const mainDir = path.join(currentPath, packageName, mainPath);\n              const plainName = filePath;\n              if ((sourceText = readFile(path.join(mainDir, plainName + \".ts\"), baseDir)) != null) {\n                sourcePath = libraryPrefix + packageName + \"/\" + plainName + \".ts\";\n                packageBases.set(sourcePath.replace(/\\.ts$/, \"\"), path.join(currentPath, packageName));\n                if (args.traceResolution) stderr.write(\"  -> \" + path.join(mainDir, plainName + \".ts\") + EOL);\n                break;\n              } else if (!isPackageRoot) {\n                const indexName = filePath + \"/index\";\n                if ((sourceText = readFile(path.join(mainDir, indexName + \".ts\"), baseDir)) !== null) {\n                  sourcePath = libraryPrefix + packageName + \"/\" + indexName + \".ts\";\n                  packageBases.set(sourcePath.replace(/\\.ts$/, \"\"), path.join(currentPath, packageName));\n                  if (args.traceResolution) stderr.write(\"  -> \" + path.join(mainDir, indexName + \".ts\") + EOL);\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    // No such file\n    if (sourceText == null) return null;\n    return { sourceText, sourcePath };\n  }\n\n  // Parses the backlog of imported files after including entry files\n  function parseBacklog() {\n    var internalPath;\n    while ((internalPath = assemblyscript.nextFile(program)) != null) {\n      let file = getFile(internalPath, assemblyscript.getDependee(program, internalPath));\n      if (!file) return callback(Error(\"Import file '\" + internalPath + \".ts' not found.\"))\n      stats.parseCount++;\n      stats.parseTime += measure(() => {\n        assemblyscript.parse(program, file.sourceText, file.sourcePath, false);\n      });\n    }\n    if (checkDiagnostics(program, stderr)) return callback(Error(\"Parse error\"));\n  }\n\n  // Include runtime template before entry files so its setup runs first\n  {\n    let runtimeName = String(args.runtime);\n    let runtimePath = \"rt/index-\" + runtimeName;\n    let runtimeText = exports.libraryFiles[runtimePath];\n    if (runtimeText == null) {\n      runtimePath = runtimeName;\n      runtimeText = readFile(runtimePath + \".ts\", baseDir);\n      if (runtimeText == null) return callback(Error(\"Runtime '\" + runtimeName + \"' not found.\"));\n    } else {\n      runtimePath = \"~lib/\" + runtimePath;\n    }\n    stats.parseCount++;\n    stats.parseTime += measure(() => {\n      assemblyscript.parse(program, runtimeText, runtimePath, true);\n    });\n  }\n\n  // Include entry files\n  for (let i = 0, k = argv.length; i < k; ++i) {\n    const filename = argv[i];\n\n    let sourcePath = String(filename).replace(/\\\\/g, \"/\").replace(/(\\.ts|\\/)$/, \"\");\n    // Setting the path to relative path\n    sourcePath = path.isAbsolute(sourcePath) ? path.relative(baseDir, sourcePath) : sourcePath;\n\n    // Try entryPath.ts, then entryPath/index.ts\n    let sourceText = readFile(sourcePath + \".ts\", baseDir);\n    if (sourceText == null) {\n      sourceText = readFile(sourcePath + \"/index.ts\", baseDir);\n      if (sourceText == null) return callback(Error(\"Entry file '\" + sourcePath + \".ts' not found.\"));\n      sourcePath += \"/index.ts\";\n    } else {\n      sourcePath += \".ts\";\n    }\n\n    stats.parseCount++;\n    stats.parseTime += measure(() => {\n      assemblyscript.parse(program, sourceText, sourcePath, true);\n    });\n  }\n\n  // Parse entry files\n  {\n    let code = parseBacklog();\n    if (code) return code;\n  }\n\n  // Call afterParse transform hook\n  {\n    let error = applyTransform(\"afterParse\", program.parser);\n    if (error) return callback(error);\n  }\n\n  // Parse additional files, if any\n  {\n    let code = parseBacklog();\n    if (code) return code;\n  }\n\n  // Print files and exit if listFiles\n  if (args.listFiles) {\n    // FIXME: not a proper C-like API\n    stderr.write(program.sources.map(s => s.normalizedPath).sort().join(EOL) + EOL);\n    return callback(null);\n  }\n\n  // Set up optimization levels\n  var optimizeLevel = 0;\n  var shrinkLevel = 0;\n  if (args.optimize) {\n    optimizeLevel = exports.defaultOptimizeLevel;\n    shrinkLevel = exports.defaultShrinkLevel;\n  }\n  if (typeof args.optimizeLevel === \"number\") {\n    optimizeLevel = args.optimizeLevel;\n  }\n  if (typeof args.shrinkLevel === \"number\") {\n    shrinkLevel = args.shrinkLevel;\n  }\n  optimizeLevel = Math.min(Math.max(optimizeLevel, 0), 3);\n  shrinkLevel = Math.min(Math.max(shrinkLevel, 0), 2);\n\n  var module;\n  stats.compileCount++;\n  try {\n    stats.compileTime += measure(() => {\n      module = assemblyscript.compile(program);\n    });\n  } catch (e) {\n    return callback(e);\n  }\n  if (checkDiagnostics(program, stderr)) {\n    if (module) module.dispose();\n    return callback(Error(\"Compile error\"));\n  }\n\n  // Call afterCompile transform hook\n  {\n    let error = applyTransform(\"afterCompile\", module);\n    if (error) return callback(error);\n  }\n\n  // Validate the module if requested\n  if (args.validate) {\n    stats.validateCount++;\n    stats.validateTime += measure(() => {\n      if (!module.validate()) {\n        module.dispose();\n        return callback(Error(\"Validate error\"));\n      }\n    });\n  }\n\n  // Set Binaryen-specific options\n  if (args.trapMode === \"clamp\") {\n    stats.optimizeCount++;\n    stats.optimizeTime += measure(() => {\n      module.runPasses([ \"trap-mode-clamp\" ]);\n    });\n  } else if (args.trapMode === \"js\") {\n    stats.optimizeCount++;\n    stats.optimizeTime += measure(() => {\n      module.runPasses([ \"trap-mode-js\" ]);\n    });\n  } else if (args.trapMode !== \"allow\") {\n    module.dispose();\n    return callback(Error(\"Unsupported trap mode\"));\n  }\n\n  // Implicitly run costly non-LLVM optimizations on -O3 or -Oz\n  // see: https://github.com/WebAssembly/binaryen/pull/1596\n  if (optimizeLevel >= 3 || shrinkLevel >= 2) optimizeLevel = 4;\n\n  module.setOptimizeLevel(optimizeLevel);\n  module.setShrinkLevel(shrinkLevel);\n  module.setDebugInfo(args.debug);\n\n  const runPasses = [];\n  if (args.runPasses) {\n    if (typeof args.runPasses === \"string\") {\n      args.runPasses = args.runPasses.split(\",\");\n    }\n    if (args.runPasses.length) {\n      args.runPasses.forEach(pass => {\n        if (runPasses.indexOf(pass = pass.trim()) < 0)\n          runPasses.push(pass);\n      });\n    }\n  }\n\n  function doOptimize() {\n    const hasARC = args.runtime == \"half\" || args.runtime == \"full\";\n    const passes = [];\n    function add(pass) { passes.push(pass); }\n\n    // Optimize the module if requested\n    if (optimizeLevel > 0 || shrinkLevel > 0) {\n      // Binaryen's default passes with Post-AssemblyScript passes added.\n      // see: Binaryen/src/pass.cpp\n\n      // PassRunner::addDefaultGlobalOptimizationPrePasses\n      add(\"duplicate-function-elimination\");\n\n      // PassRunner::addDefaultFunctionOptimizationPasses\n      if (optimizeLevel >= 3 || shrinkLevel >= 1) {\n        add(\"ssa-nomerge\");\n      }\n      if (optimizeLevel >= 4) {\n        add(\"flatten\");\n        add(\"local-cse\");\n      }\n      if (hasARC) { // differs\n        if (optimizeLevel < 4) {\n          add(\"flatten\");\n        }\n        add(\"post-assemblyscript\");\n      }\n      add(\"dce\");\n      add(\"remove-unused-brs\");\n      add(\"remove-unused-names\");\n      add(\"optimize-instructions\");\n      if (optimizeLevel >= 2 || shrinkLevel >= 2) {\n        add(\"pick-load-signs\");\n      }\n      if (optimizeLevel >= 3 || shrinkLevel >= 2) {\n        add(\"precompute-propagate\");\n      } else {\n        add(\"precompute\");\n      }\n      if (optimizeLevel >= 2 || shrinkLevel >= 2) {\n        add(\"code-pushing\");\n      }\n      add(\"simplify-locals-nostructure\");\n      add(\"vacuum\");\n      add(\"reorder-locals\");\n      add(\"remove-unused-brs\");\n      if (optimizeLevel >= 3 || shrinkLevel >= 2) {\n        add(\"merge-locals\");\n      }\n      add(\"coalesce-locals\");\n      add(\"simplify-locals\");\n      add(\"vacuum\");\n      add(\"reorder-locals\");\n      add(\"coalesce-locals\");\n      add(\"reorder-locals\");\n      add(\"vacuum\");\n      if (optimizeLevel >= 3 || shrinkLevel >= 1) {\n        add(\"code-folding\");\n      }\n      add(\"merge-blocks\");\n      add(\"remove-unused-brs\");\n      add(\"remove-unused-names\");\n      add(\"merge-blocks\");\n      if (optimizeLevel >= 3 || shrinkLevel >= 2) {\n        add(\"precompute-propagate\");\n      } else {\n        add(\"precompute\");\n      }\n      add(\"optimize-instructions\");\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        add(\"rse\");\n      }\n      if (hasARC) { // differs\n        add(\"post-assemblyscript-finalize\");\n      }\n      add(\"vacuum\");\n\n      // PassRunner::addDefaultGlobalOptimizationPostPasses\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        add(\"dae-optimizing\");\n      }\n      if (optimizeLevel >= 2 || shrinkLevel >= 2) {\n        add(\"inlining-optimizing\");\n      }\n      add(\"duplicate-function-elimination\");\n      add(\"duplicate-import-elimination\");\n      if (optimizeLevel >= 2 || shrinkLevel >= 2) {\n        add(\"simplify-globals-optimizing\");\n      } else {\n        add(\"simplify-globals\");\n      }\n      add(\"remove-unused-module-elements\");\n      add(\"memory-packing\");\n      add(\"directize\");\n      add(\"inlining-optimizing\"); // differs\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        add(\"generate-stack-ir\");\n        add(\"optimize-stack-ir\");\n      }\n    }\n\n    // Append additional passes if requested and execute\n    module.runPasses(passes.concat(runPasses));\n  }\n\n  stats.optimizeTime += measure(() => {\n    stats.optimizeCount++;\n    doOptimize();\n    if (args.converge) {\n      let last = module.toBinary();\n      do {\n        stats.optimizeCount++;\n        doOptimize();\n        let next = module.toBinary();\n        if (next.output.length >= last.output.length) {\n          if (next.output.length > last.output.length) {\n            stderr.write(\"Last converge was suboptimial.\" + EOL);\n          }\n          break;\n        }\n        last = next;\n      } while (true);\n    }\n  });\n\n  // Prepare output\n  if (!args.noEmit) {\n    let hasStdout = false;\n    let hasOutput = false;\n\n    if (args.outFile != null) {\n      if (/\\.was?t$/.test(args.outFile) && args.textFile == null) {\n        args.textFile = args.outFile;\n      } else if (/\\.js$/.test(args.outFile) && args.asmjsFile == null) {\n        args.asmjsFile = args.outFile;\n      } else if (args.binaryFile == null) {\n        args.binaryFile = args.outFile;\n      }\n    }\n\n    // Write binary\n    if (args.binaryFile != null) {\n      let basename = path.basename(args.binaryFile);\n      let sourceMapURL = args.sourceMap != null\n        ? args.sourceMap.length\n          ? args.sourceMap\n          : \"./\" + basename + \".map\"\n        : null;\n\n      let wasm;\n      stats.emitCount++;\n      stats.emitTime += measure(() => {\n        wasm = module.toBinary(sourceMapURL);\n      });\n\n      if (args.binaryFile.length) {\n        writeFile(args.binaryFile, wasm.output, baseDir);\n      } else {\n        writeStdout(wasm.output);\n        hasStdout = true;\n      }\n      hasOutput = true;\n\n      // Post-process source map\n      if (wasm.sourceMap != null) {\n        if (args.binaryFile.length) {\n          let map = JSON.parse(wasm.sourceMap);\n          map.sourceRoot = \"./\" + basename;\n          let contents = [];\n          map.sources.forEach((name, index) => {\n            let text = assemblyscript.getSource(program, name.replace(/\\.ts$/, \"\"));\n            if (text == null) return callback(Error(\"Source of file '\" + name + \"' not found.\"));\n            contents[index] = text;\n          });\n          map.sourcesContent = contents;\n          writeFile(path.join(\n            path.dirname(args.binaryFile),\n            path.basename(sourceMapURL)\n          ).replace(/^\\.\\//, \"\"), JSON.stringify(map), baseDir);\n        } else {\n          stderr.write(\"Skipped source map (stdout already occupied)\" + EOL);\n        }\n      }\n    }\n\n    // Write asm.js\n    if (args.asmjsFile != null) {\n      let asm;\n      if (args.asmjsFile.length) {\n        stats.emitCount++;\n        stats.emitTime += measure(() => {\n          asm = module.toAsmjs();\n        });\n        writeFile(args.asmjsFile, asm, baseDir);\n      } else if (!hasStdout) {\n        stats.emitCount++;\n        stats.emitTime += measure(() => {\n          asm = module.toAsmjs();\n        });\n        writeStdout(asm);\n        hasStdout = true;\n      }\n      hasOutput = true;\n    }\n\n    // Write WebIDL\n    if (args.idlFile != null) {\n      let idl;\n      if (args.idlFile.length) {\n        stats.emitCount++;\n        stats.emitTime += measure(() => {\n          idl = assemblyscript.buildIDL(program);\n        });\n        writeFile(args.idlFile, idl, baseDir);\n      } else if (!hasStdout) {\n        stats.emitCount++;\n        stats.emitTime += measure(() => {\n          idl = assemblyscript.buildIDL(program);\n        });\n        writeStdout(idl);\n        hasStdout = true;\n      }\n      hasOutput = true;\n    }\n\n    // Write TypeScript definition\n    if (args.tsdFile != null) {\n      let tsd;\n      if (args.tsdFile.length) {\n        stats.emitCount++;\n        stats.emitTime += measure(() => {\n          tsd = assemblyscript.buildTSD(program);\n        });\n        writeFile(args.tsdFile, tsd, baseDir);\n      } else if (!hasStdout) {\n        stats.emitCount++;\n        stats.emitTime += measure(() => {\n          tsd = assemblyscript.buildTSD(program);\n        });\n        writeStdout(tsd);\n        hasStdout = true;\n      }\n      hasOutput = true;\n    }\n\n    // Write text (must be last)\n    if (args.textFile != null || !hasOutput) {\n      let wat;\n      if (args.textFile && args.textFile.length) {\n        stats.emitCount++;\n        stats.emitTime += measure(() => {\n          wat = module.toText();\n        });\n        writeFile(args.textFile, wat, baseDir);\n      } else if (!hasStdout) {\n        stats.emitCount++;\n        stats.emitTime += measure(() => {\n          wat = module.toText()\n        });\n        writeStdout(wat);\n      }\n    }\n  }\n\n  module.dispose();\n  if (args.measure) {\n    printStats(stats, stderr);\n  }\n  if (args.printrtti) {\n    printRTTI(program, stderr);\n  }\n  return callback(null);\n\n  function readFileNode(filename, baseDir) {\n    let name = path.resolve(baseDir, filename);\n    try {\n      let text;\n      stats.readCount++;\n      stats.readTime += measure(() => {\n        text = fs.readFileSync(name, { encoding: \"utf8\" });\n      });\n      return text;\n    } catch (e) {\n      return null;\n    }\n  }\n\n  function writeFileNode(filename, contents, baseDir) {\n    try {\n      stats.writeCount++;\n      stats.writeTime += measure(() => {\n        mkdirp(path.join(baseDir, path.dirname(filename)));\n        if (typeof contents === \"string\") {\n          fs.writeFileSync(path.join(baseDir, filename), contents, { encoding: \"utf8\" } );\n        } else {\n          fs.writeFileSync(path.join(baseDir, filename), contents);\n        }\n      });\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  function listFilesNode(dirname, baseDir) {\n    var files;\n    try {\n      stats.readTime += measure(() => {\n        files = fs.readdirSync(path.join(baseDir, dirname)).filter(file => /^(?!.*\\.d\\.ts$).*\\.ts$/.test(file));\n      });\n      return files;\n    } catch (e) {\n      return null;\n    }\n  }\n\n  function writeStdout(contents) {\n    if (!writeStdout.used) {\n      stats.writeCount++;\n      writeStdout.used = true;\n    }\n    stats.writeTime += measure(() => {\n      if (typeof contents === \"string\") {\n        stdout.write(contents, { encoding: \"utf8\" });\n      } else {\n        stdout.write(contents);\n      }\n    });\n  }\n}\n\n/** Checks diagnostics emitted so far for errors. */\nfunction checkDiagnostics(program, stderr) {\n  var diagnostic;\n  var hasErrors = false;\n  while ((diagnostic = assemblyscript.nextDiagnostic(program)) != null) {\n    if (stderr) {\n      stderr.write(\n        assemblyscript.formatDiagnostic(diagnostic, stderr.isTTY, true) +\n        EOL + EOL\n      );\n    }\n    if (assemblyscript.isError(diagnostic)) hasErrors = true;\n  }\n  return hasErrors;\n}\n\nexports.checkDiagnostics = checkDiagnostics;\n\n/** Creates an empty set of stats. */\nfunction createStats() {\n  return {\n    readTime: 0,\n    readCount: 0,\n    writeTime: 0,\n    writeCount: 0,\n    parseTime: 0,\n    parseCount: 0,\n    compileTime: 0,\n    compileCount: 0,\n    emitTime: 0,\n    emitCount: 0,\n    validateTime: 0,\n    validateCount: 0,\n    optimizeTime: 0,\n    optimizeCount: 0\n  };\n}\n\nexports.createStats = createStats;\n\nif (!process.hrtime) process.hrtime = require(\"browser-process-hrtime\");\n\n/** Measures the execution time of the specified function.  */\nfunction measure(fn) {\n  const start = process.hrtime();\n  fn();\n  const times = process.hrtime(start);\n  return times[0] * 1e9 + times[1];\n}\n\nexports.measure = measure;\n\n/** Formats a high resolution time to a human readable string. */\nfunction formatTime(time) {\n  return time ? (time / 1e6).toFixed(3) + \" ms\" : \"N/A\";\n}\n\nexports.formatTime = formatTime;\n\n/** Formats and prints out the contents of a set of stats. */\nfunction printStats(stats, output) {\n  function format(time, count) {\n    return formatTime(time);\n  }\n  (output || process.stdout).write([\n    \"I/O Read  : \" + format(stats.readTime, stats.readCount),\n    \"I/O Write : \" + format(stats.writeTime, stats.writeCount),\n    \"Parse     : \" + format(stats.parseTime, stats.parseCount),\n    \"Compile   : \" + format(stats.compileTime, stats.compileCount),\n    \"Emit      : \" + format(stats.emitTime, stats.emitCount),\n    \"Validate  : \" + format(stats.validateTime, stats.validateCount),\n    \"Optimize  : \" + format(stats.optimizeTime, stats.optimizeCount)\n  ].join(EOL) + EOL);\n}\n\nexports.printStats = printStats;\n\n/** Prints runtime type information. */\nfunction printRTTI(program, output) {\n  if (!output) output = process.stderr;\n  output.write(\"# Runtime type information (RTTI)\\n\");\n  output.write(assemblyscript.buildRTTI(program));\n}\n\nexports.printRTTI = printRTTI;\n\nvar allocBuffer = typeof global !== \"undefined\" && global.Buffer\n  ? global.Buffer.allocUnsafe || function(len) { return new global.Buffer(len); }\n  : function(len) { return new Uint8Array(len) };\n\n/** Creates a memory stream that can be used in place of stdout/stderr. */\nfunction createMemoryStream(fn) {\n  var stream = [];\n  stream.write = function(chunk) {\n    if (fn) fn(chunk);\n    if (typeof chunk === \"string\") {\n      let buffer = allocBuffer(utf8.length(chunk));\n      utf8.write(chunk, buffer, 0);\n      chunk = buffer;\n    }\n    this.push(chunk);\n  };\n  stream.reset = function() {\n    stream.length = 0;\n  };\n  stream.toBuffer = function() {\n    var offset = 0, i = 0, k = this.length;\n    while (i < k) offset += this[i++].length;\n    var buffer = allocBuffer(offset);\n    offset = i = 0;\n    while (i < k) {\n      buffer.set(this[i], offset);\n      offset += this[i].length;\n      ++i;\n    }\n    return buffer;\n  };\n  stream.toString = function() {\n    var buffer = this.toBuffer();\n    return utf8.read(buffer, 0, buffer.length);\n  };\n  return stream;\n}\n\nexports.createMemoryStream = createMemoryStream;\n\n/** Compatible TypeScript compiler options for syntax highlighting etc. */\nexports.tscOptions = {\n  alwaysStrict: true,\n  noImplicitAny: true,\n  noImplicitReturns: true,\n  noImplicitThis: true,\n  noEmitOnError: true,\n  strictNullChecks: true,\n  experimentalDecorators: true,\n  target: \"esnext\",\n  module: \"commonjs\",\n  noLib: true,\n  types: [],\n  allowJs: false\n};\n","var proc = typeof process !== \"undefined\" && process || {};\nvar isCI = proc.env && \"CI\" in proc.env; // doesn't work when bundled because 'process' is a mock\n\nfunction from(stream, base) {\n  var colors = base || {};\n  colors.supported = (stream && !!stream.isTTY) || isCI;\n  colors.gray = text => colors.supported ? exports.GRAY + text + exports.RESET : text;\n  colors.red = text => colors.supported ? exports.RED + text + exports.RESET : text;\n  colors.green = text => colors.supported ? exports.GREEN + text + exports.RESET : text;\n  colors.yellow = text => colors.supported ? exports.YELLOW + text + exports.RESET : text;\n  colors.blue = text => colors.supported ? exports.BLUE + text + exports.RESET : text;\n  colors.magenta = text => colors.supported ? exports.MAGENTA + text + exports.RESET : text;\n  colors.cyan = text => colors.supported ? exports.CYAN + text + exports.RESET : text;\n  colors.white = text => colors.supported ? exports.WHITE + text + exports.RESET : text;\n  return colors;\n}\n\nexports.stdout = from(proc.stdout, exports);\nexports.stderr = from(proc.stderr);\nexports.from = from;\n\nexports.GRAY = \"\\u001b[90m\";\nexports.RED = \"\\u001b[91m\";\nexports.GREEN = \"\\u001b[92m\";\nexports.YELLOW = \"\\u001b[93m\";\nexports.BLUE = \"\\u001b[94m\";\nexports.MAGENTA = \"\\u001b[95m\";\nexports.CYAN = \"\\u001b[96m\";\nexports.WHITE = \"\\u001b[97m\";\nexports.RESET = \"\\u001b[0m\";\n","const fs = require(\"fs\");\nconst path = require(\"path\");\n\nfunction findFiles(dirname, filter) {\n  var out = [];\n  fs.readdirSync(dirname).forEach(name => {\n    if (fs.statSync(path.join(dirname, name)).isDirectory()) {\n      findFiles(path.join(dirname, name), filter).forEach(iname => out.push(name + \"/\" + iname));\n    } else if (!filter || typeof filter === \"function\" ? filter(name) : filter.test(name)) {\n      out.push(name);\n    }\n  });\n  return out;\n}\n\nexports.files = findFiles;\n\nexports.TS = /\\.ts$/;\nexports.TS_EXCEPT_DTS = /[^\\.][^\\d]\\.ts$/;\n","/*\nCopyright 2010 James Halliday (mail@substack.net)\n\nThis project is free software released under the MIT/X11 license:\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\nvar path = require(\"path\");\nvar fs = require(\"fs\");\nvar _0777 = parseInt(\"0777\", 8);\n\nmodule.exports = function mkdirp(p, opts, made) {\n  if (!opts || typeof opts !== \"object\") {\n    opts = { mode: opts };\n  }\n  var mode = opts.mode;\n  if (mode === undefined) {\n    mode = _0777 & (~process.umask());\n  }\n  if (!made) made = null;\n  p = path.resolve(p);\n  try {\n    fs.mkdirSync(p, mode);\n    made = made || p;\n  } catch (err0) {\n    switch (err0.code) {\n      case \"ENOENT\":\n        made = mkdirp(path.dirname(p), opts, made);\n        mkdirp(p, opts, made);\n        break;\n      default:\n        var stat;\n        try {\n          stat = fs.statSync(p);\n        } catch (err1) {\n          throw err0;\n        }\n        if (!stat.isDirectory()) throw err0;\n        break;\n    }\n  }\n  return made;\n};\n","// type | meaning\n// -----|---------------\n// b    | boolean\n// i    | integer\n// f    | float\n// s    | string\n// I    | integer array\n// F    | float array\n// S    | string array\n\n/** Parses the specified command line arguments according to the given configuration. */\nfunction parse(argv, config) {\n  var options = {};\n  var unknown = [];\n  var arguments = [];\n  var trailing = [];\n\n  // make an alias map and initialize defaults\n  var aliases = {};\n  Object.keys(config).forEach(key => {\n    if (key.startsWith(\" \")) return;\n    var option = config[key];\n    if (option.alias != null) {\n      if (typeof option.alias === \"string\") aliases[option.alias] = key;\n      else if (Array.isArray(option.alias)) option.alias.forEach(alias => aliases[alias] = key);\n    }\n    if (option.default != null) options[key] = option.default;\n  });\n\n  // iterate over argv\n  for (var i = 0, k = (argv = argv.slice()).length; i < k; ++i) {\n    let arg = argv[i];\n    if (arg == \"--\") { ++i; break; }\n    let match = /^(?:(\\-\\w)(?:=(.*))?|(\\-\\-\\w{2,})(?:=(.*))?)$/.exec(arg), option, key;\n    if (match) {\n      if (config[arg]) option = config[key = arg]; // exact\n      else if (match[1] != null) { // alias\n        option = config[key = aliases[match[1].substring(1)]];\n        if (option && match[2] != null) argv[i--] = match[2];\n      } else if (match[3] != null) { // full\n        option = config[key = match[3].substring(2)];\n        if (option && match[4] != null) argv[i--] = match[4];\n      }\n    } else {\n      if (arg.charCodeAt(0) == 45) option = config[key = arg]; // exact\n      else { arguments.push(arg); continue; } // argument\n    }\n    if (option) {\n      if (option.type == null || option.type === \"b\") options[key] = true; // flag\n      else {\n        if (i + 1 < argv.length && argv[i + 1].charCodeAt(0) != 45) { // present\n          switch (option.type) {\n            case \"i\": options[key] = parseInt(argv[++i], 10); break;\n            case \"I\": options[key] = (options[key] || []).concat(parseInt(argv[++i], 10)); break;\n            case \"f\": options[key] = parseFloat(argv[++i]); break;\n            case \"F\": options[key] = (options[key] || []).concat(parseFloat(argv[++i])); break;\n            case \"s\": options[key] = String(argv[++i]); break;\n            case \"S\": options[key] = (options[key] || []).concat(argv[++i].split(\",\")); break;\n            default: unknown.push(arg); --i;\n          }\n        } else { // omitted\n          switch (option.type) {\n            case \"i\":\n            case \"f\": options[key] = option.default || 0; break;\n            case \"s\": options[key] = option.default || \"\"; break;\n            case \"I\":\n            case \"F\":\n            case \"S\": options[key] = options.default || []; break;\n            default: unknown.push(arg);\n          }\n        }\n      }\n      if (option.value) Object.keys(option.value).forEach(k => options[k] = option.value[k]);\n    } else unknown.push(arg);\n  }\n  while (i < k) trailing.push(argv[i++]); // trailing\n\n  return { options, unknown, arguments, trailing };\n}\n\nexports.parse = parse;\n\n/** Generates the help text for the specified configuration. */\nfunction help(config, options) {\n  if (!options) options = {};\n  var indent = options.indent || 2;\n  var padding = options.padding || 24;\n  var eol = options.eol || \"\\n\";\n  var sb = [];\n  Object.keys(config).forEach(key => {\n    var option = config[key];\n    if (option.description == null) return;\n    var text = \"\";\n    while (text.length < indent) text += \" \";\n    text += \"--\" + key;\n    if (option.alias) text += \", -\" + option.alias;\n    while (text.length < padding) text += \" \";\n    if (Array.isArray(option.description)) {\n      sb.push(text + option.description[0] + option.description.slice(1).map(line => {\n        for (let i = 0; i < padding; ++i) line = \" \" + line;\n        return eol + line;\n      }).join(\"\"));\n    } else sb.push(text + option.description);\n  });\n  return sb.join(eol);\n}\n\nexports.help = help;\n","// @protobufjs/utf8\n\n/**\n * A minimal UTF8 implementation for number arrays.\n * @memberof util\n * @namespace\n */\nvar utf8 = exports;\n\n/**\n * Calculates the UTF8 byte length of a string.\n * @param {string} string String\n * @returns {number} Byte length\n */\nutf8.length = function utf8_length(string) {\n    var len = 0,\n        c = 0;\n    for (var i = 0; i < string.length; ++i) {\n        c = string.charCodeAt(i);\n        if (c < 128)\n            len += 1;\n        else if (c < 2048)\n            len += 2;\n        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\n            ++i;\n            len += 4;\n        } else\n            len += 3;\n    }\n    return len;\n};\n\n/**\n * Reads UTF8 bytes as a string.\n * @param {Uint8Array} buffer Source buffer\n * @param {number} start Source start\n * @param {number} end Source end\n * @returns {string} String read\n */\nutf8.read = function utf8_read(buffer, start, end) {\n    var len = end - start;\n    if (len < 1)\n        return \"\";\n    var parts = null,\n        chunk = [],\n        i = 0, // char offset\n        t;     // temporary\n    while (start < end) {\n        t = buffer[start++];\n        if (t < 128)\n            chunk[i++] = t;\n        else if (t > 191 && t < 224)\n            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\n        else if (t > 239 && t < 365) {\n            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;\n            chunk[i++] = 0xD800 + (t >> 10);\n            chunk[i++] = 0xDC00 + (t & 1023);\n        } else\n            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\n        if (i > 8191) {\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\n            i = 0;\n        }\n    }\n    if (parts) {\n        if (i)\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\n        return parts.join(\"\");\n    }\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\n};\n\n/**\n * Writes a string as UTF8 bytes.\n * @param {string} string Source string\n * @param {Uint8Array} buffer Destination buffer\n * @param {number} offset Destination offset\n * @returns {number} Bytes written\n */\nutf8.write = function utf8_write(string, buffer, offset) {\n    var start = offset,\n        c1, // character 1\n        c2; // character 2\n    for (var i = 0; i < string.length; ++i) {\n        c1 = string.charCodeAt(i);\n        if (c1 < 128) {\n            buffer[offset++] = c1;\n        } else if (c1 < 2048) {\n            buffer[offset++] = c1 >> 6       | 192;\n            buffer[offset++] = c1       & 63 | 128;\n        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\n            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\n            ++i;\n            buffer[offset++] = c1 >> 18      | 240;\n            buffer[offset++] = c1 >> 12 & 63 | 128;\n            buffer[offset++] = c1 >> 6  & 63 | 128;\n            buffer[offset++] = c1       & 63 | 128;\n        } else {\n            buffer[offset++] = c1 >> 12      | 224;\n            buffer[offset++] = c1 >> 6  & 63 | 128;\n            buffer[offset++] = c1       & 63 | 128;\n        }\n    }\n    return offset - start;\n};\n"],"sourceRoot":""}