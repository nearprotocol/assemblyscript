(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("binaryen"));
	else if(typeof define === 'function' && define.amd)
		define(["binaryen"], factory);
	else if(typeof exports === 'object')
		exports["assemblyscript"] = factory(require("binaryen"));
	else
		root["assemblyscript"] = factory(root["binaryen"]);
})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_binaryen__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/long/src/long.js":
/*!***************************************!*\
  !*** ./node_modules/long/src/long.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = Long;

/**
 * wasm optimizations, to do native i64 multiplication and divide
 */
var wasm = null;

try {
  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11
  ])), {}).exports;
} catch (e) {
  // no wasm support :(
}

/**
 * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
 *  See the from* functions below for more convenient ways of constructing Longs.
 * @exports Long
 * @class A Long class for representing a 64 bit two's-complement integer value.
 * @param {number} low The low (signed) 32 bits of the long
 * @param {number} high The high (signed) 32 bits of the long
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @constructor
 */
function Long(low, high, unsigned) {

    /**
     * The low 32 bits as a signed value.
     * @type {number}
     */
    this.low = low | 0;

    /**
     * The high 32 bits as a signed value.
     * @type {number}
     */
    this.high = high | 0;

    /**
     * Whether unsigned or not.
     * @type {boolean}
     */
    this.unsigned = !!unsigned;
}

// The internal representation of a long is the two given signed, 32-bit values.
// We use 32-bit pieces because these are the size of integers on which
// Javascript performs bit-operations.  For operations like addition and
// multiplication, we split each number into 16 bit pieces, which can easily be
// multiplied within Javascript's floating-point representation without overflow
// or change in sign.
//
// In the algorithms below, we frequently reduce the negative case to the
// positive case by negating the input(s) and then post-processing the result.
// Note that we must ALWAYS check specially whether those values are MIN_VALUE
// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
// a positive number, it overflows back into a negative).  Not handling this
// case would often result in infinite recursion.
//
// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
// methods on which they depend.

/**
 * An indicator used to reliably determine if an object is a Long or not.
 * @type {boolean}
 * @const
 * @private
 */
Long.prototype.__isLong__;

Object.defineProperty(Long.prototype, "__isLong__", { value: true });

/**
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 * @inner
 */
function isLong(obj) {
    return (obj && obj["__isLong__"]) === true;
}

/**
 * Tests if the specified object is a Long.
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 */
Long.isLong = isLong;

/**
 * A cache of the Long representations of small integer values.
 * @type {!Object}
 * @inner
 */
var INT_CACHE = {};

/**
 * A cache of the Long representations of small unsigned integer values.
 * @type {!Object}
 * @inner
 */
var UINT_CACHE = {};

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromInt(value, unsigned) {
    var obj, cachedObj, cache;
    if (unsigned) {
        value >>>= 0;
        if (cache = (0 <= value && value < 256)) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache)
            UINT_CACHE[value] = obj;
        return obj;
    } else {
        value |= 0;
        if (cache = (-128 <= value && value < 128)) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache)
            INT_CACHE[value] = obj;
        return obj;
    }
}

/**
 * Returns a Long representing the given 32 bit integer value.
 * @function
 * @param {number} value The 32 bit integer in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromInt = fromInt;

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromNumber(value, unsigned) {
    if (isNaN(value))
        return unsigned ? UZERO : ZERO;
    if (unsigned) {
        if (value < 0)
            return UZERO;
        if (value >= TWO_PWR_64_DBL)
            return MAX_UNSIGNED_VALUE;
    } else {
        if (value <= -TWO_PWR_63_DBL)
            return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
            return MAX_VALUE;
    }
    if (value < 0)
        return fromNumber(-value, unsigned).neg();
    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
}

/**
 * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
 * @function
 * @param {number} value The number in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromNumber = fromNumber;

/**
 * @param {number} lowBits
 * @param {number} highBits
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
}

/**
 * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
 *  assumed to use 32 bits.
 * @function
 * @param {number} lowBits The low 32 bits
 * @param {number} highBits The high 32 bits
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromBits = fromBits;

/**
 * @function
 * @param {number} base
 * @param {number} exponent
 * @returns {number}
 * @inner
 */
var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

/**
 * @param {string} str
 * @param {(boolean|number)=} unsigned
 * @param {number=} radix
 * @returns {!Long}
 * @inner
 */
function fromString(str, unsigned, radix) {
    if (str.length === 0)
        throw Error('empty string');
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO;
    if (typeof unsigned === 'number') {
        // For goog.math.long compatibility
        radix = unsigned,
        unsigned = false;
    } else {
        unsigned = !! unsigned;
    }
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');

    var p;
    if ((p = str.indexOf('-')) > 0)
        throw Error('interior hyphen');
    else if (p === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
    }

    // Do several (8) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 8));

    var result = ZERO;
    for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i),
            value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
        } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
        }
    }
    result.unsigned = unsigned;
    return result;
}

/**
 * Returns a Long representation of the given string, written using the specified radix.
 * @function
 * @param {string} str The textual representation of the Long
 * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
 * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
 * @returns {!Long} The corresponding Long value
 */
Long.fromString = fromString;

/**
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromValue(val, unsigned) {
    if (typeof val === 'number')
        return fromNumber(val, unsigned);
    if (typeof val === 'string')
        return fromString(val, unsigned);
    // Throws for non-objects, converts non-instanceof Long:
    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
}

/**
 * Converts the specified value to a Long using the appropriate from* function for its type.
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long}
 */
Long.fromValue = fromValue;

// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
// no runtime penalty for these.

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_16_DBL = 1 << 16;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_24_DBL = 1 << 24;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

/**
 * @type {!Long}
 * @const
 * @inner
 */
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

/**
 * @type {!Long}
 * @inner
 */
var ZERO = fromInt(0);

/**
 * Signed zero.
 * @type {!Long}
 */
Long.ZERO = ZERO;

/**
 * @type {!Long}
 * @inner
 */
var UZERO = fromInt(0, true);

/**
 * Unsigned zero.
 * @type {!Long}
 */
Long.UZERO = UZERO;

/**
 * @type {!Long}
 * @inner
 */
var ONE = fromInt(1);

/**
 * Signed one.
 * @type {!Long}
 */
Long.ONE = ONE;

/**
 * @type {!Long}
 * @inner
 */
var UONE = fromInt(1, true);

/**
 * Unsigned one.
 * @type {!Long}
 */
Long.UONE = UONE;

/**
 * @type {!Long}
 * @inner
 */
var NEG_ONE = fromInt(-1);

/**
 * Signed negative one.
 * @type {!Long}
 */
Long.NEG_ONE = NEG_ONE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);

/**
 * Maximum signed value.
 * @type {!Long}
 */
Long.MAX_VALUE = MAX_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);

/**
 * Maximum unsigned value.
 * @type {!Long}
 */
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MIN_VALUE = fromBits(0, 0x80000000|0, false);

/**
 * Minimum signed value.
 * @type {!Long}
 */
Long.MIN_VALUE = MIN_VALUE;

/**
 * @alias Long.prototype
 * @inner
 */
var LongPrototype = Long.prototype;

/**
 * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
 * @returns {number}
 */
LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
};

/**
 * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
 * @returns {number}
 */
LongPrototype.toNumber = function toNumber() {
    if (this.unsigned)
        return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};

/**
 * Converts the Long to a string written in the specified radix.
 * @param {number=} radix Radix (2-36), defaults to 10
 * @returns {string}
 * @override
 * @throws {RangeError} If `radix` is out of range
 */
LongPrototype.toString = function toString(radix) {
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');
    if (this.isZero())
        return '0';
    if (this.isNegative()) { // Unsigned Longs are never negative
        if (this.eq(MIN_VALUE)) {
            // We need to change the Long value before it can be negated, so we remove
            // the bottom-most digit in this base and then recurse to do the rest.
            var radixLong = fromNumber(radix),
                div = this.div(radixLong),
                rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
        } else
            return '-' + this.neg().toString(radix);
    }

    // Do several (6) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
        rem = this;
    var result = '';
    while (true) {
        var remDiv = rem.div(radixToPower),
            intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
            digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
            return digits + result;
        else {
            while (digits.length < 6)
                digits = '0' + digits;
            result = '' + digits + result;
        }
    }
};

/**
 * Gets the high 32 bits as a signed integer.
 * @returns {number} Signed high bits
 */
LongPrototype.getHighBits = function getHighBits() {
    return this.high;
};

/**
 * Gets the high 32 bits as an unsigned integer.
 * @returns {number} Unsigned high bits
 */
LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
};

/**
 * Gets the low 32 bits as a signed integer.
 * @returns {number} Signed low bits
 */
LongPrototype.getLowBits = function getLowBits() {
    return this.low;
};

/**
 * Gets the low 32 bits as an unsigned integer.
 * @returns {number} Unsigned low bits
 */
LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
};

/**
 * Gets the number of bits needed to represent the absolute value of this Long.
 * @returns {number}
 */
LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative()) // Unsigned Longs are never negative
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
    for (var bit = 31; bit > 0; bit--)
        if ((val & (1 << bit)) != 0)
            break;
    return this.high != 0 ? bit + 33 : bit + 1;
};

/**
 * Tests if this Long's value equals zero.
 * @returns {boolean}
 */
LongPrototype.isZero = function isZero() {
    return this.high === 0 && this.low === 0;
};

/**
 * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
 * @returns {boolean}
 */
LongPrototype.eqz = LongPrototype.isZero;

/**
 * Tests if this Long's value is negative.
 * @returns {boolean}
 */
LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
};

/**
 * Tests if this Long's value is positive.
 * @returns {boolean}
 */
LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
};

/**
 * Tests if this Long's value is odd.
 * @returns {boolean}
 */
LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
};

/**
 * Tests if this Long's value is even.
 * @returns {boolean}
 */
LongPrototype.isEven = function isEven() {
    return (this.low & 1) === 0;
};

/**
 * Tests if this Long's value equals the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.equals = function equals(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
        return false;
    return this.high === other.high && this.low === other.low;
};

/**
 * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.eq = LongPrototype.equals;

/**
 * Tests if this Long's value differs from the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(/* validates */ other);
};

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.neq = LongPrototype.notEquals;

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ne = LongPrototype.notEquals;

/**
 * Tests if this Long's value is less than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThan = function lessThan(other) {
    return this.comp(/* validates */ other) < 0;
};

/**
 * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lt = LongPrototype.lessThan;

/**
 * Tests if this Long's value is less than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(/* validates */ other) <= 0;
};

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lte = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.le = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is greater than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(/* validates */ other) > 0;
};

/**
 * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gt = LongPrototype.greaterThan;

/**
 * Tests if this Long's value is greater than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(/* validates */ other) >= 0;
};

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gte = LongPrototype.greaterThanOrEqual;

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ge = LongPrototype.greaterThanOrEqual;

/**
 * Compares this Long's value with the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.compare = function compare(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.eq(other))
        return 0;
    var thisNeg = this.isNegative(),
        otherNeg = other.isNegative();
    if (thisNeg && !otherNeg)
        return -1;
    if (!thisNeg && otherNeg)
        return 1;
    // At this point the sign bits are the same
    if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
    // Both are positive if at least one is unsigned
    return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
};

/**
 * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.comp = LongPrototype.compare;

/**
 * Negates this Long's value.
 * @returns {!Long} Negated Long
 */
LongPrototype.negate = function negate() {
    if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
    return this.not().add(ONE);
};

/**
 * Negates this Long's value. This is an alias of {@link Long#negate}.
 * @function
 * @returns {!Long} Negated Long
 */
LongPrototype.neg = LongPrototype.negate;

/**
 * Returns the sum of this and the specified Long.
 * @param {!Long|number|string} addend Addend
 * @returns {!Long} Sum
 */
LongPrototype.add = function add(addend) {
    if (!isLong(addend))
        addend = fromValue(addend);

    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = addend.high >>> 16;
    var b32 = addend.high & 0xFFFF;
    var b16 = addend.low >>> 16;
    var b00 = addend.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 + b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the difference of this and the specified Long.
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.subtract = function subtract(subtrahend) {
    if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
};

/**
 * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
 * @function
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.sub = LongPrototype.subtract;

/**
 * Returns the product of this and the specified Long.
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.multiply = function multiply(multiplier) {
    if (this.isZero())
        return ZERO;
    if (!isLong(multiplier))
        multiplier = fromValue(multiplier);

    // use wasm support if present
    if (wasm) {
        var low = wasm.mul(this.low,
                           this.high,
                           multiplier.low,
                           multiplier.high);
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (multiplier.isZero())
        return ZERO;
    if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;

    if (this.isNegative()) {
        if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
        else
            return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();

    // If both longs are small, use float multiplication
    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
    // We can skip products that would overflow.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = multiplier.high >>> 16;
    var b32 = multiplier.high & 0xFFFF;
    var b16 = multiplier.low >>> 16;
    var b00 = multiplier.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
 * @function
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.mul = LongPrototype.multiply;

/**
 * Returns this Long divided by the specified. The result is signed if this Long is signed or
 *  unsigned if this Long is unsigned.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.divide = function divide(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);
    if (divisor.isZero())
        throw Error('division by zero');

    // use wasm support if present
    if (wasm) {
        // guard against signed division overflow: the largest
        // negative number / -1 would be 1 larger than the largest
        // positive number, due to two's complement.
        if (!this.unsigned &&
            this.high === -0x80000000 &&
            divisor.low === -1 && divisor.high === -1) {
            // be consistent with non-wasm code path
            return this;
        }
        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
    if (!this.unsigned) {
        // This section is only relevant for signed longs and is derived from the
        // closure library as a whole.
        if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
            else if (divisor.eq(MIN_VALUE))
                return ONE;
            else {
                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                var halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);
                if (approx.eq(ZERO)) {
                    return divisor.isNegative() ? ONE : NEG_ONE;
                } else {
                    rem = this.sub(divisor.mul(approx));
                    res = approx.add(rem.div(divisor));
                    return res;
                }
            }
        } else if (divisor.eq(MIN_VALUE))
            return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
            if (divisor.isNegative())
                return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
        res = ZERO;
    } else {
        // The algorithm below has not been made for unsigned longs. It's therefore
        // required to take special care of the MSB prior to running it.
        if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
        if (divisor.gt(this))
            return UZERO;
        if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
            return UONE;
        res = UZERO;
    }

    // Repeat the following until the remainder is less than other:  find a
    // floating-point that approximates remainder / other *from below*, add this
    // into the result, and subtract it from the remainder.  It is critical that
    // the approximate value is less than or equal to the real value so that the
    // remainder never becomes negative.
    rem = this;
    while (rem.gte(divisor)) {
        // Approximate the result of division. This may be a little greater or
        // smaller than the actual value.
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

        // We will tweak the approximate result by changing it in the 48-th digit or
        // the smallest non-fractional digit, whichever is larger.
        var log2 = Math.ceil(Math.log(approx) / Math.LN2),
            delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),

        // Decrease the approximation until it is smaller than the remainder.  Note
        // that if it is too large, the product overflows and is negative.
            approxRes = fromNumber(approx),
            approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
        }

        // We know the answer can't be zero... and actually, zero would cause
        // infinite recursion since we would make no progress.
        if (approxRes.isZero())
            approxRes = ONE;

        res = res.add(approxRes);
        rem = rem.sub(approxRem);
    }
    return res;
};

/**
 * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.div = LongPrototype.divide;

/**
 * Returns this Long modulo the specified.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.modulo = function modulo(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);

    // use wasm support if present
    if (wasm) {
        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    return this.sub(this.div(divisor).mul(divisor));
};

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.mod = LongPrototype.modulo;

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.rem = LongPrototype.modulo;

/**
 * Returns the bitwise NOT of this Long.
 * @returns {!Long}
 */
LongPrototype.not = function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
};

/**
 * Returns the bitwise AND of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.and = function and(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
};

/**
 * Returns the bitwise OR of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.or = function or(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
};

/**
 * Returns the bitwise XOR of this Long and the given one.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.xor = function xor(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftLeft = function shiftLeft(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);
    else
        return fromBits(0, this.low << (numBits - 32), this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shl = LongPrototype.shiftLeft;

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRight = function shiftRight(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);
    else
        return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);
};

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr = LongPrototype.shiftRight;

/**
 * Returns this Long with bits logically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    numBits &= 63;
    if (numBits === 0)
        return this;
    else {
        var high = this.high;
        if (numBits < 32) {
            var low = this.low;
            return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
        } else if (numBits === 32)
            return fromBits(high, 0, this.unsigned);
        else
            return fromBits(high >>> (numBits - 32), 0, this.unsigned);
    }
};

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shru = LongPrototype.shiftRightUnsigned;

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;

/**
 * Converts this Long to signed.
 * @returns {!Long} Signed long
 */
LongPrototype.toSigned = function toSigned() {
    if (!this.unsigned)
        return this;
    return fromBits(this.low, this.high, false);
};

/**
 * Converts this Long to unsigned.
 * @returns {!Long} Unsigned long
 */
LongPrototype.toUnsigned = function toUnsigned() {
    if (this.unsigned)
        return this;
    return fromBits(this.low, this.high, true);
};

/**
 * Converts this Long to its byte representation.
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {!Array.<number>} Byte representation
 */
LongPrototype.toBytes = function toBytes(le) {
    return le ? this.toBytesLE() : this.toBytesBE();
};

/**
 * Converts this Long to its little endian byte representation.
 * @returns {!Array.<number>} Little endian byte representation
 */
LongPrototype.toBytesLE = function toBytesLE() {
    var hi = this.high,
        lo = this.low;
    return [
        lo        & 0xff,
        lo >>>  8 & 0xff,
        lo >>> 16 & 0xff,
        lo >>> 24       ,
        hi        & 0xff,
        hi >>>  8 & 0xff,
        hi >>> 16 & 0xff,
        hi >>> 24
    ];
};

/**
 * Converts this Long to its big endian byte representation.
 * @returns {!Array.<number>} Big endian byte representation
 */
LongPrototype.toBytesBE = function toBytesBE() {
    var hi = this.high,
        lo = this.low;
    return [
        hi >>> 24       ,
        hi >>> 16 & 0xff,
        hi >>>  8 & 0xff,
        hi        & 0xff,
        lo >>> 24       ,
        lo >>> 16 & 0xff,
        lo >>>  8 & 0xff,
        lo        & 0xff
    ];
};

/**
 * Creates a Long from its byte representation.
 * @param {!Array.<number>} bytes Byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {Long} The corresponding Long value
 */
Long.fromBytes = function fromBytes(bytes, unsigned, le) {
    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
};

/**
 * Creates a Long from its little endian byte representation.
 * @param {!Array.<number>} bytes Little endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
    return new Long(
        bytes[0]       |
        bytes[1] <<  8 |
        bytes[2] << 16 |
        bytes[3] << 24,
        bytes[4]       |
        bytes[5] <<  8 |
        bytes[6] << 16 |
        bytes[7] << 24,
        unsigned
    );
};

/**
 * Creates a Long from its big endian byte representation.
 * @param {!Array.<number>} bytes Big endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
    return new Long(
        bytes[4] << 24 |
        bytes[5] << 16 |
        bytes[6] <<  8 |
        bytes[7],
        bytes[0] << 24 |
        bytes[1] << 16 |
        bytes[2] <<  8 |
        bytes[3],
        unsigned
    );
};


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./src/ast.ts":
/*!********************!*\
  !*** ./src/ast.ts ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Abstract syntax tree representing a source file once parsed.
 * @module ast
 */ /***/
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = __webpack_require__(/*! ./common */ "./src/common.ts");
const tokenizer_1 = __webpack_require__(/*! ./tokenizer */ "./src/tokenizer.ts");
exports.Token = tokenizer_1.Token;
exports.Range = tokenizer_1.Range;
const util_1 = __webpack_require__(/*! ./util */ "./src/util/index.ts");
/** Indicates the kind of a node. */
var NodeKind;
(function (NodeKind) {
    NodeKind[NodeKind["SOURCE"] = 0] = "SOURCE";
    // types
    NodeKind[NodeKind["NAMEDTYPE"] = 1] = "NAMEDTYPE";
    NodeKind[NodeKind["FUNCTIONTYPE"] = 2] = "FUNCTIONTYPE";
    NodeKind[NodeKind["TYPENAME"] = 3] = "TYPENAME";
    NodeKind[NodeKind["TYPEPARAMETER"] = 4] = "TYPEPARAMETER";
    NodeKind[NodeKind["PARAMETER"] = 5] = "PARAMETER";
    // expressions
    NodeKind[NodeKind["IDENTIFIER"] = 6] = "IDENTIFIER";
    NodeKind[NodeKind["ASSERTION"] = 7] = "ASSERTION";
    NodeKind[NodeKind["BINARY"] = 8] = "BINARY";
    NodeKind[NodeKind["CALL"] = 9] = "CALL";
    NodeKind[NodeKind["CLASS"] = 10] = "CLASS";
    NodeKind[NodeKind["COMMA"] = 11] = "COMMA";
    NodeKind[NodeKind["ELEMENTACCESS"] = 12] = "ELEMENTACCESS";
    NodeKind[NodeKind["FALSE"] = 13] = "FALSE";
    NodeKind[NodeKind["FUNCTION"] = 14] = "FUNCTION";
    NodeKind[NodeKind["INSTANCEOF"] = 15] = "INSTANCEOF";
    NodeKind[NodeKind["LITERAL"] = 16] = "LITERAL";
    NodeKind[NodeKind["NEW"] = 17] = "NEW";
    NodeKind[NodeKind["NULL"] = 18] = "NULL";
    NodeKind[NodeKind["PARENTHESIZED"] = 19] = "PARENTHESIZED";
    NodeKind[NodeKind["PROPERTYACCESS"] = 20] = "PROPERTYACCESS";
    NodeKind[NodeKind["TERNARY"] = 21] = "TERNARY";
    NodeKind[NodeKind["SUPER"] = 22] = "SUPER";
    NodeKind[NodeKind["THIS"] = 23] = "THIS";
    NodeKind[NodeKind["TRUE"] = 24] = "TRUE";
    NodeKind[NodeKind["CONSTRUCTOR"] = 25] = "CONSTRUCTOR";
    NodeKind[NodeKind["UNARYPOSTFIX"] = 26] = "UNARYPOSTFIX";
    NodeKind[NodeKind["UNARYPREFIX"] = 27] = "UNARYPREFIX";
    // statements
    NodeKind[NodeKind["BLOCK"] = 28] = "BLOCK";
    NodeKind[NodeKind["BREAK"] = 29] = "BREAK";
    NodeKind[NodeKind["CONTINUE"] = 30] = "CONTINUE";
    NodeKind[NodeKind["DO"] = 31] = "DO";
    NodeKind[NodeKind["EMPTY"] = 32] = "EMPTY";
    NodeKind[NodeKind["EXPORT"] = 33] = "EXPORT";
    NodeKind[NodeKind["EXPORTDEFAULT"] = 34] = "EXPORTDEFAULT";
    NodeKind[NodeKind["EXPORTIMPORT"] = 35] = "EXPORTIMPORT";
    NodeKind[NodeKind["EXPRESSION"] = 36] = "EXPRESSION";
    NodeKind[NodeKind["FOR"] = 37] = "FOR";
    NodeKind[NodeKind["IF"] = 38] = "IF";
    NodeKind[NodeKind["IMPORT"] = 39] = "IMPORT";
    NodeKind[NodeKind["RETURN"] = 40] = "RETURN";
    NodeKind[NodeKind["SWITCH"] = 41] = "SWITCH";
    NodeKind[NodeKind["THROW"] = 42] = "THROW";
    NodeKind[NodeKind["TRY"] = 43] = "TRY";
    NodeKind[NodeKind["VARIABLE"] = 44] = "VARIABLE";
    NodeKind[NodeKind["VOID"] = 45] = "VOID";
    NodeKind[NodeKind["WHILE"] = 46] = "WHILE";
    // declaration statements
    NodeKind[NodeKind["CLASSDECLARATION"] = 47] = "CLASSDECLARATION";
    NodeKind[NodeKind["ENUMDECLARATION"] = 48] = "ENUMDECLARATION";
    NodeKind[NodeKind["ENUMVALUEDECLARATION"] = 49] = "ENUMVALUEDECLARATION";
    NodeKind[NodeKind["FIELDDECLARATION"] = 50] = "FIELDDECLARATION";
    NodeKind[NodeKind["FUNCTIONDECLARATION"] = 51] = "FUNCTIONDECLARATION";
    NodeKind[NodeKind["IMPORTDECLARATION"] = 52] = "IMPORTDECLARATION";
    NodeKind[NodeKind["INDEXSIGNATUREDECLARATION"] = 53] = "INDEXSIGNATUREDECLARATION";
    NodeKind[NodeKind["INTERFACEDECLARATION"] = 54] = "INTERFACEDECLARATION";
    NodeKind[NodeKind["METHODDECLARATION"] = 55] = "METHODDECLARATION";
    NodeKind[NodeKind["NAMESPACEDECLARATION"] = 56] = "NAMESPACEDECLARATION";
    NodeKind[NodeKind["TYPEDECLARATION"] = 57] = "TYPEDECLARATION";
    NodeKind[NodeKind["VARIABLEDECLARATION"] = 58] = "VARIABLEDECLARATION";
    // special
    NodeKind[NodeKind["DECORATOR"] = 59] = "DECORATOR";
    NodeKind[NodeKind["EXPORTMEMBER"] = 60] = "EXPORTMEMBER";
    NodeKind[NodeKind["SWITCHCASE"] = 61] = "SWITCHCASE";
    NodeKind[NodeKind["COMMENT"] = 62] = "COMMENT";
})(NodeKind = exports.NodeKind || (exports.NodeKind = {}));
/** Checks if a node represents a constant value. */
function nodeIsConstantValue(kind) {
    switch (kind) {
        case NodeKind.LITERAL:
        case NodeKind.NULL:
        case NodeKind.TRUE:
        case NodeKind.FALSE: return true;
    }
    return false;
}
exports.nodeIsConstantValue = nodeIsConstantValue;
/** Checks if a node might be callable. */
function nodeIsCallable(kind) {
    switch (kind) {
        case NodeKind.IDENTIFIER:
        case NodeKind.ASSERTION: // if kind=NONNULL
        case NodeKind.CALL:
        case NodeKind.ELEMENTACCESS:
        case NodeKind.PARENTHESIZED:
        case NodeKind.PROPERTYACCESS:
        case NodeKind.SUPER: return true;
    }
    return false;
}
exports.nodeIsCallable = nodeIsCallable;
/** Checks if a node might be callable with generic arguments. */
function nodeIsGenericCallable(kind) {
    switch (kind) {
        case NodeKind.IDENTIFIER:
        case NodeKind.PROPERTYACCESS: return true;
    }
    return false;
}
exports.nodeIsGenericCallable = nodeIsGenericCallable;
/** Base class of all nodes. */
class Node {
    // types
    static createTypeName(name, range) {
        var typeName = new TypeName();
        typeName.range = range;
        typeName.identifier = name;
        typeName.next = null;
        return typeName;
    }
    static createSimpleTypeName(name, range) {
        return Node.createTypeName(Node.createIdentifierExpression(name, range), range);
    }
    static createNamedType(name, typeArguments, isNullable, range) {
        var type = new NamedTypeNode();
        type.range = range;
        type.name = name;
        type.typeArguments = typeArguments;
        type.isNullable = isNullable;
        return type;
    }
    static createFunctionType(parameters, returnType, explicitThisType, isNullable, range) {
        var type = new FunctionTypeNode();
        type.range = range;
        type.parameters = parameters;
        type.returnType = returnType;
        type.explicitThisType = explicitThisType;
        type.isNullable = isNullable;
        return type;
    }
    static createOmittedType(range) {
        return Node.createNamedType(Node.createSimpleTypeName("", range), null, false, range);
    }
    static createTypeParameter(name, extendsType, defaultType, range) {
        var elem = new TypeParameterNode();
        elem.range = range;
        elem.name = name;
        elem.extendsType = extendsType;
        elem.defaultType = defaultType;
        return elem;
    }
    static createParameter(name, type, initializer, kind, range) {
        var elem = new ParameterNode();
        elem.range = range;
        elem.name = name;
        elem.type = type;
        elem.initializer = initializer;
        elem.parameterKind = kind;
        return elem;
    }
    // special
    static createDecorator(name, args, range) {
        var stmt = new DecoratorNode();
        stmt.range = range;
        stmt.name = name;
        stmt.arguments = args;
        stmt.decoratorKind = DecoratorKind.fromNode(name);
        return stmt;
    }
    static createComment(text, kind, range) {
        var node = new CommentNode();
        node.range = range;
        node.commentKind = kind;
        node.text = text;
        return node;
    }
    // expressions
    static createIdentifierExpression(name, range, isQuoted = false) {
        var expr = new IdentifierExpression();
        expr.range = range;
        expr.text = name; // TODO: extract from range
        expr.symbol = name; // TODO: Symbol.for(name)
        expr.isQuoted = isQuoted;
        return expr;
    }
    static createEmptyIdentifierExpression(range) {
        var expr = new IdentifierExpression();
        expr.range = range;
        expr.text = "";
        return expr;
    }
    static createArrayLiteralExpression(elements, range) {
        var expr = new ArrayLiteralExpression();
        expr.range = range;
        expr.elementExpressions = elements;
        return expr;
    }
    static createAssertionExpression(assertionKind, expression, toType, range) {
        var expr = new AssertionExpression();
        expr.range = range;
        expr.assertionKind = assertionKind;
        expr.expression = expression;
        expr.toType = toType;
        return expr;
    }
    static createBinaryExpression(operator, left, right, range) {
        var expr = new BinaryExpression();
        expr.range = range;
        expr.operator = operator;
        expr.left = left;
        expr.right = right;
        return expr;
    }
    static createCallExpression(expression, typeArgs, args, range) {
        var expr = new CallExpression();
        expr.range = range;
        expr.expression = expression;
        expr.typeArguments = typeArgs;
        expr.arguments = args;
        return expr;
    }
    static createClassExpression(declaration) {
        var expr = new ClassExpression();
        expr.range = declaration.range;
        expr.declaration = declaration;
        return expr;
    }
    static createCommaExpression(expressions, range) {
        var expr = new CommaExpression();
        expr.range = range;
        expr.expressions = expressions;
        return expr;
    }
    static createConstructorExpression(range) {
        var expr = new ConstructorExpression();
        expr.range = range;
        return expr;
    }
    static createElementAccessExpression(expression, element, range) {
        var expr = new ElementAccessExpression();
        expr.range = range;
        expr.expression = expression;
        expr.elementExpression = element;
        return expr;
    }
    static createFalseExpression(range) {
        var expr = new FalseExpression();
        expr.range = range;
        return expr;
    }
    static createFloatLiteralExpression(value, range) {
        var expr = new FloatLiteralExpression();
        expr.range = range;
        expr.value = value;
        return expr;
    }
    static createFunctionExpression(declaration) {
        var expr = new FunctionExpression();
        expr.range = declaration.range;
        expr.declaration = declaration;
        return expr;
    }
    static createInstanceOfExpression(expression, isType, range) {
        var expr = new InstanceOfExpression();
        expr.range = range;
        expr.expression = expression;
        expr.isType = isType;
        return expr;
    }
    static createIntegerLiteralExpression(value, range) {
        var expr = new IntegerLiteralExpression();
        expr.range = range;
        expr.value = value;
        return expr;
    }
    static createNewExpression(expression, typeArgs, args, range) {
        var expr = new NewExpression();
        expr.range = range;
        expr.expression = expression;
        expr.typeArguments = typeArgs;
        expr.arguments = args;
        return expr;
    }
    static createNullExpression(range) {
        var expr = new NullExpression();
        expr.range = range;
        return expr;
    }
    static createObjectLiteralExpression(names, values, range) {
        var expr = new ObjectLiteralExpression();
        expr.range = range;
        expr.names = names;
        expr.values = values;
        return expr;
    }
    static createParenthesizedExpression(expression, range) {
        var expr = new ParenthesizedExpression();
        expr.range = range;
        expr.expression = expression;
        return expr;
    }
    static createPropertyAccessExpression(expression, property, range) {
        var expr = new PropertyAccessExpression();
        expr.range = range;
        expr.expression = expression;
        expr.property = property;
        return expr;
    }
    static createRegexpLiteralExpression(pattern, flags, range) {
        var expr = new RegexpLiteralExpression();
        expr.range = range;
        expr.pattern = pattern;
        expr.patternFlags = flags;
        return expr;
    }
    static createTernaryExpression(condition, ifThen, ifElse, range) {
        var expr = new TernaryExpression();
        expr.range = range;
        expr.condition = condition;
        expr.ifThen = ifThen;
        expr.ifElse = ifElse;
        return expr;
    }
    static createStringLiteralExpression(value, range) {
        var expr = new StringLiteralExpression();
        expr.range = range;
        expr.value = value;
        return expr;
    }
    static createSuperExpression(range) {
        var expr = new SuperExpression();
        expr.range = range;
        return expr;
    }
    static createThisExpression(range) {
        var expr = new ThisExpression();
        expr.range = range;
        return expr;
    }
    static createTrueExpression(range) {
        var expr = new TrueExpression();
        expr.range = range;
        return expr;
    }
    static createUnaryPostfixExpression(operator, operand, range) {
        var expr = new UnaryPostfixExpression();
        expr.range = range;
        expr.operator = operator;
        expr.operand = operand;
        return expr;
    }
    static createUnaryPrefixExpression(operator, operand, range) {
        var expr = new UnaryPrefixExpression();
        expr.range = range;
        expr.operator = operator;
        expr.operand = operand;
        return expr;
    }
    // statements
    static createBlockStatement(statements, range) {
        var stmt = new BlockStatement();
        stmt.range = range;
        stmt.statements = statements;
        return stmt;
    }
    static createBreakStatement(label, range) {
        var stmt = new BreakStatement();
        stmt.range = range;
        stmt.label = label;
        return stmt;
    }
    static createClassDeclaration(identifier, typeParameters, extendsType, // can't be a function
    implementsTypes, // can't be functions
    members, decorators, flags, range) {
        var stmt = new ClassDeclaration();
        stmt.range = range;
        stmt.flags = flags;
        stmt.name = identifier;
        stmt.typeParameters = typeParameters;
        stmt.extendsType = extendsType;
        stmt.implementsTypes = implementsTypes;
        stmt.members = members;
        stmt.decorators = decorators;
        return stmt;
    }
    static createContinueStatement(label, range) {
        var stmt = new ContinueStatement();
        stmt.range = range;
        stmt.label = label;
        return stmt;
    }
    static createDoStatement(statement, condition, range) {
        var stmt = new DoStatement();
        stmt.range = range;
        stmt.statement = statement;
        stmt.condition = condition;
        return stmt;
    }
    static createEmptyStatement(range) {
        var stmt = new EmptyStatement();
        stmt.range = range;
        return stmt;
    }
    static createEnumDeclaration(name, members, decorators, flags, range) {
        var stmt = new EnumDeclaration();
        stmt.range = range;
        stmt.flags = flags;
        stmt.name = name;
        stmt.values = members;
        stmt.decorators = decorators;
        return stmt;
    }
    static createEnumValueDeclaration(name, value, flags, range) {
        var stmt = new EnumValueDeclaration();
        stmt.range = range;
        stmt.flags = flags;
        stmt.name = name;
        stmt.value = value;
        return stmt;
    }
    static createExportStatement(members, path, isDeclare, range) {
        var stmt = new ExportStatement();
        stmt.range = range;
        stmt.members = members;
        stmt.path = path;
        if (path) {
            let normalizedPath = util_1.normalizePath(path.value);
            if (path.value.startsWith(".")) { // relative
                normalizedPath = util_1.resolvePath(normalizedPath, range.source.internalPath);
            }
            else { // absolute
                if (!normalizedPath.startsWith(common_1.LIBRARY_PREFIX))
                    normalizedPath = common_1.LIBRARY_PREFIX + normalizedPath;
            }
            stmt.internalPath = mangleInternalPath(normalizedPath);
        }
        else {
            stmt.internalPath = null;
        }
        stmt.isDeclare = isDeclare;
        return stmt;
    }
    static createExportDefaultStatement(declaration, range) {
        var stmt = new ExportDefaultStatement();
        stmt.declaration = declaration;
        stmt.range = range;
        return stmt;
    }
    static createExportImportStatement(name, externalName, range) {
        var stmt = new ExportImportStatement();
        stmt.range = range;
        stmt.name = name;
        stmt.externalName = externalName;
        return stmt;
    }
    static createExportMember(name, externalName, range) {
        var elem = new ExportMember();
        elem.range = range;
        elem.localName = name;
        if (!externalName)
            externalName = name;
        elem.exportedName = externalName;
        return elem;
    }
    static createExpressionStatement(expression) {
        var stmt = new ExpressionStatement();
        stmt.range = expression.range;
        stmt.expression = expression;
        return stmt;
    }
    static createIfStatement(condition, ifTrue, ifFalse, range) {
        var stmt = new IfStatement();
        stmt.range = range;
        stmt.condition = condition;
        stmt.ifTrue = ifTrue;
        stmt.ifFalse = ifFalse;
        return stmt;
    }
    static createImportStatement(decls, path, range) {
        var stmt = new ImportStatement();
        stmt.range = range;
        stmt.declarations = decls;
        stmt.namespaceName = null;
        stmt.path = path;
        var normalizedPath = util_1.normalizePath(path.value);
        if (path.value.startsWith(".")) { // relative in project
            normalizedPath = util_1.resolvePath(normalizedPath, range.source.internalPath);
        }
        else { // absolute in library
            if (!normalizedPath.startsWith(common_1.LIBRARY_PREFIX))
                normalizedPath = common_1.LIBRARY_PREFIX + normalizedPath;
        }
        stmt.internalPath = mangleInternalPath(normalizedPath);
        return stmt;
    }
    static createImportStatementWithWildcard(identifier, path, range) {
        var stmt = new ImportStatement();
        stmt.range = range;
        stmt.declarations = null;
        stmt.namespaceName = identifier;
        stmt.path = path;
        var normalizedPath = util_1.normalizePath(path.value);
        if (path.value.startsWith(".")) {
            normalizedPath = util_1.resolvePath(normalizedPath, range.source.internalPath);
        }
        else {
            if (!normalizedPath.startsWith(common_1.LIBRARY_PREFIX))
                normalizedPath = common_1.LIBRARY_PREFIX + normalizedPath;
        }
        stmt.internalPath = mangleInternalPath(normalizedPath);
        return stmt;
    }
    static createImportDeclaration(foreignName, name, range) {
        var elem = new ImportDeclaration();
        elem.range = range;
        elem.foreignName = foreignName;
        if (!name)
            name = foreignName;
        elem.name = name;
        return elem;
    }
    static createInterfaceDeclaration(name, typeParameters, extendsType, // can't be a function
    members, decorators, flags, range) {
        var stmt = new InterfaceDeclaration();
        stmt.range = range;
        stmt.flags = flags;
        stmt.name = name;
        stmt.typeParameters = typeParameters;
        stmt.extendsType = extendsType;
        stmt.members = members;
        stmt.decorators = decorators;
        return stmt;
    }
    static createFieldDeclaration(name, type, initializer, decorators, flags, range) {
        var stmt = new FieldDeclaration();
        stmt.range = range;
        stmt.flags = flags;
        stmt.name = name;
        stmt.type = type;
        stmt.initializer = initializer;
        stmt.decorators = decorators;
        return stmt;
    }
    static createForStatement(initializer, condition, incrementor, statement, range) {
        var stmt = new ForStatement();
        stmt.range = range;
        stmt.initializer = initializer;
        stmt.condition = condition;
        stmt.incrementor = incrementor;
        stmt.statement = statement;
        return stmt;
    }
    static createFunctionDeclaration(name, typeParameters, signature, body, decorators, flags, arrowKind, range) {
        var stmt = new FunctionDeclaration();
        stmt.range = range;
        stmt.flags = flags;
        stmt.name = name;
        stmt.typeParameters = typeParameters;
        stmt.signature = signature;
        stmt.body = body;
        stmt.decorators = decorators;
        stmt.arrowKind = arrowKind;
        return stmt;
    }
    static createIndexSignatureDeclaration(keyType, valueType, range) {
        var elem = new IndexSignatureDeclaration();
        elem.range = range;
        elem.keyType = keyType;
        elem.valueType = valueType;
        return elem;
    }
    static createMethodDeclaration(name, typeParameters, signature, body, decorators, flags, range) {
        var stmt = new MethodDeclaration();
        stmt.range = range;
        stmt.flags = flags;
        stmt.name = name;
        stmt.typeParameters = typeParameters;
        stmt.signature = signature;
        stmt.body = body;
        stmt.decorators = decorators;
        return stmt;
    }
    static createNamespaceDeclaration(name, members, decorators, flags, range) {
        var stmt = new NamespaceDeclaration();
        stmt.range = range;
        stmt.flags = flags;
        stmt.name = name;
        stmt.members = members;
        stmt.decorators = decorators;
        return stmt;
    }
    static createReturnStatement(value, range) {
        var stmt = new ReturnStatement();
        stmt.range = range;
        stmt.value = value;
        return stmt;
    }
    static createSwitchStatement(condition, cases, range) {
        var stmt = new SwitchStatement();
        stmt.range = range;
        stmt.condition = condition;
        stmt.cases = cases;
        return stmt;
    }
    static createSwitchCase(label, statements, range) {
        var elem = new SwitchCase();
        elem.range = range;
        elem.label = label;
        elem.statements = statements;
        return elem;
    }
    static createThrowStatement(value, range) {
        var stmt = new ThrowStatement();
        stmt.range = range;
        stmt.value = value;
        return stmt;
    }
    static createTryStatement(statements, catchVariable, catchStatements, finallyStatements, range) {
        var stmt = new TryStatement();
        stmt.range = range;
        stmt.statements = statements;
        stmt.catchVariable = catchVariable;
        stmt.catchStatements = catchStatements;
        stmt.finallyStatements = finallyStatements;
        return stmt;
    }
    static createTypeDeclaration(name, typeParameters, alias, decorators, flags, range) {
        var stmt = new TypeDeclaration();
        stmt.range = range;
        stmt.flags = flags;
        stmt.name = name;
        stmt.typeParameters = typeParameters;
        stmt.type = alias;
        stmt.decorators = decorators;
        return stmt;
    }
    static createVariableStatement(declarations, decorators, range) {
        var stmt = new VariableStatement();
        stmt.range = range;
        stmt.declarations = declarations;
        stmt.decorators = decorators;
        return stmt;
    }
    static createVariableDeclaration(name, type, initializer, decorators, flags, range) {
        var elem = new VariableDeclaration();
        elem.range = range;
        elem.flags = flags;
        elem.name = name;
        elem.type = type;
        elem.initializer = initializer;
        elem.decorators = decorators; // inherited
        return elem;
    }
    static createVoidStatement(expression, range) {
        var stmt = new VoidStatement();
        stmt.range = range;
        stmt.expression = expression;
        return stmt;
    }
    static createWhileStatement(condition, statement, range) {
        var stmt = new WhileStatement();
        stmt.range = range;
        stmt.condition = condition;
        stmt.statement = statement;
        return stmt;
    }
}
exports.Node = Node;
// types
class TypeNode extends Node {
    /** Tests if this type has a generic component matching one of the given type parameters. */
    hasGenericComponent(typeParameterNodes) {
        var self = this; // TS otherwise complains
        if (this.kind == NodeKind.NAMEDTYPE) {
            if (!self.name.next) {
                let typeArgumentNodes = self.typeArguments;
                if (typeArgumentNodes !== null && typeArgumentNodes.length) {
                    for (let i = 0, k = typeArgumentNodes.length; i < k; ++i) {
                        if (typeArgumentNodes[i].hasGenericComponent(typeParameterNodes))
                            return true;
                    }
                }
                else {
                    let name = self.name.identifier.text;
                    for (let i = 0, k = typeParameterNodes.length; i < k; ++i) {
                        if (typeParameterNodes[i].name.text == name)
                            return true;
                    }
                }
            }
        }
        else if (this.kind == NodeKind.FUNCTIONTYPE) {
            let parameterNodes = self.parameters;
            for (let i = 0, k = parameterNodes.length; i < k; ++i) {
                if (parameterNodes[i].type.hasGenericComponent(typeParameterNodes))
                    return true;
            }
            if (self.returnType.hasGenericComponent(typeParameterNodes))
                return true;
            let explicitThisType = self.explicitThisType;
            if (explicitThisType !== null && explicitThisType.hasGenericComponent(typeParameterNodes))
                return true;
        }
        else {
            assert(false);
        }
        return false;
    }
}
exports.TypeNode = TypeNode;
/** Represents a type name. */
class TypeName extends Node {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.TYPENAME;
    }
}
exports.TypeName = TypeName;
/** Represents a named type. */
class NamedTypeNode extends TypeNode {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.NAMEDTYPE;
    }
}
exports.NamedTypeNode = NamedTypeNode;
/** Represents a function type. */
class FunctionTypeNode extends TypeNode {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.FUNCTIONTYPE;
    }
}
exports.FunctionTypeNode = FunctionTypeNode;
/** Represents a type parameter. */
class TypeParameterNode extends Node {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.TYPEPARAMETER;
    }
}
exports.TypeParameterNode = TypeParameterNode;
/** Represents the kind of a parameter. */
var ParameterKind;
(function (ParameterKind) {
    /** No specific flags. */
    ParameterKind[ParameterKind["DEFAULT"] = 0] = "DEFAULT";
    /** Is an optional parameter. */
    ParameterKind[ParameterKind["OPTIONAL"] = 1] = "OPTIONAL";
    /** Is a rest parameter. */
    ParameterKind[ParameterKind["REST"] = 2] = "REST";
})(ParameterKind = exports.ParameterKind || (exports.ParameterKind = {}));
/** Represents a function parameter. */
class ParameterNode extends Node {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.PARAMETER;
        /** Implicit field declaration, if applicable. */
        this.implicitFieldDeclaration = null;
        /** Common flags indicating specific traits. */
        this.flags = common_1.CommonFlags.NONE;
    }
    /** Tests if this node has the specified flag or flags. */
    is(flag) { return (this.flags & flag) == flag; }
    /** Tests if this node has one of the specified flags. */
    isAny(flag) { return (this.flags & flag) != 0; }
    /** Sets a specific flag or flags. */
    set(flag) { this.flags |= flag; }
}
exports.ParameterNode = ParameterNode;
// special
/** Built-in decorator kinds. */
var DecoratorKind;
(function (DecoratorKind) {
    DecoratorKind[DecoratorKind["CUSTOM"] = 0] = "CUSTOM";
    DecoratorKind[DecoratorKind["GLOBAL"] = 1] = "GLOBAL";
    DecoratorKind[DecoratorKind["OPERATOR"] = 2] = "OPERATOR";
    DecoratorKind[DecoratorKind["OPERATOR_BINARY"] = 3] = "OPERATOR_BINARY";
    DecoratorKind[DecoratorKind["OPERATOR_PREFIX"] = 4] = "OPERATOR_PREFIX";
    DecoratorKind[DecoratorKind["OPERATOR_POSTFIX"] = 5] = "OPERATOR_POSTFIX";
    DecoratorKind[DecoratorKind["UNMANAGED"] = 6] = "UNMANAGED";
    DecoratorKind[DecoratorKind["SEALED"] = 7] = "SEALED";
    DecoratorKind[DecoratorKind["INLINE"] = 8] = "INLINE";
    DecoratorKind[DecoratorKind["EXTERNAL"] = 9] = "EXTERNAL";
    DecoratorKind[DecoratorKind["BUILTIN"] = 10] = "BUILTIN";
    DecoratorKind[DecoratorKind["LAZY"] = 11] = "LAZY";
    DecoratorKind[DecoratorKind["UNSAFE"] = 12] = "UNSAFE";
})(DecoratorKind = exports.DecoratorKind || (exports.DecoratorKind = {}));
(function (DecoratorKind) {
    /** Returns the kind of the specified decorator name node. Defaults to {@link DecoratorKind.CUSTOM}. */
    function fromNode(nameNode) {
        // @global, @inline, @operator, @sealed, @unmanaged
        if (nameNode.kind == NodeKind.IDENTIFIER) {
            let nameStr = nameNode.text;
            assert(nameStr.length);
            switch (nameStr.charCodeAt(0)) {
                case 98 /* b */: {
                    if (nameStr == "builtin")
                        return DecoratorKind.BUILTIN;
                    break;
                }
                case 101 /* e */: {
                    if (nameStr == "external")
                        return DecoratorKind.EXTERNAL;
                    break;
                }
                case 103 /* g */: {
                    if (nameStr == "global")
                        return DecoratorKind.GLOBAL;
                    break;
                }
                case 105 /* i */: {
                    if (nameStr == "inline")
                        return DecoratorKind.INLINE;
                    break;
                }
                case 108 /* l */: {
                    if (nameStr == "lazy")
                        return DecoratorKind.LAZY;
                    break;
                }
                case 111 /* o */: {
                    if (nameStr == "operator")
                        return DecoratorKind.OPERATOR;
                    break;
                }
                case 115 /* s */: {
                    if (nameStr == "sealed")
                        return DecoratorKind.SEALED;
                    break;
                }
                case 117 /* u */: {
                    if (nameStr == "unmanaged")
                        return DecoratorKind.UNMANAGED;
                    if (nameStr == "unsafe")
                        return DecoratorKind.UNSAFE;
                    break;
                }
            }
        }
        else if (nameNode.kind == NodeKind.PROPERTYACCESS &&
            nameNode.expression.kind == NodeKind.IDENTIFIER) {
            let nameStr = nameNode.expression.text;
            assert(nameStr.length);
            let propStr = nameNode.property.text;
            assert(propStr.length);
            // @operator.binary, @operator.prefix, @operator.postfix
            if (nameStr == "operator") {
                switch (propStr.charCodeAt(0)) {
                    case 98 /* b */: {
                        if (propStr == "binary")
                            return DecoratorKind.OPERATOR_BINARY;
                        break;
                    }
                    case 112 /* p */: {
                        switch (propStr) {
                            case "prefix": return DecoratorKind.OPERATOR_PREFIX;
                            case "postfix": return DecoratorKind.OPERATOR_POSTFIX;
                        }
                        break;
                    }
                }
            }
        }
        return DecoratorKind.CUSTOM;
    }
    DecoratorKind.fromNode = fromNode;
})(DecoratorKind = exports.DecoratorKind || (exports.DecoratorKind = {}));
/** Represents a decorator. */
class DecoratorNode extends Node {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.DECORATOR;
    }
}
exports.DecoratorNode = DecoratorNode;
/** Comment kinds. */
var CommentKind;
(function (CommentKind) {
    /** Line comment. */
    CommentKind[CommentKind["LINE"] = 0] = "LINE";
    /** Triple-slash comment. */
    CommentKind[CommentKind["TRIPLE"] = 1] = "TRIPLE";
    /** Block comment. */
    CommentKind[CommentKind["BLOCK"] = 2] = "BLOCK";
})(CommentKind = exports.CommentKind || (exports.CommentKind = {}));
/** Represents a comment. */
class CommentNode extends Node {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.COMMENT;
    }
}
exports.CommentNode = CommentNode;
// expressions
/** Base class of all expression nodes. */
class Expression extends Node {
}
exports.Expression = Expression;
/** Represents an identifier expression. */
class IdentifierExpression extends Expression {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.IDENTIFIER;
    }
}
exports.IdentifierExpression = IdentifierExpression;
/** Indicates the kind of a literal. */
var LiteralKind;
(function (LiteralKind) {
    LiteralKind[LiteralKind["FLOAT"] = 0] = "FLOAT";
    LiteralKind[LiteralKind["INTEGER"] = 1] = "INTEGER";
    LiteralKind[LiteralKind["STRING"] = 2] = "STRING";
    LiteralKind[LiteralKind["REGEXP"] = 3] = "REGEXP";
    LiteralKind[LiteralKind["ARRAY"] = 4] = "ARRAY";
    LiteralKind[LiteralKind["OBJECT"] = 5] = "OBJECT";
})(LiteralKind = exports.LiteralKind || (exports.LiteralKind = {}));
/** Checks if the given node represents a numeric (float or integer) literal. */
function isNumericLiteral(node) {
    if (node.kind == NodeKind.LITERAL) {
        switch (node.literalKind) {
            case LiteralKind.FLOAT:
            case LiteralKind.INTEGER: return true;
        }
    }
    return false;
}
exports.isNumericLiteral = isNumericLiteral;
/** Base class of all literal expressions. */
class LiteralExpression extends Expression {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.LITERAL;
    }
}
exports.LiteralExpression = LiteralExpression;
/** Represents an `[]` literal expression. */
class ArrayLiteralExpression extends LiteralExpression {
    constructor() {
        super(...arguments);
        this.literalKind = LiteralKind.ARRAY;
    }
}
exports.ArrayLiteralExpression = ArrayLiteralExpression;
/** Indicates the kind of an assertion. */
var AssertionKind;
(function (AssertionKind) {
    AssertionKind[AssertionKind["PREFIX"] = 0] = "PREFIX";
    AssertionKind[AssertionKind["AS"] = 1] = "AS";
    AssertionKind[AssertionKind["NONNULL"] = 2] = "NONNULL";
})(AssertionKind = exports.AssertionKind || (exports.AssertionKind = {}));
/** Represents an assertion expression. */
class AssertionExpression extends Expression {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.ASSERTION;
    }
}
exports.AssertionExpression = AssertionExpression;
/** Represents a binary expression. */
class BinaryExpression extends Expression {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.BINARY;
    }
}
exports.BinaryExpression = BinaryExpression;
/** Represents a call expression. */
class CallExpression extends Expression {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.CALL;
    }
    /** Gets the type arguments range for reporting. */
    get typeArgumentsRange() {
        var typeArguments = this.typeArguments;
        var numTypeArguments;
        if (typeArguments && (numTypeArguments = typeArguments.length)) {
            return tokenizer_1.Range.join(typeArguments[0].range, typeArguments[numTypeArguments - 1].range);
        }
        return this.expression.range;
    }
    /** Gets the arguments range for reporting. */
    get argumentsRange() {
        var args = this.arguments;
        var numArguments = args.length;
        if (numArguments) {
            return tokenizer_1.Range.join(args[0].range, args[numArguments - 1].range);
        }
        return this.expression.range;
    }
}
exports.CallExpression = CallExpression;
/** Represents a class expression using the 'class' keyword. */
class ClassExpression extends Expression {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.CLASS;
    }
}
exports.ClassExpression = ClassExpression;
/** Represents a comma expression composed of multiple expressions. */
class CommaExpression extends Expression {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.COMMA;
    }
}
exports.CommaExpression = CommaExpression;
/** Represents a `constructor` expression. */
class ConstructorExpression extends IdentifierExpression {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.CONSTRUCTOR;
        this.text = "constructor";
        this.symbol = common_1.CommonSymbols.constructor;
    }
}
exports.ConstructorExpression = ConstructorExpression;
/** Represents an element access expression, e.g., array access. */
class ElementAccessExpression extends Expression {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.ELEMENTACCESS;
    }
}
exports.ElementAccessExpression = ElementAccessExpression;
/** Represents a float literal expression. */
class FloatLiteralExpression extends LiteralExpression {
    constructor() {
        super(...arguments);
        this.literalKind = LiteralKind.FLOAT;
    }
}
exports.FloatLiteralExpression = FloatLiteralExpression;
/** Represents a function expression using the 'function' keyword. */
class FunctionExpression extends Expression {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.FUNCTION;
    }
}
exports.FunctionExpression = FunctionExpression;
/** Represents an `instanceof` expression. */
class InstanceOfExpression extends Expression {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.INSTANCEOF;
    }
}
exports.InstanceOfExpression = InstanceOfExpression;
/** Represents an integer literal expression. */
class IntegerLiteralExpression extends LiteralExpression {
    constructor() {
        super(...arguments);
        this.literalKind = LiteralKind.INTEGER;
    }
}
exports.IntegerLiteralExpression = IntegerLiteralExpression;
/** Represents a `new` expression. Like a call but with its own kind. */
class NewExpression extends CallExpression {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.NEW;
    }
}
exports.NewExpression = NewExpression;
/** Represents a `null` expression. */
class NullExpression extends IdentifierExpression {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.NULL;
        this.text = "null";
        this.symbol = common_1.CommonSymbols.null_;
    }
}
exports.NullExpression = NullExpression;
/** Represents an object literal expression. */
class ObjectLiteralExpression extends LiteralExpression {
    constructor() {
        super(...arguments);
        this.literalKind = LiteralKind.OBJECT;
    }
}
exports.ObjectLiteralExpression = ObjectLiteralExpression;
/** Represents a parenthesized expression. */
class ParenthesizedExpression extends Expression {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.PARENTHESIZED;
    }
}
exports.ParenthesizedExpression = ParenthesizedExpression;
/** Represents a property access expression. */
class PropertyAccessExpression extends Expression {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.PROPERTYACCESS;
    }
}
exports.PropertyAccessExpression = PropertyAccessExpression;
/** Represents a regular expression literal expression. */
class RegexpLiteralExpression extends LiteralExpression {
    constructor() {
        super(...arguments);
        this.literalKind = LiteralKind.REGEXP;
    }
}
exports.RegexpLiteralExpression = RegexpLiteralExpression;
/** Represents a ternary expression, i.e., short if notation. */
class TernaryExpression extends Expression {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.TERNARY;
    }
}
exports.TernaryExpression = TernaryExpression;
/** Represents a string literal expression. */
class StringLiteralExpression extends LiteralExpression {
    constructor() {
        super(...arguments);
        this.literalKind = LiteralKind.STRING;
    }
}
exports.StringLiteralExpression = StringLiteralExpression;
/** Represents a `super` expression. */
class SuperExpression extends IdentifierExpression {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.SUPER;
        this.text = "super";
        this.symbol = common_1.CommonSymbols.super_;
    }
}
exports.SuperExpression = SuperExpression;
/** Represents a `this` expression. */
class ThisExpression extends IdentifierExpression {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.THIS;
        this.text = "this";
        this.symbol = common_1.CommonSymbols.this_;
    }
}
exports.ThisExpression = ThisExpression;
/** Represents a `true` expression. */
class TrueExpression extends IdentifierExpression {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.TRUE;
        this.text = "true";
        this.symbol = common_1.CommonSymbols.true_;
    }
}
exports.TrueExpression = TrueExpression;
/** Represents a `false` expression. */
class FalseExpression extends IdentifierExpression {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.FALSE;
        this.text = "false";
        this.symbol = common_1.CommonSymbols.false_;
    }
}
exports.FalseExpression = FalseExpression;
/** Base class of all unary expressions. */
class UnaryExpression extends Expression {
}
exports.UnaryExpression = UnaryExpression;
/** Represents a unary postfix expression, e.g. a postfix increment. */
class UnaryPostfixExpression extends UnaryExpression {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.UNARYPOSTFIX;
    }
}
exports.UnaryPostfixExpression = UnaryPostfixExpression;
/** Represents a unary prefix expression, e.g. a negation. */
class UnaryPrefixExpression extends UnaryExpression {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.UNARYPREFIX;
    }
}
exports.UnaryPrefixExpression = UnaryPrefixExpression;
// statements
/** Base class of all statement nodes. */
class Statement extends Node {
}
exports.Statement = Statement;
/** Indicates the specific kind of a source. */
var SourceKind;
(function (SourceKind) {
    /** User-provided file. */
    SourceKind[SourceKind["USER"] = 0] = "USER";
    /** User-provided entry file. */
    SourceKind[SourceKind["USER_ENTRY"] = 1] = "USER_ENTRY";
    /** Library-provided file. */
    SourceKind[SourceKind["LIBRARY"] = 2] = "LIBRARY";
    /** Library-provided entry file. */
    SourceKind[SourceKind["LIBRARY_ENTRY"] = 3] = "LIBRARY_ENTRY";
})(SourceKind = exports.SourceKind || (exports.SourceKind = {}));
/** A top-level source node. */
class Source extends Node {
    /** Constructs a new source node. */
    constructor(normalizedPath, text, kind) {
        super();
        this.kind = NodeKind.SOURCE;
        this.parent = null;
        /** Tokenizer reference. */
        this.tokenizer = null;
        /** Source map index. */
        this.debugInfoIndex = -1;
        /** Re-exported sources. */
        this.exportPaths = null;
        this.sourceKind = kind;
        this.normalizedPath = normalizedPath;
        var internalPath = mangleInternalPath(this.normalizedPath);
        this.internalPath = internalPath;
        var pos = internalPath.lastIndexOf(common_1.PATH_DELIMITER);
        this.simplePath = pos >= 0 ? internalPath.substring(pos + 1) : internalPath;
        this.statements = new Array();
        this.range = new tokenizer_1.Range(this, 0, text.length);
        this.text = text;
    }
    /** Checks if this source represents native code. */
    get isNative() {
        return this.internalPath == common_1.LIBRARY_SUBST;
    }
    /** Checks if this source is part of the (standard) library. */
    get isLibrary() {
        var kind = this.sourceKind;
        return kind == SourceKind.LIBRARY || kind == SourceKind.LIBRARY_ENTRY;
    }
}
exports.Source = Source;
/** Base class of all declaration statements. */
class DeclarationStatement extends Statement {
    constructor() {
        super(...arguments);
        /** Array of decorators. */
        this.decorators = null;
        /** Common flags indicating specific traits. */
        this.flags = common_1.CommonFlags.NONE;
    }
    /** Tests if this node has the specified flag or flags. */
    is(flag) { return (this.flags & flag) == flag; }
    /** Tests if this node has one of the specified flags. */
    isAny(flag) { return (this.flags & flag) != 0; }
    /** Sets a specific flag or flags. */
    set(flag) { this.flags |= flag; }
}
exports.DeclarationStatement = DeclarationStatement;
/** Represents an index signature declaration. */
class IndexSignatureDeclaration extends DeclarationStatement {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.INDEXSIGNATUREDECLARATION;
    }
}
exports.IndexSignatureDeclaration = IndexSignatureDeclaration;
/** Base class of all variable-like declaration statements. */
class VariableLikeDeclarationStatement extends DeclarationStatement {
}
exports.VariableLikeDeclarationStatement = VariableLikeDeclarationStatement;
/** Represents a block statement. */
class BlockStatement extends Statement {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.BLOCK;
    }
}
exports.BlockStatement = BlockStatement;
/** Represents a `break` statement. */
class BreakStatement extends Statement {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.BREAK;
    }
}
exports.BreakStatement = BreakStatement;
/** Represents a `class` declaration. */
class ClassDeclaration extends DeclarationStatement {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.CLASSDECLARATION;
    }
    get isGeneric() {
        var typeParameters = this.typeParameters;
        return typeParameters != null && typeParameters.length > 0;
    }
}
exports.ClassDeclaration = ClassDeclaration;
/** Represents a `continue` statement. */
class ContinueStatement extends Statement {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.CONTINUE;
    }
}
exports.ContinueStatement = ContinueStatement;
/** Represents a `do` statement. */
class DoStatement extends Statement {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.DO;
    }
}
exports.DoStatement = DoStatement;
/** Represents an empty statement, i.e., a semicolon terminating nothing. */
class EmptyStatement extends Statement {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.EMPTY;
    }
}
exports.EmptyStatement = EmptyStatement;
/** Represents an `enum` declaration. */
class EnumDeclaration extends DeclarationStatement {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.ENUMDECLARATION;
    }
}
exports.EnumDeclaration = EnumDeclaration;
/** Represents a value of an `enum` declaration. */
class EnumValueDeclaration extends VariableLikeDeclarationStatement {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.ENUMVALUEDECLARATION;
    }
}
exports.EnumValueDeclaration = EnumValueDeclaration;
/** Represents an `export import` statement of an interface. */
class ExportImportStatement extends Node {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.EXPORTIMPORT;
    }
}
exports.ExportImportStatement = ExportImportStatement;
/** Represents a member of an `export` statement. */
class ExportMember extends Node {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.EXPORTMEMBER;
    }
}
exports.ExportMember = ExportMember;
/** Represents an `export` statement. */
class ExportStatement extends Statement {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.EXPORT;
    }
}
exports.ExportStatement = ExportStatement;
/** Represents an `export default` statement. */
class ExportDefaultStatement extends Statement {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.EXPORTDEFAULT;
    }
}
exports.ExportDefaultStatement = ExportDefaultStatement;
/** Represents an expression that is used as a statement. */
class ExpressionStatement extends Statement {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.EXPRESSION;
    }
}
exports.ExpressionStatement = ExpressionStatement;
/** Represents a field declaration within a `class`. */
class FieldDeclaration extends VariableLikeDeclarationStatement {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.FIELDDECLARATION;
        /** Parameter index if declared as a constructor parameter, otherwise `-1`. */
        this.parameterIndex = -1;
    }
}
exports.FieldDeclaration = FieldDeclaration;
/** Represents a `for` statement. */
class ForStatement extends Statement {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.FOR;
    }
}
exports.ForStatement = ForStatement;
/** Indicates the kind of an array function. */
var ArrowKind;
(function (ArrowKind) {
    /** Not an arrow function. */
    ArrowKind[ArrowKind["NONE"] = 0] = "NONE";
    /** Parenthesized parameter list. */
    ArrowKind[ArrowKind["ARROW_PARENTHESIZED"] = 1] = "ARROW_PARENTHESIZED";
    /** Single parameter without parenthesis. */
    ArrowKind[ArrowKind["ARROW_SINGLE"] = 2] = "ARROW_SINGLE";
})(ArrowKind = exports.ArrowKind || (exports.ArrowKind = {}));
/** Represents a `function` declaration. */
class FunctionDeclaration extends DeclarationStatement {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.FUNCTIONDECLARATION;
    }
    get isGeneric() {
        var typeParameters = this.typeParameters;
        return typeParameters != null && typeParameters.length > 0;
    }
    /** Clones this function declaration. */
    clone() {
        return Node.createFunctionDeclaration(this.name, this.typeParameters, this.signature, this.body, this.decorators, this.flags, this.arrowKind, this.range);
    }
}
exports.FunctionDeclaration = FunctionDeclaration;
/** Represents an `if` statement. */
class IfStatement extends Statement {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.IF;
    }
}
exports.IfStatement = IfStatement;
/** Represents an `import` declaration part of an {@link ImportStatement}. */
class ImportDeclaration extends DeclarationStatement {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.IMPORTDECLARATION;
    }
}
exports.ImportDeclaration = ImportDeclaration;
/** Represents an `import` statement. */
class ImportStatement extends Statement {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.IMPORT;
    }
}
exports.ImportStatement = ImportStatement;
/** Represents an `interfarce` declaration. */
class InterfaceDeclaration extends ClassDeclaration {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.INTERFACEDECLARATION;
    }
}
exports.InterfaceDeclaration = InterfaceDeclaration;
/** Represents a method declaration within a `class`. */
class MethodDeclaration extends FunctionDeclaration {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.METHODDECLARATION;
    }
}
exports.MethodDeclaration = MethodDeclaration;
/** Represents a `namespace` declaration. */
class NamespaceDeclaration extends DeclarationStatement {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.NAMESPACEDECLARATION;
    }
}
exports.NamespaceDeclaration = NamespaceDeclaration;
/** Represents a `return` statement. */
class ReturnStatement extends Statement {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.RETURN;
    }
}
exports.ReturnStatement = ReturnStatement;
/** Represents a single `case` within a `switch` statement. */
class SwitchCase extends Node {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.SWITCHCASE;
    }
}
exports.SwitchCase = SwitchCase;
/** Represents a `switch` statement. */
class SwitchStatement extends Statement {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.SWITCH;
    }
}
exports.SwitchStatement = SwitchStatement;
/** Represents a `throw` statement. */
class ThrowStatement extends Statement {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.THROW;
    }
}
exports.ThrowStatement = ThrowStatement;
/** Represents a `try` statement. */
class TryStatement extends Statement {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.TRY;
    }
}
exports.TryStatement = TryStatement;
/** Represents a `type` declaration. */
class TypeDeclaration extends DeclarationStatement {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.TYPEDECLARATION;
    }
}
exports.TypeDeclaration = TypeDeclaration;
/** Represents a variable declaration part of a {@link VariableStatement}. */
class VariableDeclaration extends VariableLikeDeclarationStatement {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.VARIABLEDECLARATION;
    }
}
exports.VariableDeclaration = VariableDeclaration;
/** Represents a variable statement wrapping {@link VariableDeclaration}s. */
class VariableStatement extends Statement {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.VARIABLE;
    }
}
exports.VariableStatement = VariableStatement;
/** Represents a void statement dropping an expression's value. */
class VoidStatement extends Statement {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.VOID;
    }
}
exports.VoidStatement = VoidStatement;
/** Represents a `while` statement. */
class WhileStatement extends Statement {
    constructor() {
        super(...arguments);
        this.kind = NodeKind.WHILE;
    }
}
exports.WhileStatement = WhileStatement;
/** Finds the first decorator matching the specified kind. */
function findDecorator(kind, decorators) {
    if (decorators) {
        for (let i = 0, k = decorators.length; i < k; ++i) {
            let decorator = decorators[i];
            if (decorator.decoratorKind == kind)
                return decorator;
        }
    }
    return null;
}
exports.findDecorator = findDecorator;
/** Mangles an external to an internal path. */
function mangleInternalPath(path) {
    if (path.endsWith(".ts"))
        path = path.substring(0, path.length - 3);
    return path;
}
exports.mangleInternalPath = mangleInternalPath;
/** Tests if the specified type node represents an omitted type. */
function isTypeOmitted(type) {
    if (type.kind == NodeKind.NAMEDTYPE) {
        let name = type.name;
        return !(name.next || name.identifier.text.length);
    }
    return false;
}
exports.isTypeOmitted = isTypeOmitted;


/***/ }),

/***/ "./src/builtins.ts":
/*!*************************!*\
  !*** ./src/builtins.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Built-in elements providing WebAssembly core functionality.
 * @module builtins
 */ /***/
Object.defineProperty(exports, "__esModule", { value: true });
const compiler_1 = __webpack_require__(/*! ./compiler */ "./src/compiler.ts");
const diagnostics_1 = __webpack_require__(/*! ./diagnostics */ "./src/diagnostics.ts");
const ast_1 = __webpack_require__(/*! ./ast */ "./src/ast.ts");
const types_1 = __webpack_require__(/*! ./types */ "./src/types.ts");
const module_1 = __webpack_require__(/*! ./module */ "./src/module.ts");
const program_1 = __webpack_require__(/*! ./program */ "./src/program.ts");
const flow_1 = __webpack_require__(/*! ./flow */ "./src/flow.ts");
const resolver_1 = __webpack_require__(/*! ./resolver */ "./src/resolver.ts");
const common_1 = __webpack_require__(/*! ./common */ "./src/common.ts");
const util_1 = __webpack_require__(/*! ./util */ "./src/util/index.ts");
/** Symbols of various compiler built-ins. */
var BuiltinSymbols;
(function (BuiltinSymbols) {
    // std/builtins.ts
    BuiltinSymbols.isInteger = "~lib/builtins/isInteger";
    BuiltinSymbols.isFloat = "~lib/builtins/isFloat";
    BuiltinSymbols.isBoolean = "~lib/builtins/isBoolean";
    BuiltinSymbols.isSigned = "~lib/builtins/isSigned";
    BuiltinSymbols.isReference = "~lib/builtins/isReference";
    BuiltinSymbols.isString = "~lib/builtins/isString";
    BuiltinSymbols.isArray = "~lib/builtins/isArray";
    BuiltinSymbols.isArrayLike = "~lib/builtins/isArrayLike";
    BuiltinSymbols.isFunction = "~lib/builtins/isFunction";
    BuiltinSymbols.isNullable = "~lib/builtins/isNullable";
    BuiltinSymbols.isDefined = "~lib/builtins/isDefined";
    BuiltinSymbols.isConstant = "~lib/builtins/isConstant";
    BuiltinSymbols.isManaged = "~lib/builtins/isManaged";
    BuiltinSymbols.isVoid = "~lib/builtins/isVoid";
    BuiltinSymbols.clz = "~lib/builtins/clz";
    BuiltinSymbols.ctz = "~lib/builtins/ctz";
    BuiltinSymbols.popcnt = "~lib/builtins/popcnt";
    BuiltinSymbols.rotl = "~lib/builtins/rotl";
    BuiltinSymbols.rotr = "~lib/builtins/rotr";
    BuiltinSymbols.abs = "~lib/builtins/abs";
    BuiltinSymbols.max = "~lib/builtins/max";
    BuiltinSymbols.min = "~lib/builtins/min";
    BuiltinSymbols.ceil = "~lib/builtins/ceil";
    BuiltinSymbols.floor = "~lib/builtins/floor";
    BuiltinSymbols.copysign = "~lib/builtins/copysign";
    BuiltinSymbols.nearest = "~lib/builtins/nearest";
    BuiltinSymbols.reinterpret = "~lib/builtins/reinterpret";
    BuiltinSymbols.sqrt = "~lib/builtins/sqrt";
    BuiltinSymbols.trunc = "~lib/builtins/trunc";
    BuiltinSymbols.load = "~lib/builtins/load";
    BuiltinSymbols.store = "~lib/builtins/store";
    BuiltinSymbols.atomic_load = "~lib/builtins/atomic.load";
    BuiltinSymbols.atomic_store = "~lib/builtins/atomic.store";
    BuiltinSymbols.atomic_add = "~lib/builtins/atomic.add";
    BuiltinSymbols.atomic_sub = "~lib/builtins/atomic.sub";
    BuiltinSymbols.atomic_and = "~lib/builtins/atomic.and";
    BuiltinSymbols.atomic_or = "~lib/builtins/atomic.or";
    BuiltinSymbols.atomic_xor = "~lib/builtins/atomic.xor";
    BuiltinSymbols.atomic_xchg = "~lib/builtins/atomic.xchg";
    BuiltinSymbols.atomic_cmpxchg = "~lib/builtins/atomic.cmpxchg";
    BuiltinSymbols.atomic_wait = "~lib/builtins/atomic.wait";
    BuiltinSymbols.atomic_notify = "~lib/builtins/atomic.notify";
    BuiltinSymbols.atomic_fence = "~lib/builtins/atomic.fence";
    BuiltinSymbols.sizeof = "~lib/builtins/sizeof";
    BuiltinSymbols.alignof = "~lib/builtins/alignof";
    BuiltinSymbols.offsetof = "~lib/builtins/offsetof";
    BuiltinSymbols.nameof = "~lib/builtins/nameof";
    BuiltinSymbols.lengthof = "~lib/builtins/lengthof";
    BuiltinSymbols.select = "~lib/builtins/select";
    BuiltinSymbols.unreachable = "~lib/builtins/unreachable";
    BuiltinSymbols.changetype = "~lib/builtins/changetype";
    BuiltinSymbols.assert = "~lib/builtins/assert";
    BuiltinSymbols.unchecked = "~lib/builtins/unchecked";
    BuiltinSymbols.call_direct = "~lib/builtins/call_direct";
    BuiltinSymbols.call_indirect = "~lib/builtins/call_indirect";
    BuiltinSymbols.instantiate = "~lib/builtins/instantiate";
    BuiltinSymbols.idof = "~lib/builtins/idof";
    BuiltinSymbols.i8 = "~lib/builtins/i8";
    BuiltinSymbols.i16 = "~lib/builtins/i16";
    BuiltinSymbols.i32 = "~lib/builtins/i32";
    BuiltinSymbols.i64 = "~lib/builtins/i64";
    BuiltinSymbols.isize = "~lib/builtins/isize";
    BuiltinSymbols.u8 = "~lib/builtins/u8";
    BuiltinSymbols.u16 = "~lib/builtins/u16";
    BuiltinSymbols.u32 = "~lib/builtins/u32";
    BuiltinSymbols.u64 = "~lib/builtins/u64";
    BuiltinSymbols.usize = "~lib/builtins/usize";
    BuiltinSymbols.bool = "~lib/builtins/bool";
    BuiltinSymbols.f32 = "~lib/builtins/f32";
    BuiltinSymbols.f64 = "~lib/builtins/f64";
    BuiltinSymbols.v128 = "~lib/builtins/v128";
    BuiltinSymbols.void_ = "~lib/builtins/void";
    BuiltinSymbols.i32_clz = "~lib/builtins/i32.clz";
    BuiltinSymbols.i64_clz = "~lib/builtins/i64.clz";
    BuiltinSymbols.i32_ctz = "~lib/builtins/i32.ctz";
    BuiltinSymbols.i64_ctz = "~lib/builtins/i64.ctz";
    BuiltinSymbols.i32_popcnt = "~lib/builtins/i32.popcnt";
    BuiltinSymbols.i64_popcnt = "~lib/builtins/i64.popcnt";
    BuiltinSymbols.i32_rotl = "~lib/builtins/i32.rotl";
    BuiltinSymbols.i64_rotl = "~lib/builtins/i64.rotl";
    BuiltinSymbols.i32_rotr = "~lib/builtins/i32.rotr";
    BuiltinSymbols.i64_rotr = "~lib/builtins/i64.rotr";
    BuiltinSymbols.f32_abs = "~lib/builtins/f32.abs";
    BuiltinSymbols.f64_abs = "~lib/builtins/f64.abs";
    BuiltinSymbols.f32_max = "~lib/builtins/f32.max";
    BuiltinSymbols.f64_max = "~lib/builtins/f64.max";
    BuiltinSymbols.f32_min = "~lib/builtins/f32.min";
    BuiltinSymbols.f64_min = "~lib/builtins/f64.min";
    BuiltinSymbols.f32_ceil = "~lib/builtins/f32.ceil";
    BuiltinSymbols.f64_ceil = "~lib/builtins/f64.ceil";
    BuiltinSymbols.f32_floor = "~lib/builtins/f32.floor";
    BuiltinSymbols.f64_floor = "~lib/builtins/f64.floor";
    BuiltinSymbols.f32_copysign = "~lib/builtins/f32.copysign";
    BuiltinSymbols.f64_copysign = "~lib/builtins/f64.copysign";
    BuiltinSymbols.f32_nearest = "~lib/builtins/f32.nearest";
    BuiltinSymbols.f64_nearest = "~lib/builtins/f64.nearest";
    BuiltinSymbols.i32_reinterpret_f32 = "~lib/builtins/i32.reinterpret_f32";
    BuiltinSymbols.i64_reinterpret_f64 = "~lib/builtins/i64.reinterpret_f64";
    BuiltinSymbols.f32_reinterpret_i32 = "~lib/builtins/f32.reinterpret_i32";
    BuiltinSymbols.f64_reinterpret_i64 = "~lib/builtins/f64.reinterpret_i64";
    BuiltinSymbols.f32_sqrt = "~lib/builtins/f32.sqrt";
    BuiltinSymbols.f64_sqrt = "~lib/builtins/f64.sqrt";
    BuiltinSymbols.f32_trunc = "~lib/builtins/f32.trunc";
    BuiltinSymbols.f64_trunc = "~lib/builtins/f64.trunc";
    BuiltinSymbols.i32_load8_s = "~lib/builtins/i32.load8_s";
    BuiltinSymbols.i32_load8_u = "~lib/builtins/i32.load8_u";
    BuiltinSymbols.i32_load16_s = "~lib/builtins/i32.load16_s";
    BuiltinSymbols.i32_load16_u = "~lib/builtins/i32.load16_u";
    BuiltinSymbols.i32_load = "~lib/builtins/i32.load";
    BuiltinSymbols.i64_load8_s = "~lib/builtins/i64.load8_s";
    BuiltinSymbols.i64_load8_u = "~lib/builtins/i64.load8_u";
    BuiltinSymbols.i64_load16_s = "~lib/builtins/i64.load16_s";
    BuiltinSymbols.i64_load16_u = "~lib/builtins/i64.load16_u";
    BuiltinSymbols.i64_load32_s = "~lib/builtins/i64.load32_s";
    BuiltinSymbols.i64_load32_u = "~lib/builtins/i64.load32_u";
    BuiltinSymbols.i64_load = "~lib/builtins/i64.load";
    BuiltinSymbols.f32_load = "~lib/builtins/f32.load";
    BuiltinSymbols.f64_load = "~lib/builtins/f64.load";
    BuiltinSymbols.i32_store8 = "~lib/builtins/i32.store8";
    BuiltinSymbols.i32_store16 = "~lib/builtins/i32.store16";
    BuiltinSymbols.i32_store = "~lib/builtins/i32.store";
    BuiltinSymbols.i64_store8 = "~lib/builtins/i64.store8";
    BuiltinSymbols.i64_store16 = "~lib/builtins/i64.store16";
    BuiltinSymbols.i64_store32 = "~lib/builtins/i64.store32";
    BuiltinSymbols.i64_store = "~lib/builtins/i64.store";
    BuiltinSymbols.f32_store = "~lib/builtins/f32.store";
    BuiltinSymbols.f64_store = "~lib/builtins/f64.store";
    BuiltinSymbols.i32_atomic_load8_u = "~lib/builtins/i32.atomic.load8_u";
    BuiltinSymbols.i32_atomic_load16_u = "~lib/builtins/i32.atomic.load16_u";
    BuiltinSymbols.i32_atomic_load = "~lib/builtins/i32.atomic.load";
    BuiltinSymbols.i64_atomic_load8_u = "~lib/builtins/i64.atomic.load8_u";
    BuiltinSymbols.i64_atomic_load16_u = "~lib/builtins/i64.atomic.load16_u";
    BuiltinSymbols.i64_atomic_load32_u = "~lib/builtins/i64.atomic.load32_u";
    BuiltinSymbols.i64_atomic_load = "~lib/builtins/i64.atomic.load";
    BuiltinSymbols.i32_atomic_store8 = "~lib/builtins/i32.atomic.store8";
    BuiltinSymbols.i32_atomic_store16 = "~lib/builtins/i32.atomic.store16";
    BuiltinSymbols.i32_atomic_store = "~lib/builtins/i32.atomic.store";
    BuiltinSymbols.i64_atomic_store8 = "~lib/builtins/i64.atomic.store8";
    BuiltinSymbols.i64_atomic_store16 = "~lib/builtins/i64.atomic.store16";
    BuiltinSymbols.i64_atomic_store32 = "~lib/builtins/i64.atomic.store32";
    BuiltinSymbols.i64_atomic_store = "~lib/builtins/i64.atomic.store";
    BuiltinSymbols.i32_atomic_rmw8_add_u = "~lib/builtins/i32.atomic.rmw8.add_u";
    BuiltinSymbols.i32_atomic_rmw16_add_u = "~lib/builtins/i32.atomic.rmw16.add_u";
    BuiltinSymbols.i32_atomic_rmw_add = "~lib/builtins/i32.atomic.rmw.add";
    BuiltinSymbols.i64_atomic_rmw8_add_u = "~lib/builtins/i64.atomic.rmw8.add_u";
    BuiltinSymbols.i64_atomic_rmw16_add_u = "~lib/builtins/i64.atomic.rmw16.add_u";
    BuiltinSymbols.i64_atomic_rmw32_add_u = "~lib/builtins/i64.atomic.rmw32.add_u";
    BuiltinSymbols.i64_atomic_rmw_add = "~lib/builtins/i64.atomic.rmw.add";
    BuiltinSymbols.i32_atomic_rmw8_sub_u = "~lib/builtins/i32.atomic.rmw8.sub_u";
    BuiltinSymbols.i32_atomic_rmw16_sub_u = "~lib/builtins/i32.atomic.rmw16.sub_u";
    BuiltinSymbols.i32_atomic_rmw_sub = "~lib/builtins/i32.atomic.rmw.sub";
    BuiltinSymbols.i64_atomic_rmw8_sub_u = "~lib/builtins/i64.atomic.rmw8.sub_u";
    BuiltinSymbols.i64_atomic_rmw16_sub_u = "~lib/builtins/i64.atomic.rmw16.sub_u";
    BuiltinSymbols.i64_atomic_rmw32_sub_u = "~lib/builtins/i64.atomic.rmw32.sub_u";
    BuiltinSymbols.i64_atomic_rmw_sub = "~lib/builtins/i64.atomic.rmw.sub";
    BuiltinSymbols.i32_atomic_rmw8_and_u = "~lib/builtins/i32.atomic.rmw8.and_u";
    BuiltinSymbols.i32_atomic_rmw16_and_u = "~lib/builtins/i32.atomic.rmw16.and_u";
    BuiltinSymbols.i32_atomic_rmw_and = "~lib/builtins/i32.atomic.rmw.and";
    BuiltinSymbols.i64_atomic_rmw8_and_u = "~lib/builtins/i64.atomic.rmw8.and_u";
    BuiltinSymbols.i64_atomic_rmw16_and_u = "~lib/builtins/i64.atomic.rmw16.and_u";
    BuiltinSymbols.i64_atomic_rmw32_and_u = "~lib/builtins/i64.atomic.rmw32.and_u";
    BuiltinSymbols.i64_atomic_rmw_and = "~lib/builtins/i64.atomic.rmw.and";
    BuiltinSymbols.i32_atomic_rmw8_or_u = "~lib/builtins/i32.atomic.rmw8.or_u";
    BuiltinSymbols.i32_atomic_rmw16_or_u = "~lib/builtins/i32.atomic.rmw16.or_u";
    BuiltinSymbols.i32_atomic_rmw_or = "~lib/builtins/i32.atomic.rmw.or";
    BuiltinSymbols.i64_atomic_rmw8_or_u = "~lib/builtins/i64.atomic.rmw8.or_u";
    BuiltinSymbols.i64_atomic_rmw16_or_u = "~lib/builtins/i64.atomic.rmw16.or_u";
    BuiltinSymbols.i64_atomic_rmw32_or_u = "~lib/builtins/i64.atomic.rmw32.or_u";
    BuiltinSymbols.i64_atomic_rmw_or = "~lib/builtins/i64.atomic.rmw.or";
    BuiltinSymbols.i32_atomic_rmw8_xor_u = "~lib/builtins/i32.atomic.rmw8.xor_u";
    BuiltinSymbols.i32_atomic_rmw16_xor_u = "~lib/builtins/i32.atomic.rmw16.xor_u";
    BuiltinSymbols.i32_atomic_rmw_xor = "~lib/builtins/i32.atomic.rmw.xor";
    BuiltinSymbols.i64_atomic_rmw8_xor_u = "~lib/builtins/i64.atomic.rmw8.xor_u";
    BuiltinSymbols.i64_atomic_rmw16_xor_u = "~lib/builtins/i64.atomic.rmw16.xor_u";
    BuiltinSymbols.i64_atomic_rmw32_xor_u = "~lib/builtins/i64.atomic.rmw32.xor_u";
    BuiltinSymbols.i64_atomic_rmw_xor = "~lib/builtins/i64.atomic.rmw.xor";
    BuiltinSymbols.i32_atomic_rmw8_xchg_u = "~lib/builtins/i32.atomic.rmw8.xchg_u";
    BuiltinSymbols.i32_atomic_rmw16_xchg_u = "~lib/builtins/i32.atomic.rmw16.xchg_u";
    BuiltinSymbols.i32_atomic_rmw_xchg = "~lib/builtins/i32.atomic.rmw.xchg";
    BuiltinSymbols.i64_atomic_rmw8_xchg_u = "~lib/builtins/i64.atomic.rmw8.xchg_u";
    BuiltinSymbols.i64_atomic_rmw16_xchg_u = "~lib/builtins/i64.atomic.rmw16.xchg_u";
    BuiltinSymbols.i64_atomic_rmw32_xchg_u = "~lib/builtins/i64.atomic.rmw32.xchg_u";
    BuiltinSymbols.i64_atomic_rmw_xchg = "~lib/builtins/i64.atomic.rmw.xchg";
    BuiltinSymbols.i32_atomic_rmw8_cmpxchg_u = "~lib/builtins/i32.atomic.rmw8.cmpxchg_u";
    BuiltinSymbols.i32_atomic_rmw16_cmpxchg_u = "~lib/builtins/i32.atomic.rmw16.cmpxchg_u";
    BuiltinSymbols.i32_atomic_rmw_cmpxchg = "~lib/builtins/i32.atomic.rmw.cmpxchg";
    BuiltinSymbols.i64_atomic_rmw8_cmpxchg_u = "~lib/builtins/i64.atomic.rmw8.cmpxchg_u";
    BuiltinSymbols.i64_atomic_rmw16_cmpxchg_u = "~lib/builtins/i64.atomic.rmw16.cmpxchg_u";
    BuiltinSymbols.i64_atomic_rmw32_cmpxchg_u = "~lib/builtins/i64.atomic.rmw32.cmpxchg_u";
    BuiltinSymbols.i64_atomic_rmw_cmpxchg = "~lib/builtins/i64.atomic.rmw.cmpxchg";
    BuiltinSymbols.i32_wait = "~lib/builtins/i32.wait";
    BuiltinSymbols.i64_wait = "~lib/builtins/i64.wait";
    BuiltinSymbols.v128_splat = "~lib/builtins/v128.splat";
    BuiltinSymbols.v128_extract_lane = "~lib/builtins/v128.extract_lane";
    BuiltinSymbols.v128_replace_lane = "~lib/builtins/v128.replace_lane";
    BuiltinSymbols.v128_shuffle = "~lib/builtins/v128.shuffle";
    BuiltinSymbols.v128_swizzle = "~lib/builtins/v128.swizzle";
    BuiltinSymbols.v128_load_splat = "~lib/builtins/v128.load_splat";
    BuiltinSymbols.v128_load_ext = "~lib/builtins/v128.load_ext";
    BuiltinSymbols.v128_load = "~lib/builtins/v128.load";
    BuiltinSymbols.v128_store = "~lib/builtins/v128.store";
    BuiltinSymbols.v128_add = "~lib/builtins/v128.add";
    BuiltinSymbols.v128_sub = "~lib/builtins/v128.sub";
    BuiltinSymbols.v128_mul = "~lib/builtins/v128.mul";
    BuiltinSymbols.v128_div = "~lib/builtins/v128.div";
    BuiltinSymbols.v128_neg = "~lib/builtins/v128.neg";
    BuiltinSymbols.v128_add_saturate = "~lib/builtins/v128.add_saturate";
    BuiltinSymbols.v128_sub_saturate = "~lib/builtins/v128.sub_saturate";
    BuiltinSymbols.v128_shl = "~lib/builtins/v128.shl";
    BuiltinSymbols.v128_shr = "~lib/builtins/v128.shr";
    BuiltinSymbols.v128_and = "~lib/builtins/v128.and";
    BuiltinSymbols.v128_or = "~lib/builtins/v128.or";
    BuiltinSymbols.v128_xor = "~lib/builtins/v128.xor";
    BuiltinSymbols.v128_andnot = "~lib/builtins/v128.andnot";
    BuiltinSymbols.v128_not = "~lib/builtins/v128.not";
    BuiltinSymbols.v128_bitselect = "~lib/builtins/v128.bitselect";
    BuiltinSymbols.v128_any_true = "~lib/builtins/v128.any_true";
    BuiltinSymbols.v128_all_true = "~lib/builtins/v128.all_true";
    BuiltinSymbols.v128_min = "~lib/builtins/v128.min";
    BuiltinSymbols.v128_max = "~lib/builtins/v128.max";
    BuiltinSymbols.v128_dot = "~lib/builtins/v128.dot";
    BuiltinSymbols.v128_abs = "~lib/builtins/v128.abs";
    BuiltinSymbols.v128_sqrt = "~lib/builtins/v128.sqrt";
    BuiltinSymbols.v128_eq = "~lib/builtins/v128.eq";
    BuiltinSymbols.v128_ne = "~lib/builtins/v128.ne";
    BuiltinSymbols.v128_lt = "~lib/builtins/v128.lt";
    BuiltinSymbols.v128_le = "~lib/builtins/v128.le";
    BuiltinSymbols.v128_gt = "~lib/builtins/v128.gt";
    BuiltinSymbols.v128_ge = "~lib/builtins/v128.ge";
    BuiltinSymbols.v128_convert = "~lib/builtins/v128.convert";
    BuiltinSymbols.v128_trunc_sat = "~lib/builtins/v128.trunc_sat";
    BuiltinSymbols.v128_narrow = "~lib/builtins/v128.narrow";
    BuiltinSymbols.v128_widen_low = "~lib/builtins/v128.widen_low";
    BuiltinSymbols.v128_widen_high = "~lib/builtins/v128.widen_high";
    BuiltinSymbols.v128_qfma = "~lib/builtins/v128.qfma";
    BuiltinSymbols.v128_qfms = "~lib/builtins/v128.qfms";
    BuiltinSymbols.i8x16 = "~lib/builtins/i8x16";
    BuiltinSymbols.i16x8 = "~lib/builtins/i16x8";
    BuiltinSymbols.i32x4 = "~lib/builtins/i32x4";
    BuiltinSymbols.i64x2 = "~lib/builtins/i64x2";
    BuiltinSymbols.f32x4 = "~lib/builtins/f32x4";
    BuiltinSymbols.f64x2 = "~lib/builtins/f64x2";
    BuiltinSymbols.i8x16_splat = "~lib/builtins/i8x16.splat";
    BuiltinSymbols.i8x16_extract_lane_s = "~lib/builtins/i8x16.extract_lane_s";
    BuiltinSymbols.i8x16_extract_lane_u = "~lib/builtins/i8x16.extract_lane_u";
    BuiltinSymbols.i8x16_replace_lane = "~lib/builtins/i8x16.replace_lane";
    BuiltinSymbols.i8x16_add = "~lib/builtins/i8x16.add";
    BuiltinSymbols.i8x16_sub = "~lib/builtins/i8x16.sub";
    BuiltinSymbols.i8x16_mul = "~lib/builtins/i8x16.mul";
    BuiltinSymbols.i8x16_min_s = "~lib/builtins/i8x16.min_s";
    BuiltinSymbols.i8x16_min_u = "~lib/builtins/i8x16.min_u";
    BuiltinSymbols.i8x16_max_s = "~lib/builtins/i8x16.max_s";
    BuiltinSymbols.i8x16_max_u = "~lib/builtins/i8x16.max_u";
    BuiltinSymbols.i8x16_neg = "~lib/builtins/i8x16.neg";
    BuiltinSymbols.i8x16_add_saturate_s = "~lib/builtins/i8x16.add_saturate_s";
    BuiltinSymbols.i8x16_add_saturate_u = "~lib/builtins/i8x16.add_saturate_u";
    BuiltinSymbols.i8x16_sub_saturate_s = "~lib/builtins/i8x16.sub_saturate_s";
    BuiltinSymbols.i8x16_sub_saturate_u = "~lib/builtins/i8x16.sub_saturate_u";
    BuiltinSymbols.i8x16_shl = "~lib/builtins/i8x16.shl";
    BuiltinSymbols.i8x16_shr_s = "~lib/builtins/i8x16.shr_s";
    BuiltinSymbols.i8x16_shr_u = "~lib/builtins/i8x16.shr_u";
    BuiltinSymbols.i8x16_any_true = "~lib/builtins/i8x16.any_true";
    BuiltinSymbols.i8x16_all_true = "~lib/builtins/i8x16.all_true";
    BuiltinSymbols.i8x16_eq = "~lib/builtins/i8x16.eq";
    BuiltinSymbols.i8x16_ne = "~lib/builtins/i8x16.ne";
    BuiltinSymbols.i8x16_lt_s = "~lib/builtins/i8x16.lt_s";
    BuiltinSymbols.i8x16_lt_u = "~lib/builtins/i8x16.lt_u";
    BuiltinSymbols.i8x16_le_s = "~lib/builtins/i8x16.le_s";
    BuiltinSymbols.i8x16_le_u = "~lib/builtins/i8x16.le_u";
    BuiltinSymbols.i8x16_gt_s = "~lib/builtins/i8x16.gt_s";
    BuiltinSymbols.i8x16_gt_u = "~lib/builtins/i8x16.gt_u";
    BuiltinSymbols.i8x16_ge_s = "~lib/builtins/i8x16.ge_s";
    BuiltinSymbols.i8x16_ge_u = "~lib/builtins/i8x16.ge_u";
    BuiltinSymbols.i8x16_narrow_i16x8_s = "~lib/builtins/i8x16.narrow_i16x8_s";
    BuiltinSymbols.i8x16_narrow_i16x8_u = "~lib/builtins/i8x16.narrow_i16x8_u";
    BuiltinSymbols.i16x8_splat = "~lib/builtins/i16x8.splat";
    BuiltinSymbols.i16x8_extract_lane_s = "~lib/builtins/i16x8.extract_lane_s";
    BuiltinSymbols.i16x8_extract_lane_u = "~lib/builtins/i16x8.extract_lane_u";
    BuiltinSymbols.i16x8_replace_lane = "~lib/builtins/i16x8.replace_lane";
    BuiltinSymbols.i16x8_add = "~lib/builtins/i16x8.add";
    BuiltinSymbols.i16x8_sub = "~lib/builtins/i16x8.sub";
    BuiltinSymbols.i16x8_mul = "~lib/builtins/i16x8.mul";
    BuiltinSymbols.i16x8_min_s = "~lib/builtins/i16x8.min_s";
    BuiltinSymbols.i16x8_min_u = "~lib/builtins/i16x8.min_u";
    BuiltinSymbols.i16x8_max_s = "~lib/builtins/i16x8.max_s";
    BuiltinSymbols.i16x8_max_u = "~lib/builtins/i16x8.max_u";
    BuiltinSymbols.i16x8_neg = "~lib/builtins/i16x8.neg";
    BuiltinSymbols.i16x8_add_saturate_s = "~lib/builtins/i16x8.add_saturate_s";
    BuiltinSymbols.i16x8_add_saturate_u = "~lib/builtins/i16x8.add_saturate_u";
    BuiltinSymbols.i16x8_sub_saturate_s = "~lib/builtins/i16x8.sub_saturate_s";
    BuiltinSymbols.i16x8_sub_saturate_u = "~lib/builtins/i16x8.sub_saturate_u";
    BuiltinSymbols.i16x8_shl = "~lib/builtins/i16x8.shl";
    BuiltinSymbols.i16x8_shr_s = "~lib/builtins/i16x8.shr_s";
    BuiltinSymbols.i16x8_shr_u = "~lib/builtins/i16x8.shr_u";
    BuiltinSymbols.i16x8_any_true = "~lib/builtins/i16x8.any_true";
    BuiltinSymbols.i16x8_all_true = "~lib/builtins/i16x8.all_true";
    BuiltinSymbols.i16x8_eq = "~lib/builtins/i16x8.eq";
    BuiltinSymbols.i16x8_ne = "~lib/builtins/i16x8.ne";
    BuiltinSymbols.i16x8_lt_s = "~lib/builtins/i16x8.lt_s";
    BuiltinSymbols.i16x8_lt_u = "~lib/builtins/i16x8.lt_u";
    BuiltinSymbols.i16x8_le_s = "~lib/builtins/i16x8.le_s";
    BuiltinSymbols.i16x8_le_u = "~lib/builtins/i16x8.le_u";
    BuiltinSymbols.i16x8_gt_s = "~lib/builtins/i16x8.gt_s";
    BuiltinSymbols.i16x8_gt_u = "~lib/builtins/i16x8.gt_u";
    BuiltinSymbols.i16x8_ge_s = "~lib/builtins/i16x8.ge_s";
    BuiltinSymbols.i16x8_ge_u = "~lib/builtins/i16x8.ge_u";
    BuiltinSymbols.i16x8_narrow_i32x4_s = "~lib/builtins/i16x8.narrow_i32x4_s";
    BuiltinSymbols.i16x8_narrow_i32x4_u = "~lib/builtins/i16x8.narrow_i32x4_u";
    BuiltinSymbols.i16x8_widen_low_i8x16_s = "~lib/builtins/i16x8.widen_low_i8x16_s";
    BuiltinSymbols.i16x8_widen_low_i8x16_u = "~lib/builtins/i16x8.widen_low_i8x16_u";
    BuiltinSymbols.i16x8_widen_high_i8x16_s = "~lib/builtins/i16x8.widen_high_i8x16_s";
    BuiltinSymbols.i16x8_widen_high_i8x16_u = "~lib/builtins/i16x8.widen_high_i8x16_u";
    BuiltinSymbols.i16x8_load8x8_s = "~lib/builtins/i16x8.load8x8_s";
    BuiltinSymbols.i16x8_load8x8_u = "~lib/builtins/i16x8.load8x8_u";
    BuiltinSymbols.i32x4_splat = "~lib/builtins/i32x4.splat";
    BuiltinSymbols.i32x4_extract_lane = "~lib/builtins/i32x4.extract_lane";
    BuiltinSymbols.i32x4_replace_lane = "~lib/builtins/i32x4.replace_lane";
    BuiltinSymbols.i32x4_add = "~lib/builtins/i32x4.add";
    BuiltinSymbols.i32x4_sub = "~lib/builtins/i32x4.sub";
    BuiltinSymbols.i32x4_mul = "~lib/builtins/i32x4.mul";
    BuiltinSymbols.i32x4_min_s = "~lib/builtins/i32x4.min_s";
    BuiltinSymbols.i32x4_min_u = "~lib/builtins/i32x4.min_u";
    BuiltinSymbols.i32x4_max_s = "~lib/builtins/i32x4.max_s";
    BuiltinSymbols.i32x4_max_u = "~lib/builtins/i32x4.max_u";
    BuiltinSymbols.i32x4_dot_i16x8_s = "~lib/builtins/i32x4.dot_i16x8_s";
    BuiltinSymbols.i32x4_neg = "~lib/builtins/i32x4.neg";
    BuiltinSymbols.i32x4_shl = "~lib/builtins/i32x4.shl";
    BuiltinSymbols.i32x4_shr_s = "~lib/builtins/i32x4.shr_s";
    BuiltinSymbols.i32x4_shr_u = "~lib/builtins/i32x4.shr_u";
    BuiltinSymbols.i32x4_any_true = "~lib/builtins/i32x4.any_true";
    BuiltinSymbols.i32x4_all_true = "~lib/builtins/i32x4.all_true";
    BuiltinSymbols.i32x4_eq = "~lib/builtins/i32x4.eq";
    BuiltinSymbols.i32x4_ne = "~lib/builtins/i32x4.ne";
    BuiltinSymbols.i32x4_lt_s = "~lib/builtins/i32x4.lt_s";
    BuiltinSymbols.i32x4_lt_u = "~lib/builtins/i32x4.lt_u";
    BuiltinSymbols.i32x4_le_s = "~lib/builtins/i32x4.le_s";
    BuiltinSymbols.i32x4_le_u = "~lib/builtins/i32x4.le_u";
    BuiltinSymbols.i32x4_gt_s = "~lib/builtins/i32x4.gt_s";
    BuiltinSymbols.i32x4_gt_u = "~lib/builtins/i32x4.gt_u";
    BuiltinSymbols.i32x4_ge_s = "~lib/builtins/i32x4.ge_s";
    BuiltinSymbols.i32x4_ge_u = "~lib/builtins/i32x4.ge_u";
    BuiltinSymbols.i32x4_trunc_sat_f32x4_s = "~lib/builtins/i32x4.trunc_sat_f32x4_s";
    BuiltinSymbols.i32x4_trunc_sat_f32x4_u = "~lib/builtins/i32x4.trunc_sat_f32x4_u";
    BuiltinSymbols.i32x4_widen_low_i16x8_s = "~lib/builtins/i32x4.widen_low_i16x8_s";
    BuiltinSymbols.i32x4_widen_low_i16x8_u = "~lib/builtins/i32x4.widen_low_i16x8_u";
    BuiltinSymbols.i32x4_widen_high_i16x8_s = "~lib/builtins/i32x4.widen_high_i16x8_s";
    BuiltinSymbols.i32x4_widen_high_i16x8_u = "~lib/builtins/i32x4.widen_high_i16x8_u";
    BuiltinSymbols.i32x4_load16x4_s = "~lib/builtins/i32x4.load16x4_s";
    BuiltinSymbols.i32x4_load16x4_u = "~lib/builtins/i32x4.load16x4_u";
    BuiltinSymbols.i64x2_splat = "~lib/builtins/i64x2.splat";
    BuiltinSymbols.i64x2_extract_lane = "~lib/builtins/i64x2.extract_lane";
    BuiltinSymbols.i64x2_replace_lane = "~lib/builtins/i64x2.replace_lane";
    BuiltinSymbols.i64x2_add = "~lib/builtins/i64x2.add";
    BuiltinSymbols.i64x2_sub = "~lib/builtins/i64x2.sub"; // i64x2 has no .mul
    BuiltinSymbols.i64x2_neg = "~lib/builtins/i64x2.neg";
    BuiltinSymbols.i64x2_shl = "~lib/builtins/i64x2.shl";
    BuiltinSymbols.i64x2_shr_s = "~lib/builtins/i64x2.shr_s";
    BuiltinSymbols.i64x2_shr_u = "~lib/builtins/i64x2.shr_u";
    BuiltinSymbols.i64x2_any_true = "~lib/builtins/i64x2.any_true";
    BuiltinSymbols.i64x2_all_true = "~lib/builtins/i64x2.all_true"; // i64x2 has no .eq etc.
    BuiltinSymbols.i64x2_trunc_sat_f64x2_s = "~lib/builtins/i64x2.trunc_sat_f64x2_s";
    BuiltinSymbols.i64x2_trunc_sat_f64x2_u = "~lib/builtins/i64x2.trunc_sat_f64x2_u";
    BuiltinSymbols.i64x2_load32x2_s = "~lib/builtins/i64x2.load32x2_s";
    BuiltinSymbols.i64x2_load32x2_u = "~lib/builtins/i64x2.load32x2_u";
    BuiltinSymbols.f32x4_splat = "~lib/builtins/f32x4.splat";
    BuiltinSymbols.f32x4_extract_lane = "~lib/builtins/f32x4.extract_lane";
    BuiltinSymbols.f32x4_replace_lane = "~lib/builtins/f32x4.replace_lane";
    BuiltinSymbols.f32x4_add = "~lib/builtins/f32x4.add";
    BuiltinSymbols.f32x4_sub = "~lib/builtins/f32x4.sub";
    BuiltinSymbols.f32x4_mul = "~lib/builtins/f32x4.mul";
    BuiltinSymbols.f32x4_div = "~lib/builtins/f32x4.div";
    BuiltinSymbols.f32x4_neg = "~lib/builtins/f32x4.neg";
    BuiltinSymbols.f32x4_min = "~lib/builtins/f32x4.min";
    BuiltinSymbols.f32x4_max = "~lib/builtins/f32x4.max";
    BuiltinSymbols.f32x4_abs = "~lib/builtins/f32x4.abs";
    BuiltinSymbols.f32x4_sqrt = "~lib/builtins/f32x4.sqrt";
    BuiltinSymbols.f32x4_eq = "~lib/builtins/f32x4.eq";
    BuiltinSymbols.f32x4_ne = "~lib/builtins/f32x4.ne";
    BuiltinSymbols.f32x4_lt = "~lib/builtins/f32x4.lt";
    BuiltinSymbols.f32x4_le = "~lib/builtins/f32x4.le";
    BuiltinSymbols.f32x4_gt = "~lib/builtins/f32x4.gt";
    BuiltinSymbols.f32x4_ge = "~lib/builtins/f32x4.ge";
    BuiltinSymbols.f32x4_convert_i32x4_s = "~lib/builtins/f32x4.convert_i32x4_s";
    BuiltinSymbols.f32x4_convert_i32x4_u = "~lib/builtins/f32x4.convert_i32x4_u";
    BuiltinSymbols.f32x4_qfma = "~lib/builtins/f32x4.qfma";
    BuiltinSymbols.f32x4_qfms = "~lib/builtins/f32x4.qfms";
    BuiltinSymbols.f64x2_splat = "~lib/builtins/f64x2.splat";
    BuiltinSymbols.f64x2_extract_lane = "~lib/builtins/f64x2.extract_lane";
    BuiltinSymbols.f64x2_replace_lane = "~lib/builtins/f64x2.replace_lane";
    BuiltinSymbols.f64x2_add = "~lib/builtins/f64x2.add";
    BuiltinSymbols.f64x2_sub = "~lib/builtins/f64x2.sub";
    BuiltinSymbols.f64x2_mul = "~lib/builtins/f64x2.mul";
    BuiltinSymbols.f64x2_div = "~lib/builtins/f64x2.div";
    BuiltinSymbols.f64x2_neg = "~lib/builtins/f64x2.neg";
    BuiltinSymbols.f64x2_min = "~lib/builtins/f64x2.min";
    BuiltinSymbols.f64x2_max = "~lib/builtins/f64x2.max";
    BuiltinSymbols.f64x2_abs = "~lib/builtins/f64x2.abs";
    BuiltinSymbols.f64x2_sqrt = "~lib/builtins/f64x2.sqrt";
    BuiltinSymbols.f64x2_eq = "~lib/builtins/f64x2.eq";
    BuiltinSymbols.f64x2_ne = "~lib/builtins/f64x2.ne";
    BuiltinSymbols.f64x2_lt = "~lib/builtins/f64x2.lt";
    BuiltinSymbols.f64x2_le = "~lib/builtins/f64x2.le";
    BuiltinSymbols.f64x2_gt = "~lib/builtins/f64x2.gt";
    BuiltinSymbols.f64x2_ge = "~lib/builtins/f64x2.ge";
    BuiltinSymbols.f64x2_convert_i64x2_s = "~lib/builtins/f64x2.convert_i64x2_s";
    BuiltinSymbols.f64x2_convert_i64x2_u = "~lib/builtins/f64x2.convert_i64x2_u";
    BuiltinSymbols.f64x2_qfma = "~lib/builtins/f64x2.qfma";
    BuiltinSymbols.f64x2_qfms = "~lib/builtins/f64x2.qfms";
    BuiltinSymbols.v8x16_shuffle = "~lib/builtins/v8x16.shuffle";
    BuiltinSymbols.v8x16_swizzle = "~lib/builtins/v8x16.swizzle";
    BuiltinSymbols.v8x16_load_splat = "~lib/builtins/v8x16.load_splat";
    BuiltinSymbols.v16x8_load_splat = "~lib/builtins/v16x8.load_splat";
    BuiltinSymbols.v32x4_load_splat = "~lib/builtins/v32x4.load_splat";
    BuiltinSymbols.v64x2_load_splat = "~lib/builtins/v64x2.load_splat";
    // internals
    BuiltinSymbols.heap_base = "~lib/heap/__heap_base";
    BuiltinSymbols.rtti_base = "~lib/rt/__rtti_base";
    BuiltinSymbols.visit_globals = "~lib/rt/__visit_globals";
    BuiltinSymbols.visit_members = "~lib/rt/__visit_members";
    // std/number.ts
    BuiltinSymbols.isNaN = "~lib/number/isNaN";
    BuiltinSymbols.isFinite = "~lib/number/isFinite";
    // std/diagnostics.ts
    BuiltinSymbols.ERROR = "~lib/diagnostics/ERROR";
    BuiltinSymbols.WARNING = "~lib/diagnostics/WARNING";
    BuiltinSymbols.INFO = "~lib/diagnostics/INFO";
    // std/memory.ts
    BuiltinSymbols.memory_size = "~lib/memory/memory.size";
    BuiltinSymbols.memory_grow = "~lib/memory/memory.grow";
    BuiltinSymbols.memory_copy = "~lib/memory/memory.copy";
    BuiltinSymbols.memory_fill = "~lib/memory/memory.fill";
    BuiltinSymbols.memory_allocate = "~lib/memory/memory.allocate";
    BuiltinSymbols.memory_free = "~lib/memory/memory.free";
    BuiltinSymbols.memory_reset = "~lib/memory/memory.reset";
    // std/runtime.ts
    BuiltinSymbols.runtime_instanceof = "~lib/runtime/runtime.instanceof";
    BuiltinSymbols.runtime_flags = "~lib/runtime/runtime.flags";
    BuiltinSymbols.runtime_allocate = "~lib/util/runtime/allocate";
    BuiltinSymbols.runtime_reallocate = "~lib/util/runtime/reallocate";
    BuiltinSymbols.runtime_register = "~lib/util/runtime/register";
    BuiltinSymbols.runtime_discard = "~lib/util/runtime/discard";
    BuiltinSymbols.runtime_makeArray = "~lib/util/runtime/makeArray";
    // std/typedarray.ts
    BuiltinSymbols.Int8Array = "~lib/typedarray/Int8Array";
    BuiltinSymbols.Uint8Array = "~lib/typedarray/Uint8Array";
    BuiltinSymbols.Int16Array = "~lib/typedarray/Int16Array";
    BuiltinSymbols.Uint16Array = "~lib/typedarray/Uint16Array";
    BuiltinSymbols.Int32Array = "~lib/typedarray/Int32Array";
    BuiltinSymbols.Uint32Array = "~lib/typedarray/Uint32Array";
    BuiltinSymbols.Int64Array = "~lib/typedarray/Int64Array";
    BuiltinSymbols.Uint64Array = "~lib/typedarray/Uint64Array";
    BuiltinSymbols.Uint8ClampedArray = "~lib/typedarray/Uint8ClampedArray";
    BuiltinSymbols.Float32Array = "~lib/typedarray/Float32Array";
    BuiltinSymbols.Float64Array = "~lib/typedarray/Float64Array";
    // compiler generated
    BuiltinSymbols.started = "~lib/started";
    BuiltinSymbols.argc = "~lib/argc";
    BuiltinSymbols.setargc = "~lib/setargc";
    BuiltinSymbols.capabilities = "~lib/capabilities";
})(BuiltinSymbols = exports.BuiltinSymbols || (exports.BuiltinSymbols = {}));
/** Compiles a call to a built-in function. */
function compileCall(
/* Compiler reference. */
compiler, 
/** Respective function prototype. */
prototype, 
/** Pre-resolved type arguments. */
typeArguments, 
/** Operand expressions. */
operands, 
/** Contextual type. */
contextualType, 
/** Respective call expression. */
reportNode, 
/** Indicates that contextual type is ASM type. */
isAsm = false) {
    var module = compiler.module;
    switch (prototype.internalName) {
        // === Static type evaluation =================================================================
        case BuiltinSymbols.isInteger: { // isInteger<T!>() / isInteger<T?>(value: T) -> bool
            let type = evaluateConstantType(compiler, typeArguments, operands, reportNode);
            compiler.currentType = types_1.Type.bool;
            if (!type)
                return module.unreachable();
            return type.is(4 /* INTEGER */) && !type.is(256 /* REFERENCE */)
                ? module.i32(1)
                : module.i32(0);
        }
        case BuiltinSymbols.isFloat: { // isFloat<T!>() / isFloat<T?>(value: T) -> bool
            let type = evaluateConstantType(compiler, typeArguments, operands, reportNode);
            compiler.currentType = types_1.Type.bool;
            if (!type)
                return module.unreachable();
            return type.is(8 /* FLOAT */)
                ? module.i32(1)
                : module.i32(0);
        }
        case BuiltinSymbols.isBoolean: { // isBoolean<T!>() / isBoolean<T?>(value: T) -> bool
            let type = evaluateConstantType(compiler, typeArguments, operands, reportNode);
            compiler.currentType = types_1.Type.bool;
            if (!type)
                return module.unreachable();
            return type == types_1.Type.bool
                ? module.i32(1)
                : module.i32(0);
        }
        case BuiltinSymbols.isSigned: { // isSigned<T!>() / isSigned<T?>(value: T) -> bool
            let type = evaluateConstantType(compiler, typeArguments, operands, reportNode);
            compiler.currentType = types_1.Type.bool;
            if (!type)
                return module.unreachable();
            return type.is(1 /* SIGNED */)
                ? module.i32(1)
                : module.i32(0);
        }
        case BuiltinSymbols.isReference: { // isReference<T!>() / isReference<T?>(value: T) -> bool
            let type = evaluateConstantType(compiler, typeArguments, operands, reportNode);
            compiler.currentType = types_1.Type.bool;
            if (!type)
                return module.unreachable();
            return type.is(256 /* REFERENCE */)
                ? module.i32(1)
                : module.i32(0);
        }
        case BuiltinSymbols.isString: { // isString<T!>() / isString<T?>(value: T) -> bool
            let type = evaluateConstantType(compiler, typeArguments, operands, reportNode);
            compiler.currentType = types_1.Type.bool;
            if (!type)
                return module.unreachable();
            if (type.is(256 /* REFERENCE */)) {
                let classReference = type.classReference;
                if (classReference) {
                    let stringInstance = compiler.program.stringInstance;
                    if (stringInstance && classReference.isAssignableTo(stringInstance))
                        return module.i32(1);
                }
            }
            return module.i32(0);
        }
        case BuiltinSymbols.isArray: { // isArray<T!>() / isArray<T?>(value: T) -> bool
            let type = evaluateConstantType(compiler, typeArguments, operands, reportNode);
            compiler.currentType = types_1.Type.bool;
            if (!type)
                return module.unreachable();
            if (type.is(256 /* REFERENCE */)) {
                let classReference = type.classReference;
                if (classReference) {
                    return module.i32(classReference.prototype.extends(compiler.program.arrayPrototype) ? 1 : 0);
                }
            }
            return module.i32(0);
        }
        case BuiltinSymbols.isArrayLike: { // isArrayLike<T!>() / isArrayLike<T?>(value: T) -> bool
            let type = evaluateConstantType(compiler, typeArguments, operands, reportNode);
            compiler.currentType = types_1.Type.bool;
            if (!type)
                return module.unreachable();
            if (type.is(256 /* REFERENCE */)) {
                let classReference = type.classReference;
                if (classReference) {
                    return module.i32(classReference.isArrayLike ? 1 : 0);
                }
            }
            return module.i32(0);
        }
        case BuiltinSymbols.isFunction: { // isFunction<T!> / isFunction<T?>(value: T) -> bool
            let type = evaluateConstantType(compiler, typeArguments, operands, reportNode);
            compiler.currentType = types_1.Type.bool;
            if (!type)
                return module.unreachable();
            return module.i32(type.signatureReference ? 1 : 0);
        }
        case BuiltinSymbols.isNullable: { // isNullable<T!> / isNullable<T?>(value: T) -> bool
            let type = evaluateConstantType(compiler, typeArguments, operands, reportNode);
            compiler.currentType = types_1.Type.bool;
            if (!type)
                return module.unreachable();
            return module.i32(type.is(512 /* NULLABLE */) ? 1 : 0);
        }
        case BuiltinSymbols.isDefined: { // isDefined(expression) -> bool
            compiler.currentType = types_1.Type.bool;
            if (checkTypeAbsent(typeArguments, reportNode, prototype) |
                checkArgsRequired(operands, 1, reportNode, compiler))
                return module.unreachable();
            let element = compiler.resolver.lookupExpression(operands[0], compiler.currentFlow, types_1.Type.auto, resolver_1.ReportMode.SWALLOW);
            return module.i32(element ? 1 : 0);
        }
        case BuiltinSymbols.isConstant: { // isConstant(expression) -> bool
            compiler.currentType = types_1.Type.bool;
            if (checkTypeAbsent(typeArguments, reportNode, prototype) |
                checkArgsRequired(operands, 1, reportNode, compiler))
                return module.unreachable();
            let expr = compiler.compileExpression(operands[0], types_1.Type.auto);
            compiler.currentType = types_1.Type.bool;
            return module.i32(module_1.getExpressionId(expr) == module_1.ExpressionId.Const ? 1 : 0);
        }
        case BuiltinSymbols.isManaged: { // isManaged<T!>() -> bool
            let type = evaluateConstantType(compiler, typeArguments, operands, reportNode);
            compiler.currentType = types_1.Type.bool;
            if (!type)
                return module.unreachable();
            return module.i32(type.isManaged ? 1 : 0);
        }
        case BuiltinSymbols.isVoid: { // isVoid<T!>() -> bool
            let type = evaluateConstantType(compiler, typeArguments, operands, reportNode);
            compiler.currentType = types_1.Type.bool;
            if (!type)
                return module.unreachable();
            return module.i32(type.kind == 15 /* VOID */ ? 1 : 0);
        }
        case BuiltinSymbols.lengthof: { // lengthof<T!>() -> i32
            let type = evaluateConstantType(compiler, typeArguments, operands, reportNode);
            compiler.currentType = types_1.Type.i32;
            if (!type)
                return module.unreachable();
            let signatureReference = type.signatureReference;
            if (!signatureReference) {
                compiler.error(diagnostics_1.DiagnosticCode.Type_0_has_no_call_signatures, reportNode.range, type.toString());
                return module.unreachable();
            }
            return module.i32(signatureReference.parameterTypes.length);
        }
        case BuiltinSymbols.sizeof: { // sizeof<T!>() -> usize
            compiler.currentType = compiler.options.usizeType;
            if (checkTypeRequired(typeArguments, reportNode, compiler) |
                checkArgsRequired(operands, 0, reportNode, compiler))
                return module.unreachable();
            let type = typeArguments[0];
            let byteSize = type.byteSize;
            if (!byteSize) {
                compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "sizeof", type.toString());
                return module.unreachable();
            }
            if (compiler.options.isWasm64) {
                // implicitly wrap if contextual type is a 32-bit integer
                if (contextualType.is(4 /* INTEGER */) && contextualType.size <= 32) {
                    compiler.currentType = types_1.Type.u32;
                    return module.i32(byteSize);
                }
                return module.i64(byteSize, 0);
            }
            else {
                // implicitly extend if contextual type is a 64-bit integer
                if (contextualType.is(4 /* INTEGER */) && contextualType.size == 64) {
                    compiler.currentType = types_1.Type.u64;
                    return module.i64(byteSize, 0);
                }
                return module.i32(byteSize);
            }
        }
        case BuiltinSymbols.alignof: { // alignof<T!>() -> usize
            compiler.currentType = compiler.options.usizeType;
            if (checkTypeRequired(typeArguments, reportNode, compiler) |
                checkArgsRequired(operands, 0, reportNode, compiler))
                return module.unreachable();
            let type = typeArguments[0];
            let byteSize = type.byteSize;
            if (!util_1.isPowerOf2(byteSize)) { // implies == 0
                compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "alignof", type.toString());
                return module.unreachable();
            }
            let alignLog2 = ctz(byteSize);
            if (compiler.options.isWasm64) {
                // implicitly wrap if contextual type is a 32-bit integer
                if (contextualType.is(4 /* INTEGER */) && contextualType.size <= 32) {
                    compiler.currentType = types_1.Type.u32;
                    return module.i32(alignLog2);
                }
                return module.i64(alignLog2, 0);
            }
            else {
                // implicitly extend if contextual type is a 64-bit integer
                if (contextualType.is(4 /* INTEGER */) && contextualType.size == 64) {
                    compiler.currentType = types_1.Type.u64;
                    return module.i64(alignLog2, 0);
                }
                return module.i32(alignLog2);
            }
        }
        case BuiltinSymbols.offsetof: { // offsetof<T!>(fieldName?: string) -> usize
            compiler.currentType = compiler.options.usizeType;
            if (checkTypeRequired(typeArguments, reportNode, compiler) |
                checkArgsOptional(operands, 0, 1, reportNode, compiler))
                return module.unreachable();
            let type = typeArguments[0];
            let classType = type.classReference;
            if (!(type.is(256 /* REFERENCE */) && classType !== null)) {
                compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "offsetof", type.toString());
                if (compiler.options.isWasm64) {
                    if (contextualType.is(4 /* INTEGER */) && contextualType.size <= 32) {
                        compiler.currentType = types_1.Type.u32;
                    }
                }
                else {
                    if (contextualType.is(4 /* INTEGER */) && contextualType.size == 64) {
                        compiler.currentType = types_1.Type.u64;
                    }
                }
                return module.unreachable();
            }
            let offset;
            if (operands.length) {
                if (operands[0].kind != ast_1.NodeKind.LITERAL ||
                    operands[0].literalKind != ast_1.LiteralKind.STRING) {
                    compiler.error(diagnostics_1.DiagnosticCode.String_literal_expected, operands[0].range);
                    return module.unreachable();
                }
                let fieldName = operands[0].value;
                let field = classType.members ? classType.members.get(fieldName) : null;
                if (!(field && field.kind == program_1.ElementKind.FIELD)) {
                    compiler.error(diagnostics_1.DiagnosticCode.Type_0_has_no_property_1, operands[0].range, classType.internalName, fieldName);
                    return module.unreachable();
                }
                offset = field.memoryOffset;
            }
            else {
                offset = classType.currentMemoryOffset;
            }
            if (compiler.options.isWasm64) {
                // implicitly wrap if contextual type is a 32-bit integer
                if (contextualType.is(4 /* INTEGER */) && contextualType.size <= 32) {
                    compiler.currentType = types_1.Type.u32;
                    return module.i32(offset);
                }
                return module.i64(offset);
            }
            else {
                // implicitly extend if contextual type is a 64-bit integer
                if (contextualType.is(4 /* INTEGER */) && contextualType.size == 64) {
                    compiler.currentType = types_1.Type.u64;
                    return module.i64(offset);
                }
                return module.i32(offset);
            }
        }
        case BuiltinSymbols.nameof: {
            let resultType = evaluateConstantType(compiler, typeArguments, operands, reportNode);
            if (!resultType) {
                compiler.currentType = compiler.program.stringInstance.type;
                return module.unreachable();
            }
            let value;
            if (resultType.is(256 /* REFERENCE */)) {
                let classReference = resultType.classReference;
                if (classReference) {
                    value = classReference.name;
                }
                else {
                    let signatureReference = resultType.signatureReference;
                    if (signatureReference) {
                        value = "Function";
                    }
                    else {
                        value = "Anyref";
                    }
                }
            }
            else {
                switch (resultType.kind) {
                    case 10 /* BOOL */: {
                        value = "bool";
                        break;
                    }
                    case 0 /* I8 */: {
                        value = "i8";
                        break;
                    }
                    case 5 /* U8 */: {
                        value = "u8";
                        break;
                    }
                    case 1 /* I16 */: {
                        value = "i16";
                        break;
                    }
                    case 6 /* U16 */: {
                        value = "u16";
                        break;
                    }
                    case 2 /* I32 */: {
                        value = "i32";
                        break;
                    }
                    case 7 /* U32 */: {
                        value = "u32";
                        break;
                    }
                    case 11 /* F32 */: {
                        value = "f32";
                        break;
                    }
                    case 3 /* I64 */: {
                        value = "i64";
                        break;
                    }
                    case 8 /* U64 */: {
                        value = "u64";
                        break;
                    }
                    case 12 /* F64 */: {
                        value = "f64";
                        break;
                    }
                    case 4 /* ISIZE */: {
                        value = "isize";
                        break;
                    }
                    case 9 /* USIZE */: {
                        value = "usize";
                        break;
                    }
                    case 13 /* V128 */: {
                        value = "v128";
                        break;
                    }
                    case 14 /* ANYREF */: {
                        value = "anyref";
                        break;
                    }
                    default: assert(false);
                    case 15 /* VOID */: {
                        value = "void";
                        break;
                    }
                }
            }
            return compiler.ensureStaticString(value);
        }
        // === Math ===================================================================================
        case BuiltinSymbols.clz: { // clz<T?>(value: T) -> T
            if (checkTypeOptional(typeArguments, reportNode, compiler, true) |
                checkArgsRequired(operands, 1, reportNode, compiler))
                return module.unreachable();
            let arg0 = typeArguments
                ? compiler.compileExpression(operands[0], typeArguments[0], 1 /* CONV_IMPLICIT */ | 4 /* MUST_WRAP */)
                : compiler.compileExpression(operands[0], types_1.Type.i32, 4 /* MUST_WRAP */);
            let type = compiler.currentType;
            if (!type.is(256 /* REFERENCE */)) {
                switch (type.kind) {
                    case 10 /* BOOL */: // not wrapped
                    case 0 /* I8 */:
                    case 5 /* U8 */:
                    case 1 /* I16 */:
                    case 6 /* U16 */:
                    case 2 /* I32 */:
                    case 7 /* U32 */: return module.unary(module_1.UnaryOp.ClzI32, arg0);
                    case 9 /* USIZE */:
                    case 4 /* ISIZE */: {
                        return module.unary(compiler.options.isWasm64
                            ? module_1.UnaryOp.ClzI64
                            : module_1.UnaryOp.ClzI32, arg0);
                    }
                    case 3 /* I64 */:
                    case 8 /* U64 */: return module.unary(module_1.UnaryOp.ClzI64, arg0);
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "clz", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.ctz: { // ctz<T?>(value: T) -> T
            if (checkTypeOptional(typeArguments, reportNode, compiler, true) |
                checkArgsRequired(operands, 1, reportNode, compiler))
                return module.unreachable();
            let arg0 = typeArguments
                ? compiler.compileExpression(operands[0], typeArguments[0], 1 /* CONV_IMPLICIT */ | 4 /* MUST_WRAP */)
                : compiler.compileExpression(operands[0], types_1.Type.i32, 4 /* MUST_WRAP */);
            let type = compiler.currentType;
            if (!type.is(256 /* REFERENCE */)) {
                switch (type.kind) {
                    case 10 /* BOOL */: // not wrapped
                    case 0 /* I8 */:
                    case 5 /* U8 */:
                    case 1 /* I16 */:
                    case 6 /* U16 */:
                    case 2 /* I32 */:
                    case 7 /* U32 */: return module.unary(module_1.UnaryOp.CtzI32, arg0);
                    case 9 /* USIZE */:
                    case 4 /* ISIZE */: {
                        return module.unary(compiler.options.isWasm64
                            ? module_1.UnaryOp.CtzI64
                            : module_1.UnaryOp.CtzI32, arg0);
                    }
                    case 3 /* I64 */:
                    case 8 /* U64 */: return module.unary(module_1.UnaryOp.CtzI64, arg0);
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "ctz", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.popcnt: { // popcnt<T?>(value: T) -> T
            if (checkTypeOptional(typeArguments, reportNode, compiler, true) |
                checkArgsRequired(operands, 1, reportNode, compiler))
                return module.unreachable();
            let arg0 = typeArguments
                ? compiler.compileExpression(operands[0], typeArguments[0], 1 /* CONV_IMPLICIT */ | 4 /* MUST_WRAP */)
                : compiler.compileExpression(operands[0], types_1.Type.i32, 4 /* MUST_WRAP */);
            let type = compiler.currentType;
            if (!type.is(256 /* REFERENCE */)) {
                switch (compiler.currentType.kind) {
                    case 10 /* BOOL */: // not wrapped
                    case 0 /* I8 */:
                    case 5 /* U8 */:
                    case 1 /* I16 */:
                    case 6 /* U16 */:
                    case 2 /* I32 */:
                    case 7 /* U32 */: return module.unary(module_1.UnaryOp.PopcntI32, arg0);
                    case 3 /* I64 */:
                    case 8 /* U64 */: return module.unary(module_1.UnaryOp.PopcntI64, arg0);
                    case 4 /* ISIZE */:
                    case 9 /* USIZE */: {
                        return module.unary(compiler.options.isWasm64
                            ? module_1.UnaryOp.PopcntI64
                            : module_1.UnaryOp.PopcntI32, arg0);
                    }
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "popcnt", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.rotl: { // rotl<T?>(value: T, shift: T) -> T
            if (checkTypeOptional(typeArguments, reportNode, compiler, true) |
                checkArgsRequired(operands, 2, reportNode, compiler))
                return module.unreachable();
            let arg0 = typeArguments
                ? compiler.compileExpression(operands[0], typeArguments[0], 1 /* CONV_IMPLICIT */ | 4 /* MUST_WRAP */)
                : compiler.compileExpression(operands[0], types_1.Type.i32, 4 /* MUST_WRAP */);
            let type = compiler.currentType;
            if (!type.is(256 /* REFERENCE */)) {
                let arg1 = compiler.compileExpression(operands[1], type, 1 /* CONV_IMPLICIT */);
                switch (type.kind) {
                    case 0 /* I8 */:
                    case 1 /* I16 */:
                    case 5 /* U8 */:
                    case 6 /* U16 */:
                    case 10 /* BOOL */: {
                        return compiler.ensureSmallIntegerWrap(module.binary(module_1.BinaryOp.RotlI32, arg0, arg1), type);
                    }
                    case 2 /* I32 */:
                    case 7 /* U32 */: return module.binary(module_1.BinaryOp.RotlI32, arg0, arg1);
                    case 9 /* USIZE */:
                    case 4 /* ISIZE */: {
                        return module.binary(compiler.options.isWasm64
                            ? module_1.BinaryOp.RotlI64
                            : module_1.BinaryOp.RotlI32, arg0, arg1);
                    }
                    case 3 /* I64 */:
                    case 8 /* U64 */: return module.binary(module_1.BinaryOp.RotlI64, arg0, arg1);
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "rotl", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.rotr: { // rotr<T?>(value: T, shift: T) -> T
            if (checkTypeOptional(typeArguments, reportNode, compiler, true) |
                checkArgsRequired(operands, 2, reportNode, compiler))
                return module.unreachable();
            let arg0 = typeArguments
                ? compiler.compileExpression(operands[0], typeArguments[0], 1 /* CONV_IMPLICIT */ | 4 /* MUST_WRAP */)
                : compiler.compileExpression(operands[0], types_1.Type.i32, 4 /* MUST_WRAP */);
            let type = compiler.currentType;
            if (!type.is(256 /* REFERENCE */)) {
                let arg1 = compiler.compileExpression(operands[1], type, 1 /* CONV_IMPLICIT */);
                switch (type.kind) {
                    case 0 /* I8 */:
                    case 1 /* I16 */:
                    case 5 /* U8 */:
                    case 6 /* U16 */:
                    case 10 /* BOOL */: {
                        return compiler.ensureSmallIntegerWrap(module.binary(module_1.BinaryOp.RotrI32, arg0, arg1), type);
                    }
                    case 2 /* I32 */:
                    case 7 /* U32 */: return module.binary(module_1.BinaryOp.RotrI32, arg0, arg1);
                    case 9 /* USIZE */:
                    case 4 /* ISIZE */: {
                        return module.binary(compiler.options.isWasm64
                            ? module_1.BinaryOp.RotrI64
                            : module_1.BinaryOp.RotrI32, arg0, arg1);
                    }
                    case 3 /* I64 */:
                    case 8 /* U64 */: return module.binary(module_1.BinaryOp.RotrI64, arg0, arg1);
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "rotr", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.abs: { // abs<T?>(value: T) -> T
            if (checkTypeOptional(typeArguments, reportNode, compiler, true) |
                checkArgsRequired(operands, 1, reportNode, compiler))
                return module.unreachable();
            let arg0 = typeArguments
                ? compiler.compileExpression(operands[0], typeArguments[0], 1 /* CONV_IMPLICIT */ | 4 /* MUST_WRAP */)
                : compiler.compileExpression(operands[0], types_1.Type.auto, 4 /* MUST_WRAP */);
            let type = compiler.currentType;
            if (!type.is(256 /* REFERENCE */)) {
                switch (type.kind) {
                    case 0 /* I8 */:
                    case 1 /* I16 */:
                    case 2 /* I32 */: {
                        let flow = compiler.currentFlow;
                        // possibly overflows, e.g. abs<i8>(-128) == 128
                        let temp1 = flow.getTempLocal(types_1.Type.i32);
                        let temp2 = flow.getTempLocal(types_1.Type.i32);
                        // (x + (x >> 31)) ^ (x >> 31)
                        let ret = module.binary(module_1.BinaryOp.XorI32, module.binary(module_1.BinaryOp.AddI32, module.local_tee(temp2.index, module.binary(module_1.BinaryOp.ShrI32, module.local_tee(temp1.index, arg0), module.i32(31))), module.local_get(temp1.index, module_1.NativeType.I32)), module.local_get(temp2.index, module_1.NativeType.I32));
                        flow.freeTempLocal(temp2);
                        flow.freeTempLocal(temp1);
                        return ret;
                    }
                    case 4 /* ISIZE */: {
                        let options = compiler.options;
                        let flow = compiler.currentFlow;
                        let isWasm64 = options.isWasm64;
                        let temp1 = flow.getTempLocal(options.usizeType);
                        let temp2 = flow.getTempLocal(options.usizeType);
                        let ret = module.binary(isWasm64 ? module_1.BinaryOp.XorI64 : module_1.BinaryOp.XorI32, module.binary(isWasm64 ? module_1.BinaryOp.AddI64 : module_1.BinaryOp.AddI32, module.local_tee(temp2.index, module.binary(isWasm64 ? module_1.BinaryOp.ShrI64 : module_1.BinaryOp.ShrI32, module.local_tee(temp1.index, arg0), isWasm64 ? module.i64(63) : module.i32(31))), module.local_get(temp1.index, options.nativeSizeType)), module.local_get(temp2.index, options.nativeSizeType));
                        flow.freeTempLocal(temp2);
                        flow.freeTempLocal(temp1);
                        return ret;
                    }
                    case 3 /* I64 */: {
                        let flow = compiler.currentFlow;
                        let temp1 = flow.getTempLocal(types_1.Type.i64);
                        let temp2 = flow.getTempLocal(types_1.Type.i64);
                        // (x + (x >> 63)) ^ (x >> 63)
                        let ret = module.binary(module_1.BinaryOp.XorI64, module.binary(module_1.BinaryOp.AddI64, module.local_tee(temp2.index, module.binary(module_1.BinaryOp.ShrI64, module.local_tee(temp1.index, arg0), module.i64(63))), module.local_get(temp1.index, module_1.NativeType.I64)), module.local_get(temp2.index, module_1.NativeType.I64));
                        flow.freeTempLocal(temp2);
                        flow.freeTempLocal(temp1);
                        return ret;
                    }
                    case 9 /* USIZE */:
                    case 5 /* U8 */:
                    case 6 /* U16 */:
                    case 7 /* U32 */:
                    case 8 /* U64 */:
                    case 10 /* BOOL */: return arg0;
                    case 11 /* F32 */: return module.unary(module_1.UnaryOp.AbsF32, arg0);
                    case 12 /* F64 */: return module.unary(module_1.UnaryOp.AbsF64, arg0);
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "abs", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.max: { // max<T?>(left: T, right: T) -> T
            if (checkTypeOptional(typeArguments, reportNode, compiler, true) |
                checkArgsRequired(operands, 2, reportNode, compiler))
                return module.unreachable();
            let left = operands[0];
            let arg0 = typeArguments
                ? compiler.compileExpression(left, typeArguments[0], 1 /* CONV_IMPLICIT */ | 4 /* MUST_WRAP */)
                : compiler.compileExpression(operands[0], types_1.Type.auto, 4 /* MUST_WRAP */);
            let type = compiler.currentType;
            if (!type.is(256 /* REFERENCE */)) {
                let arg1;
                if (!typeArguments && ast_1.isNumericLiteral(left)) { // prefer right type
                    arg1 = compiler.compileExpression(operands[1], type, 4 /* MUST_WRAP */);
                    if (compiler.currentType != type) {
                        arg0 = compiler.compileExpression(left, type = compiler.currentType, 1 /* CONV_IMPLICIT */ | 4 /* MUST_WRAP */);
                    }
                }
                else {
                    arg1 = compiler.compileExpression(operands[1], type, 1 /* CONV_IMPLICIT */ | 4 /* MUST_WRAP */);
                }
                let op = -1;
                switch (type.kind) {
                    case 0 /* I8 */:
                    case 1 /* I16 */:
                    case 2 /* I32 */: {
                        op = module_1.BinaryOp.GtI32;
                        break;
                    }
                    case 5 /* U8 */:
                    case 6 /* U16 */:
                    case 7 /* U32 */:
                    case 10 /* BOOL */: {
                        op = module_1.BinaryOp.GtU32;
                        break;
                    }
                    case 3 /* I64 */: {
                        op = module_1.BinaryOp.GtI64;
                        break;
                    }
                    case 8 /* U64 */: {
                        op = module_1.BinaryOp.GtU64;
                        break;
                    }
                    case 4 /* ISIZE */: {
                        op = compiler.options.isWasm64
                            ? module_1.BinaryOp.GtI64
                            : module_1.BinaryOp.GtI32;
                        break;
                    }
                    case 9 /* USIZE */: {
                        op = compiler.options.isWasm64
                            ? module_1.BinaryOp.GtU64
                            : module_1.BinaryOp.GtU32;
                        break;
                    }
                    case 11 /* F32 */: return module.binary(module_1.BinaryOp.MaxF32, arg0, arg1);
                    case 12 /* F64 */: return module.binary(module_1.BinaryOp.MaxF64, arg0, arg1);
                }
                if (op != -1) {
                    let flow = compiler.currentFlow;
                    let nativeType = type.toNativeType();
                    let temp1 = flow.getTempLocal(type);
                    flow.setLocalFlag(temp1.index, flow_1.LocalFlags.WRAPPED);
                    let temp2 = flow.getTempLocal(type);
                    flow.setLocalFlag(temp2.index, flow_1.LocalFlags.WRAPPED);
                    let ret = module.select(module.local_tee(temp1.index, arg0), module.local_tee(temp2.index, arg1), module.binary(op, module.local_get(temp1.index, nativeType), module.local_get(temp2.index, nativeType)));
                    flow.freeTempLocal(temp2);
                    flow.freeTempLocal(temp1);
                    return ret;
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "max", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.min: { // min<T?>(left: T, right: T) -> T
            if (checkTypeOptional(typeArguments, reportNode, compiler, true) |
                checkArgsRequired(operands, 2, reportNode, compiler))
                return module.unreachable();
            let left = operands[0];
            let arg0 = typeArguments
                ? compiler.compileExpression(left, typeArguments[0], 1 /* CONV_IMPLICIT */ | 4 /* MUST_WRAP */)
                : compiler.compileExpression(operands[0], types_1.Type.auto, 4 /* MUST_WRAP */);
            let type = compiler.currentType;
            if (!type.is(256 /* REFERENCE */)) {
                let arg1;
                if (!typeArguments && ast_1.isNumericLiteral(left)) { // prefer right type
                    arg1 = compiler.compileExpression(operands[1], type, 4 /* MUST_WRAP */);
                    if (compiler.currentType != type) {
                        arg0 = compiler.compileExpression(left, type = compiler.currentType, 1 /* CONV_IMPLICIT */ | 4 /* MUST_WRAP */);
                    }
                }
                else {
                    arg1 = compiler.compileExpression(operands[1], type, 1 /* CONV_IMPLICIT */ | 4 /* MUST_WRAP */);
                }
                let op = -1;
                switch (type.kind) {
                    case 0 /* I8 */:
                    case 1 /* I16 */:
                    case 2 /* I32 */: {
                        op = module_1.BinaryOp.LtI32;
                        break;
                    }
                    case 5 /* U8 */:
                    case 6 /* U16 */:
                    case 7 /* U32 */:
                    case 10 /* BOOL */: {
                        op = module_1.BinaryOp.LtU32;
                        break;
                    }
                    case 3 /* I64 */: {
                        op = module_1.BinaryOp.LtI64;
                        break;
                    }
                    case 8 /* U64 */: {
                        op = module_1.BinaryOp.LtU64;
                        break;
                    }
                    case 4 /* ISIZE */: {
                        op = compiler.options.isWasm64
                            ? module_1.BinaryOp.LtI64
                            : module_1.BinaryOp.LtI32;
                        break;
                    }
                    case 9 /* USIZE */: {
                        op = compiler.options.isWasm64
                            ? module_1.BinaryOp.LtU64
                            : module_1.BinaryOp.LtU32;
                        break;
                    }
                    case 11 /* F32 */: return module.binary(module_1.BinaryOp.MinF32, arg0, arg1);
                    case 12 /* F64 */: return module.binary(module_1.BinaryOp.MinF64, arg0, arg1);
                }
                if (op != -1) {
                    let flow = compiler.currentFlow;
                    let nativeType = type.toNativeType();
                    let temp1 = flow.getTempLocal(type);
                    flow.setLocalFlag(temp1.index, flow_1.LocalFlags.WRAPPED);
                    let temp2 = flow.getTempLocal(type);
                    flow.setLocalFlag(temp2.index, flow_1.LocalFlags.WRAPPED);
                    let ret = module.select(module.local_tee(temp1.index, arg0), module.local_tee(temp2.index, arg1), module.binary(op, module.local_get(temp1.index, nativeType), module.local_get(temp2.index, nativeType)));
                    flow.freeTempLocal(temp2);
                    flow.freeTempLocal(temp1);
                    return ret;
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "min", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.ceil: { // ceil<T?>(value: T) -> T
            if (checkTypeOptional(typeArguments, reportNode, compiler, true) |
                checkArgsRequired(operands, 1, reportNode, compiler))
                return module.unreachable();
            let arg0 = typeArguments
                ? compiler.compileExpression(operands[0], typeArguments[0], 1 /* CONV_IMPLICIT */)
                : compiler.compileExpression(operands[0], types_1.Type.auto, 0 /* NONE */);
            let type = compiler.currentType;
            if (!type.is(256 /* REFERENCE */)) {
                switch (type.kind) {
                    case 0 /* I8 */:
                    case 1 /* I16 */:
                    case 2 /* I32 */:
                    case 3 /* I64 */:
                    case 4 /* ISIZE */:
                    case 5 /* U8 */:
                    case 6 /* U16 */:
                    case 7 /* U32 */:
                    case 8 /* U64 */:
                    case 9 /* USIZE */:
                    case 10 /* BOOL */: return arg0; // considered rounded
                    case 11 /* F32 */: return module.unary(module_1.UnaryOp.CeilF32, arg0);
                    case 12 /* F64 */: return module.unary(module_1.UnaryOp.CeilF64, arg0);
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "ceil", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.floor: { // floor<T?>(value: T) -> T
            if (checkTypeOptional(typeArguments, reportNode, compiler, true) |
                checkArgsRequired(operands, 1, reportNode, compiler))
                return module.unreachable();
            let arg0 = typeArguments
                ? compiler.compileExpression(operands[0], typeArguments[0], 1 /* CONV_IMPLICIT */)
                : compiler.compileExpression(operands[0], types_1.Type.auto, 0 /* NONE */);
            let type = compiler.currentType;
            if (!type.is(256 /* REFERENCE */)) {
                switch (type.kind) {
                    case 0 /* I8 */:
                    case 1 /* I16 */:
                    case 2 /* I32 */:
                    case 3 /* I64 */:
                    case 4 /* ISIZE */:
                    case 5 /* U8 */:
                    case 6 /* U16 */:
                    case 7 /* U32 */:
                    case 8 /* U64 */:
                    case 9 /* USIZE */:
                    case 10 /* BOOL */: return arg0; // considered rounded
                    case 11 /* F32 */: return module.unary(module_1.UnaryOp.FloorF32, arg0);
                    case 12 /* F64 */: return module.unary(module_1.UnaryOp.FloorF64, arg0);
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "floor", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.copysign: { // copysign<T?>(left: T, right: T) -> T
            if (checkTypeOptional(typeArguments, reportNode, compiler, true) |
                checkArgsRequired(operands, 2, reportNode, compiler))
                return module.unreachable();
            let arg0 = typeArguments
                ? compiler.compileExpression(operands[0], typeArguments[0], 1 /* CONV_IMPLICIT */)
                : compiler.compileExpression(operands[0], types_1.Type.f64, 0 /* NONE */);
            let type = compiler.currentType;
            if (!type.is(256 /* REFERENCE */)) {
                let arg1 = compiler.compileExpression(operands[1], type, 1 /* CONV_IMPLICIT */);
                switch (type.kind) {
                    // TODO: does an integer version make sense?
                    case 11 /* F32 */: return module.binary(module_1.BinaryOp.CopysignF32, arg0, arg1);
                    case 12 /* F64 */: return module.binary(module_1.BinaryOp.CopysignF64, arg0, arg1);
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "copysign", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.nearest: { // nearest<T?>(value: T) -> T
            if (checkTypeOptional(typeArguments, reportNode, compiler, true) |
                checkArgsRequired(operands, 1, reportNode, compiler))
                return module.unreachable();
            let arg0 = typeArguments
                ? compiler.compileExpression(operands[0], typeArguments[0], 1 /* CONV_IMPLICIT */)
                : compiler.compileExpression(operands[0], types_1.Type.auto, 0 /* NONE */);
            let type = compiler.currentType;
            if (!type.is(256 /* REFERENCE */)) {
                switch (type.kind) {
                    case 0 /* I8 */:
                    case 1 /* I16 */:
                    case 2 /* I32 */:
                    case 3 /* I64 */:
                    case 4 /* ISIZE */:
                    case 5 /* U8 */:
                    case 6 /* U16 */:
                    case 7 /* U32 */:
                    case 8 /* U64 */:
                    case 9 /* USIZE */:
                    case 10 /* BOOL */: return arg0;
                    case 11 /* F32 */: return module.unary(module_1.UnaryOp.NearestF32, arg0);
                    case 12 /* F64 */: return module.unary(module_1.UnaryOp.NearestF64, arg0);
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "nearest", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.reinterpret: { // reinterpret<T!>(value: *) -> T
            if (checkTypeRequired(typeArguments, reportNode, compiler, true) |
                checkArgsRequired(operands, 1, reportNode, compiler))
                return module.unreachable();
            let type = typeArguments[0];
            if (!type.is(256 /* REFERENCE */)) {
                switch (type.kind) {
                    case 2 /* I32 */:
                    case 7 /* U32 */: {
                        let arg0 = compiler.compileExpression(operands[0], types_1.Type.f32, 1 /* CONV_IMPLICIT */);
                        compiler.currentType = type;
                        return module.unary(module_1.UnaryOp.ReinterpretF32, arg0);
                    }
                    case 3 /* I64 */:
                    case 8 /* U64 */: {
                        let arg0 = compiler.compileExpression(operands[0], types_1.Type.f64, 1 /* CONV_IMPLICIT */);
                        compiler.currentType = type;
                        return module.unary(module_1.UnaryOp.ReinterpretF64, arg0);
                    }
                    case 4 /* ISIZE */:
                    case 9 /* USIZE */: {
                        let arg0 = compiler.compileExpression(operands[0], compiler.options.isWasm64
                            ? types_1.Type.f64
                            : types_1.Type.f32, 1 /* CONV_IMPLICIT */);
                        compiler.currentType = type;
                        return module.unary(compiler.options.isWasm64
                            ? module_1.UnaryOp.ReinterpretF64
                            : module_1.UnaryOp.ReinterpretF32, arg0);
                    }
                    case 11 /* F32 */: {
                        let arg0 = compiler.compileExpression(operands[0], types_1.Type.i32, 1 /* CONV_IMPLICIT */);
                        compiler.currentType = types_1.Type.f32;
                        return module.unary(module_1.UnaryOp.ReinterpretI32, arg0);
                    }
                    case 12 /* F64 */: {
                        let arg0 = compiler.compileExpression(operands[0], types_1.Type.i64, 1 /* CONV_IMPLICIT */);
                        compiler.currentType = types_1.Type.f64;
                        return module.unary(module_1.UnaryOp.ReinterpretI64, arg0);
                    }
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "reinterpret", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.sqrt: { // sqrt<T?>(value: T) -> T
            if (checkTypeOptional(typeArguments, reportNode, compiler, true) |
                checkArgsRequired(operands, 1, reportNode, compiler))
                return module.unreachable();
            let arg0 = typeArguments
                ? compiler.compileExpression(operands[0], typeArguments[0], 1 /* CONV_IMPLICIT */)
                : compiler.compileExpression(operands[0], types_1.Type.f64, 0 /* NONE */);
            let type = compiler.currentType;
            if (!type.is(256 /* REFERENCE */)) {
                switch (type.kind) {
                    // TODO: integer versions (that return f64 or convert)?
                    case 11 /* F32 */: return module.unary(module_1.UnaryOp.SqrtF32, arg0);
                    case 12 /* F64 */: return module.unary(module_1.UnaryOp.SqrtF64, arg0);
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "sqrt", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.trunc: { // trunc<T?>(value: T) -> T
            if (checkTypeOptional(typeArguments, reportNode, compiler, true) |
                checkArgsRequired(operands, 1, reportNode, compiler))
                return module.unreachable();
            let arg0 = typeArguments
                ? compiler.compileExpression(operands[0], typeArguments[0], 1 /* CONV_IMPLICIT */)
                : compiler.compileExpression(operands[0], types_1.Type.auto, 0 /* NONE */);
            let type = compiler.currentType;
            if (!type.is(256 /* REFERENCE */)) {
                switch (type.kind) {
                    case 0 /* I8 */:
                    case 1 /* I16 */:
                    case 2 /* I32 */:
                    case 3 /* I64 */:
                    case 4 /* ISIZE */:
                    case 5 /* U8 */:
                    case 6 /* U16 */:
                    case 7 /* U32 */:
                    case 8 /* U64 */:
                    case 9 /* USIZE */:
                    case 10 /* BOOL */: return arg0; // considered truncated
                    case 11 /* F32 */: return module.unary(module_1.UnaryOp.TruncF32, arg0);
                    case 12 /* F64 */: return module.unary(module_1.UnaryOp.TruncF64, arg0);
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "trunc", type.toString());
            return module.unreachable();
        }
        // === Memory access ==========================================================================
        case BuiltinSymbols.load: { // load<T!>(offset: usize, immOffset?: usize, immAlign?: usize) -> T*
            if (checkTypeRequired(typeArguments, reportNode, compiler, true) |
                checkArgsOptional(operands, 1, 3, reportNode, compiler))
                return module.unreachable();
            let type = typeArguments[0];
            let outType = (contextualType != types_1.Type.auto &&
                type.is(4 /* INTEGER */) &&
                contextualType.is(4 /* INTEGER */) &&
                contextualType.size > type.size) ? contextualType : type;
            let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, 1 /* CONV_IMPLICIT */);
            let numOperands = operands.length;
            let immOffset = numOperands >= 2 ? evaluateImmediateOffset(operands[1], compiler) : 0; // reports
            if (immOffset < 0) {
                compiler.currentType = outType;
                return module.unreachable();
            }
            let immAlign;
            let naturalAlign = type.byteSize;
            if (numOperands == 3) {
                immAlign = evaluateImmediateOffset(operands[2], compiler);
                if (immAlign < 0) {
                    compiler.currentType = outType;
                    return module.unreachable();
                }
                if (immAlign > naturalAlign) {
                    compiler.error(diagnostics_1.DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive, operands[2].range, "Alignment", "0", naturalAlign.toString());
                    compiler.currentType = outType;
                    return module.unreachable();
                }
                if (!util_1.isPowerOf2(immAlign)) {
                    compiler.error(diagnostics_1.DiagnosticCode._0_must_be_a_power_of_two, operands[2].range, "Alignment");
                    compiler.currentType = outType;
                    return module.unreachable();
                }
            }
            else {
                immAlign = naturalAlign;
            }
            compiler.currentType = outType;
            return module.load(type.byteSize, type.is(1 /* SIGNED */ | 4 /* INTEGER */), arg0, outType.toNativeType(), immOffset, immAlign);
        }
        case BuiltinSymbols.store: { // store<T!>(offset: usize, value: T*, offset?: usize, align?: usize) -> void
            compiler.currentType = types_1.Type.void;
            if (checkTypeRequired(typeArguments, reportNode, compiler) |
                checkArgsOptional(operands, 2, 4, reportNode, compiler))
                return module.unreachable();
            let type = typeArguments[0];
            let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, 1 /* CONV_IMPLICIT */);
            let arg1 = isAsm
                ? compiler.compileExpression(operands[1], contextualType, 1 /* CONV_IMPLICIT */)
                : compiler.compileExpression(operands[1], type, type.is(4 /* INTEGER */)
                    ? 0 /* NONE */
                    : 1 /* CONV_IMPLICIT */);
            let inType = compiler.currentType;
            if (type.is(4 /* INTEGER */) &&
                (!inType.is(4 /* INTEGER */) || // float to int
                    inType.size < type.size // int to larger int (clear garbage bits)
                )) {
                arg1 = compiler.convertExpression(arg1, inType, type, false, false, // still clears garbage bits when not wrapping
                operands[1]);
                inType = type;
            }
            let immOffset = operands.length >= 3 ? evaluateImmediateOffset(operands[2], compiler) : 0; // reports
            if (immOffset < 0) {
                compiler.currentType = types_1.Type.void;
                return module.unreachable();
            }
            let immAlign;
            let naturalAlign = type.byteSize;
            if (operands.length == 4) {
                immAlign = evaluateImmediateOffset(operands[3], compiler);
                if (immAlign < 0) {
                    compiler.currentType = types_1.Type.void;
                    return module.unreachable();
                }
                if (immAlign > naturalAlign) {
                    compiler.error(diagnostics_1.DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive, operands[3].range, "Alignment", "0", naturalAlign.toString());
                    compiler.currentType = types_1.Type.void;
                    return module.unreachable();
                }
                if (!util_1.isPowerOf2(immAlign)) {
                    compiler.error(diagnostics_1.DiagnosticCode._0_must_be_a_power_of_two, operands[3].range, "Alignment");
                    compiler.currentType = types_1.Type.void;
                    return module.unreachable();
                }
            }
            else {
                immAlign = naturalAlign;
            }
            compiler.currentType = types_1.Type.void;
            return module.store(type.byteSize, arg0, arg1, inType.toNativeType(), immOffset, immAlign);
        }
        // === Atomics ================================================================================
        case BuiltinSymbols.atomic_load: { // load<T!>(offset: usize, immOffset?: usize) -> T*
            if (checkFeatureEnabled(32 /* THREADS */, reportNode, compiler) |
                checkTypeRequired(typeArguments, reportNode, compiler, true) |
                checkArgsOptional(operands, 1, 2, reportNode, compiler))
                return module.unreachable();
            let type = typeArguments[0];
            let outType = (type.is(4 /* INTEGER */) &&
                contextualType.is(4 /* INTEGER */) &&
                contextualType.size > type.size) ? contextualType : type;
            if (!type.is(4 /* INTEGER */)) {
                compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "atomic.load", type.toString());
                compiler.currentType = outType;
                return module.unreachable();
            }
            let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, 1 /* CONV_IMPLICIT */);
            let immOffset = operands.length == 2 ? evaluateImmediateOffset(operands[1], compiler) : 0; // reports
            if (immOffset < 0) {
                compiler.currentType = outType;
                return module.unreachable();
            }
            compiler.currentType = outType;
            return module.atomic_load(type.byteSize, arg0, outType.toNativeType(), immOffset);
        }
        case BuiltinSymbols.atomic_store: { // store<T!>(offset: usize, value: T*, immOffset?: usize) -> void
            if (checkFeatureEnabled(32 /* THREADS */, reportNode, compiler) |
                checkTypeRequired(typeArguments, reportNode, compiler) |
                checkArgsOptional(operands, 2, 3, reportNode, compiler))
                return module.unreachable();
            let type = typeArguments[0];
            if (!type.is(4 /* INTEGER */)) {
                compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "atomic.store", type.toString());
                compiler.currentType = types_1.Type.void;
                return module.unreachable();
            }
            let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, 1 /* CONV_IMPLICIT */);
            let arg1 = isAsm
                ? compiler.compileExpression(operands[1], contextualType, 1 /* CONV_IMPLICIT */)
                : compiler.compileExpression(operands[1], type, type.is(4 /* INTEGER */)
                    ? 0 /* NONE */
                    : 1 /* CONV_IMPLICIT */);
            let inType = compiler.currentType;
            if (type.is(4 /* INTEGER */) &&
                (!inType.is(4 /* INTEGER */) || // float to int
                    inType.size < type.size // int to larger int (clear garbage bits)
                )) {
                arg1 = compiler.convertExpression(arg1, inType, type, false, false, // still clears garbage bits when not wrapping
                operands[1]);
                inType = type;
            }
            let immOffset = operands.length == 3 ? evaluateImmediateOffset(operands[2], compiler) : 0; // reports
            if (immOffset < 0) {
                compiler.currentType = types_1.Type.void;
                return module.unreachable();
            }
            compiler.currentType = types_1.Type.void;
            return module.atomic_store(type.byteSize, arg0, arg1, inType.toNativeType(), immOffset);
        }
        case BuiltinSymbols.atomic_add: // any_atomic_binary<T!>(ptr, value: T, immOffset?: usize) -> T
        case BuiltinSymbols.atomic_sub:
        case BuiltinSymbols.atomic_and:
        case BuiltinSymbols.atomic_or:
        case BuiltinSymbols.atomic_xor:
        case BuiltinSymbols.atomic_xchg: {
            if (checkFeatureEnabled(32 /* THREADS */, reportNode, compiler) |
                checkTypeRequired(typeArguments, reportNode, compiler, true) |
                checkArgsOptional(operands, 2, 3, reportNode, compiler))
                return module.unreachable();
            let type = typeArguments[0];
            if (!type.is(4 /* INTEGER */) || type.size < 8) {
                let opName;
                switch (prototype.internalName) {
                    default: assert(false);
                    case BuiltinSymbols.atomic_add: {
                        opName = "atomic.add";
                        break;
                    }
                    case BuiltinSymbols.atomic_sub: {
                        opName = "atomic.sub";
                        break;
                    }
                    case BuiltinSymbols.atomic_and: {
                        opName = "atomic.and";
                        break;
                    }
                    case BuiltinSymbols.atomic_or: {
                        opName = "atomic.or";
                        break;
                    }
                    case BuiltinSymbols.atomic_xor: {
                        opName = "atomic.xor";
                        break;
                    }
                    case BuiltinSymbols.atomic_xchg: {
                        opName = "atomic.xchg";
                        break;
                    }
                }
                compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, opName, type.toString());
                return module.unreachable();
            }
            let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, 1 /* CONV_IMPLICIT */);
            let arg1 = isAsm
                ? compiler.compileExpression(operands[1], contextualType, 1 /* CONV_IMPLICIT */)
                : compiler.compileExpression(operands[1], type, type.is(4 /* INTEGER */)
                    ? 0 /* NONE */
                    : 1 /* CONV_IMPLICIT */);
            let inType = compiler.currentType;
            if (type.is(4 /* INTEGER */) &&
                (!inType.is(4 /* INTEGER */) || // float to int
                    inType.size < type.size // int to larger int (clear garbage bits)
                )) {
                arg1 = compiler.convertExpression(arg1, inType, type, false, false, // still clears garbage bits when not wrapping
                operands[1]);
                inType = type;
            }
            let immOffset = operands.length == 3 ? evaluateImmediateOffset(operands[2], compiler) : 0; // reports
            if (immOffset < 0) {
                compiler.currentType = inType;
                return module.unreachable();
            }
            let op;
            switch (prototype.internalName) {
                default: assert(false);
                case BuiltinSymbols.atomic_add: {
                    op = module_1.AtomicRMWOp.Add;
                    break;
                }
                case BuiltinSymbols.atomic_sub: {
                    op = module_1.AtomicRMWOp.Sub;
                    break;
                }
                case BuiltinSymbols.atomic_and: {
                    op = module_1.AtomicRMWOp.And;
                    break;
                }
                case BuiltinSymbols.atomic_or: {
                    op = module_1.AtomicRMWOp.Or;
                    break;
                }
                case BuiltinSymbols.atomic_xor: {
                    op = module_1.AtomicRMWOp.Xor;
                    break;
                }
                case BuiltinSymbols.atomic_xchg: {
                    op = module_1.AtomicRMWOp.Xchg;
                    break;
                }
            }
            compiler.currentType = inType;
            return module.atomic_rmw(op, type.byteSize, immOffset, arg0, arg1, inType.toNativeType());
        }
        case BuiltinSymbols.atomic_cmpxchg: { // cmpxchg<T!>(ptr: usize, expected: T, replacement: T, off?: usize) -> T
            if (checkFeatureEnabled(32 /* THREADS */, reportNode, compiler) |
                checkTypeRequired(typeArguments, reportNode, compiler, true) |
                checkArgsOptional(operands, 3, 4, reportNode, compiler))
                return module.unreachable();
            let type = typeArguments[0];
            if (!type.is(4 /* INTEGER */) || type.size < 8) {
                compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "atomic.cmpxchg", type.toString());
                return module.unreachable();
            }
            let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, 1 /* CONV_IMPLICIT */);
            let arg1 = isAsm
                ? compiler.compileExpression(operands[1], contextualType, 1 /* CONV_IMPLICIT */)
                : compiler.compileExpression(operands[1], type, type.is(4 /* INTEGER */)
                    ? 0 /* NONE */
                    : 1 /* CONV_IMPLICIT */);
            let inType = compiler.currentType;
            let arg2 = compiler.compileExpression(operands[2], inType, 1 /* CONV_IMPLICIT */);
            if (type.is(4 /* INTEGER */) &&
                (!inType.is(4 /* INTEGER */) || // float to int
                    inType.size < type.size // int to larger int (clear garbage bits)
                )) {
                arg1 = compiler.convertExpression(arg1, inType, type, false, false, // still clears garbage bits when not wrapping
                operands[1]);
                arg2 = compiler.convertExpression(arg2, inType, type, false, false, // still clears garbage bits when not wrapping
                operands[2]);
                inType = type;
            }
            let immOffset = operands.length == 4 ? evaluateImmediateOffset(operands[3], compiler) : 0; // reports
            if (immOffset < 0) {
                compiler.currentType = inType;
                return module.unreachable();
            }
            compiler.currentType = inType;
            return module.atomic_cmpxchg(type.byteSize, immOffset, arg0, arg1, arg2, inType.toNativeType());
        }
        case BuiltinSymbols.atomic_wait: { // wait<T!>(ptr: usize, expected: T, timeout: i64) -> i32
            if (checkFeatureEnabled(32 /* THREADS */, reportNode, compiler) |
                checkTypeRequired(typeArguments, reportNode, compiler) |
                checkArgsRequired(operands, 3, reportNode, compiler)) {
                compiler.currentType = types_1.Type.i32;
                return module.unreachable();
            }
            let type = typeArguments[0];
            let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, 1 /* CONV_IMPLICIT */);
            let arg1 = compiler.compileExpression(operands[1], type, 1 /* CONV_IMPLICIT */);
            let arg2 = compiler.compileExpression(operands[2], types_1.Type.i64, 1 /* CONV_IMPLICIT */);
            compiler.currentType = types_1.Type.i32;
            switch (type.kind) {
                case 2 /* I32 */:
                case 3 /* I64 */:
                case 4 /* ISIZE */:
                case 7 /* U32 */:
                case 8 /* U64 */:
                case 9 /* USIZE */: return module.atomic_wait(arg0, arg1, arg2, type.toNativeType());
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "atomic.wait", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.atomic_notify: { // notify(ptr: usize, count: i32) -> i32
            if (checkFeatureEnabled(32 /* THREADS */, reportNode, compiler) |
                checkTypeAbsent(typeArguments, reportNode, prototype) |
                checkArgsRequired(operands, 2, reportNode, compiler)) {
                compiler.currentType = types_1.Type.i32;
                return module.unreachable();
            }
            let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, 1 /* CONV_IMPLICIT */);
            let arg1 = compiler.compileExpression(operands[1], types_1.Type.i32, 1 /* CONV_IMPLICIT */);
            compiler.currentType = types_1.Type.i32;
            return module.atomic_notify(arg0, arg1);
        }
        case BuiltinSymbols.atomic_fence: { // fence() -> void
            compiler.currentType = types_1.Type.void;
            if (checkFeatureEnabled(32 /* THREADS */, reportNode, compiler) |
                checkTypeAbsent(typeArguments, reportNode, prototype) |
                checkArgsRequired(operands, 0, reportNode, compiler))
                return module.unreachable();
            return module.atomic_fence();
        }
        // === Control flow ===========================================================================
        case BuiltinSymbols.select: { // select<T?>(ifTrue: T, ifFalse: T, condition: bool) -> T
            if (checkTypeOptional(typeArguments, reportNode, compiler, true) |
                checkArgsRequired(operands, 3, reportNode, compiler))
                return module.unreachable();
            let arg0 = typeArguments
                ? compiler.compileExpression(operands[0], typeArguments[0], 1 /* CONV_IMPLICIT */)
                : compiler.compileExpression(operands[0], types_1.Type.auto);
            let type = compiler.currentType;
            if (!type.isAny(128 /* VALUE */ | 256 /* REFERENCE */)) {
                compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "select", type.toString());
                return module.unreachable();
            }
            let arg1 = compiler.compileExpression(operands[1], type, 1 /* CONV_IMPLICIT */);
            let arg2 = compiler.makeIsTrueish(compiler.compileExpression(operands[2], types_1.Type.bool), compiler.currentType // ^
            );
            compiler.currentType = type;
            return module.select(arg0, arg1, arg2);
        }
        case BuiltinSymbols.unreachable: { // unreachable() -> *
            if (typeArguments) {
                compiler.error(diagnostics_1.DiagnosticCode.Type_0_is_not_generic, reportNode.typeArgumentsRange, prototype.internalName);
            }
            checkArgsRequired(operands, 0, reportNode, compiler);
            return module.unreachable();
        }
        // === Memory =================================================================================
        case BuiltinSymbols.memory_size: { // memory.size() -> i32
            compiler.currentType = types_1.Type.i32;
            if (checkTypeAbsent(typeArguments, reportNode, prototype) |
                checkArgsRequired(operands, 0, reportNode, compiler))
                return module.unreachable();
            return module.host(module_1.HostOp.MemorySize);
        }
        case BuiltinSymbols.memory_grow: { // memory.grow(pages: i32) -> i32
            compiler.currentType = types_1.Type.i32;
            if (checkTypeAbsent(typeArguments, reportNode, prototype) |
                checkArgsRequired(operands, 1, reportNode, compiler))
                return module.unreachable();
            return module.host(module_1.HostOp.MemoryGrow, null, [
                compiler.compileExpression(operands[0], types_1.Type.i32, 1 /* CONV_IMPLICIT */)
            ]);
        }
        case BuiltinSymbols.memory_copy: { // memory.copy(dest: usize, src: usize: n: usize) -> void
            compiler.currentType = types_1.Type.void;
            if (checkTypeAbsent(typeArguments, reportNode, prototype) |
                checkArgsRequired(operands, 3, reportNode, compiler))
                return module.unreachable();
            if (!compiler.options.hasFeature(8 /* BULK_MEMORY */)) {
                let instance = compiler.resolver.resolveFunction(prototype, null); // reports
                compiler.currentType = types_1.Type.void;
                if (!instance)
                    return module.unreachable();
                return compiler.compileCallDirect(instance, operands, reportNode);
            }
            let usizeType = compiler.options.usizeType;
            let arg0 = compiler.compileExpression(operands[0], usizeType, 1 /* CONV_IMPLICIT */);
            let arg1 = compiler.compileExpression(operands[1], usizeType, 1 /* CONV_IMPLICIT */);
            let arg2 = compiler.compileExpression(operands[2], usizeType, 1 /* CONV_IMPLICIT */);
            compiler.currentType = types_1.Type.void;
            return module.memory_copy(arg0, arg1, arg2);
        }
        case BuiltinSymbols.memory_fill: { // memory.fill(dest: usize, value: u8, n: usize) -> void
            compiler.currentType = types_1.Type.void;
            if (checkTypeAbsent(typeArguments, reportNode, prototype) |
                checkArgsRequired(operands, 3, reportNode, compiler))
                return module.unreachable();
            if (!compiler.options.hasFeature(8 /* BULK_MEMORY */)) {
                let instance = compiler.resolver.resolveFunction(prototype, null); // reports
                compiler.currentType = types_1.Type.void;
                if (!instance)
                    return module.unreachable();
                return compiler.compileCallDirect(instance, operands, reportNode);
            }
            let usizeType = compiler.options.usizeType;
            let arg0 = compiler.compileExpression(operands[0], usizeType, 1 /* CONV_IMPLICIT */);
            let arg1 = compiler.compileExpression(operands[1], types_1.Type.u8, 1 /* CONV_IMPLICIT */);
            let arg2 = compiler.compileExpression(operands[2], usizeType, 1 /* CONV_IMPLICIT */);
            compiler.currentType = types_1.Type.void;
            return module.memory_fill(arg0, arg1, arg2);
        }
        // === Helpers ================================================================================
        case BuiltinSymbols.changetype: { // changetype<T!>(value: *) -> T
            if (checkTypeRequired(typeArguments, reportNode, compiler, true) |
                checkArgsRequired(operands, 1, reportNode, compiler))
                return module.unreachable();
            let toType = typeArguments[0];
            let arg0 = compiler.compileExpression(operands[0], types_1.Type.auto);
            let fromType = compiler.currentType;
            compiler.currentType = toType;
            if (!fromType.isChangeableTo(toType)) {
                compiler.error(diagnostics_1.DiagnosticCode.Type_0_cannot_be_changed_to_type_1, reportNode.range, fromType.toString(), toType.toString());
                return module.unreachable();
            }
            return arg0;
        }
        case BuiltinSymbols.assert: { // assert<T?>(isTrueish: T, message?: string) -> T{!= null}
            if (checkTypeOptional(typeArguments, reportNode, compiler) |
                checkArgsOptional(operands, 1, 2, reportNode, compiler)) {
                if (typeArguments) {
                    assert(typeArguments.length); // otherwise invalid, should not been set at all
                    compiler.currentType = typeArguments[0].nonNullableType;
                }
                return module.unreachable();
            }
            let arg0 = typeArguments
                ? compiler.compileExpression(operands[0], typeArguments[0], 1 /* CONV_IMPLICIT */ | 4 /* MUST_WRAP */)
                : compiler.compileExpression(operands[0], types_1.Type.bool, 4 /* MUST_WRAP */);
            let type = compiler.currentType;
            compiler.currentType = type.nonNullableType;
            // if the assertion can be proven statically, omit it
            if (module_1.getExpressionId(arg0 = module.precomputeExpression(arg0)) == module_1.ExpressionId.Const) {
                switch (module_1.getExpressionType(arg0)) {
                    case module_1.NativeType.I32: {
                        if (module_1.getConstValueI32(arg0) != 0) {
                            if (contextualType == types_1.Type.void) {
                                compiler.currentType = types_1.Type.void;
                                return module.nop();
                            }
                            return arg0;
                        }
                        break;
                    }
                    case module_1.NativeType.I64: {
                        if (module_1.getConstValueI64Low(arg0) != 0 || module_1.getConstValueI64High(arg0) != 0) {
                            if (contextualType == types_1.Type.void) {
                                compiler.currentType = types_1.Type.void;
                                return module.nop();
                            }
                            return arg0;
                        }
                        break;
                    }
                    case module_1.NativeType.F32: {
                        if (module_1.getConstValueF32(arg0) != 0) {
                            if (contextualType == types_1.Type.void) {
                                compiler.currentType = types_1.Type.void;
                                return module.nop();
                            }
                            return arg0;
                        }
                        break;
                    }
                    case module_1.NativeType.F64: {
                        if (module_1.getConstValueF64(arg0) != 0) {
                            if (contextualType == types_1.Type.void) {
                                compiler.currentType = types_1.Type.void;
                                return module.nop();
                            }
                            return arg0;
                        }
                        break;
                    }
                }
            }
            // return ifTrueish if assertions are disabled
            if (compiler.options.noAssert) {
                if (contextualType == types_1.Type.void) { // simplify if dropped anyway
                    compiler.currentType = types_1.Type.void;
                    return module.nop();
                }
                return arg0;
            }
            // otherwise call abort if the assertion is false-ish
            let abort = compileAbort(compiler, operands.length == 2 ? operands[1] : null, reportNode);
            compiler.currentType = type.nonNullableType;
            if (contextualType == types_1.Type.void) { // simplify if dropped anyway
                compiler.currentType = types_1.Type.void;
                switch (type.kind) {
                    case 0 /* I8 */:
                    case 1 /* I16 */:
                    case 2 /* I32 */:
                    case 5 /* U8 */:
                    case 6 /* U16 */:
                    case 7 /* U32 */:
                    case 10 /* BOOL */: return module.if(module.unary(module_1.UnaryOp.EqzI32, arg0), abort);
                    case 3 /* I64 */:
                    case 8 /* U64 */: return module.if(module.unary(module_1.UnaryOp.EqzI64, arg0), abort);
                    case 4 /* ISIZE */:
                    case 9 /* USIZE */: {
                        return module.if(module.unary(compiler.options.isWasm64
                            ? module_1.UnaryOp.EqzI64
                            : module_1.UnaryOp.EqzI32, arg0), abort);
                    }
                    // TODO: also check for NaN in float assertions, as in `Boolean(NaN) -> false`?
                    case 11 /* F32 */: return module.if(module.binary(module_1.BinaryOp.EqF32, arg0, module.f32(0)), abort);
                    case 12 /* F64 */: return module.if(module.binary(module_1.BinaryOp.EqF64, arg0, module.f64(0)), abort);
                }
            }
            else {
                compiler.currentType = type.nonNullableType;
                let flow = compiler.currentFlow;
                switch (compiler.currentType.kind) {
                    case 0 /* I8 */:
                    case 1 /* I16 */:
                    case 2 /* I32 */:
                    case 5 /* U8 */:
                    case 6 /* U16 */:
                    case 7 /* U32 */:
                    case 10 /* BOOL */: {
                        let temp = flow.getTempLocal(type);
                        flow.setLocalFlag(temp.index, flow_1.LocalFlags.WRAPPED); // arg0 is wrapped
                        let ret = module.if(module.local_tee(temp.index, arg0), module.local_get(temp.index, module_1.NativeType.I32), abort);
                        flow.freeTempLocal(temp);
                        return ret;
                    }
                    case 3 /* I64 */:
                    case 8 /* U64 */: {
                        let temp = flow.getTempLocal(types_1.Type.i64);
                        let ret = module.if(module.unary(module_1.UnaryOp.EqzI64, module.local_tee(temp.index, arg0)), abort, module.local_get(temp.index, module_1.NativeType.I64));
                        flow.freeTempLocal(temp);
                        return ret;
                    }
                    case 4 /* ISIZE */:
                    case 9 /* USIZE */: {
                        let temp = flow.getTempLocal(compiler.options.usizeType);
                        let ret = module.if(module.unary(compiler.options.isWasm64
                            ? module_1.UnaryOp.EqzI64
                            : module_1.UnaryOp.EqzI32, module.local_tee(temp.index, arg0)), abort, module.local_get(temp.index, compiler.options.nativeSizeType));
                        flow.freeTempLocal(temp);
                        return ret;
                    }
                    case 11 /* F32 */: {
                        let temp = flow.getTempLocal(types_1.Type.f32);
                        let ret = module.if(module.binary(module_1.BinaryOp.EqF32, module.local_tee(temp.index, arg0), module.f32(0)), abort, module.local_get(temp.index, module_1.NativeType.F32));
                        flow.freeTempLocal(temp);
                        return ret;
                    }
                    case 12 /* F64 */: {
                        let temp = flow.getTempLocal(types_1.Type.f64);
                        let ret = module.if(module.binary(module_1.BinaryOp.EqF64, module.local_tee(temp.index, arg0), module.f64(0)), abort, module.local_get(temp.index, module_1.NativeType.F64));
                        flow.freeTempLocal(temp);
                        return ret;
                    }
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Not_implemented, reportNode.typeArgumentsRange);
            return abort;
        }
        case BuiltinSymbols.unchecked: { // unchecked(expr: *) -> *
            if (checkTypeAbsent(typeArguments, reportNode, prototype) |
                checkArgsRequired(operands, 1, reportNode, compiler))
                return module.unreachable();
            let flow = compiler.currentFlow;
            let alreadyUnchecked = flow.is(65536 /* UNCHECKED_CONTEXT */);
            flow.set(65536 /* UNCHECKED_CONTEXT */);
            // eliminate unnecessary tees by preferring contextualType(=void)
            let expr = compiler.compileExpression(operands[0], contextualType);
            if (!alreadyUnchecked)
                flow.unset(65536 /* UNCHECKED_CONTEXT */);
            return expr;
        }
        case BuiltinSymbols.call_direct:
        case BuiltinSymbols.call_indirect: { // call_indirect<T?>(target: Function | u32, ...args: *[]) -> T
            if (checkTypeOptional(typeArguments, reportNode, compiler, true) |
                checkArgsOptional(operands, 1, i32.MAX_VALUE, reportNode, compiler))
                return module.unreachable();
            let returnType = typeArguments ? typeArguments[0] : contextualType;
            let arg0 = compiler.compileExpression(operands[0], types_1.Type.u32);
            let arg0Type = compiler.currentType;
            if (!(arg0Type == types_1.Type.u32 || // either plain index
                arg0Type.kind == 7 /* U32 */ && arg0Type.signatureReference // or function reference
            )) {
                compiler.error(diagnostics_1.DiagnosticCode.Type_0_is_not_a_function_index_or_function_reference, operands[0].range, arg0Type.toString());
                return module.unreachable();
            }
            let numOperands = operands.length - 1;
            let operandExprs = new Array(numOperands);
            let nativeReturnType = returnType.toNativeType();
            let parameterTypes = new Array(numOperands);
            let nativeParamTypes = new Array(numOperands);
            for (let i = 0; i < numOperands; ++i) {
                operandExprs[i] = compiler.compileExpression(operands[1 + i], types_1.Type.i32);
                let operandType = compiler.currentType;
                parameterTypes[i] = operandType;
                nativeParamTypes[i] = operandType.toNativeType();
            }
            let typeName = types_1.Signature.makeSignatureString(parameterTypes, returnType);
            let typeRef = module.getFunctionTypeBySignature(nativeReturnType, nativeParamTypes);
            if (!typeRef)
                typeRef = module.addFunctionType(typeName, nativeReturnType, nativeParamTypes);
            compiler.currentType = returnType;
            if (prototype.internalName == BuiltinSymbols.call_direct) {
                // if the index expression is precomputable to a constant value, emit a direct call
                if (module_1.getExpressionId(arg0 = module.precomputeExpression(arg0)) == module_1.ExpressionId.Const) {
                    assert(module_1.getExpressionType(arg0) == module_1.NativeType.I32);
                    let index = module_1.getConstValueI32(arg0);
                    let functionTable = compiler.functionTable;
                    if (index >= 0 && index < functionTable.length) {
                        return module.call(functionTable[index], operandExprs, nativeReturnType);
                    }
                }
                compiler.error(diagnostics_1.DiagnosticCode.Expression_must_be_a_compile_time_constant, operands[0].range);
                return module.unreachable();
            }
            // of course this can easily result in a 'RuntimeError: function signature mismatch' trap and
            // thus must be used with care. it exists because it *might* be useful in specific scenarios.
            return module.call_indirect(arg0, operandExprs, typeName);
        }
        case BuiltinSymbols.instantiate: { // instantiate<T!>(...args: *[]) -> T
            if (checkTypeRequired(typeArguments, reportNode, compiler, true))
                return module.unreachable();
            let typeArgument = typeArguments[0];
            let classInstance = typeArgument.classReference;
            if (!(typeArgument.is(256 /* REFERENCE */) && classInstance !== null)) {
                compiler.error(diagnostics_1.DiagnosticCode.This_expression_is_not_constructable, reportNode.expression.range);
                return module.unreachable();
            }
            compiler.currentType = classInstance.type;
            return compiler.compileInstantiate(classInstance, operands, 0 /* NONE */, reportNode);
        }
        // === User-defined diagnostics ===============================================================
        case BuiltinSymbols.ERROR: {
            checkTypeAbsent(typeArguments, reportNode, prototype);
            compiler.error(diagnostics_1.DiagnosticCode.User_defined_0, reportNode.range, (operands.length ? operands[0] : reportNode).range.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.WARNING: {
            checkTypeAbsent(typeArguments, reportNode, prototype);
            compiler.warning(diagnostics_1.DiagnosticCode.User_defined_0, reportNode.range, (operands.length ? operands[0] : reportNode).range.toString());
            return module.nop();
        }
        case BuiltinSymbols.INFO: {
            checkTypeAbsent(typeArguments, reportNode, prototype);
            compiler.info(diagnostics_1.DiagnosticCode.User_defined_0, reportNode.range, (operands.length ? operands[0] : reportNode).range.toString());
            return module.nop();
        }
        // === Portable type conversions ==============================================================
        case BuiltinSymbols.i8: {
            if (checkTypeAbsent(typeArguments, reportNode, prototype) |
                checkArgsRequired(operands, 1, reportNode, compiler)) {
                compiler.currentType = types_1.Type.i8;
                return module.unreachable();
            }
            return compiler.compileExpression(operands[0], types_1.Type.i8, 2 /* CONV_EXPLICIT */);
        }
        case BuiltinSymbols.i16: {
            if (checkTypeAbsent(typeArguments, reportNode, prototype) |
                checkArgsRequired(operands, 1, reportNode, compiler)) {
                compiler.currentType = types_1.Type.i16;
                return module.unreachable();
            }
            return compiler.compileExpression(operands[0], types_1.Type.i16, 2 /* CONV_EXPLICIT */);
        }
        case BuiltinSymbols.i32: {
            if (checkTypeAbsent(typeArguments, reportNode, prototype) |
                checkArgsRequired(operands, 1, reportNode, compiler)) {
                compiler.currentType = types_1.Type.i32;
                return module.unreachable();
            }
            return compiler.compileExpression(operands[0], types_1.Type.i32, 2 /* CONV_EXPLICIT */);
        }
        case BuiltinSymbols.i64: {
            if (checkTypeAbsent(typeArguments, reportNode, prototype) |
                checkArgsRequired(operands, 1, reportNode, compiler)) {
                compiler.currentType = types_1.Type.i64;
                return module.unreachable();
            }
            return compiler.compileExpression(operands[0], types_1.Type.i64, 2 /* CONV_EXPLICIT */);
        }
        case BuiltinSymbols.isize: {
            let isizeType = compiler.options.isizeType;
            if (checkTypeAbsent(typeArguments, reportNode, prototype) |
                checkArgsRequired(operands, 1, reportNode, compiler)) {
                compiler.currentType = isizeType;
                return module.unreachable();
            }
            return compiler.compileExpression(operands[0], isizeType, 2 /* CONV_EXPLICIT */);
        }
        case BuiltinSymbols.u8: {
            if (checkTypeAbsent(typeArguments, reportNode, prototype) |
                checkArgsRequired(operands, 1, reportNode, compiler)) {
                compiler.currentType = types_1.Type.u8;
                return module.unreachable();
            }
            return compiler.compileExpression(operands[0], types_1.Type.u8, 2 /* CONV_EXPLICIT */);
        }
        case BuiltinSymbols.u16: {
            if (checkTypeAbsent(typeArguments, reportNode, prototype) |
                checkArgsRequired(operands, 1, reportNode, compiler)) {
                compiler.currentType = types_1.Type.u16;
                return module.unreachable();
            }
            return compiler.compileExpression(operands[0], types_1.Type.u16, 2 /* CONV_EXPLICIT */);
        }
        case BuiltinSymbols.u32: {
            if (checkTypeAbsent(typeArguments, reportNode, prototype) |
                checkArgsRequired(operands, 1, reportNode, compiler)) {
                compiler.currentType = types_1.Type.u32;
                return module.unreachable();
            }
            return compiler.compileExpression(operands[0], types_1.Type.u32, 2 /* CONV_EXPLICIT */);
        }
        case BuiltinSymbols.u64: {
            if (checkTypeAbsent(typeArguments, reportNode, prototype) |
                checkArgsRequired(operands, 1, reportNode, compiler)) {
                compiler.currentType = types_1.Type.u64;
                return module.unreachable();
            }
            return compiler.compileExpression(operands[0], types_1.Type.u64, 2 /* CONV_EXPLICIT */);
        }
        case BuiltinSymbols.usize: {
            let usizeType = compiler.options.usizeType;
            if (checkTypeAbsent(typeArguments, reportNode, prototype) |
                checkArgsRequired(operands, 1, reportNode, compiler)) {
                compiler.currentType = usizeType;
                return module.unreachable();
            }
            return compiler.compileExpression(operands[0], usizeType, 2 /* CONV_EXPLICIT */);
        }
        case BuiltinSymbols.bool: {
            if (checkTypeAbsent(typeArguments, reportNode, prototype) |
                checkArgsRequired(operands, 1, reportNode, compiler)) {
                compiler.currentType = types_1.Type.bool;
                return module.unreachable();
            }
            return compiler.compileExpression(operands[0], types_1.Type.bool, 2 /* CONV_EXPLICIT */);
        }
        case BuiltinSymbols.f32: {
            if (checkTypeAbsent(typeArguments, reportNode, prototype) |
                checkArgsRequired(operands, 1, reportNode, compiler)) {
                compiler.currentType = types_1.Type.f32;
                return module.unreachable();
            }
            return compiler.compileExpression(operands[0], types_1.Type.f32, 2 /* CONV_EXPLICIT */);
        }
        case BuiltinSymbols.f64: {
            if (checkTypeAbsent(typeArguments, reportNode, prototype) |
                checkArgsRequired(operands, 1, reportNode, compiler)) {
                compiler.currentType = types_1.Type.f64;
                return module.unreachable();
            }
            return compiler.compileExpression(operands[0], types_1.Type.f64, 2 /* CONV_EXPLICIT */);
        }
        // === SIMD ===================================================================================
        case BuiltinSymbols.v128: // alias for now
        case BuiltinSymbols.i8x16: {
            if (checkFeatureEnabled(16 /* SIMD */, reportNode, compiler) |
                checkTypeAbsent(typeArguments, reportNode, prototype) |
                checkArgsRequired(operands, 16, reportNode, compiler)) {
                compiler.currentType = types_1.Type.v128;
                return module.unreachable();
            }
            let bytes = new Uint8Array(16);
            for (let i = 0; i < 16; ++i) {
                let value = operands[i];
                if (value) {
                    let expr = compiler.precomputeExpression(value, types_1.Type.i8, 1 /* CONV_IMPLICIT */);
                    if (module_1.getExpressionId(expr) != module_1.ExpressionId.Const) {
                        compiler.error(diagnostics_1.DiagnosticCode.Expression_must_be_a_compile_time_constant, value.range);
                        compiler.currentType = types_1.Type.v128;
                        return module.unreachable();
                    }
                    assert(module_1.getExpressionType(expr) == module_1.NativeType.I32);
                    util_1.writeI8(module_1.getConstValueI32(expr), bytes, i);
                }
            }
            compiler.currentType = types_1.Type.v128;
            return module.v128(bytes);
        }
        case BuiltinSymbols.i16x8: {
            if (checkFeatureEnabled(16 /* SIMD */, reportNode, compiler) |
                checkTypeAbsent(typeArguments, reportNode, prototype) |
                checkArgsRequired(operands, 8, reportNode, compiler)) {
                compiler.currentType = types_1.Type.v128;
                return module.unreachable();
            }
            let bytes = new Uint8Array(16);
            for (let i = 0; i < 8; ++i) {
                let value = operands[i];
                if (value) {
                    let expr = compiler.precomputeExpression(value, types_1.Type.i16, 1 /* CONV_IMPLICIT */);
                    if (module_1.getExpressionId(expr) != module_1.ExpressionId.Const) {
                        compiler.error(diagnostics_1.DiagnosticCode.Expression_must_be_a_compile_time_constant, value.range);
                        compiler.currentType = types_1.Type.v128;
                        return module.unreachable();
                    }
                    assert(module_1.getExpressionType(expr) == module_1.NativeType.I32);
                    util_1.writeI16(module_1.getConstValueI32(expr), bytes, i << 1);
                }
            }
            compiler.currentType = types_1.Type.v128;
            return module.v128(bytes);
        }
        case BuiltinSymbols.i32x4: {
            if (checkFeatureEnabled(16 /* SIMD */, reportNode, compiler) |
                checkTypeAbsent(typeArguments, reportNode, prototype) |
                checkArgsRequired(operands, 4, reportNode, compiler)) {
                compiler.currentType = types_1.Type.v128;
                return module.unreachable();
            }
            let bytes = new Uint8Array(16);
            for (let i = 0; i < 4; ++i) {
                let value = operands[i];
                if (value) {
                    let expr = compiler.precomputeExpression(value, types_1.Type.i32, 1 /* CONV_IMPLICIT */);
                    if (module_1.getExpressionId(expr) != module_1.ExpressionId.Const) {
                        compiler.error(diagnostics_1.DiagnosticCode.Expression_must_be_a_compile_time_constant, value.range);
                        compiler.currentType = types_1.Type.v128;
                        return module.unreachable();
                    }
                    assert(module_1.getExpressionType(expr) == module_1.NativeType.I32);
                    util_1.writeI32(module_1.getConstValueI32(expr), bytes, i << 2);
                }
            }
            compiler.currentType = types_1.Type.v128;
            return module.v128(bytes);
        }
        case BuiltinSymbols.i64x2: {
            if (checkFeatureEnabled(16 /* SIMD */, reportNode, compiler) |
                checkTypeAbsent(typeArguments, reportNode, prototype) |
                checkArgsRequired(operands, 2, reportNode, compiler)) {
                compiler.currentType = types_1.Type.v128;
                return module.unreachable();
            }
            let bytes = new Uint8Array(16);
            for (let i = 0; i < 2; ++i) {
                let value = operands[i];
                if (value) {
                    let expr = compiler.precomputeExpression(value, types_1.Type.i64, 1 /* CONV_IMPLICIT */);
                    if (module_1.getExpressionId(expr) != module_1.ExpressionId.Const) {
                        compiler.error(diagnostics_1.DiagnosticCode.Expression_must_be_a_compile_time_constant, value.range);
                        compiler.currentType = types_1.Type.v128;
                        return module.unreachable();
                    }
                    assert(module_1.getExpressionType(expr) == module_1.NativeType.I64);
                    let off = i << 3;
                    util_1.writeI32(module_1.getConstValueI64Low(expr), bytes, off);
                    util_1.writeI32(module_1.getConstValueI64High(expr), bytes, off + 4);
                }
            }
            compiler.currentType = types_1.Type.v128;
            return module.v128(bytes);
        }
        case BuiltinSymbols.f32x4: {
            if (checkFeatureEnabled(16 /* SIMD */, reportNode, compiler) |
                checkTypeAbsent(typeArguments, reportNode, prototype) |
                checkArgsRequired(operands, 4, reportNode, compiler)) {
                compiler.currentType = types_1.Type.v128;
                return module.unreachable();
            }
            let bytes = new Uint8Array(16);
            for (let i = 0; i < 4; ++i) {
                let value = operands[i];
                if (value) {
                    let expr = compiler.precomputeExpression(value, types_1.Type.f32, 1 /* CONV_IMPLICIT */);
                    if (module_1.getExpressionId(expr) != module_1.ExpressionId.Const) {
                        compiler.error(diagnostics_1.DiagnosticCode.Expression_must_be_a_compile_time_constant, value.range);
                        compiler.currentType = types_1.Type.v128;
                        return module.unreachable();
                    }
                    assert(module_1.getExpressionType(expr) == module_1.NativeType.F32);
                    util_1.writeF32(module_1.getConstValueF32(expr), bytes, i << 2);
                }
            }
            compiler.currentType = types_1.Type.v128;
            return module.v128(bytes);
        }
        case BuiltinSymbols.f64x2: {
            if (checkFeatureEnabled(16 /* SIMD */, reportNode, compiler) |
                checkTypeAbsent(typeArguments, reportNode, prototype) |
                checkArgsRequired(operands, 2, reportNode, compiler)) {
                compiler.currentType = types_1.Type.v128;
                return module.unreachable();
            }
            let bytes = new Uint8Array(16);
            for (let i = 0; i < 2; ++i) {
                let value = operands[i];
                if (value) {
                    let expr = compiler.precomputeExpression(value, types_1.Type.f64, 1 /* CONV_IMPLICIT */);
                    if (module_1.getExpressionId(expr) != module_1.ExpressionId.Const) {
                        compiler.error(diagnostics_1.DiagnosticCode.Expression_must_be_a_compile_time_constant, value.range);
                        compiler.currentType = types_1.Type.v128;
                        return module.unreachable();
                    }
                    assert(module_1.getExpressionType(expr) == module_1.NativeType.F64);
                    util_1.writeF64(module_1.getConstValueF64(expr), bytes, i << 3);
                }
            }
            compiler.currentType = types_1.Type.v128;
            return module.v128(bytes);
        }
        case BuiltinSymbols.v128_splat: { // splat<T!>(x: T) -> v128
            if (checkFeatureEnabled(16 /* SIMD */, reportNode, compiler) |
                checkTypeRequired(typeArguments, reportNode, compiler) |
                checkArgsRequired(operands, 1, reportNode, compiler)) {
                compiler.currentType = types_1.Type.v128;
                return module.unreachable();
            }
            let type = typeArguments[0];
            let arg0 = compiler.compileExpression(operands[0], type, 1 /* CONV_IMPLICIT */);
            compiler.currentType = types_1.Type.v128;
            if (!type.is(256 /* REFERENCE */)) {
                switch (type.kind) {
                    case 0 /* I8 */:
                    case 5 /* U8 */: return module.unary(module_1.UnaryOp.SplatI8x16, arg0);
                    case 1 /* I16 */:
                    case 6 /* U16 */: return module.unary(module_1.UnaryOp.SplatI16x8, arg0);
                    case 2 /* I32 */:
                    case 7 /* U32 */: return module.unary(module_1.UnaryOp.SplatI32x4, arg0);
                    case 3 /* I64 */:
                    case 8 /* U64 */: return module.unary(module_1.UnaryOp.SplatI64x2, arg0);
                    case 4 /* ISIZE */:
                    case 9 /* USIZE */: {
                        return module.unary(compiler.options.isWasm64
                            ? module_1.UnaryOp.SplatI64x2
                            : module_1.UnaryOp.SplatI32x4, arg0);
                    }
                    case 11 /* F32 */: return module.unary(module_1.UnaryOp.SplatF32x4, arg0);
                    case 12 /* F64 */: return module.unary(module_1.UnaryOp.SplatF64x2, arg0);
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "v128.splat", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.v128_extract_lane: { // extract_lane<T!>(x: v128, idx: u8) -> T
            if (checkFeatureEnabled(16 /* SIMD */, reportNode, compiler) |
                checkTypeRequired(typeArguments, reportNode, compiler, true) |
                checkArgsRequired(operands, 2, reportNode, compiler))
                return module.unreachable();
            let type = typeArguments[0];
            let arg0 = compiler.compileExpression(operands[0], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            let arg1 = compiler.precomputeExpression(operands[1], types_1.Type.u8, 1 /* CONV_IMPLICIT */);
            compiler.currentType = type;
            let idx = 0;
            if (module_1.getExpressionId(arg1) == module_1.ExpressionId.Const) {
                assert(module_1.getExpressionType(arg1) == module_1.NativeType.I32);
                idx = module_1.getConstValueI32(arg1);
            }
            else {
                compiler.error(diagnostics_1.DiagnosticCode.Expression_must_be_a_compile_time_constant, operands[1].range);
            }
            if (!type.is(256 /* REFERENCE */)) {
                let maxIdx = (16 / assert(type.byteSize)) - 1;
                if (idx < 0 || idx > maxIdx) {
                    compiler.error(diagnostics_1.DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive, operands[1].range, "Lane index", "0", maxIdx.toString());
                    idx = 0;
                }
                switch (type.kind) {
                    case 0 /* I8 */: return module.simd_extract(module_1.SIMDExtractOp.ExtractLaneI8x16, arg0, idx);
                    case 5 /* U8 */: return module.simd_extract(module_1.SIMDExtractOp.ExtractLaneU8x16, arg0, idx);
                    case 1 /* I16 */: return module.simd_extract(module_1.SIMDExtractOp.ExtractLaneI16x8, arg0, idx);
                    case 6 /* U16 */: return module.simd_extract(module_1.SIMDExtractOp.ExtractLaneU16x8, arg0, idx);
                    case 2 /* I32 */:
                    case 7 /* U32 */: return module.simd_extract(module_1.SIMDExtractOp.ExtractLaneI32x4, arg0, idx);
                    case 3 /* I64 */:
                    case 8 /* U64 */: return module.simd_extract(module_1.SIMDExtractOp.ExtractLaneI64x2, arg0, idx);
                    case 4 /* ISIZE */:
                    case 9 /* USIZE */: {
                        return module.simd_extract(compiler.options.isWasm64
                            ? module_1.SIMDExtractOp.ExtractLaneI64x2
                            : module_1.SIMDExtractOp.ExtractLaneI32x4, arg0, idx);
                    }
                    case 11 /* F32 */: return module.simd_extract(module_1.SIMDExtractOp.ExtractLaneF32x4, arg0, idx);
                    case 12 /* F64 */: return module.simd_extract(module_1.SIMDExtractOp.ExtractLaneF64x2, arg0, idx);
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "v128.extract_lane", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.v128_replace_lane: { // replace_lane<T!>(x: v128, idx: u8, value: T) -> v128
            if (checkFeatureEnabled(16 /* SIMD */, reportNode, compiler) |
                checkTypeRequired(typeArguments, reportNode, compiler) |
                checkArgsRequired(operands, 3, reportNode, compiler)) {
                compiler.currentType = types_1.Type.v128;
                return module.unreachable();
            }
            let type = typeArguments[0];
            let arg0 = compiler.compileExpression(operands[0], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            let arg1 = compiler.precomputeExpression(operands[1], types_1.Type.u8, 1 /* CONV_IMPLICIT */);
            let arg2 = compiler.compileExpression(operands[2], type, 1 /* CONV_IMPLICIT */);
            compiler.currentType = types_1.Type.v128;
            let idx = 0;
            if (module_1.getExpressionId(arg1) == module_1.ExpressionId.Const) {
                assert(module_1.getExpressionType(arg1) == module_1.NativeType.I32);
                idx = module_1.getConstValueI32(arg1);
            }
            else {
                compiler.error(diagnostics_1.DiagnosticCode.Expression_must_be_a_compile_time_constant, operands[1].range);
            }
            if (!type.is(256 /* REFERENCE */)) {
                let maxIdx = (16 / assert(type.byteSize)) - 1;
                if (idx < 0 || idx > maxIdx) {
                    compiler.error(diagnostics_1.DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive, operands[1].range, "Lane index", "0", maxIdx.toString());
                    idx = 0;
                }
                switch (type.kind) {
                    case 0 /* I8 */:
                    case 5 /* U8 */: return module.simd_replace(module_1.SIMDReplaceOp.ReplaceLaneI8x16, arg0, idx, arg2);
                    case 1 /* I16 */:
                    case 6 /* U16 */: return module.simd_replace(module_1.SIMDReplaceOp.ReplaceLaneI16x8, arg0, idx, arg2);
                    case 2 /* I32 */:
                    case 7 /* U32 */: return module.simd_replace(module_1.SIMDReplaceOp.ReplaceLaneI32x4, arg0, idx, arg2);
                    case 3 /* I64 */:
                    case 8 /* U64 */: return module.simd_replace(module_1.SIMDReplaceOp.ReplaceLaneI64x2, arg0, idx, arg2);
                    case 4 /* ISIZE */:
                    case 9 /* USIZE */: {
                        return module.simd_replace(compiler.options.isWasm64
                            ? module_1.SIMDReplaceOp.ReplaceLaneI64x2
                            : module_1.SIMDReplaceOp.ReplaceLaneI32x4, arg0, idx, arg2);
                    }
                    case 11 /* F32 */: return module.simd_replace(module_1.SIMDReplaceOp.ReplaceLaneF32x4, arg0, idx, arg2);
                    case 12 /* F64 */: return module.simd_replace(module_1.SIMDReplaceOp.ReplaceLaneF64x2, arg0, idx, arg2);
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "v128.replace_lane", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.v128_shuffle: { // shuffle<T!>(a: v128, b: v128, ...lanes: u8[]) -> v128
            if (checkFeatureEnabled(16 /* SIMD */, reportNode, compiler) |
                checkTypeRequired(typeArguments, reportNode, compiler)) {
                compiler.currentType = types_1.Type.v128;
                return module.unreachable();
            }
            let type = typeArguments[0];
            if (!type.is(256 /* REFERENCE */)) {
                let laneWidth = type.byteSize;
                let laneCount = 16 / laneWidth;
                assert(isInteger(laneCount) && util_1.isPowerOf2(laneCount));
                if (checkArgsRequired(operands, 2 + laneCount, reportNode, compiler)) {
                    compiler.currentType = types_1.Type.v128;
                    return module.unreachable();
                }
                let arg0 = compiler.compileExpression(operands[0], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
                let arg1 = compiler.compileExpression(operands[1], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
                switch (type.kind) {
                    case 0 /* I8 */:
                    case 1 /* I16 */:
                    case 2 /* I32 */:
                    case 3 /* I64 */:
                    case 4 /* ISIZE */:
                    case 5 /* U8 */:
                    case 6 /* U16 */:
                    case 7 /* U32 */:
                    case 8 /* U64 */:
                    case 9 /* USIZE */:
                    case 11 /* F32 */:
                    case 12 /* F64 */: {
                        let mask = new Uint8Array(16);
                        let maxIdx = (laneCount << 1) - 1;
                        for (let i = 0; i < laneCount; ++i) {
                            let operand = operands[2 + i];
                            let argN = compiler.precomputeExpression(operand, types_1.Type.u8, 1 /* CONV_IMPLICIT */);
                            if (module_1.getExpressionId(argN) != module_1.ExpressionId.Const) {
                                compiler.error(diagnostics_1.DiagnosticCode.Expression_must_be_a_compile_time_constant, operand.range);
                                compiler.currentType = types_1.Type.v128;
                                return module.unreachable();
                            }
                            assert(module_1.getExpressionType(argN) == module_1.NativeType.I32);
                            let idx = module_1.getConstValueI32(argN);
                            if (idx < 0 || idx > maxIdx) {
                                compiler.error(diagnostics_1.DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive, operand.range, "Lane index", "0", maxIdx.toString());
                                compiler.currentType = types_1.Type.v128;
                                return module.unreachable();
                            }
                            switch (laneWidth) {
                                case 1: {
                                    util_1.writeI8(idx, mask, i);
                                    break;
                                }
                                case 2: {
                                    let off8 = i << 1;
                                    let idx8 = idx << 1;
                                    util_1.writeI8(idx8, mask, off8);
                                    util_1.writeI8(idx8 + 1, mask, off8 + 1);
                                    break;
                                }
                                case 4: {
                                    let off8 = i << 2;
                                    let idx8 = idx << 2;
                                    util_1.writeI8(idx8, mask, off8);
                                    util_1.writeI8(idx8 + 1, mask, off8 + 1);
                                    util_1.writeI8(idx8 + 2, mask, off8 + 2);
                                    util_1.writeI8(idx8 + 3, mask, off8 + 3);
                                    break;
                                }
                                case 8: {
                                    let off8 = i << 3;
                                    let idx8 = idx << 3;
                                    util_1.writeI8(idx8, mask, off8);
                                    util_1.writeI8(idx8 + 1, mask, off8 + 1);
                                    util_1.writeI8(idx8 + 2, mask, off8 + 2);
                                    util_1.writeI8(idx8 + 3, mask, off8 + 3);
                                    util_1.writeI8(idx8 + 4, mask, off8 + 4);
                                    util_1.writeI8(idx8 + 5, mask, off8 + 5);
                                    util_1.writeI8(idx8 + 6, mask, off8 + 6);
                                    util_1.writeI8(idx8 + 7, mask, off8 + 7);
                                    break;
                                }
                                default: assert(false);
                            }
                        }
                        compiler.currentType = types_1.Type.v128;
                        return module.simd_shuffle(arg0, arg1, mask);
                    }
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "v128.shuffle", type.toString());
            compiler.currentType = types_1.Type.v128;
            return module.unreachable();
        }
        case BuiltinSymbols.v128_swizzle: { // swizzle(a: v128, b: v128) -> v128
            if (checkFeatureEnabled(16 /* SIMD */, reportNode, compiler) |
                checkTypeAbsent(typeArguments, reportNode, prototype) |
                checkArgsRequired(operands, 2, reportNode, compiler)) {
                compiler.currentType = types_1.Type.v128;
                return module.unreachable();
            }
            let arg0 = compiler.compileExpression(operands[0], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            let arg1 = compiler.compileExpression(operands[1], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            return module.binary(module_1.BinaryOp.SwizzleV8x16, arg0, arg1);
        }
        case BuiltinSymbols.v128_load_splat: { // load_splat<T!>(ptr: usize, immOffset?: usize, immAlign?: usize) -> v128
            if (checkFeatureEnabled(16 /* SIMD */, reportNode, compiler) |
                checkTypeRequired(typeArguments, reportNode, compiler, true) |
                checkArgsOptional(operands, 1, 3, reportNode, compiler))
                return module.unreachable();
            let type = typeArguments[0];
            let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, 1 /* CONV_IMPLICIT */);
            let numOperands = operands.length;
            let immOffset = numOperands >= 2 ? evaluateImmediateOffset(operands[1], compiler) : 0; // reports
            if (immOffset < 0) {
                compiler.currentType = types_1.Type.v128;
                return module.unreachable();
            }
            let immAlign;
            let naturalAlign = type.byteSize;
            if (numOperands == 3) {
                immAlign = evaluateImmediateOffset(operands[2], compiler);
                if (immAlign < 0) {
                    compiler.currentType = types_1.Type.v128;
                    return module.unreachable();
                }
            }
            else {
                immAlign = naturalAlign;
            }
            compiler.currentType = types_1.Type.v128;
            if (!type.is(256 /* REFERENCE */)) {
                if (immAlign > naturalAlign) {
                    compiler.error(diagnostics_1.DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive, operands[2].range, "Alignment", "0", naturalAlign.toString());
                    return module.unreachable();
                }
                if (!util_1.isPowerOf2(immAlign)) {
                    compiler.error(diagnostics_1.DiagnosticCode._0_must_be_a_power_of_two, operands[2].range, "Alignment");
                    return module.unreachable();
                }
                switch (type.kind) {
                    case 0 /* I8 */:
                    case 5 /* U8 */: {
                        return module.simd_load(module_1.SIMDLoadOp.LoadSplatV8x16, arg0, immOffset, immAlign);
                    }
                    case 1 /* I16 */:
                    case 6 /* U16 */: {
                        return module.simd_load(module_1.SIMDLoadOp.LoadSplatV16x8, arg0, immOffset, immAlign);
                    }
                    case 2 /* I32 */:
                    case 7 /* U32 */:
                    case 11 /* F32 */: {
                        return module.simd_load(module_1.SIMDLoadOp.LoadSplatV32x4, arg0, immOffset, immAlign);
                    }
                    case 4 /* ISIZE */:
                    case 9 /* USIZE */: {
                        if (!compiler.options.isWasm64) {
                            return module.simd_load(module_1.SIMDLoadOp.LoadSplatV32x4, arg0, immOffset, immAlign);
                        }
                        // fall-through
                    }
                    case 3 /* I64 */:
                    case 8 /* U64 */:
                    case 12 /* F64 */: {
                        return module.simd_load(module_1.SIMDLoadOp.LoadSplatV64x2, arg0, immOffset, immAlign);
                    }
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "v128.load_splat", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.v128_load_ext: { // load_ext<TFrom!>(ptr: usize, immOffset?: usize, immAlign?: usize) -> v128
            if (checkFeatureEnabled(16 /* SIMD */, reportNode, compiler) |
                checkTypeRequired(typeArguments, reportNode, compiler, true) |
                checkArgsOptional(operands, 1, 3, reportNode, compiler))
                return module.unreachable();
            let type = typeArguments[0];
            let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, 1 /* CONV_IMPLICIT */);
            let numOperands = operands.length;
            let immOffset = numOperands >= 2 ? evaluateImmediateOffset(operands[1], compiler) : 0; // reports
            if (immOffset < 0) {
                compiler.currentType = types_1.Type.v128;
                return module.unreachable();
            }
            let immAlign;
            let naturalAlign = type.byteSize;
            if (numOperands == 3) {
                immAlign = evaluateImmediateOffset(operands[2], compiler);
                if (immAlign < 0) {
                    compiler.currentType = types_1.Type.v128;
                    return module.unreachable();
                }
            }
            else {
                immAlign = naturalAlign;
            }
            compiler.currentType = types_1.Type.v128;
            if (!type.is(256 /* REFERENCE */)) {
                if (immAlign > naturalAlign) {
                    compiler.error(diagnostics_1.DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive, operands[2].range, "Alignment", "0", naturalAlign.toString());
                    return module.unreachable();
                }
                if (!util_1.isPowerOf2(immAlign)) {
                    compiler.error(diagnostics_1.DiagnosticCode._0_must_be_a_power_of_two, operands[2].range, "Alignment");
                    return module.unreachable();
                }
                switch (type.kind) {
                    case 0 /* I8 */: return module.simd_load(module_1.SIMDLoadOp.LoadI8ToI16x8, arg0, immOffset, immAlign);
                    case 5 /* U8 */: return module.simd_load(module_1.SIMDLoadOp.LoadU8ToU16x8, arg0, immOffset, immAlign);
                    case 1 /* I16 */: return module.simd_load(module_1.SIMDLoadOp.LoadI16ToI32x4, arg0, immOffset, immAlign);
                    case 6 /* U16 */: return module.simd_load(module_1.SIMDLoadOp.LoadU16ToU32x4, arg0, immOffset, immAlign);
                    case 4 /* ISIZE */: {
                        if (compiler.options.isWasm64)
                            break;
                        // fall-through
                    }
                    case 2 /* I32 */: return module.simd_load(module_1.SIMDLoadOp.LoadI32ToI64x2, arg0, immOffset, immAlign);
                    case 9 /* USIZE */: {
                        if (compiler.options.isWasm64)
                            break;
                        // fall-through
                    }
                    case 7 /* U32 */: return module.simd_load(module_1.SIMDLoadOp.LoadU32ToU64x2, arg0, immOffset, immAlign);
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "v128.load_ext", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.v128_add: { // add<T!>(a: v128, b: v128) -> v128
            if (checkFeatureEnabled(16 /* SIMD */, reportNode, compiler) |
                checkTypeRequired(typeArguments, reportNode, compiler) |
                checkArgsRequired(operands, 2, reportNode, compiler)) {
                compiler.currentType = types_1.Type.v128;
                return module.unreachable();
            }
            let type = typeArguments[0];
            let arg0 = compiler.compileExpression(operands[0], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            let arg1 = compiler.compileExpression(operands[1], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            if (!type.is(256 /* REFERENCE */)) {
                switch (type.kind) {
                    case 0 /* I8 */:
                    case 5 /* U8 */: return module.binary(module_1.BinaryOp.AddI8x16, arg0, arg1);
                    case 1 /* I16 */:
                    case 6 /* U16 */: return module.binary(module_1.BinaryOp.AddI16x8, arg0, arg1);
                    case 2 /* I32 */:
                    case 7 /* U32 */: return module.binary(module_1.BinaryOp.AddI32x4, arg0, arg1);
                    case 3 /* I64 */:
                    case 8 /* U64 */: return module.binary(module_1.BinaryOp.AddI64x2, arg0, arg1);
                    case 4 /* ISIZE */:
                    case 9 /* USIZE */: {
                        return module.binary(compiler.options.isWasm64
                            ? module_1.BinaryOp.AddI64x2
                            : module_1.BinaryOp.AddI32x4, arg0, arg1);
                    }
                    case 11 /* F32 */: return module.binary(module_1.BinaryOp.AddF32x4, arg0, arg1);
                    case 12 /* F64 */: return module.binary(module_1.BinaryOp.AddF64x2, arg0, arg1);
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "v128.add", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.v128_sub: { // sub<T!>(a: v128, b: v128) -> v128
            if (checkFeatureEnabled(16 /* SIMD */, reportNode, compiler) |
                checkTypeRequired(typeArguments, reportNode, compiler) |
                checkArgsRequired(operands, 2, reportNode, compiler)) {
                compiler.currentType = types_1.Type.v128;
                return module.unreachable();
            }
            let type = typeArguments[0];
            let arg0 = compiler.compileExpression(operands[0], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            let arg1 = compiler.compileExpression(operands[1], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            if (!type.is(256 /* REFERENCE */)) {
                switch (type.kind) {
                    case 0 /* I8 */:
                    case 5 /* U8 */: return module.binary(module_1.BinaryOp.SubI8x16, arg0, arg1);
                    case 1 /* I16 */:
                    case 6 /* U16 */: return module.binary(module_1.BinaryOp.SubI16x8, arg0, arg1);
                    case 2 /* I32 */:
                    case 7 /* U32 */: return module.binary(module_1.BinaryOp.SubI32x4, arg0, arg1);
                    case 3 /* I64 */:
                    case 8 /* U64 */: return module.binary(module_1.BinaryOp.SubI64x2, arg0, arg1);
                    case 4 /* ISIZE */:
                    case 9 /* USIZE */: {
                        return module.binary(compiler.options.isWasm64
                            ? module_1.BinaryOp.SubI64x2
                            : module_1.BinaryOp.SubI32x4, arg0, arg1);
                    }
                    case 11 /* F32 */: return module.binary(module_1.BinaryOp.SubF32x4, arg0, arg1);
                    case 12 /* F64 */: return module.binary(module_1.BinaryOp.SubF64x2, arg0, arg1);
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "v128.sub", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.v128_mul: { // mul<T!>(a: v128, b: v128) -> v128
            if (checkFeatureEnabled(16 /* SIMD */, reportNode, compiler) |
                checkTypeRequired(typeArguments, reportNode, compiler) |
                checkArgsRequired(operands, 2, reportNode, compiler)) {
                compiler.currentType = types_1.Type.v128;
                return module.unreachable();
            }
            let type = typeArguments[0];
            let arg0 = compiler.compileExpression(operands[0], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            let arg1 = compiler.compileExpression(operands[1], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            if (!type.is(256 /* REFERENCE */)) {
                switch (type.kind) {
                    case 0 /* I8 */:
                    case 5 /* U8 */: return module.binary(module_1.BinaryOp.MulI8x16, arg0, arg1);
                    case 1 /* I16 */:
                    case 6 /* U16 */: return module.binary(module_1.BinaryOp.MulI16x8, arg0, arg1);
                    case 2 /* I32 */:
                    case 7 /* U32 */: return module.binary(module_1.BinaryOp.MulI32x4, arg0, arg1);
                    case 4 /* ISIZE */:
                    case 9 /* USIZE */: {
                        if (!compiler.options.isWasm64) {
                            return module.binary(module_1.BinaryOp.MulI32x4, arg0, arg1);
                        }
                        break;
                    }
                    case 11 /* F32 */: return module.binary(module_1.BinaryOp.MulF32x4, arg0, arg1);
                    case 12 /* F64 */: return module.binary(module_1.BinaryOp.MulF64x2, arg0, arg1);
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "v128.mul", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.v128_div: { // div<T!>(a: v128, b: v128) -> v128
            if (checkFeatureEnabled(16 /* SIMD */, reportNode, compiler) |
                checkTypeRequired(typeArguments, reportNode, compiler) |
                checkArgsRequired(operands, 2, reportNode, compiler)) {
                compiler.currentType = types_1.Type.v128;
                return module.unreachable();
            }
            let type = typeArguments[0];
            let arg0 = compiler.compileExpression(operands[0], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            let arg1 = compiler.compileExpression(operands[1], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            if (!type.is(256 /* REFERENCE */)) {
                switch (type.kind) {
                    case 11 /* F32 */: return module.binary(module_1.BinaryOp.DivF32x4, arg0, arg1);
                    case 12 /* F64 */: return module.binary(module_1.BinaryOp.DivF64x2, arg0, arg1);
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "v128.div", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.v128_add_saturate: { // add_saturate<T!>(a: v128, b: v128) -> v128
            if (checkFeatureEnabled(16 /* SIMD */, reportNode, compiler) |
                checkTypeRequired(typeArguments, reportNode, compiler) |
                checkArgsRequired(operands, 2, reportNode, compiler)) {
                compiler.currentType = types_1.Type.v128;
                return module.unreachable();
            }
            let type = typeArguments[0];
            let arg0 = compiler.compileExpression(operands[0], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            let arg1 = compiler.compileExpression(operands[1], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            if (!type.is(256 /* REFERENCE */)) {
                switch (type.kind) {
                    case 0 /* I8 */: return module.binary(module_1.BinaryOp.AddSatI8x16, arg0, arg1);
                    case 5 /* U8 */: return module.binary(module_1.BinaryOp.AddSatU8x16, arg0, arg1);
                    case 1 /* I16 */: return module.binary(module_1.BinaryOp.AddSatI16x8, arg0, arg1);
                    case 6 /* U16 */: return module.binary(module_1.BinaryOp.AddSatU16x8, arg0, arg1);
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "v128.add_saturate", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.v128_sub_saturate: { // sub_saturate<T!>(a: v128, b: v128) -> v128
            if (checkFeatureEnabled(16 /* SIMD */, reportNode, compiler) |
                checkTypeRequired(typeArguments, reportNode, compiler) |
                checkArgsRequired(operands, 2, reportNode, compiler)) {
                compiler.currentType = types_1.Type.v128;
                return module.unreachable();
            }
            let type = typeArguments[0];
            let arg0 = compiler.compileExpression(operands[0], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            let arg1 = compiler.compileExpression(operands[1], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            if (!type.is(256 /* REFERENCE */)) {
                switch (type.kind) {
                    case 0 /* I8 */: return module.binary(module_1.BinaryOp.SubSatI8x16, arg0, arg1);
                    case 5 /* U8 */: return module.binary(module_1.BinaryOp.SubSatU8x16, arg0, arg1);
                    case 1 /* I16 */: return module.binary(module_1.BinaryOp.SubSatI16x8, arg0, arg1);
                    case 6 /* U16 */: return module.binary(module_1.BinaryOp.SubSatU16x8, arg0, arg1);
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "v128.sub_saturate", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.v128_min: { // min<T!>(a: v128, b: v128) -> v128
            if (checkFeatureEnabled(16 /* SIMD */, reportNode, compiler) |
                checkTypeRequired(typeArguments, reportNode, compiler) |
                checkArgsRequired(operands, 2, reportNode, compiler)) {
                compiler.currentType = types_1.Type.v128;
                return module.unreachable();
            }
            let type = typeArguments[0];
            let arg0 = compiler.compileExpression(operands[0], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            let arg1 = compiler.compileExpression(operands[1], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            if (!type.is(256 /* REFERENCE */)) {
                switch (type.kind) {
                    case 0 /* I8 */: return module.binary(module_1.BinaryOp.MinI8x16, arg0, arg1);
                    case 5 /* U8 */: return module.binary(module_1.BinaryOp.MinU8x16, arg0, arg1);
                    case 1 /* I16 */: return module.binary(module_1.BinaryOp.MinI16x8, arg0, arg1);
                    case 6 /* U16 */: return module.binary(module_1.BinaryOp.MinU16x8, arg0, arg1);
                    case 4 /* ISIZE */: {
                        if (compiler.options.isWasm64)
                            break;
                        // fall-through
                    }
                    case 2 /* I32 */: return module.binary(module_1.BinaryOp.MinI32x4, arg0, arg1);
                    case 9 /* USIZE */: {
                        if (compiler.options.isWasm64)
                            break;
                        // fall-through
                    }
                    case 7 /* U32 */: return module.binary(module_1.BinaryOp.MinU32x4, arg0, arg1);
                    case 11 /* F32 */: return module.binary(module_1.BinaryOp.MinF32x4, arg0, arg1);
                    case 12 /* F64 */: return module.binary(module_1.BinaryOp.MinF64x2, arg0, arg1);
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "v128.min", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.v128_max: { // max<T!>(a: v128, b: v128) -> v128
            if (checkFeatureEnabled(16 /* SIMD */, reportNode, compiler) |
                checkTypeRequired(typeArguments, reportNode, compiler) |
                checkArgsRequired(operands, 2, reportNode, compiler)) {
                compiler.currentType = types_1.Type.v128;
                return module.unreachable();
            }
            let type = typeArguments[0];
            let arg0 = compiler.compileExpression(operands[0], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            let arg1 = compiler.compileExpression(operands[1], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            if (!type.is(256 /* REFERENCE */)) {
                switch (type.kind) {
                    case 0 /* I8 */: return module.binary(module_1.BinaryOp.MaxI8x16, arg0, arg1);
                    case 5 /* U8 */: return module.binary(module_1.BinaryOp.MaxU8x16, arg0, arg1);
                    case 1 /* I16 */: return module.binary(module_1.BinaryOp.MaxI16x8, arg0, arg1);
                    case 6 /* U16 */: return module.binary(module_1.BinaryOp.MaxU16x8, arg0, arg1);
                    case 4 /* ISIZE */: {
                        if (compiler.options.isWasm64)
                            break;
                        // fall-through
                    }
                    case 2 /* I32 */: return module.binary(module_1.BinaryOp.MaxI32x4, arg0, arg1);
                    case 9 /* USIZE */: {
                        if (compiler.options.isWasm64)
                            break;
                        // fall-through
                    }
                    case 7 /* U32 */: return module.binary(module_1.BinaryOp.MaxU32x4, arg0, arg1);
                    case 11 /* F32 */: return module.binary(module_1.BinaryOp.MaxF32x4, arg0, arg1);
                    case 12 /* F64 */: return module.binary(module_1.BinaryOp.MaxF64x2, arg0, arg1);
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "v128.max", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.v128_dot: { // dot<T!>(a: v128, b: v128) -> v128
            if (checkFeatureEnabled(16 /* SIMD */, reportNode, compiler) |
                checkTypeRequired(typeArguments, reportNode, compiler) |
                checkArgsRequired(operands, 2, reportNode, compiler)) {
                compiler.currentType = types_1.Type.v128;
                return module.unreachable();
            }
            let type = typeArguments[0];
            let arg0 = compiler.compileExpression(operands[0], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            let arg1 = compiler.compileExpression(operands[1], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            if (!type.is(256 /* REFERENCE */)) {
                switch (type.kind) {
                    case 1 /* I16 */: return module.binary(module_1.BinaryOp.DotI16x8, arg0, arg1);
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "v128.dot", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.v128_eq: { // eq<T!>(a: v128, b: v128) -> v128
            if (checkFeatureEnabled(16 /* SIMD */, reportNode, compiler) |
                checkTypeRequired(typeArguments, reportNode, compiler) |
                checkArgsRequired(operands, 2, reportNode, compiler)) {
                compiler.currentType = types_1.Type.v128;
                return module.unreachable();
            }
            let type = typeArguments[0];
            let arg0 = compiler.compileExpression(operands[0], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            let arg1 = compiler.compileExpression(operands[1], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            if (!type.is(256 /* REFERENCE */)) {
                switch (type.kind) {
                    case 0 /* I8 */:
                    case 5 /* U8 */: return module.binary(module_1.BinaryOp.EqI8x16, arg0, arg1);
                    case 1 /* I16 */:
                    case 6 /* U16 */: return module.binary(module_1.BinaryOp.EqI16x8, arg0, arg1);
                    case 2 /* I32 */:
                    case 7 /* U32 */: return module.binary(module_1.BinaryOp.EqI32x4, arg0, arg1);
                    case 4 /* ISIZE */:
                    case 9 /* USIZE */: {
                        if (!compiler.options.isWasm64) {
                            return module.binary(module_1.BinaryOp.EqI32x4, arg0, arg1);
                        }
                        break;
                    }
                    case 11 /* F32 */: return module.binary(module_1.BinaryOp.EqF32x4, arg0, arg1);
                    case 12 /* F64 */: return module.binary(module_1.BinaryOp.EqF64x2, arg0, arg1);
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "v128.eq", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.v128_ne: { // ne<T!>(a: v128, b: v128) -> v128
            if (checkFeatureEnabled(16 /* SIMD */, reportNode, compiler) |
                checkTypeRequired(typeArguments, reportNode, compiler) |
                checkArgsRequired(operands, 2, reportNode, compiler)) {
                compiler.currentType = types_1.Type.v128;
                return module.unreachable();
            }
            let type = typeArguments[0];
            let arg0 = compiler.compileExpression(operands[0], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            let arg1 = compiler.compileExpression(operands[1], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            if (!type.is(256 /* REFERENCE */)) {
                switch (type.kind) {
                    case 0 /* I8 */:
                    case 5 /* U8 */: return module.binary(module_1.BinaryOp.NeI8x16, arg0, arg1);
                    case 1 /* I16 */:
                    case 6 /* U16 */: return module.binary(module_1.BinaryOp.NeI16x8, arg0, arg1);
                    case 2 /* I32 */:
                    case 7 /* U32 */: return module.binary(module_1.BinaryOp.NeI32x4, arg0, arg1);
                    case 4 /* ISIZE */:
                    case 9 /* USIZE */: {
                        if (!compiler.options.isWasm64) {
                            return module.binary(module_1.BinaryOp.NeI32x4, arg0, arg1);
                        }
                        break;
                    }
                    case 11 /* F32 */: return module.binary(module_1.BinaryOp.NeF32x4, arg0, arg1);
                    case 12 /* F64 */: return module.binary(module_1.BinaryOp.NeF64x2, arg0, arg1);
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "v128.ne", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.v128_lt: { // lt<T!>(a: v128, b: v128) -> v128
            if (checkFeatureEnabled(16 /* SIMD */, reportNode, compiler) |
                checkTypeRequired(typeArguments, reportNode, compiler) |
                checkArgsRequired(operands, 2, reportNode, compiler)) {
                compiler.currentType = types_1.Type.v128;
                return module.unreachable();
            }
            let type = typeArguments[0];
            let arg0 = compiler.compileExpression(operands[0], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            let arg1 = compiler.compileExpression(operands[1], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            if (!type.is(256 /* REFERENCE */)) {
                switch (type.kind) {
                    case 0 /* I8 */: return module.binary(module_1.BinaryOp.LtI8x16, arg0, arg1);
                    case 5 /* U8 */: return module.binary(module_1.BinaryOp.LtU8x16, arg0, arg1);
                    case 1 /* I16 */: return module.binary(module_1.BinaryOp.LtI16x8, arg0, arg1);
                    case 6 /* U16 */: return module.binary(module_1.BinaryOp.LtU16x8, arg0, arg1);
                    case 2 /* I32 */: return module.binary(module_1.BinaryOp.LtI32x4, arg0, arg1);
                    case 7 /* U32 */: return module.binary(module_1.BinaryOp.LtU32x4, arg0, arg1);
                    case 4 /* ISIZE */: {
                        if (!compiler.options.isWasm64) {
                            return module.binary(module_1.BinaryOp.LtI32x4, arg0, arg1);
                        }
                        break;
                    }
                    case 9 /* USIZE */: {
                        if (!compiler.options.isWasm64) {
                            return module.binary(module_1.BinaryOp.LtU32x4, arg0, arg1);
                        }
                        break;
                    }
                    case 11 /* F32 */: return module.binary(module_1.BinaryOp.LtF32x4, arg0, arg1);
                    case 12 /* F64 */: return module.binary(module_1.BinaryOp.LtF64x2, arg0, arg1);
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "v128.lt", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.v128_le: { // le<T!>(a: v128, b: v128) -> v128
            if (checkFeatureEnabled(16 /* SIMD */, reportNode, compiler) |
                checkTypeRequired(typeArguments, reportNode, compiler) |
                checkArgsRequired(operands, 2, reportNode, compiler)) {
                compiler.currentType = types_1.Type.v128;
                return module.unreachable();
            }
            let type = typeArguments[0];
            let arg0 = compiler.compileExpression(operands[0], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            let arg1 = compiler.compileExpression(operands[1], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            if (!type.is(256 /* REFERENCE */)) {
                switch (type.kind) {
                    case 0 /* I8 */: return module.binary(module_1.BinaryOp.LeI8x16, arg0, arg1);
                    case 5 /* U8 */: return module.binary(module_1.BinaryOp.LeU8x16, arg0, arg1);
                    case 1 /* I16 */: return module.binary(module_1.BinaryOp.LeI16x8, arg0, arg1);
                    case 6 /* U16 */: return module.binary(module_1.BinaryOp.LeU16x8, arg0, arg1);
                    case 2 /* I32 */: return module.binary(module_1.BinaryOp.LeI32x4, arg0, arg1);
                    case 7 /* U32 */: return module.binary(module_1.BinaryOp.LeU32x4, arg0, arg1);
                    case 4 /* ISIZE */: {
                        if (!compiler.options.isWasm64) {
                            return module.binary(module_1.BinaryOp.LeI32x4, arg0, arg1);
                        }
                        break;
                    }
                    case 9 /* USIZE */: {
                        if (!compiler.options.isWasm64) {
                            return module.binary(module_1.BinaryOp.LeU32x4, arg0, arg1);
                        }
                        break;
                    }
                    case 11 /* F32 */: return module.binary(module_1.BinaryOp.LeF32x4, arg0, arg1);
                    case 12 /* F64 */: return module.binary(module_1.BinaryOp.LeF64x2, arg0, arg1);
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "v128.le", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.v128_gt: { // gt<T!>(a: v128, b: v128) -> v128
            if (checkFeatureEnabled(16 /* SIMD */, reportNode, compiler) |
                checkTypeRequired(typeArguments, reportNode, compiler) |
                checkArgsRequired(operands, 2, reportNode, compiler)) {
                compiler.currentType = types_1.Type.v128;
                return module.unreachable();
            }
            let type = typeArguments[0];
            let arg0 = compiler.compileExpression(operands[0], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            let arg1 = compiler.compileExpression(operands[1], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            if (!type.is(256 /* REFERENCE */)) {
                switch (type.kind) {
                    case 0 /* I8 */: return module.binary(module_1.BinaryOp.GtI8x16, arg0, arg1);
                    case 5 /* U8 */: return module.binary(module_1.BinaryOp.GtU8x16, arg0, arg1);
                    case 1 /* I16 */: return module.binary(module_1.BinaryOp.GtI16x8, arg0, arg1);
                    case 6 /* U16 */: return module.binary(module_1.BinaryOp.GtU16x8, arg0, arg1);
                    case 2 /* I32 */: return module.binary(module_1.BinaryOp.GtI32x4, arg0, arg1);
                    case 7 /* U32 */: return module.binary(module_1.BinaryOp.GtU32x4, arg0, arg1);
                    case 4 /* ISIZE */: {
                        if (!compiler.options.isWasm64) {
                            return module.binary(module_1.BinaryOp.GtI32x4, arg0, arg1);
                        }
                        break;
                    }
                    case 9 /* USIZE */: {
                        if (!compiler.options.isWasm64) {
                            return module.binary(module_1.BinaryOp.GtU32x4, arg0, arg1);
                        }
                        break;
                    }
                    case 11 /* F32 */: return module.binary(module_1.BinaryOp.GtF32x4, arg0, arg1);
                    case 12 /* F64 */: return module.binary(module_1.BinaryOp.GtF64x2, arg0, arg1);
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "v128.gt", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.v128_ge: { // ge<T!>(a: v128, b: v128) -> v128
            if (checkFeatureEnabled(16 /* SIMD */, reportNode, compiler) |
                checkTypeRequired(typeArguments, reportNode, compiler) |
                checkArgsRequired(operands, 2, reportNode, compiler)) {
                compiler.currentType = types_1.Type.v128;
                return module.unreachable();
            }
            let type = typeArguments[0];
            let arg0 = compiler.compileExpression(operands[0], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            let arg1 = compiler.compileExpression(operands[1], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            if (!type.is(256 /* REFERENCE */)) {
                switch (type.kind) {
                    case 0 /* I8 */: return module.binary(module_1.BinaryOp.GeI8x16, arg0, arg1);
                    case 5 /* U8 */: return module.binary(module_1.BinaryOp.GeU8x16, arg0, arg1);
                    case 1 /* I16 */: return module.binary(module_1.BinaryOp.GeI16x8, arg0, arg1);
                    case 6 /* U16 */: return module.binary(module_1.BinaryOp.GeU16x8, arg0, arg1);
                    case 2 /* I32 */: return module.binary(module_1.BinaryOp.GeI32x4, arg0, arg1);
                    case 7 /* U32 */: return module.binary(module_1.BinaryOp.GeU32x4, arg0, arg1);
                    case 4 /* ISIZE */: {
                        if (!compiler.options.isWasm64) {
                            return module.binary(module_1.BinaryOp.GeI32x4, arg0, arg1);
                        }
                        break;
                    }
                    case 9 /* USIZE */: {
                        if (!compiler.options.isWasm64) {
                            return module.binary(module_1.BinaryOp.GeU32x4, arg0, arg1);
                        }
                        break;
                    }
                    case 11 /* F32 */: return module.binary(module_1.BinaryOp.GeF32x4, arg0, arg1);
                    case 12 /* F64 */: return module.binary(module_1.BinaryOp.GeF64x2, arg0, arg1);
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "v128.ge", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.v128_narrow: {
            if (checkFeatureEnabled(16 /* SIMD */, reportNode, compiler) |
                checkTypeRequired(typeArguments, reportNode, compiler) |
                checkArgsRequired(operands, 2, reportNode, compiler)) {
                compiler.currentType = types_1.Type.v128;
                return module.unreachable();
            }
            let type = typeArguments[0];
            let arg0 = compiler.compileExpression(operands[0], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            let arg1 = compiler.compileExpression(operands[1], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            if (!type.is(256 /* REFERENCE */)) {
                switch (type.kind) {
                    case 1 /* I16 */: return module.binary(module_1.BinaryOp.NarrowI16x8ToI8x16, arg0, arg1);
                    case 6 /* U16 */: return module.binary(module_1.BinaryOp.NarrowU16x8ToU8x16, arg0, arg1);
                    case 2 /* I32 */: return module.binary(module_1.BinaryOp.NarrowI32x4ToI16x8, arg0, arg1);
                    case 7 /* U32 */: return module.binary(module_1.BinaryOp.NarrowU32x4ToU16x8, arg0, arg1);
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "v128.narrow", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.v128_neg: {
            if (checkFeatureEnabled(16 /* SIMD */, reportNode, compiler) |
                checkTypeRequired(typeArguments, reportNode, compiler) |
                checkArgsRequired(operands, 1, reportNode, compiler)) {
                compiler.currentType = types_1.Type.v128;
                return module.unreachable();
            }
            let type = typeArguments[0];
            let arg0 = compiler.compileExpression(operands[0], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            if (!type.is(256 /* REFERENCE */)) {
                switch (type.kind) {
                    case 0 /* I8 */:
                    case 5 /* U8 */: return module.unary(module_1.UnaryOp.NegI8x16, arg0);
                    case 1 /* I16 */:
                    case 6 /* U16 */: return module.unary(module_1.UnaryOp.NegI16x8, arg0);
                    case 2 /* I32 */:
                    case 7 /* U32 */: return module.unary(module_1.UnaryOp.NegI32x4, arg0);
                    case 3 /* I64 */:
                    case 8 /* U64 */: return module.unary(module_1.UnaryOp.NegI64x2, arg0);
                    case 4 /* ISIZE */:
                    case 9 /* USIZE */: {
                        return module.unary(compiler.options.isWasm64
                            ? module_1.UnaryOp.NegI64x2
                            : module_1.UnaryOp.NegI32x4, arg0);
                    }
                    case 11 /* F32 */: return module.unary(module_1.UnaryOp.NegF32x4, arg0);
                    case 12 /* F64 */: return module.unary(module_1.UnaryOp.NegF64x2, arg0);
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "v128.neg", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.v128_abs: {
            if (checkFeatureEnabled(16 /* SIMD */, reportNode, compiler) |
                checkTypeRequired(typeArguments, reportNode, compiler) |
                checkArgsRequired(operands, 1, reportNode, compiler)) {
                compiler.currentType = types_1.Type.v128;
                return module.unreachable();
            }
            let type = typeArguments[0];
            let arg0 = compiler.compileExpression(operands[0], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            if (!type.is(256 /* REFERENCE */)) {
                switch (type.kind) {
                    case 11 /* F32 */: return module.unary(module_1.UnaryOp.AbsF32x4, arg0);
                    case 12 /* F64 */: return module.unary(module_1.UnaryOp.AbsF64x2, arg0);
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "v128.abs", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.v128_sqrt: {
            if (checkFeatureEnabled(16 /* SIMD */, reportNode, compiler) |
                checkTypeRequired(typeArguments, reportNode, compiler) |
                checkArgsRequired(operands, 1, reportNode, compiler)) {
                compiler.currentType = types_1.Type.v128;
                return module.unreachable();
            }
            let type = typeArguments[0];
            let arg0 = compiler.compileExpression(operands[0], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            if (!type.is(256 /* REFERENCE */)) {
                switch (type.kind) {
                    case 11 /* F32 */: return module.unary(module_1.UnaryOp.SqrtF32x4, arg0);
                    case 12 /* F64 */: return module.unary(module_1.UnaryOp.SqrtF64x2, arg0);
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "v128.sqrt", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.v128_convert: {
            if (checkFeatureEnabled(16 /* SIMD */, reportNode, compiler) |
                checkTypeRequired(typeArguments, reportNode, compiler) |
                checkArgsRequired(operands, 1, reportNode, compiler)) {
                compiler.currentType = types_1.Type.v128;
                return module.unreachable();
            }
            let type = typeArguments[0];
            let arg0 = compiler.compileExpression(operands[0], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            if (!type.is(256 /* REFERENCE */)) {
                switch (type.kind) {
                    case 2 /* I32 */: return module.unary(module_1.UnaryOp.ConvertI32x4ToF32x4, arg0);
                    case 7 /* U32 */: return module.unary(module_1.UnaryOp.ConvertU32x4ToF32x4, arg0);
                    case 3 /* I64 */: return module.unary(module_1.UnaryOp.ConvertI64x2ToF64x2, arg0);
                    case 8 /* U64 */: return module.unary(module_1.UnaryOp.ConvertU64x2ToF64x2, arg0);
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "v128.convert", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.v128_trunc_sat: {
            if (checkFeatureEnabled(16 /* SIMD */, reportNode, compiler) |
                checkTypeRequired(typeArguments, reportNode, compiler) |
                checkArgsRequired(operands, 1, reportNode, compiler)) {
                compiler.currentType = types_1.Type.v128;
                return module.unreachable();
            }
            let type = typeArguments[0];
            let arg0 = compiler.compileExpression(operands[0], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            if (!type.is(256 /* REFERENCE */)) {
                switch (type.kind) {
                    case 2 /* I32 */: return module.unary(module_1.UnaryOp.TruncSatF32x4ToI32x4, arg0);
                    case 7 /* U32 */: return module.unary(module_1.UnaryOp.TruncSatF32x4ToU32x4, arg0);
                    case 3 /* I64 */: return module.unary(module_1.UnaryOp.TruncSatF64x2ToI64x2, arg0);
                    case 8 /* U64 */: return module.unary(module_1.UnaryOp.TruncSatF64x2ToU64x2, arg0);
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "v128.trunc_sat", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.v128_widen_low: {
            if (checkFeatureEnabled(16 /* SIMD */, reportNode, compiler) |
                checkTypeRequired(typeArguments, reportNode, compiler) |
                checkArgsRequired(operands, 1, reportNode, compiler)) {
                compiler.currentType = types_1.Type.v128;
                return module.unreachable();
            }
            let type = typeArguments[0];
            let arg0 = compiler.compileExpression(operands[0], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            if (!type.is(256 /* REFERENCE */)) {
                switch (type.kind) {
                    case 0 /* I8 */: return module.unary(module_1.UnaryOp.WidenLowI8x16ToI16x8, arg0);
                    case 5 /* U8 */: return module.unary(module_1.UnaryOp.WidenLowU8x16ToU16x8, arg0);
                    case 1 /* I16 */: return module.unary(module_1.UnaryOp.WidenLowI16x8ToI32x4, arg0);
                    case 6 /* U16 */: return module.unary(module_1.UnaryOp.WidenLowU16x8ToU32x4, arg0);
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "v128.widen_low", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.v128_widen_high: {
            if (checkFeatureEnabled(16 /* SIMD */, reportNode, compiler) |
                checkTypeRequired(typeArguments, reportNode, compiler) |
                checkArgsRequired(operands, 1, reportNode, compiler)) {
                compiler.currentType = types_1.Type.v128;
                return module.unreachable();
            }
            let type = typeArguments[0];
            let arg0 = compiler.compileExpression(operands[0], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            if (!type.is(256 /* REFERENCE */)) {
                switch (type.kind) {
                    case 0 /* I8 */: return module.unary(module_1.UnaryOp.WidenHighI8x16ToI16x8, arg0);
                    case 5 /* U8 */: return module.unary(module_1.UnaryOp.WidenHighU8x16ToU16x8, arg0);
                    case 1 /* I16 */: return module.unary(module_1.UnaryOp.WidenHighI16x8ToI32x4, arg0);
                    case 6 /* U16 */: return module.unary(module_1.UnaryOp.WidenHighU16x8ToU32x4, arg0);
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "v128.widen_high", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.v128_shl: { // shl<T!>(a: v128, b: i32) -> v128
            if (checkFeatureEnabled(16 /* SIMD */, reportNode, compiler) |
                checkTypeRequired(typeArguments, reportNode, compiler) |
                checkArgsRequired(operands, 2, reportNode, compiler)) {
                compiler.currentType = types_1.Type.v128;
                return module.unreachable();
            }
            let type = typeArguments[0];
            let arg0 = compiler.compileExpression(operands[0], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            let arg1 = compiler.compileExpression(operands[1], types_1.Type.i32, 1 /* CONV_IMPLICIT */);
            compiler.currentType = types_1.Type.v128;
            if (!type.is(256 /* REFERENCE */)) {
                switch (type.kind) {
                    case 0 /* I8 */:
                    case 5 /* U8 */: return module.simd_shift(module_1.SIMDShiftOp.ShlI8x16, arg0, arg1);
                    case 1 /* I16 */:
                    case 6 /* U16 */: return module.simd_shift(module_1.SIMDShiftOp.ShlI16x8, arg0, arg1);
                    case 2 /* I32 */:
                    case 7 /* U32 */: return module.simd_shift(module_1.SIMDShiftOp.ShlI32x4, arg0, arg1);
                    case 3 /* I64 */:
                    case 8 /* U64 */: return module.simd_shift(module_1.SIMDShiftOp.ShlI64x2, arg0, arg1);
                    case 4 /* ISIZE */:
                    case 9 /* USIZE */: {
                        return module.simd_shift(compiler.options.isWasm64
                            ? module_1.SIMDShiftOp.ShlI64x2
                            : module_1.SIMDShiftOp.ShlI32x4, arg0, arg1);
                    }
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "v128.shl", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.v128_shr: { // shr<T!>(a: v128, b: i32) -> v128
            if (checkFeatureEnabled(16 /* SIMD */, reportNode, compiler) |
                checkTypeRequired(typeArguments, reportNode, compiler) |
                checkArgsRequired(operands, 2, reportNode, compiler)) {
                compiler.currentType = types_1.Type.v128;
                return module.unreachable();
            }
            let type = typeArguments[0];
            let arg0 = compiler.compileExpression(operands[0], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            let arg1 = compiler.compileExpression(operands[1], types_1.Type.i32, 1 /* CONV_IMPLICIT */);
            compiler.currentType = types_1.Type.v128;
            if (!type.is(256 /* REFERENCE */)) {
                switch (type.kind) {
                    case 0 /* I8 */: return module.simd_shift(module_1.SIMDShiftOp.ShrI8x16, arg0, arg1);
                    case 5 /* U8 */: return module.simd_shift(module_1.SIMDShiftOp.ShrU8x16, arg0, arg1);
                    case 1 /* I16 */: return module.simd_shift(module_1.SIMDShiftOp.ShrI16x8, arg0, arg1);
                    case 6 /* U16 */: return module.simd_shift(module_1.SIMDShiftOp.ShrU16x8, arg0, arg1);
                    case 2 /* I32 */: return module.simd_shift(module_1.SIMDShiftOp.ShrI32x4, arg0, arg1);
                    case 7 /* U32 */: return module.simd_shift(module_1.SIMDShiftOp.ShrU32x4, arg0, arg1);
                    case 3 /* I64 */: return module.simd_shift(module_1.SIMDShiftOp.ShrI64x2, arg0, arg1);
                    case 8 /* U64 */: return module.simd_shift(module_1.SIMDShiftOp.ShrU64x2, arg0, arg1);
                    case 4 /* ISIZE */: {
                        return module.simd_shift(compiler.options.isWasm64
                            ? module_1.SIMDShiftOp.ShrI64x2
                            : module_1.SIMDShiftOp.ShrI32x4, arg0, arg1);
                    }
                    case 9 /* USIZE */: {
                        return module.simd_shift(compiler.options.isWasm64
                            ? module_1.SIMDShiftOp.ShrU64x2
                            : module_1.SIMDShiftOp.ShrU32x4, arg0, arg1);
                    }
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "v128.shr", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.v128_and: { // and(a: v128) -> v128
            if (checkFeatureEnabled(16 /* SIMD */, reportNode, compiler) |
                checkTypeAbsent(typeArguments, reportNode, prototype) |
                checkArgsRequired(operands, 2, reportNode, compiler)) {
                compiler.currentType = types_1.Type.v128;
                return module.unreachable();
            }
            let arg0 = compiler.compileExpression(operands[0], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            let arg1 = compiler.compileExpression(operands[1], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            return module.binary(module_1.BinaryOp.AndV128, arg0, arg1);
        }
        case BuiltinSymbols.v128_or: { // or(a: v128) -> v128
            if (checkFeatureEnabled(16 /* SIMD */, reportNode, compiler) |
                checkTypeAbsent(typeArguments, reportNode, prototype) |
                checkArgsRequired(operands, 2, reportNode, compiler)) {
                compiler.currentType = types_1.Type.v128;
                return module.unreachable();
            }
            let arg0 = compiler.compileExpression(operands[0], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            let arg1 = compiler.compileExpression(operands[1], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            return module.binary(module_1.BinaryOp.OrV128, arg0, arg1);
        }
        case BuiltinSymbols.v128_xor: { // xor(a: v128) -> v128
            if (checkFeatureEnabled(16 /* SIMD */, reportNode, compiler) |
                checkTypeAbsent(typeArguments, reportNode, prototype) |
                checkArgsRequired(operands, 2, reportNode, compiler)) {
                compiler.currentType = types_1.Type.v128;
                return module.unreachable();
            }
            let arg0 = compiler.compileExpression(operands[0], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            let arg1 = compiler.compileExpression(operands[1], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            return module.binary(module_1.BinaryOp.XorV128, arg0, arg1);
        }
        case BuiltinSymbols.v128_andnot: { // andnot(a: v128, b: v128) -> v128
            if (checkFeatureEnabled(16 /* SIMD */, reportNode, compiler) |
                checkTypeAbsent(typeArguments, reportNode, prototype) |
                checkArgsRequired(operands, 2, reportNode, compiler)) {
                compiler.currentType = types_1.Type.v128;
                return module.unreachable();
            }
            let arg0 = compiler.compileExpression(operands[0], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            let arg1 = compiler.compileExpression(operands[1], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            return module.binary(module_1.BinaryOp.AndNotV128, arg0, arg1);
        }
        case BuiltinSymbols.v128_not: { // not(a: v128) -> v128
            if (checkFeatureEnabled(16 /* SIMD */, reportNode, compiler) |
                checkTypeAbsent(typeArguments, reportNode, prototype) |
                checkArgsRequired(operands, 1, reportNode, compiler)) {
                compiler.currentType = types_1.Type.v128;
                return module.unreachable();
            }
            let arg0 = compiler.compileExpression(operands[0], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            return module.unary(module_1.UnaryOp.NotV128, arg0);
        }
        case BuiltinSymbols.v128_bitselect: { // bitselect(v1: v128, v2: v128, c: v128) -> v128
            if (checkFeatureEnabled(16 /* SIMD */, reportNode, compiler) |
                checkTypeAbsent(typeArguments, reportNode, prototype) |
                checkArgsRequired(operands, 3, reportNode, compiler)) {
                compiler.currentType = types_1.Type.v128;
                return module.unreachable();
            }
            let arg0 = compiler.compileExpression(operands[0], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            let arg1 = compiler.compileExpression(operands[1], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            let arg2 = compiler.compileExpression(operands[2], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            return module.simd_ternary(module_1.SIMDTernaryOp.Bitselect, arg0, arg1, arg2);
        }
        case BuiltinSymbols.v128_any_true: { // any_true<T!>(a: v128) -> bool
            if (checkFeatureEnabled(16 /* SIMD */, reportNode, compiler) |
                checkTypeRequired(typeArguments, reportNode, compiler) |
                checkArgsRequired(operands, 1, reportNode, compiler)) {
                compiler.currentType = types_1.Type.bool;
                return module.unreachable();
            }
            let type = typeArguments[0];
            let arg0 = compiler.compileExpression(operands[0], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            compiler.currentType = types_1.Type.bool;
            if (!type.is(256 /* REFERENCE */)) {
                switch (type.kind) {
                    case 0 /* I8 */:
                    case 5 /* U8 */: return module.unary(module_1.UnaryOp.AnyTrueI8x16, arg0);
                    case 1 /* I16 */:
                    case 6 /* U16 */: return module.unary(module_1.UnaryOp.AnyTrueI16x8, arg0);
                    case 2 /* I32 */:
                    case 7 /* U32 */: return module.unary(module_1.UnaryOp.AnyTrueI32x4, arg0);
                    case 3 /* I64 */:
                    case 8 /* U64 */: return module.unary(module_1.UnaryOp.AnyTrueI64x2, arg0);
                    case 4 /* ISIZE */:
                    case 9 /* USIZE */: {
                        return module.unary(compiler.options.isWasm64
                            ? module_1.UnaryOp.AnyTrueI64x2
                            : module_1.UnaryOp.AnyTrueI32x4, arg0);
                    }
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "v128.any_true", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.v128_all_true: { // all_true<T!>(a: v128) -> bool
            if (checkFeatureEnabled(16 /* SIMD */, reportNode, compiler) |
                checkTypeRequired(typeArguments, reportNode, compiler) |
                checkArgsRequired(operands, 1, reportNode, compiler)) {
                compiler.currentType = types_1.Type.bool;
                return module.unreachable();
            }
            let type = typeArguments[0];
            let arg0 = compiler.compileExpression(operands[0], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            compiler.currentType = types_1.Type.bool;
            if (!type.is(256 /* REFERENCE */)) {
                switch (type.kind) {
                    case 0 /* I8 */:
                    case 5 /* U8 */: return module.unary(module_1.UnaryOp.AllTrueI8x16, arg0);
                    case 1 /* I16 */:
                    case 6 /* U16 */: return module.unary(module_1.UnaryOp.AllTrueI16x8, arg0);
                    case 2 /* I32 */:
                    case 7 /* U32 */: return module.unary(module_1.UnaryOp.AllTrueI32x4, arg0);
                    case 3 /* I64 */:
                    case 8 /* U64 */: return module.unary(module_1.UnaryOp.AllTrueI64x2, arg0);
                    case 4 /* ISIZE */:
                    case 9 /* USIZE */: {
                        return module.unary(compiler.options.isWasm64
                            ? module_1.UnaryOp.AllTrueI64x2
                            : module_1.UnaryOp.AllTrueI32x4, arg0);
                    }
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "v128.all_true", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.v128_qfma: { // qfma(a: v128, b: v128, c: v128) -> v128
            if (checkFeatureEnabled(16 /* SIMD */, reportNode, compiler) |
                checkTypeRequired(typeArguments, reportNode, compiler) |
                checkArgsRequired(operands, 3, reportNode, compiler)) {
                compiler.currentType = types_1.Type.v128;
                return module.unreachable();
            }
            let type = typeArguments[0];
            let arg0 = compiler.compileExpression(operands[0], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            let arg1 = compiler.compileExpression(operands[1], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            let arg2 = compiler.compileExpression(operands[2], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            if (!type.is(256 /* REFERENCE */)) {
                switch (type.kind) {
                    case 11 /* F32 */: return module.simd_ternary(module_1.SIMDTernaryOp.QFMAF32x4, arg0, arg1, arg2);
                    case 12 /* F64 */: return module.simd_ternary(module_1.SIMDTernaryOp.QFMAF64x2, arg0, arg1, arg2);
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "v128.qfma", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.v128_qfms: { // qfms(a: v128, b: v128, c: v128) -> v128
            if (checkFeatureEnabled(16 /* SIMD */, reportNode, compiler) |
                checkTypeRequired(typeArguments, reportNode, compiler) |
                checkArgsRequired(operands, 3, reportNode, compiler)) {
                compiler.currentType = types_1.Type.v128;
                return module.unreachable();
            }
            let type = typeArguments[0];
            let arg0 = compiler.compileExpression(operands[0], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            let arg1 = compiler.compileExpression(operands[1], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            let arg2 = compiler.compileExpression(operands[2], types_1.Type.v128, 1 /* CONV_IMPLICIT */);
            if (!type.is(256 /* REFERENCE */)) {
                switch (type.kind) {
                    case 11 /* F32 */: return module.simd_ternary(module_1.SIMDTernaryOp.QFMSF32x4, arg0, arg1, arg2);
                    case 12 /* F64 */: return module.simd_ternary(module_1.SIMDTernaryOp.QFMSF64x2, arg0, arg1, arg2);
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "v128.qfms", type.toString());
            return module.unreachable();
        }
        // === Internal runtime =======================================================================
        case BuiltinSymbols.idof: {
            let type = evaluateConstantType(compiler, typeArguments, operands, reportNode);
            compiler.currentType = types_1.Type.u32;
            if (!type)
                return module.unreachable();
            if (type.is(256 /* REFERENCE */)) {
                let signatureReference = type.signatureReference;
                if (signatureReference) {
                    return module.i32(signatureReference.id);
                }
                let classReference = type.classReference;
                if (classReference !== null && !classReference.hasDecorator(program_1.DecoratorFlags.UNMANAGED)) {
                    return module.i32(classReference.id);
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "idof", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.visit_globals: {
            if (checkTypeAbsent(typeArguments, reportNode, prototype) |
                checkArgsRequired(operands, 1, reportNode, compiler) // cookie
            ) {
                compiler.currentType = types_1.Type.void;
                return module.unreachable();
            }
            let arg0 = compiler.compileExpression(operands[0], types_1.Type.u32, 1 /* CONV_IMPLICIT */);
            compiler.runtimeFeatures |= 4 /* visitGlobals */;
            compiler.currentType = types_1.Type.void;
            return module.call(BuiltinSymbols.visit_globals, [arg0], module_1.NativeType.None);
        }
        case BuiltinSymbols.visit_members: {
            if (checkTypeAbsent(typeArguments, reportNode, prototype) |
                checkArgsRequired(operands, 2, reportNode, compiler) // ref, cookie
            ) {
                compiler.currentType = types_1.Type.void;
                return module.unreachable();
            }
            let arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, 1 /* CONV_IMPLICIT */);
            let arg1 = compiler.compileExpression(operands[1], types_1.Type.u32, 1 /* CONV_IMPLICIT */);
            compiler.runtimeFeatures |= 8 /* visitMembers */;
            compiler.currentType = types_1.Type.void;
            return module.call(BuiltinSymbols.visit_members, [arg0, arg1], module_1.NativeType.None);
        }
        case BuiltinSymbols.isNaN: {
            if (checkTypeOptional(typeArguments, reportNode, compiler) |
                checkArgsRequired(operands, 1, reportNode, compiler)) {
                compiler.currentType = types_1.Type.bool;
                return module.unreachable();
            }
            let arg0 = typeArguments
                ? compiler.compileExpression(operands[0], typeArguments[0], 1 /* CONV_IMPLICIT */)
                : compiler.compileExpression(operands[0], types_1.Type.auto);
            let type = compiler.currentType;
            compiler.currentType = types_1.Type.bool;
            if (!type.is(256 /* REFERENCE */)) {
                switch (type.kind) {
                    // never NaN
                    case 0 /* I8 */:
                    case 1 /* I16 */:
                    case 2 /* I32 */:
                    case 3 /* I64 */:
                    case 4 /* ISIZE */:
                    case 5 /* U8 */:
                    case 6 /* U16 */:
                    case 7 /* U32 */:
                    case 8 /* U64 */:
                    case 9 /* USIZE */: {
                        return module_1.hasSideEffects(arg0)
                            ? module.block(null, [
                                module.drop(arg0),
                                module.i32(0)
                            ], module_1.NativeType.I32)
                            : module.i32(0);
                    }
                    // (t = arg0) != t
                    case 11 /* F32 */: {
                        if (module_1.getExpressionId(arg0) == module_1.ExpressionId.LocalGet) {
                            return module.binary(module_1.BinaryOp.NeF32, arg0, module.local_get(module_1.getLocalGetIndex(arg0), module_1.NativeType.F32));
                        }
                        let flow = compiler.currentFlow;
                        let temp = flow.getTempLocal(types_1.Type.f32);
                        let ret = module.binary(module_1.BinaryOp.NeF32, module.local_tee(temp.index, arg0), module.local_get(temp.index, module_1.NativeType.F32));
                        flow.freeTempLocal(temp);
                        return ret;
                    }
                    case 12 /* F64 */: {
                        if (module_1.getExpressionId(arg0) == module_1.ExpressionId.LocalGet) {
                            return module.binary(module_1.BinaryOp.NeF64, arg0, module.local_get(module_1.getLocalGetIndex(arg0), module_1.NativeType.F64));
                        }
                        let flow = compiler.currentFlow;
                        let temp = flow.getTempLocal(types_1.Type.f64);
                        let ret = module.binary(module_1.BinaryOp.NeF64, module.local_tee(temp.index, arg0), module.local_get(temp.index, module_1.NativeType.F64));
                        flow.freeTempLocal(temp);
                        return ret;
                    }
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "isNaN", type.toString());
            return module.unreachable();
        }
        case BuiltinSymbols.isFinite: {
            if (checkTypeOptional(typeArguments, reportNode, compiler) |
                checkArgsRequired(operands, 1, reportNode, compiler)) {
                compiler.currentType = types_1.Type.bool;
                return module.unreachable();
            }
            let arg0 = typeArguments
                ? compiler.compileExpression(operands[0], typeArguments[0], 1 /* CONV_IMPLICIT */)
                : compiler.compileExpression(operands[0], types_1.Type.auto);
            let type = compiler.currentType;
            compiler.currentType = types_1.Type.bool;
            if (!type.is(256 /* REFERENCE */)) {
                switch (type.kind) {
                    // always finite
                    case 0 /* I8 */:
                    case 1 /* I16 */:
                    case 2 /* I32 */:
                    case 3 /* I64 */:
                    case 4 /* ISIZE */:
                    case 5 /* U8 */:
                    case 6 /* U16 */:
                    case 7 /* U32 */:
                    case 8 /* U64 */:
                    case 9 /* USIZE */: {
                        return module_1.hasSideEffects(arg0)
                            ? module.block(null, [
                                module.drop(arg0),
                                module.i32(1)
                            ], module_1.NativeType.I32)
                            : module.i32(1);
                    }
                    // (t = arg0) - t == 0
                    case 11 /* F32 */: {
                        if (module_1.getExpressionId(arg0) == module_1.ExpressionId.LocalGet) {
                            return module.binary(module_1.BinaryOp.EqF32, module.binary(module_1.BinaryOp.SubF32, arg0, module.local_get(module_1.getLocalGetIndex(arg0), module_1.NativeType.F32)), module.f32(0));
                        }
                        let flow = compiler.currentFlow;
                        let temp = flow.getTempLocal(types_1.Type.f32);
                        let ret = module.binary(module_1.BinaryOp.EqF32, module.binary(module_1.BinaryOp.SubF32, module.local_tee(temp.index, arg0), module.local_get(temp.index, module_1.NativeType.F32)), module.f32(0));
                        flow.freeTempLocal(temp);
                        return ret;
                    }
                    case 12 /* F64 */: {
                        if (module_1.getExpressionId(arg0) == module_1.ExpressionId.LocalGet) {
                            return module.binary(module_1.BinaryOp.EqF64, module.binary(module_1.BinaryOp.SubF64, arg0, module.local_get(module_1.getLocalGetIndex(arg0), module_1.NativeType.F64)), module.f64(0));
                        }
                        let flow = compiler.currentFlow;
                        let temp = flow.getTempLocal(types_1.Type.f64);
                        let ret = module.binary(module_1.BinaryOp.EqF64, module.binary(module_1.BinaryOp.SubF64, module.local_tee(temp.index, arg0), module.local_get(temp.index, module_1.NativeType.F64)), module.f64(0));
                        flow.freeTempLocal(temp);
                        return ret;
                    }
                }
            }
            compiler.error(diagnostics_1.DiagnosticCode.Operation_0_cannot_be_applied_to_type_1, reportNode.typeArgumentsRange, "isFinite", type.toString());
            return module.unreachable();
        }
    }
    // try to defer inline asm to a concrete built-in
    {
        let expr = tryDeferASM(compiler, prototype, operands, reportNode);
        if (expr) {
            if (typeArguments) {
                compiler.error(diagnostics_1.DiagnosticCode.Type_0_is_not_generic, reportNode.typeArgumentsRange, prototype.internalName);
            }
            return expr;
        }
    }
    compiler.error(diagnostics_1.DiagnosticCode.Not_implemented, reportNode.expression.range);
    return module.unreachable();
}
exports.compileCall = compileCall;
/** Tries to defer an inline-assembler-like call to a built-in function. */
function tryDeferASM(compiler, prototype, operands, reportNode) {
    /* tslint:disable:max-line-length */
    switch (prototype.internalName) {
        // TODO: Operators can't be just deferred (don't have a corresponding generic built-in)
        //   add, sub, mul, div_s, div_u, rem_s, rem_u
        //   and, or, xor, shl, shr_u, shr_s
        //   eq, eqz, ne, lt_s, lt_u, le_s, le_u, gt_s, gt_u, ge_s, ge_u
        case BuiltinSymbols.i32_clz: return deferASM(BuiltinSymbols.clz, compiler, types_1.Type.i32, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i64_clz: return deferASM(BuiltinSymbols.clz, compiler, types_1.Type.i64, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i32_ctz: return deferASM(BuiltinSymbols.ctz, compiler, types_1.Type.i32, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i64_ctz: return deferASM(BuiltinSymbols.ctz, compiler, types_1.Type.i64, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i32_popcnt: return deferASM(BuiltinSymbols.popcnt, compiler, types_1.Type.i32, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i64_popcnt: return deferASM(BuiltinSymbols.popcnt, compiler, types_1.Type.i64, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i32_rotl: return deferASM(BuiltinSymbols.rotl, compiler, types_1.Type.i32, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i64_rotl: return deferASM(BuiltinSymbols.rotl, compiler, types_1.Type.i64, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i32_rotr: return deferASM(BuiltinSymbols.rotr, compiler, types_1.Type.i32, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i64_rotr: return deferASM(BuiltinSymbols.rotr, compiler, types_1.Type.i64, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.f32_abs: return deferASM(BuiltinSymbols.abs, compiler, types_1.Type.f32, operands, types_1.Type.f32, reportNode);
        case BuiltinSymbols.f64_abs: return deferASM(BuiltinSymbols.abs, compiler, types_1.Type.f64, operands, types_1.Type.f64, reportNode);
        case BuiltinSymbols.f32_max: return deferASM(BuiltinSymbols.max, compiler, types_1.Type.f32, operands, types_1.Type.f32, reportNode);
        case BuiltinSymbols.f64_max: return deferASM(BuiltinSymbols.max, compiler, types_1.Type.f64, operands, types_1.Type.f64, reportNode);
        case BuiltinSymbols.f32_min: return deferASM(BuiltinSymbols.min, compiler, types_1.Type.f32, operands, types_1.Type.f32, reportNode);
        case BuiltinSymbols.f64_min: return deferASM(BuiltinSymbols.min, compiler, types_1.Type.f64, operands, types_1.Type.f64, reportNode);
        case BuiltinSymbols.f32_ceil: return deferASM(BuiltinSymbols.ceil, compiler, types_1.Type.f32, operands, types_1.Type.f32, reportNode);
        case BuiltinSymbols.f64_ceil: return deferASM(BuiltinSymbols.ceil, compiler, types_1.Type.f64, operands, types_1.Type.f64, reportNode);
        case BuiltinSymbols.f32_floor: return deferASM(BuiltinSymbols.floor, compiler, types_1.Type.f32, operands, types_1.Type.f32, reportNode);
        case BuiltinSymbols.f64_floor: return deferASM(BuiltinSymbols.floor, compiler, types_1.Type.f64, operands, types_1.Type.f64, reportNode);
        case BuiltinSymbols.f32_copysign: return deferASM(BuiltinSymbols.copysign, compiler, types_1.Type.f32, operands, types_1.Type.f32, reportNode);
        case BuiltinSymbols.f64_copysign: return deferASM(BuiltinSymbols.copysign, compiler, types_1.Type.f64, operands, types_1.Type.f64, reportNode);
        case BuiltinSymbols.f32_nearest: return deferASM(BuiltinSymbols.nearest, compiler, types_1.Type.f32, operands, types_1.Type.f32, reportNode);
        case BuiltinSymbols.f64_nearest: return deferASM(BuiltinSymbols.nearest, compiler, types_1.Type.f64, operands, types_1.Type.f64, reportNode);
        case BuiltinSymbols.i32_reinterpret_f32: return deferASM(BuiltinSymbols.reinterpret, compiler, types_1.Type.i32, operands, types_1.Type.f32, reportNode);
        case BuiltinSymbols.i64_reinterpret_f64: return deferASM(BuiltinSymbols.reinterpret, compiler, types_1.Type.i64, operands, types_1.Type.f64, reportNode);
        case BuiltinSymbols.f32_reinterpret_i32: return deferASM(BuiltinSymbols.reinterpret, compiler, types_1.Type.f32, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.f64_reinterpret_i64: return deferASM(BuiltinSymbols.reinterpret, compiler, types_1.Type.f64, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.f32_sqrt: return deferASM(BuiltinSymbols.sqrt, compiler, types_1.Type.f32, operands, types_1.Type.f32, reportNode);
        case BuiltinSymbols.f64_sqrt: return deferASM(BuiltinSymbols.sqrt, compiler, types_1.Type.f64, operands, types_1.Type.f64, reportNode);
        case BuiltinSymbols.f32_trunc: return deferASM(BuiltinSymbols.trunc, compiler, types_1.Type.f32, operands, types_1.Type.f32, reportNode);
        case BuiltinSymbols.f64_trunc: return deferASM(BuiltinSymbols.trunc, compiler, types_1.Type.f64, operands, types_1.Type.f64, reportNode);
        case BuiltinSymbols.i32_load8_s: return deferASM(BuiltinSymbols.load, compiler, types_1.Type.i8, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i32_load8_u: return deferASM(BuiltinSymbols.load, compiler, types_1.Type.u8, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i32_load16_s: return deferASM(BuiltinSymbols.load, compiler, types_1.Type.i16, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i32_load16_u: return deferASM(BuiltinSymbols.load, compiler, types_1.Type.u16, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i32_load: return deferASM(BuiltinSymbols.load, compiler, types_1.Type.i32, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i64_load8_s: return deferASM(BuiltinSymbols.load, compiler, types_1.Type.i8, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i64_load8_u: return deferASM(BuiltinSymbols.load, compiler, types_1.Type.u8, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i64_load16_s: return deferASM(BuiltinSymbols.load, compiler, types_1.Type.i16, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i64_load16_u: return deferASM(BuiltinSymbols.load, compiler, types_1.Type.u16, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i64_load32_s: return deferASM(BuiltinSymbols.load, compiler, types_1.Type.i32, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i64_load32_u: return deferASM(BuiltinSymbols.load, compiler, types_1.Type.u32, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i64_load: return deferASM(BuiltinSymbols.load, compiler, types_1.Type.i64, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.f32_load: return deferASM(BuiltinSymbols.load, compiler, types_1.Type.f32, operands, types_1.Type.f32, reportNode);
        case BuiltinSymbols.f64_load: return deferASM(BuiltinSymbols.load, compiler, types_1.Type.f64, operands, types_1.Type.f64, reportNode);
        case BuiltinSymbols.i32_store8: return deferASM(BuiltinSymbols.store, compiler, types_1.Type.i8, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i32_store16: return deferASM(BuiltinSymbols.store, compiler, types_1.Type.i16, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i32_store: return deferASM(BuiltinSymbols.store, compiler, types_1.Type.i32, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i64_store8: return deferASM(BuiltinSymbols.store, compiler, types_1.Type.i8, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i64_store16: return deferASM(BuiltinSymbols.store, compiler, types_1.Type.i16, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i64_store32: return deferASM(BuiltinSymbols.store, compiler, types_1.Type.i32, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i64_store: return deferASM(BuiltinSymbols.store, compiler, types_1.Type.i64, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.f32_store: return deferASM(BuiltinSymbols.store, compiler, types_1.Type.f32, operands, types_1.Type.f32, reportNode);
        case BuiltinSymbols.f64_store: return deferASM(BuiltinSymbols.store, compiler, types_1.Type.f64, operands, types_1.Type.f64, reportNode);
        case BuiltinSymbols.i32_atomic_load8_u: return deferASM(BuiltinSymbols.atomic_load, compiler, types_1.Type.u8, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i32_atomic_load16_u: return deferASM(BuiltinSymbols.atomic_load, compiler, types_1.Type.u16, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i32_atomic_load: return deferASM(BuiltinSymbols.atomic_load, compiler, types_1.Type.i32, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i64_atomic_load8_u: return deferASM(BuiltinSymbols.atomic_load, compiler, types_1.Type.u8, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i64_atomic_load16_u: return deferASM(BuiltinSymbols.atomic_load, compiler, types_1.Type.u16, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i64_atomic_load32_u: return deferASM(BuiltinSymbols.atomic_load, compiler, types_1.Type.u32, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i64_atomic_load: return deferASM(BuiltinSymbols.atomic_load, compiler, types_1.Type.i64, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i32_atomic_store8: return deferASM(BuiltinSymbols.atomic_store, compiler, types_1.Type.u8, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i32_atomic_store16: return deferASM(BuiltinSymbols.atomic_store, compiler, types_1.Type.u16, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i32_atomic_store: return deferASM(BuiltinSymbols.atomic_store, compiler, types_1.Type.i32, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i64_atomic_store8: return deferASM(BuiltinSymbols.atomic_store, compiler, types_1.Type.u8, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i64_atomic_store16: return deferASM(BuiltinSymbols.atomic_store, compiler, types_1.Type.u16, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i64_atomic_store32: return deferASM(BuiltinSymbols.atomic_store, compiler, types_1.Type.u32, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i64_atomic_store: return deferASM(BuiltinSymbols.atomic_store, compiler, types_1.Type.i64, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i32_atomic_rmw8_add_u: return deferASM(BuiltinSymbols.atomic_add, compiler, types_1.Type.u8, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i32_atomic_rmw16_add_u: return deferASM(BuiltinSymbols.atomic_add, compiler, types_1.Type.u16, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i32_atomic_rmw_add: return deferASM(BuiltinSymbols.atomic_add, compiler, types_1.Type.i32, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i64_atomic_rmw8_add_u: return deferASM(BuiltinSymbols.atomic_add, compiler, types_1.Type.u8, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i64_atomic_rmw16_add_u: return deferASM(BuiltinSymbols.atomic_add, compiler, types_1.Type.u16, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i64_atomic_rmw32_add_u: return deferASM(BuiltinSymbols.atomic_add, compiler, types_1.Type.u32, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i64_atomic_rmw_add: return deferASM(BuiltinSymbols.atomic_add, compiler, types_1.Type.i64, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i32_atomic_rmw8_sub_u: return deferASM(BuiltinSymbols.atomic_sub, compiler, types_1.Type.u8, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i32_atomic_rmw16_sub_u: return deferASM(BuiltinSymbols.atomic_sub, compiler, types_1.Type.u16, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i32_atomic_rmw_sub: return deferASM(BuiltinSymbols.atomic_sub, compiler, types_1.Type.i32, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i64_atomic_rmw8_sub_u: return deferASM(BuiltinSymbols.atomic_sub, compiler, types_1.Type.u8, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i64_atomic_rmw16_sub_u: return deferASM(BuiltinSymbols.atomic_sub, compiler, types_1.Type.u16, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i64_atomic_rmw32_sub_u: return deferASM(BuiltinSymbols.atomic_sub, compiler, types_1.Type.u32, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i64_atomic_rmw_sub: return deferASM(BuiltinSymbols.atomic_sub, compiler, types_1.Type.i64, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i32_atomic_rmw8_and_u: return deferASM(BuiltinSymbols.atomic_and, compiler, types_1.Type.u8, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i32_atomic_rmw16_and_u: return deferASM(BuiltinSymbols.atomic_and, compiler, types_1.Type.u16, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i32_atomic_rmw_and: return deferASM(BuiltinSymbols.atomic_and, compiler, types_1.Type.i32, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i64_atomic_rmw8_and_u: return deferASM(BuiltinSymbols.atomic_and, compiler, types_1.Type.u8, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i64_atomic_rmw16_and_u: return deferASM(BuiltinSymbols.atomic_and, compiler, types_1.Type.u16, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i64_atomic_rmw32_and_u: return deferASM(BuiltinSymbols.atomic_and, compiler, types_1.Type.u32, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i64_atomic_rmw_and: return deferASM(BuiltinSymbols.atomic_and, compiler, types_1.Type.i64, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i32_atomic_rmw8_or_u: return deferASM(BuiltinSymbols.atomic_or, compiler, types_1.Type.u8, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i32_atomic_rmw16_or_u: return deferASM(BuiltinSymbols.atomic_or, compiler, types_1.Type.u16, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i32_atomic_rmw_or: return deferASM(BuiltinSymbols.atomic_or, compiler, types_1.Type.i32, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i64_atomic_rmw8_or_u: return deferASM(BuiltinSymbols.atomic_or, compiler, types_1.Type.u8, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i64_atomic_rmw16_or_u: return deferASM(BuiltinSymbols.atomic_or, compiler, types_1.Type.u16, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i64_atomic_rmw32_or_u: return deferASM(BuiltinSymbols.atomic_or, compiler, types_1.Type.u32, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i64_atomic_rmw_or: return deferASM(BuiltinSymbols.atomic_or, compiler, types_1.Type.i64, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i32_atomic_rmw8_xor_u: return deferASM(BuiltinSymbols.atomic_xor, compiler, types_1.Type.u8, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i32_atomic_rmw16_xor_u: return deferASM(BuiltinSymbols.atomic_xor, compiler, types_1.Type.u16, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i32_atomic_rmw_xor: return deferASM(BuiltinSymbols.atomic_xor, compiler, types_1.Type.i32, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i64_atomic_rmw8_xor_u: return deferASM(BuiltinSymbols.atomic_xor, compiler, types_1.Type.u8, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i64_atomic_rmw16_xor_u: return deferASM(BuiltinSymbols.atomic_xor, compiler, types_1.Type.u16, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i64_atomic_rmw32_xor_u: return deferASM(BuiltinSymbols.atomic_xor, compiler, types_1.Type.u32, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i64_atomic_rmw_xor: return deferASM(BuiltinSymbols.atomic_xor, compiler, types_1.Type.i64, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i32_atomic_rmw8_xchg_u: return deferASM(BuiltinSymbols.atomic_xchg, compiler, types_1.Type.u8, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i32_atomic_rmw16_xchg_u: return deferASM(BuiltinSymbols.atomic_xchg, compiler, types_1.Type.u16, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i32_atomic_rmw_xchg: return deferASM(BuiltinSymbols.atomic_xchg, compiler, types_1.Type.i32, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i64_atomic_rmw8_xchg_u: return deferASM(BuiltinSymbols.atomic_xchg, compiler, types_1.Type.u8, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i64_atomic_rmw16_xchg_u: return deferASM(BuiltinSymbols.atomic_xchg, compiler, types_1.Type.u16, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i64_atomic_rmw32_xchg_u: return deferASM(BuiltinSymbols.atomic_xchg, compiler, types_1.Type.u32, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i64_atomic_rmw_xchg: return deferASM(BuiltinSymbols.atomic_xchg, compiler, types_1.Type.i64, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i32_atomic_rmw8_cmpxchg_u: return deferASM(BuiltinSymbols.atomic_cmpxchg, compiler, types_1.Type.u8, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i32_atomic_rmw16_cmpxchg_u: return deferASM(BuiltinSymbols.atomic_cmpxchg, compiler, types_1.Type.u16, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i32_atomic_rmw_cmpxchg: return deferASM(BuiltinSymbols.atomic_cmpxchg, compiler, types_1.Type.i32, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i64_atomic_rmw8_cmpxchg_u: return deferASM(BuiltinSymbols.atomic_cmpxchg, compiler, types_1.Type.u8, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i64_atomic_rmw16_cmpxchg_u: return deferASM(BuiltinSymbols.atomic_cmpxchg, compiler, types_1.Type.u16, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i64_atomic_rmw32_cmpxchg_u: return deferASM(BuiltinSymbols.atomic_cmpxchg, compiler, types_1.Type.u32, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i64_atomic_rmw_cmpxchg: return deferASM(BuiltinSymbols.atomic_cmpxchg, compiler, types_1.Type.i64, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i32_wait: return deferASM(BuiltinSymbols.atomic_wait, compiler, types_1.Type.i32, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i64_wait: return deferASM(BuiltinSymbols.atomic_wait, compiler, types_1.Type.i64, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.v128_load: return deferASM(BuiltinSymbols.load, compiler, types_1.Type.v128, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.v128_store: return deferASM(BuiltinSymbols.store, compiler, types_1.Type.v128, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i8x16_splat: return deferASM(BuiltinSymbols.v128_splat, compiler, types_1.Type.i8, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i8x16_extract_lane_s: return deferASM(BuiltinSymbols.v128_extract_lane, compiler, types_1.Type.i8, operands, types_1.Type.i8, reportNode);
        case BuiltinSymbols.i8x16_extract_lane_u: return deferASM(BuiltinSymbols.v128_extract_lane, compiler, types_1.Type.u8, operands, types_1.Type.u8, reportNode);
        case BuiltinSymbols.i8x16_replace_lane: return deferASM(BuiltinSymbols.v128_replace_lane, compiler, types_1.Type.i8, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i8x16_add: return deferASM(BuiltinSymbols.v128_add, compiler, types_1.Type.i8, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i8x16_sub: return deferASM(BuiltinSymbols.v128_sub, compiler, types_1.Type.i8, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i8x16_mul: return deferASM(BuiltinSymbols.v128_mul, compiler, types_1.Type.i8, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i8x16_min_s: return deferASM(BuiltinSymbols.v128_min, compiler, types_1.Type.i8, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i8x16_min_u: return deferASM(BuiltinSymbols.v128_min, compiler, types_1.Type.u8, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i8x16_max_s: return deferASM(BuiltinSymbols.v128_max, compiler, types_1.Type.i8, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i8x16_max_u: return deferASM(BuiltinSymbols.v128_max, compiler, types_1.Type.u8, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i8x16_neg: return deferASM(BuiltinSymbols.v128_neg, compiler, types_1.Type.i8, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i8x16_add_saturate_s: return deferASM(BuiltinSymbols.v128_add_saturate, compiler, types_1.Type.i8, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i8x16_add_saturate_u: return deferASM(BuiltinSymbols.v128_add_saturate, compiler, types_1.Type.u8, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i8x16_sub_saturate_s: return deferASM(BuiltinSymbols.v128_sub_saturate, compiler, types_1.Type.i8, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i8x16_sub_saturate_u: return deferASM(BuiltinSymbols.v128_sub_saturate, compiler, types_1.Type.u8, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i8x16_shl: return deferASM(BuiltinSymbols.v128_shl, compiler, types_1.Type.i8, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i8x16_shr_s: return deferASM(BuiltinSymbols.v128_shr, compiler, types_1.Type.i8, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i8x16_shr_u: return deferASM(BuiltinSymbols.v128_shr, compiler, types_1.Type.u8, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i8x16_any_true: return deferASM(BuiltinSymbols.v128_any_true, compiler, types_1.Type.i8, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i8x16_all_true: return deferASM(BuiltinSymbols.v128_all_true, compiler, types_1.Type.i8, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i8x16_eq: return deferASM(BuiltinSymbols.v128_eq, compiler, types_1.Type.i8, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i8x16_ne: return deferASM(BuiltinSymbols.v128_ne, compiler, types_1.Type.i8, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i8x16_lt_s: return deferASM(BuiltinSymbols.v128_lt, compiler, types_1.Type.i8, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i8x16_lt_u: return deferASM(BuiltinSymbols.v128_lt, compiler, types_1.Type.u8, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i8x16_le_s: return deferASM(BuiltinSymbols.v128_le, compiler, types_1.Type.i8, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i8x16_le_u: return deferASM(BuiltinSymbols.v128_le, compiler, types_1.Type.u8, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i8x16_gt_s: return deferASM(BuiltinSymbols.v128_gt, compiler, types_1.Type.i8, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i8x16_gt_u: return deferASM(BuiltinSymbols.v128_gt, compiler, types_1.Type.u8, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i8x16_ge_s: return deferASM(BuiltinSymbols.v128_ge, compiler, types_1.Type.i8, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i8x16_ge_u: return deferASM(BuiltinSymbols.v128_ge, compiler, types_1.Type.u8, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i8x16_narrow_i16x8_s: return deferASM(BuiltinSymbols.v128_narrow, compiler, types_1.Type.i16, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i8x16_narrow_i16x8_u: return deferASM(BuiltinSymbols.v128_narrow, compiler, types_1.Type.u16, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i16x8_splat: return deferASM(BuiltinSymbols.v128_splat, compiler, types_1.Type.i16, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i16x8_extract_lane_s: return deferASM(BuiltinSymbols.v128_extract_lane, compiler, types_1.Type.i16, operands, types_1.Type.i16, reportNode);
        case BuiltinSymbols.i16x8_extract_lane_u: return deferASM(BuiltinSymbols.v128_extract_lane, compiler, types_1.Type.u16, operands, types_1.Type.u16, reportNode);
        case BuiltinSymbols.i16x8_replace_lane: return deferASM(BuiltinSymbols.v128_replace_lane, compiler, types_1.Type.i16, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i16x8_add: return deferASM(BuiltinSymbols.v128_add, compiler, types_1.Type.i16, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i16x8_sub: return deferASM(BuiltinSymbols.v128_sub, compiler, types_1.Type.i16, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i16x8_mul: return deferASM(BuiltinSymbols.v128_mul, compiler, types_1.Type.i16, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i16x8_min_s: return deferASM(BuiltinSymbols.v128_min, compiler, types_1.Type.i16, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i16x8_min_u: return deferASM(BuiltinSymbols.v128_min, compiler, types_1.Type.u16, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i16x8_max_s: return deferASM(BuiltinSymbols.v128_max, compiler, types_1.Type.i16, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i16x8_max_u: return deferASM(BuiltinSymbols.v128_max, compiler, types_1.Type.u16, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i16x8_neg: return deferASM(BuiltinSymbols.v128_neg, compiler, types_1.Type.i16, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i16x8_add_saturate_s: return deferASM(BuiltinSymbols.v128_add_saturate, compiler, types_1.Type.i16, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i16x8_add_saturate_u: return deferASM(BuiltinSymbols.v128_add_saturate, compiler, types_1.Type.u16, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i16x8_sub_saturate_s: return deferASM(BuiltinSymbols.v128_sub_saturate, compiler, types_1.Type.i16, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i16x8_sub_saturate_u: return deferASM(BuiltinSymbols.v128_sub_saturate, compiler, types_1.Type.u16, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i16x8_shl: return deferASM(BuiltinSymbols.v128_shl, compiler, types_1.Type.i16, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i16x8_shr_s: return deferASM(BuiltinSymbols.v128_shr, compiler, types_1.Type.i16, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i16x8_shr_u: return deferASM(BuiltinSymbols.v128_shr, compiler, types_1.Type.u16, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i16x8_any_true: return deferASM(BuiltinSymbols.v128_any_true, compiler, types_1.Type.i16, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i16x8_all_true: return deferASM(BuiltinSymbols.v128_all_true, compiler, types_1.Type.i16, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i16x8_eq: return deferASM(BuiltinSymbols.v128_eq, compiler, types_1.Type.i16, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i16x8_ne: return deferASM(BuiltinSymbols.v128_ne, compiler, types_1.Type.i16, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i16x8_lt_s: return deferASM(BuiltinSymbols.v128_lt, compiler, types_1.Type.i16, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i16x8_lt_u: return deferASM(BuiltinSymbols.v128_lt, compiler, types_1.Type.u16, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i16x8_le_s: return deferASM(BuiltinSymbols.v128_le, compiler, types_1.Type.i16, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i16x8_le_u: return deferASM(BuiltinSymbols.v128_le, compiler, types_1.Type.u16, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i16x8_gt_s: return deferASM(BuiltinSymbols.v128_gt, compiler, types_1.Type.i16, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i16x8_gt_u: return deferASM(BuiltinSymbols.v128_gt, compiler, types_1.Type.u16, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i16x8_ge_s: return deferASM(BuiltinSymbols.v128_ge, compiler, types_1.Type.i16, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i16x8_ge_u: return deferASM(BuiltinSymbols.v128_ge, compiler, types_1.Type.u16, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i16x8_narrow_i32x4_s: return deferASM(BuiltinSymbols.v128_narrow, compiler, types_1.Type.i32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i16x8_narrow_i32x4_u: return deferASM(BuiltinSymbols.v128_narrow, compiler, types_1.Type.u32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i16x8_widen_low_i8x16_s: return deferASM(BuiltinSymbols.v128_widen_low, compiler, types_1.Type.i8, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i16x8_widen_low_i8x16_u: return deferASM(BuiltinSymbols.v128_widen_low, compiler, types_1.Type.u8, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i16x8_widen_high_i8x16_s: return deferASM(BuiltinSymbols.v128_widen_high, compiler, types_1.Type.i8, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i16x8_widen_high_i8x16_u: return deferASM(BuiltinSymbols.v128_widen_high, compiler, types_1.Type.u8, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i16x8_load8x8_s: return deferASM(BuiltinSymbols.v128_load_ext, compiler, types_1.Type.i8, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i16x8_load8x8_u: return deferASM(BuiltinSymbols.v128_load_ext, compiler, types_1.Type.u8, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i32x4_splat: return deferASM(BuiltinSymbols.v128_splat, compiler, types_1.Type.i32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i32x4_extract_lane: return deferASM(BuiltinSymbols.v128_extract_lane, compiler, types_1.Type.i32, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i32x4_replace_lane: return deferASM(BuiltinSymbols.v128_replace_lane, compiler, types_1.Type.i32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i32x4_add: return deferASM(BuiltinSymbols.v128_add, compiler, types_1.Type.i32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i32x4_sub: return deferASM(BuiltinSymbols.v128_sub, compiler, types_1.Type.i32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i32x4_mul: return deferASM(BuiltinSymbols.v128_mul, compiler, types_1.Type.i32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i32x4_min_s: return deferASM(BuiltinSymbols.v128_min, compiler, types_1.Type.i32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i32x4_min_u: return deferASM(BuiltinSymbols.v128_min, compiler, types_1.Type.u32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i32x4_max_s: return deferASM(BuiltinSymbols.v128_max, compiler, types_1.Type.i32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i32x4_max_u: return deferASM(BuiltinSymbols.v128_max, compiler, types_1.Type.u32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i32x4_dot_i16x8_s: return deferASM(BuiltinSymbols.v128_dot, compiler, types_1.Type.i16, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i32x4_neg: return deferASM(BuiltinSymbols.v128_neg, compiler, types_1.Type.i32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i32x4_shl: return deferASM(BuiltinSymbols.v128_shl, compiler, types_1.Type.i32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i32x4_shr_s: return deferASM(BuiltinSymbols.v128_shr, compiler, types_1.Type.i32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i32x4_shr_u: return deferASM(BuiltinSymbols.v128_shr, compiler, types_1.Type.u32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i32x4_any_true: return deferASM(BuiltinSymbols.v128_any_true, compiler, types_1.Type.i32, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i32x4_all_true: return deferASM(BuiltinSymbols.v128_all_true, compiler, types_1.Type.i32, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i32x4_eq: return deferASM(BuiltinSymbols.v128_eq, compiler, types_1.Type.i32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i32x4_ne: return deferASM(BuiltinSymbols.v128_ne, compiler, types_1.Type.i32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i32x4_lt_s: return deferASM(BuiltinSymbols.v128_lt, compiler, types_1.Type.i32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i32x4_lt_u: return deferASM(BuiltinSymbols.v128_lt, compiler, types_1.Type.u32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i32x4_le_s: return deferASM(BuiltinSymbols.v128_le, compiler, types_1.Type.i32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i32x4_le_u: return deferASM(BuiltinSymbols.v128_le, compiler, types_1.Type.u32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i32x4_gt_s: return deferASM(BuiltinSymbols.v128_gt, compiler, types_1.Type.i32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i32x4_gt_u: return deferASM(BuiltinSymbols.v128_gt, compiler, types_1.Type.u32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i32x4_ge_s: return deferASM(BuiltinSymbols.v128_ge, compiler, types_1.Type.i32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i32x4_ge_u: return deferASM(BuiltinSymbols.v128_ge, compiler, types_1.Type.u32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i32x4_trunc_sat_f32x4_s: return deferASM(BuiltinSymbols.v128_trunc_sat, compiler, types_1.Type.i32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i32x4_trunc_sat_f32x4_u: return deferASM(BuiltinSymbols.v128_trunc_sat, compiler, types_1.Type.u32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i32x4_widen_low_i16x8_s: return deferASM(BuiltinSymbols.v128_widen_low, compiler, types_1.Type.i16, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i32x4_widen_low_i16x8_u: return deferASM(BuiltinSymbols.v128_widen_low, compiler, types_1.Type.u16, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i32x4_widen_high_i16x8_s: return deferASM(BuiltinSymbols.v128_widen_high, compiler, types_1.Type.i16, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i32x4_widen_high_i16x8_u: return deferASM(BuiltinSymbols.v128_widen_high, compiler, types_1.Type.u16, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i32x4_load16x4_s: return deferASM(BuiltinSymbols.v128_load_ext, compiler, types_1.Type.i16, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i32x4_load16x4_u: return deferASM(BuiltinSymbols.v128_load_ext, compiler, types_1.Type.u16, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i64x2_splat: return deferASM(BuiltinSymbols.v128_splat, compiler, types_1.Type.i64, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i64x2_extract_lane: return deferASM(BuiltinSymbols.v128_extract_lane, compiler, types_1.Type.i64, operands, types_1.Type.i64, reportNode);
        case BuiltinSymbols.i64x2_replace_lane: return deferASM(BuiltinSymbols.v128_replace_lane, compiler, types_1.Type.i64, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i64x2_add: return deferASM(BuiltinSymbols.v128_add, compiler, types_1.Type.i64, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i64x2_sub: return deferASM(BuiltinSymbols.v128_sub, compiler, types_1.Type.i64, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i64x2_neg: return deferASM(BuiltinSymbols.v128_neg, compiler, types_1.Type.i64, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i64x2_shl: return deferASM(BuiltinSymbols.v128_shl, compiler, types_1.Type.i64, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i64x2_shr_s: return deferASM(BuiltinSymbols.v128_shr, compiler, types_1.Type.i64, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i64x2_shr_u: return deferASM(BuiltinSymbols.v128_shr, compiler, types_1.Type.u64, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i64x2_any_true: return deferASM(BuiltinSymbols.v128_any_true, compiler, types_1.Type.i64, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i64x2_all_true: return deferASM(BuiltinSymbols.v128_all_true, compiler, types_1.Type.i64, operands, types_1.Type.i32, reportNode);
        case BuiltinSymbols.i64x2_trunc_sat_f64x2_s: return deferASM(BuiltinSymbols.v128_trunc_sat, compiler, types_1.Type.i64, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i64x2_trunc_sat_f64x2_u: return deferASM(BuiltinSymbols.v128_trunc_sat, compiler, types_1.Type.u64, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i64x2_load32x2_s: return deferASM(BuiltinSymbols.v128_load_ext, compiler, types_1.Type.i32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.i64x2_load32x2_u: return deferASM(BuiltinSymbols.v128_load_ext, compiler, types_1.Type.u32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.f32x4_splat: return deferASM(BuiltinSymbols.v128_splat, compiler, types_1.Type.f32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.f32x4_extract_lane: return deferASM(BuiltinSymbols.v128_extract_lane, compiler, types_1.Type.f32, operands, types_1.Type.f32, reportNode);
        case BuiltinSymbols.f32x4_replace_lane: return deferASM(BuiltinSymbols.v128_replace_lane, compiler, types_1.Type.f32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.f32x4_add: return deferASM(BuiltinSymbols.v128_add, compiler, types_1.Type.f32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.f32x4_sub: return deferASM(BuiltinSymbols.v128_sub, compiler, types_1.Type.f32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.f32x4_mul: return deferASM(BuiltinSymbols.v128_mul, compiler, types_1.Type.f32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.f32x4_div: return deferASM(BuiltinSymbols.v128_div, compiler, types_1.Type.f32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.f32x4_neg: return deferASM(BuiltinSymbols.v128_neg, compiler, types_1.Type.f32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.f32x4_min: return deferASM(BuiltinSymbols.v128_min, compiler, types_1.Type.f32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.f32x4_max: return deferASM(BuiltinSymbols.v128_max, compiler, types_1.Type.f32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.f32x4_abs: return deferASM(BuiltinSymbols.v128_abs, compiler, types_1.Type.f32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.f32x4_sqrt: return deferASM(BuiltinSymbols.v128_sqrt, compiler, types_1.Type.f32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.f32x4_eq: return deferASM(BuiltinSymbols.v128_eq, compiler, types_1.Type.f32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.f32x4_ne: return deferASM(BuiltinSymbols.v128_ne, compiler, types_1.Type.f32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.f32x4_lt: return deferASM(BuiltinSymbols.v128_lt, compiler, types_1.Type.f32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.f32x4_le: return deferASM(BuiltinSymbols.v128_le, compiler, types_1.Type.f32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.f32x4_gt: return deferASM(BuiltinSymbols.v128_gt, compiler, types_1.Type.f32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.f32x4_ge: return deferASM(BuiltinSymbols.v128_ge, compiler, types_1.Type.f32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.f32x4_convert_i32x4_s: return deferASM(BuiltinSymbols.v128_convert, compiler, types_1.Type.i32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.f32x4_convert_i32x4_u: return deferASM(BuiltinSymbols.v128_convert, compiler, types_1.Type.u32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.f32x4_qfma: return deferASM(BuiltinSymbols.v128_qfma, compiler, types_1.Type.f32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.f32x4_qfms: return deferASM(BuiltinSymbols.v128_qfms, compiler, types_1.Type.f32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.f64x2_splat: return deferASM(BuiltinSymbols.v128_splat, compiler, types_1.Type.f64, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.f64x2_extract_lane: return deferASM(BuiltinSymbols.v128_extract_lane, compiler, types_1.Type.f64, operands, types_1.Type.f64, reportNode);
        case BuiltinSymbols.f64x2_replace_lane: return deferASM(BuiltinSymbols.v128_replace_lane, compiler, types_1.Type.f64, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.f64x2_add: return deferASM(BuiltinSymbols.v128_add, compiler, types_1.Type.f64, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.f64x2_sub: return deferASM(BuiltinSymbols.v128_sub, compiler, types_1.Type.f64, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.f64x2_mul: return deferASM(BuiltinSymbols.v128_mul, compiler, types_1.Type.f64, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.f64x2_div: return deferASM(BuiltinSymbols.v128_div, compiler, types_1.Type.f64, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.f64x2_neg: return deferASM(BuiltinSymbols.v128_neg, compiler, types_1.Type.f64, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.f64x2_min: return deferASM(BuiltinSymbols.v128_min, compiler, types_1.Type.f64, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.f64x2_max: return deferASM(BuiltinSymbols.v128_max, compiler, types_1.Type.f64, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.f64x2_abs: return deferASM(BuiltinSymbols.v128_abs, compiler, types_1.Type.f64, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.f64x2_sqrt: return deferASM(BuiltinSymbols.v128_sqrt, compiler, types_1.Type.f64, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.f64x2_eq: return deferASM(BuiltinSymbols.v128_eq, compiler, types_1.Type.f64, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.f64x2_ne: return deferASM(BuiltinSymbols.v128_ne, compiler, types_1.Type.f64, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.f64x2_lt: return deferASM(BuiltinSymbols.v128_lt, compiler, types_1.Type.f64, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.f64x2_le: return deferASM(BuiltinSymbols.v128_le, compiler, types_1.Type.f64, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.f64x2_gt: return deferASM(BuiltinSymbols.v128_gt, compiler, types_1.Type.f64, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.f64x2_ge: return deferASM(BuiltinSymbols.v128_ge, compiler, types_1.Type.f64, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.f64x2_convert_i64x2_s: return deferASM(BuiltinSymbols.v128_convert, compiler, types_1.Type.i64, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.f64x2_convert_i64x2_u: return deferASM(BuiltinSymbols.v128_convert, compiler, types_1.Type.u64, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.f64x2_qfma: return deferASM(BuiltinSymbols.v128_qfma, compiler, types_1.Type.f64, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.f64x2_qfms: return deferASM(BuiltinSymbols.v128_qfms, compiler, types_1.Type.f64, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.v8x16_shuffle: return deferASM(BuiltinSymbols.v128_shuffle, compiler, types_1.Type.i8, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.v8x16_swizzle: return deferASM(BuiltinSymbols.v128_swizzle, compiler, null, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.v8x16_load_splat: return deferASM(BuiltinSymbols.v128_load_splat, compiler, types_1.Type.u8, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.v16x8_load_splat: return deferASM(BuiltinSymbols.v128_load_splat, compiler, types_1.Type.u16, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.v32x4_load_splat: return deferASM(BuiltinSymbols.v128_load_splat, compiler, types_1.Type.u32, operands, types_1.Type.v128, reportNode);
        case BuiltinSymbols.v64x2_load_splat: return deferASM(BuiltinSymbols.v128_load_splat, compiler, types_1.Type.u64, operands, types_1.Type.v128, reportNode);
    }
    /* tslint:enable:max-line-length */
    return 0;
}
/** A helper for deferring inline-assembler-like calls to built-in functions. */
function deferASM(name, compiler, typeArgument, operands, contextualType, reportNode) {
    assert(compiler.program.elementsByName.has(name));
    var prototype = compiler.program.elementsByName.get(name);
    assert(prototype.kind == program_1.ElementKind.FUNCTION_PROTOTYPE);
    return compileCall(compiler, prototype, typeArgument ? [typeArgument] : null, operands, contextualType, reportNode, 
    /* isAsm */ true);
}
/** Compiles an abort wired to the conditionally imported 'abort' function. */
function compileAbort(compiler, message, reportNode) {
    var program = compiler.program;
    var module = compiler.module;
    var stringInstance = compiler.program.stringInstance;
    if (!stringInstance)
        return module.unreachable();
    var abortInstance = program.abortInstance;
    if (!(abortInstance && compiler.compileFunction(abortInstance)))
        return module.unreachable();
    var messageArg;
    if (message !== null) {
        // The message argument works much like an arm of an IF that does not become executed if the
        // assertion succeeds respectively is only being computed if the program actually crashes.
        // Hence, let's make it so that the autorelease is skipped at the end of the current block,
        // essentially ignoring the message GC-wise. Doesn't matter anyway on a crash.
        messageArg = compiler.compileExpression(message, stringInstance.type, 1 /* CONV_IMPLICIT */ | 16 /* WILL_RETAIN */);
    }
    else {
        messageArg = stringInstance.type.toNativeZero(module);
    }
    var filenameArg = compiler.ensureStaticString(reportNode.range.source.normalizedPath);
    compiler.currentType = types_1.Type.void;
    return module.block(null, [
        module.call(abortInstance.internalName, [
            messageArg,
            filenameArg,
            module.i32(reportNode.range.line),
            module.i32(reportNode.range.column)
        ], module_1.NativeType.None),
        module.unreachable()
    ]);
}
exports.compileAbort = compileAbort;
/** Compiles the `visit_globals` function. */
function compileVisitGlobals(compiler) {
    var module = compiler.module;
    var exprs = new Array();
    var typeRef = compiler.ensureFunctionType([types_1.Type.u32], types_1.Type.void); // cookie
    var nativeSizeType = compiler.options.nativeSizeType;
    var visitInstance = assert(compiler.program.visitInstance);
    compiler.compileFunction(visitInstance);
    for (let element of compiler.program.elementsByName.values()) {
        if (element.kind != program_1.ElementKind.GLOBAL)
            continue;
        let global = element;
        let globalType = global.type;
        let classType = globalType.classReference;
        if (globalType.is(256 /* REFERENCE */) &&
            classType !== null &&
            !classType.hasDecorator(program_1.DecoratorFlags.UNMANAGED) &&
            global.is(common_1.CommonFlags.COMPILED)) {
            if (global.is(common_1.CommonFlags.INLINED)) {
                let value = global.constantIntegerValue;
                if (i64_low(value) || i64_high(value)) {
                    exprs.push(module.call(visitInstance.internalName, [
                        compiler.options.isWasm64
                            ? module.i64(i64_low(value), i64_high(value))
                            : module.i32(i64_low(value))
                    ], module_1.NativeType.None));
                }
            }
            else {
                exprs.push(module.if(module.local_tee(1, module.global_get(global.internalName, nativeSizeType)), module.call(visitInstance.internalName, [
                    module.local_get(1, nativeSizeType),
                    module.local_get(0, module_1.NativeType.I32) // cookie
                ], module_1.NativeType.None)));
            }
        }
    }
    module.addFunction(BuiltinSymbols.visit_globals, typeRef, [nativeSizeType], exprs.length
        ? module.block(null, exprs)
        : module.nop());
}
exports.compileVisitGlobals = compileVisitGlobals;
/** Compiles the `visit_members` function. */
function compileVisitMembers(compiler) {
    var program = compiler.program;
    var module = compiler.module;
    var usizeType = program.options.usizeType;
    var nativeSizeType = usizeType.toNativeType();
    var nativeSizeSize = usizeType.byteSize;
    var ftype = compiler.ensureFunctionType([usizeType, types_1.Type.i32], types_1.Type.void); // ref, cookie
    var managedClasses = program.managedClasses;
    var visitInstance = assert(program.visitInstance);
    var blocks = new Array();
    var relooper = module_1.Relooper.create(module);
    var outer = relooper.addBlockWithSwitch(module.nop(), module.load(nativeSizeSize, false, nativeSizeType == module_1.NativeType.I64
        ? module.binary(module_1.BinaryOp.SubI64, module.local_get(0, nativeSizeType), module.i64(8))
        : module.binary(module_1.BinaryOp.SubI32, module.local_get(0, nativeSizeType), module.i32(8) // rtId is at -8
        ), module_1.NativeType.I32, 0));
    var lastId = 0;
    for (let [id, instance] of managedClasses) {
        assert(instance.type.isManaged);
        assert(id == lastId++);
        let visitImpl;
        let code = new Array();
        // if a library element, check if it implements a custom traversal function
        if (instance.isDeclaredInLibrary && (visitImpl = instance.lookupInSelf("__visit_impl"))) {
            assert(visitImpl.kind == program_1.ElementKind.FUNCTION_PROTOTYPE);
            let visitFunc = program.resolver.resolveFunction(visitImpl, null);
            if (!visitFunc || !compiler.compileFunction(visitFunc)) {
                code.push(module.unreachable());
            }
            else {
                let visitSig = visitFunc.signature;
                assert(visitSig.parameterTypes.length == 1 &&
                    visitSig.parameterTypes[0] == types_1.Type.u32 &&
                    visitSig.returnType == types_1.Type.void &&
                    visitSig.thisType == instance.type);
                code.push(module.call(visitFunc.internalName, [
                    module.local_get(0, nativeSizeType),
                    module.local_get(1, module_1.NativeType.I32) // cookie
                ], module_1.NativeType.None));
            }
            // otherwise generate traversal logic for own fields
        }
        else {
            let members = instance.members;
            if (members) {
                for (let member of members.values()) {
                    if (member.kind == program_1.ElementKind.FIELD) {
                        if (member.parent === instance) {
                            let fieldType = member.type;
                            if (fieldType.isManaged) {
                                let fieldOffset = member.memoryOffset;
                                assert(fieldOffset >= 0);
                                code.push(
                                // if ($2 = value) FIELDCLASS~traverse($2)
                                module.if(module.local_tee(2, module.load(nativeSizeSize, false, module.local_get(0, nativeSizeType), nativeSizeType, fieldOffset)), module.call(visitInstance.internalName, [
                                    module.local_get(2, nativeSizeType),
                                    module.local_get(1, module_1.NativeType.I32) // cookie
                                ], module_1.NativeType.None)));
                            }
                        }
                    }
                }
            }
        }
        if (!instance.base)
            code.push(module.return());
        let block = relooper.addBlock(compiler_1.flatten(module, code, module_1.NativeType.None));
        relooper.addBranchForSwitch(outer, block, [id]);
        blocks.push(block);
    }
    for (let [id, instance] of managedClasses) {
        let base = instance.base;
        if (base) {
            relooper.addBranch(blocks[id], blocks[base.id]);
        }
    }
    blocks.push(relooper.addBlock(module.unreachable()));
    relooper.addBranchForSwitch(outer, blocks[blocks.length - 1], []); // default
    compiler.compileFunction(visitInstance);
    module.addFunction(BuiltinSymbols.visit_members, ftype, [nativeSizeType], relooper.renderAndDispose(outer, 2));
}
exports.compileVisitMembers = compileVisitMembers;
function typeToRuntimeFlags(type) {
    var flags = 32 /* VALUE_ALIGN_0 */ * (1 << type.alignLog2);
    if (type.is(1 /* SIGNED */))
        flags |= 1024 /* VALUE_SIGNED */;
    if (type.is(8 /* FLOAT */))
        flags |= 2048 /* VALUE_FLOAT */;
    if (type.is(512 /* NULLABLE */))
        flags |= 4096 /* VALUE_NULLABLE */;
    if (type.isManaged)
        flags |= 8192 /* VALUE_MANAGED */;
    return flags / 32 /* VALUE_ALIGN_0 */;
}
/** Compiles runtime type information for use by stdlib. */
function compileRTTI(compiler) {
    var program = compiler.program;
    var module = compiler.module;
    var managedClasses = program.managedClasses;
    var count = managedClasses.size;
    var size = 4 + 8 * count;
    var data = new Uint8Array(size);
    util_1.writeI32(count, data, 0);
    var off = 4;
    var abvInstance = program.arrayBufferViewInstance;
    var abvPrototype = abvInstance.prototype;
    var arrayPrototype = program.arrayPrototype;
    var setPrototype = program.setPrototype;
    var mapPrototype = program.mapPrototype;
    var lastId = 0;
    for (let [id, instance] of managedClasses) {
        assert(id == lastId++);
        let flags = 0;
        if (instance.isAcyclic)
            flags |= 16 /* ACYCLIC */;
        if (instance !== abvInstance && instance.extends(abvPrototype)) {
            let valueType = instance.getArrayValueType();
            flags |= 1 /* ARRAYBUFFERVIEW */;
            if (instance.extends(arrayPrototype))
                flags |= 2 /* ARRAY */;
            flags |= 32 /* VALUE_ALIGN_0 */ * typeToRuntimeFlags(valueType);
        }
        else if (instance.extends(setPrototype)) {
            let typeArguments = assert(instance.getTypeArgumentsTo(setPrototype));
            assert(typeArguments.length == 1);
            flags |= 4 /* SET */;
            flags |= 32 /* VALUE_ALIGN_0 */ * typeToRuntimeFlags(typeArguments[0]);
        }
        else if (instance.extends(mapPrototype)) {
            let typeArguments = assert(instance.getTypeArgumentsTo(mapPrototype));
            assert(typeArguments.length == 2);
            flags |= 8 /* MAP */;
            flags |= 16384 /* KEY_ALIGN_0 */ * typeToRuntimeFlags(typeArguments[0]);
            flags |= 32 /* VALUE_ALIGN_0 */ * typeToRuntimeFlags(typeArguments[1]);
        }
        util_1.writeI32(flags, data, off);
        off += 4;
        instance.rttiFlags = flags;
        let base = instance.base;
        util_1.writeI32(base ? base.id : 0, data, off);
        off += 4;
    }
    assert(off == size);
    var usizeType = program.options.usizeType;
    var segment = compiler.addMemorySegment(data);
    if (usizeType.size == 8) {
        let offset = segment.offset;
        module.addGlobal(BuiltinSymbols.rtti_base, module_1.NativeType.I64, false, module.i64(i64_low(offset), i64_high(offset)));
    }
    else {
        module.addGlobal(BuiltinSymbols.rtti_base, module_1.NativeType.I32, false, module.i32(i64_low(segment.offset)));
    }
}
exports.compileRTTI = compileRTTI;
// Helpers
/** Evaluates the constant type of a type argument *or* expression. */
function evaluateConstantType(compiler, typeArguments, operands, reportNode) {
    if (operands.length == 0) { // requires type argument
        if (!typeArguments || typeArguments.length != 1) {
            compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.typeArgumentsRange, "1", typeArguments ? typeArguments.length.toString(10) : "0");
            return null;
        }
        return typeArguments[0];
    }
    if (operands.length == 1) { // optional type argument
        if (typeArguments !== null && typeArguments.length) {
            if (typeArguments.length > 1) {
                compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.typeArgumentsRange, "1", typeArguments.length.toString(10));
                return null;
            }
            compiler.compileExpression(operands[0], typeArguments[0], 1 /* CONV_IMPLICIT */);
        }
        else {
            compiler.compileExpression(operands[0], types_1.Type.auto);
        }
        return compiler.currentType;
    }
    if (typeArguments && typeArguments.length > 1) {
        compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.typeArgumentsRange, "1", typeArguments.length.toString(10));
    }
    compiler.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, reportNode.argumentsRange, "1", operands.length.toString(10));
    return null;
}
/** Evaluates a compile-time constant immediate offset argument.*/
function evaluateImmediateOffset(expression, compiler) {
    var expr;
    var value;
    if (compiler.options.isWasm64) {
        expr = compiler.precomputeExpression(expression, types_1.Type.usize64, 1 /* CONV_IMPLICIT */);
        if (module_1.getExpressionId(expr) != module_1.ExpressionId.Const ||
            module_1.getExpressionType(expr) != module_1.NativeType.I64 ||
            module_1.getConstValueI64High(expr) != 0 ||
            (value = module_1.getConstValueI64Low(expr)) < 0) {
            compiler.error(diagnostics_1.DiagnosticCode.Expression_must_be_a_compile_time_constant, expression.range);
            value = -1;
        }
    }
    else {
        expr = compiler.precomputeExpression(expression, types_1.Type.usize32, 1 /* CONV_IMPLICIT */);
        if (module_1.getExpressionId(expr) != module_1.ExpressionId.Const ||
            module_1.getExpressionType(expr) != module_1.NativeType.I32 ||
            (value = module_1.getConstValueI32(expr)) < 0) {
            compiler.error(diagnostics_1.DiagnosticCode.Expression_must_be_a_compile_time_constant, expression.range);
            value = -1;
        }
    }
    return value;
}
/** Checks that the specified feature is enabled. */
function checkFeatureEnabled(feature, reportNode, compiler) {
    if (!compiler.options.hasFeature(feature)) {
        compiler.error(diagnostics_1.DiagnosticCode.Feature_0_is_not_enabled, reportNode.range, common_1.featureToString(feature));
        return 1;
    }
    return 0;
}
/** Checks a call with a single required type argument. Returns `1` on error. */
function checkTypeRequired(typeArguments, reportNode, compiler, setCurrentTypeOnError = false) {
    if (typeArguments) {
        let numTypeArguments = typeArguments.length;
        if (numTypeArguments == 1)
            return 0;
        assert(numTypeArguments); // invalid if 0, must not be set at all instead
        if (setCurrentTypeOnError)
            compiler.currentType = typeArguments[0];
        compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.typeArgumentsRange, "1", numTypeArguments.toString());
    }
    else {
        compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.range, "1", "0");
    }
    return 1;
}
/** Checks a call with a single optional type argument. Returns `1` on error. */
function checkTypeOptional(typeArguments, reportNode, compiler, setCurrentTypeOnError = false) {
    if (typeArguments) {
        let numTypeArguments = typeArguments.length;
        if (numTypeArguments == 1)
            return 0;
        assert(numTypeArguments); // invalid if 0, must not be set at all instead
        if (setCurrentTypeOnError)
            compiler.currentType = typeArguments[0];
        compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.typeArgumentsRange, "1", numTypeArguments.toString());
        return 1;
    }
    return 0;
}
/** Checks a call that is not generic. Returns `1` on error. */
function checkTypeAbsent(typeArguments, reportNode, prototype) {
    if (typeArguments) {
        prototype.program.error(diagnostics_1.DiagnosticCode.Type_0_is_not_generic, reportNode.typeArgumentsRange, prototype.internalName);
        return 1;
    }
    return 0;
}
/** Checks a call that requires a fixed number of arguments. Returns `1` on error. */
function checkArgsRequired(operands, expected, reportNode, compiler) {
    if (operands.length != expected) {
        compiler.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, reportNode.range, expected.toString(), operands.length.toString());
        return 1;
    }
    return 0;
}
/** Checks a call that requires a variable number of arguments. Returns `1` on error. */
function checkArgsOptional(operands, expectedMinimum, expectedMaximum, reportNode, compiler) {
    var numOperands = operands.length;
    if (numOperands < expectedMinimum) {
        compiler.error(diagnostics_1.DiagnosticCode.Expected_at_least_0_arguments_but_got_1, reportNode.range, expectedMinimum.toString(), numOperands.toString());
        return 1;
    }
    else if (numOperands > expectedMaximum) {
        compiler.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, reportNode.range, expectedMaximum.toString(), numOperands.toString());
        return 1;
    }
    return 0;
}


/***/ }),

/***/ "./src/common.ts":
/*!***********************!*\
  !*** ./src/common.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Common constants.
 * @module common
 */ /***/
Object.defineProperty(exports, "__esModule", { value: true });
/** Indicates traits of a {@link Node} or {@link Element}. */
var CommonFlags;
(function (CommonFlags) {
    /** No flags set. */
    CommonFlags[CommonFlags["NONE"] = 0] = "NONE";
    // Basic modifiers
    /** Has an `import` modifier. */
    CommonFlags[CommonFlags["IMPORT"] = 1] = "IMPORT";
    /** Has an `export` modifier. */
    CommonFlags[CommonFlags["EXPORT"] = 2] = "EXPORT";
    /** Has a `declare` modifier. */
    CommonFlags[CommonFlags["DECLARE"] = 4] = "DECLARE";
    /** Has a `const` modifier. */
    CommonFlags[CommonFlags["CONST"] = 8] = "CONST";
    /** Has a `let` modifier. */
    CommonFlags[CommonFlags["LET"] = 16] = "LET";
    /** Has a `static` modifier. */
    CommonFlags[CommonFlags["STATIC"] = 32] = "STATIC";
    /** Has a `readonly` modifier. */
    CommonFlags[CommonFlags["READONLY"] = 64] = "READONLY";
    /** Has an `abstract` modifier. */
    CommonFlags[CommonFlags["ABSTRACT"] = 128] = "ABSTRACT";
    /** Has a `public` modifier. */
    CommonFlags[CommonFlags["PUBLIC"] = 256] = "PUBLIC";
    /** Has a `private` modifier. */
    CommonFlags[CommonFlags["PRIVATE"] = 512] = "PRIVATE";
    /** Has a `protected` modifier. */
    CommonFlags[CommonFlags["PROTECTED"] = 1024] = "PROTECTED";
    /** Has a `get` modifier. */
    CommonFlags[CommonFlags["GET"] = 2048] = "GET";
    /** Has a `set` modifier. */
    CommonFlags[CommonFlags["SET"] = 4096] = "SET";
    /** Has a definite assignment assertion `!` as in `x!: i32;`. */
    CommonFlags[CommonFlags["DEFINITE_ASSIGNMENT"] = 8192] = "DEFINITE_ASSIGNMENT";
    // Extended modifiers usually derived from basic modifiers
    /** Is ambient, that is either declared or nested in a declared element. */
    CommonFlags[CommonFlags["AMBIENT"] = 16384] = "AMBIENT";
    /** Is generic. */
    CommonFlags[CommonFlags["GENERIC"] = 32768] = "GENERIC";
    /** Is part of a generic context. */
    CommonFlags[CommonFlags["GENERIC_CONTEXT"] = 65536] = "GENERIC_CONTEXT";
    /** Is an instance member. */
    CommonFlags[CommonFlags["INSTANCE"] = 131072] = "INSTANCE";
    /** Is a constructor. */
    CommonFlags[CommonFlags["CONSTRUCTOR"] = 262144] = "CONSTRUCTOR";
    /** Is a module export. */
    CommonFlags[CommonFlags["MODULE_EXPORT"] = 524288] = "MODULE_EXPORT";
    /** Is a module import. */
    CommonFlags[CommonFlags["MODULE_IMPORT"] = 1048576] = "MODULE_IMPORT";
    // Compilation states
    /** Is resolved. */
    CommonFlags[CommonFlags["RESOLVED"] = 2097152] = "RESOLVED";
    /** Is compiled. */
    CommonFlags[CommonFlags["COMPILED"] = 4194304] = "COMPILED";
    /** Has a constant value and is therefore inlined. */
    CommonFlags[CommonFlags["INLINED"] = 8388608] = "INLINED";
    /** Is scoped. */
    CommonFlags[CommonFlags["SCOPED"] = 16777216] = "SCOPED";
    /** Is a trampoline. */
    CommonFlags[CommonFlags["TRAMPOLINE"] = 33554432] = "TRAMPOLINE";
    /** Is a virtual method. */
    CommonFlags[CommonFlags["VIRTUAL"] = 67108864] = "VIRTUAL";
    /** Is the main function. */
    CommonFlags[CommonFlags["MAIN"] = 134217728] = "MAIN";
    // Other
    /** Is quoted. */
    CommonFlags[CommonFlags["QUOTED"] = 268435456] = "QUOTED";
})(CommonFlags = exports.CommonFlags || (exports.CommonFlags = {}));
/** Path delimiter inserted between file system levels. */
exports.PATH_DELIMITER = "/";
/** Substitution used to indicate the parent directory. */
exports.PARENT_SUBST = "..";
/** Function name prefix used for getters. */
exports.GETTER_PREFIX = "get:";
/** Function name prefix used for setters. */
exports.SETTER_PREFIX = "set:";
/** Delimiter used between class names and instance members. */
exports.INSTANCE_DELIMITER = "#";
/** Delimiter used between class and namespace names and static members. */
exports.STATIC_DELIMITER = ".";
/** Delimiter used between a function and its inner elements. */
exports.INNER_DELIMITER = "~";
/** Substitution used to indicate a library directory. */
exports.LIBRARY_SUBST = "~lib";
/** Library directory prefix. */
exports.LIBRARY_PREFIX = exports.LIBRARY_SUBST + exports.PATH_DELIMITER;
/** Path index suffix. */
exports.INDEX_SUFFIX = exports.PATH_DELIMITER + "index";
/** Common compiler symbols. */
var CommonSymbols;
(function (CommonSymbols) {
    // special
    CommonSymbols.EMPTY = "";
    // types
    CommonSymbols.i8 = "i8";
    CommonSymbols.i16 = "i16";
    CommonSymbols.i32 = "i32";
    CommonSymbols.i64 = "i64";
    CommonSymbols.isize = "isize";
    CommonSymbols.u8 = "u8";
    CommonSymbols.u16 = "u16";
    CommonSymbols.u32 = "u32";
    CommonSymbols.u64 = "u64";
    CommonSymbols.usize = "usize";
    CommonSymbols.bool = "bool";
    CommonSymbols.f32 = "f32";
    CommonSymbols.f64 = "f64";
    CommonSymbols.v128 = "v128";
    CommonSymbols.anyref = "anyref";
    CommonSymbols.i8x16 = "i8x16";
    CommonSymbols.u8x16 = "u8x16";
    CommonSymbols.i16x8 = "i16x8";
    CommonSymbols.u16x8 = "u16x8";
    CommonSymbols.i32x4 = "i32x4";
    CommonSymbols.u32x4 = "u32x4";
    CommonSymbols.i64x2 = "i64x2";
    CommonSymbols.u64x2 = "u64x2";
    CommonSymbols.f32x4 = "f32x4";
    CommonSymbols.f64x2 = "f64x2";
    CommonSymbols.void_ = "void";
    CommonSymbols.number = "number";
    CommonSymbols.boolean = "boolean";
    CommonSymbols.string = "string";
    CommonSymbols.native = "native";
    CommonSymbols.indexof = "indexof";
    CommonSymbols.valueof = "valueof";
    CommonSymbols.returnof = "returnof";
    // aliases
    CommonSymbols.null_ = "null";
    CommonSymbols.true_ = "true";
    CommonSymbols.false_ = "false";
    // objects
    CommonSymbols.this_ = "this";
    CommonSymbols.super_ = "super";
    CommonSymbols.constructor = "constructor";
    // constants
    CommonSymbols.ASC_TARGET = "ASC_TARGET";
    CommonSymbols.ASC_NO_TREESHAKING = "ASC_NO_TREESHAKING";
    CommonSymbols.ASC_NO_ASSERT = "ASC_NO_ASSERT";
    CommonSymbols.ASC_MEMORY_BASE = "ASC_MEMORY_BASE";
    CommonSymbols.ASC_OPTIMIZE_LEVEL = "ASC_OPTIMIZE_LEVEL";
    CommonSymbols.ASC_SHRINK_LEVEL = "ASC_SHRINK_LEVEL";
    CommonSymbols.ASC_FEATURE_SIGN_EXTENSION = "ASC_FEATURE_SIGN_EXTENSION";
    CommonSymbols.ASC_FEATURE_MUTABLE_GLOBALS = "ASC_FEATURE_MUTABLE_GLOBALS";
    CommonSymbols.ASC_FEATURE_NONTRAPPING_F2I = "ASC_FEATURE_NONTRAPPING_F2I";
    CommonSymbols.ASC_FEATURE_BULK_MEMORY = "ASC_FEATURE_BULK_MEMORY";
    CommonSymbols.ASC_FEATURE_SIMD = "ASC_FEATURE_SIMD";
    CommonSymbols.ASC_FEATURE_THREADS = "ASC_FEATURE_THREADS";
    CommonSymbols.ASC_FEATURE_EXCEPTION_HANDLING = "ASC_FEATURE_EXCEPTION_HANDLING";
    CommonSymbols.ASC_FEATURE_TAIL_CALLS = "ASC_FEATURE_TAIL_CALLS";
    CommonSymbols.ASC_FEATURE_REFERENCE_TYPES = "ASC_FEATURE_REFERENCE_TYPES";
    // classes
    CommonSymbols.I8 = "I8";
    CommonSymbols.I16 = "I16";
    CommonSymbols.I32 = "I32";
    CommonSymbols.I64 = "I64";
    CommonSymbols.Isize = "Isize";
    CommonSymbols.U8 = "U8";
    CommonSymbols.U16 = "U16";
    CommonSymbols.U32 = "U32";
    CommonSymbols.U64 = "U64";
    CommonSymbols.Usize = "Usize";
    CommonSymbols.Bool = "Bool";
    CommonSymbols.F32 = "F32";
    CommonSymbols.F64 = "F64";
    CommonSymbols.V128 = "V128";
    CommonSymbols.Anyref = "Anyref";
    CommonSymbols.String = "String";
    CommonSymbols.Array = "Array";
    CommonSymbols.FixedArray = "FixedArray";
    CommonSymbols.Set = "Set";
    CommonSymbols.Map = "Map";
    CommonSymbols.ArrayBufferView = "ArrayBufferView";
    CommonSymbols.ArrayBuffer = "ArrayBuffer";
    CommonSymbols.Math = "Math";
    CommonSymbols.Mathf = "Mathf";
    CommonSymbols.Int8Array = "Int8Array";
    CommonSymbols.Int16Array = "Int16Array";
    CommonSymbols.Int32Array = "Int32Array";
    CommonSymbols.Int64Array = "Int64Array";
    CommonSymbols.Uint8Array = "Uint8Array";
    CommonSymbols.Uint8ClampedArray = "Uint8ClampedArray";
    CommonSymbols.Uint16Array = "Uint16Array";
    CommonSymbols.Uint32Array = "Uint32Array";
    CommonSymbols.Uint64Array = "Uint64Array";
    CommonSymbols.Float32Array = "Float32Array";
    CommonSymbols.Float64Array = "Float64Array";
    // runtime
    CommonSymbols.abort = "abort";
    CommonSymbols.pow = "pow";
    CommonSymbols.mod = "mod";
    CommonSymbols.alloc = "__alloc";
    CommonSymbols.realloc = "__realloc";
    CommonSymbols.free = "__free";
    CommonSymbols.retain = "__retain";
    CommonSymbols.release = "__release";
    CommonSymbols.collect = "__collect";
    CommonSymbols.typeinfo = "__typeinfo";
    CommonSymbols.instanceof_ = "__instanceof";
    CommonSymbols.visit = "__visit";
    CommonSymbols.allocArray = "__allocArray";
})(CommonSymbols = exports.CommonSymbols || (exports.CommonSymbols = {}));
// shared
var feature_1 = __webpack_require__(/*! ../std/assembly/shared/feature */ "./std/assembly/shared/feature.ts");
exports.Feature = feature_1.Feature;
exports.featureToString = feature_1.featureToString;
var target_1 = __webpack_require__(/*! ../std/assembly/shared/target */ "./std/assembly/shared/target.ts");
exports.Target = target_1.Target;
var typeinfo_1 = __webpack_require__(/*! ../std/assembly/shared/typeinfo */ "./std/assembly/shared/typeinfo.ts");
exports.Typeinfo = typeinfo_1.Typeinfo;
exports.TypeinfoFlags = typeinfo_1.TypeinfoFlags;


/***/ }),

/***/ "./src/compiler.ts":
/*!*************************!*\
  !*** ./src/compiler.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * The AssemblyScript compiler.
 * @module compiler
 */ /***/
Object.defineProperty(exports, "__esModule", { value: true });
const builtins_1 = __webpack_require__(/*! ./builtins */ "./src/builtins.ts");
const diagnostics_1 = __webpack_require__(/*! ./diagnostics */ "./src/diagnostics.ts");
const module_1 = __webpack_require__(/*! ./module */ "./src/module.ts");
const common_1 = __webpack_require__(/*! ./common */ "./src/common.ts");
const program_1 = __webpack_require__(/*! ./program */ "./src/program.ts");
const flow_1 = __webpack_require__(/*! ./flow */ "./src/flow.ts");
const resolver_1 = __webpack_require__(/*! ./resolver */ "./src/resolver.ts");
const tokenizer_1 = __webpack_require__(/*! ./tokenizer */ "./src/tokenizer.ts");
const ast_1 = __webpack_require__(/*! ./ast */ "./src/ast.ts");
const types_1 = __webpack_require__(/*! ./types */ "./src/types.ts");
const util_1 = __webpack_require__(/*! ./util */ "./src/util/index.ts");
/** Compiler options. */
class Options {
    constructor() {
        /** WebAssembly target. Defaults to {@link Target.WASM32}. */
        this.target = common_1.Target.WASM32;
        /** If true, replaces assertions with nops. */
        this.noAssert = false;
        /** If true, imports the memory provided by the embedder. */
        this.importMemory = false;
        /** If greater than zero, declare memory as shared by setting max memory to sharedMemory. */
        this.sharedMemory = 0;
        /** If true, imports the function table provided by the embedder. */
        this.importTable = false;
        /** If true, generates information necessary for source maps. */
        this.sourceMap = false;
        /** If true, generates an explicit start function. */
        this.explicitStart = false;
        /** Static memory start offset. */
        this.memoryBase = 0;
        /** Global aliases, mapping alias names as the key to internal names to be aliased as the value. */
        this.globalAliases = null;
        /** Features to activate by default. These are the finished proposals. */
        this.features = 2 /* MUTABLE_GLOBALS */;
        /** If true, disallows unsafe features in user code. */
        this.noUnsafe = false;
        /** Hinted optimize level. Not applied by the compiler itself. */
        this.optimizeLevelHint = 0;
        /** Hinted shrink level. Not applied by the compiler itself. */
        this.shrinkLevelHint = 0;
    }
    /** Tests if the target is WASM64 or, otherwise, WASM32. */
    get isWasm64() {
        return this.target == common_1.Target.WASM64;
    }
    /** Gets the unsigned size type matching the target. */
    get usizeType() {
        return this.target == common_1.Target.WASM64 ? types_1.Type.usize64 : types_1.Type.usize32;
    }
    /** Gets the signed size type matching the target. */
    get isizeType() {
        return this.target == common_1.Target.WASM64 ? types_1.Type.isize64 : types_1.Type.isize32;
    }
    /** Gets the native size type matching the target. */
    get nativeSizeType() {
        return this.target == common_1.Target.WASM64 ? module_1.NativeType.I64 : module_1.NativeType.I32;
    }
    /** Tests if a specific feature is activated. */
    hasFeature(feature) {
        return (this.features & feature) != 0;
    }
}
exports.Options = Options;
/** Various constraints in expression compilation. */
var Constraints;
(function (Constraints) {
    Constraints[Constraints["NONE"] = 0] = "NONE";
    /** Must implicitly convert to the target type. */
    Constraints[Constraints["CONV_IMPLICIT"] = 1] = "CONV_IMPLICIT";
    /** Must explicitly convert to the target type. */
    Constraints[Constraints["CONV_EXPLICIT"] = 2] = "CONV_EXPLICIT";
    /** Must wrap small integer values to match the target type. */
    Constraints[Constraints["MUST_WRAP"] = 4] = "MUST_WRAP";
    /** Indicates that the value will be dropped immediately. */
    Constraints[Constraints["WILL_DROP"] = 8] = "WILL_DROP";
    /** Indicates that the value will be retained immediately. */
    Constraints[Constraints["WILL_RETAIN"] = 16] = "WILL_RETAIN";
    /** Indicates that static data is preferred. */
    Constraints[Constraints["PREFER_STATIC"] = 32] = "PREFER_STATIC";
})(Constraints = exports.Constraints || (exports.Constraints = {}));
/** Runtime features to be activated by the compiler. */
var RuntimeFeatures;
(function (RuntimeFeatures) {
    RuntimeFeatures[RuntimeFeatures["NONE"] = 0] = "NONE";
    /** Requires heap setup. */
    RuntimeFeatures[RuntimeFeatures["HEAP"] = 1] = "HEAP";
    /** Requires runtime type information setup. */
    RuntimeFeatures[RuntimeFeatures["RTTI"] = 2] = "RTTI";
    /** Requires the built-in globals visitor. */
    RuntimeFeatures[RuntimeFeatures["visitGlobals"] = 4] = "visitGlobals";
    /** Requires the built-in members visitor. */
    RuntimeFeatures[RuntimeFeatures["visitMembers"] = 8] = "visitMembers";
})(RuntimeFeatures = exports.RuntimeFeatures || (exports.RuntimeFeatures = {}));
/** Compiler interface. */
class Compiler extends diagnostics_1.DiagnosticEmitter {
    /** Constructs a new compiler for a {@link Program} using the specified options. */
    constructor(program, options = null) {
        super(program.diagnostics);
        /** Current inline functions stack. */
        this.currentInlineFunctions = [];
        /** Current parent element if not a function, i.e. an enum or namespace. */
        this.currentParent = null;
        /** Current type in compilation. */
        this.currentType = types_1.Type.void;
        /** Memory segments being compiled. */
        this.memorySegments = [];
        /** Map of already compiled static string segments. */
        this.stringSegments = new Map();
        /** Function table being compiled. */
        this.functionTable = ["null"];
        /** Argument count helper global. */
        this.argcVar = 0;
        /** Argument count helper setter. */
        this.argcSet = 0;
        /** Requires runtime features. */
        this.runtimeFeatures = 0 /* NONE */;
        /** Expressions known to have skipped an autorelease. Usually function returns. */
        this.skippedAutoreleases = new Set();
        this.f32ModInstance = null;
        this.f64ModInstance = null;
        this.f32PowInstance = null;
        this.f64PowInstance = null;
        this.program = program;
        if (!options)
            options = new Options();
        this.options = options;
        this.memoryOffset = i64_new(
        // leave space for `null`. also functions as a sentinel for erroneous stores at offset 0.
        // note that Binaryen's asm.js output utilizes the first 8 bytes for reinterpretations (#1547)
        max(options.memoryBase, 8));
        this.module = module_1.Module.create();
        var featureFlags = 0;
        if (this.options.hasFeature(1 /* SIGN_EXTENSION */))
            featureFlags |= module_1.FeatureFlags.SignExt;
        if (this.options.hasFeature(2 /* MUTABLE_GLOBALS */))
            featureFlags |= module_1.FeatureFlags.MutableGloabls;
        if (this.options.hasFeature(4 /* NONTRAPPING_F2I */))
            featureFlags |= module_1.FeatureFlags.NontrappingFPToInt;
        if (this.options.hasFeature(8 /* BULK_MEMORY */))
            featureFlags |= module_1.FeatureFlags.BulkMemory;
        if (this.options.hasFeature(16 /* SIMD */))
            featureFlags |= module_1.FeatureFlags.SIMD128;
        if (this.options.hasFeature(32 /* THREADS */))
            featureFlags |= module_1.FeatureFlags.Atomics;
        if (this.options.hasFeature(64 /* EXCEPTION_HANDLING */))
            featureFlags |= module_1.FeatureFlags.ExceptionHandling;
        if (this.options.hasFeature(128 /* TAIL_CALLS */))
            featureFlags |= module_1.FeatureFlags.TailCall;
        if (this.options.hasFeature(256 /* REFERENCE_TYPES */))
            featureFlags |= module_1.FeatureFlags.ReferenceTypes;
        this.module.setFeatures(featureFlags);
    }
    /** Resolver reference. */
    get resolver() { return this.program.resolver; }
    /** Compiles a {@link Program} to a {@link Module} using the specified options. */
    static compile(program, options = null) {
        return new Compiler(program, options).compile();
    }
    /** Performs compilation of the underlying {@link Program} to a {@link Module}. */
    compile() {
        var options = this.options;
        var module = this.module;
        var program = this.program;
        // initialize lookup maps, built-ins, imports, exports, etc.
        program.initialize(options);
        // set up the main start function
        var startFunctionInstance = program.makeNativeFunction("start", new types_1.Signature(program, [], types_1.Type.void));
        startFunctionInstance.internalName = "start";
        var startFunctionBody = new Array();
        this.currentFlow = startFunctionInstance.flow;
        this.currentBody = startFunctionBody;
        // add a mutable heap and rtti base dummies
        if (options.isWasm64) {
            module.addGlobal(builtins_1.BuiltinSymbols.heap_base, module_1.NativeType.I64, true, module.i64(0));
            module.addGlobal(builtins_1.BuiltinSymbols.rtti_base, module_1.NativeType.I64, true, module.i64(0));
        }
        else {
            module.addGlobal(builtins_1.BuiltinSymbols.heap_base, module_1.NativeType.I32, true, module.i32(0));
            module.addGlobal(builtins_1.BuiltinSymbols.rtti_base, module_1.NativeType.I32, true, module.i32(0));
        }
        // compile entry file(s) while traversing reachable elements
        var files = program.filesByName;
        for (let file of files.values()) {
            if (file.source.sourceKind == ast_1.SourceKind.USER_ENTRY) {
                this.compileFile(file);
                this.compileExports(file);
            }
        }
        // compile the start function if not empty or explicitly requested
        var startIsEmpty = !startFunctionBody.length;
        var explicitStart = options.explicitStart;
        if (!startIsEmpty || explicitStart) {
            let signature = startFunctionInstance.signature;
            if (!startIsEmpty && explicitStart) {
                module.addGlobal(builtins_1.BuiltinSymbols.started, module_1.NativeType.I32, true, module.i32(0));
                startFunctionBody.unshift(module.if(module.global_get(builtins_1.BuiltinSymbols.started, module_1.NativeType.I32), module.return(), module.global_set(builtins_1.BuiltinSymbols.started, module.i32(1))));
            }
            let funcRef = module.addFunction(startFunctionInstance.internalName, this.ensureFunctionType(signature.parameterTypes, signature.returnType, signature.thisType), types_1.typesToNativeTypes(startFunctionInstance.additionalLocals), module.block(null, startFunctionBody));
            startFunctionInstance.finalize(module, funcRef);
            if (!explicitStart)
                module.setStart(funcRef);
            else
                module.addFunctionExport(startFunctionInstance.internalName, "__start");
        }
        // compile runtime features
        if (this.runtimeFeatures & 4 /* visitGlobals */)
            builtins_1.compileVisitGlobals(this);
        if (this.runtimeFeatures & 8 /* visitMembers */)
            builtins_1.compileVisitMembers(this);
        module.removeGlobal(builtins_1.BuiltinSymbols.rtti_base);
        if (this.runtimeFeatures & 2 /* RTTI */)
            builtins_1.compileRTTI(this);
        // update the heap base pointer
        var memoryOffset = this.memoryOffset;
        memoryOffset = i64_align(memoryOffset, options.usizeType.byteSize);
        this.memoryOffset = memoryOffset;
        module.removeGlobal(builtins_1.BuiltinSymbols.heap_base);
        if (this.runtimeFeatures & 1 /* HEAP */) {
            if (options.isWasm64) {
                module.addGlobal(builtins_1.BuiltinSymbols.heap_base, module_1.NativeType.I64, false, module.i64(i64_low(memoryOffset), i64_high(memoryOffset)));
            }
            else {
                module.addGlobal(builtins_1.BuiltinSymbols.heap_base, module_1.NativeType.I32, false, module.i32(i64_low(memoryOffset)));
            }
        }
        // set up memory
        var isSharedMemory = options.hasFeature(32 /* THREADS */) && options.sharedMemory > 0;
        module.setMemory(this.options.memoryBase /* is specified */ || this.memorySegments.length
            ? i64_low(i64_shr_u(i64_align(memoryOffset, 0x10000), i64_new(16, 0)))
            : 0, isSharedMemory ? options.sharedMemory : module_1.Module.UNLIMITED_MEMORY, this.memorySegments, options.target, "memory", isSharedMemory);
        // import memory if requested (default memory is named '0' by Binaryen)
        if (options.importMemory)
            module.addMemoryImport("0", "env", "memory", isSharedMemory);
        // set up function table
        var functionTable = this.functionTable;
        module.setFunctionTable(functionTable.length, 0xffffffff, functionTable, module.i32(0));
        module.addFunction("null", this.ensureFunctionType(null, types_1.Type.void), null, module.block(null, []));
        // import table if requested (default table is named '0' by Binaryen)
        if (options.importTable)
            module.addTableImport("0", "env", "table");
        // set up module exports
        for (let file of this.program.filesByName.values()) {
            if (file.source.sourceKind == ast_1.SourceKind.USER_ENTRY)
                this.ensureModuleExports(file);
        }
        return module;
    }
    // === Exports ==================================================================================
    /** Applies the respective module exports for the specified file. */
    ensureModuleExports(file) {
        var members = file.exports;
        if (members)
            for (let [name, member] of members)
                this.ensureModuleExport(name, member);
        var exportsStar = file.exportsStar;
        if (exportsStar) {
            for (let i = 0, k = exportsStar.length; i < k; ++i)
                this.ensureModuleExports(exportsStar[i]);
        }
    }
    /** Applies the respective module export(s) for the specified element. */
    ensureModuleExport(name, element, prefix = "") {
        switch (element.kind) {
            // traverse instances
            case program_1.ElementKind.FUNCTION_PROTOTYPE: {
                let instances = element.instances;
                if (instances) {
                    for (let instance of instances.values()) {
                        let instanceName = name;
                        if (instance.is(common_1.CommonFlags.GENERIC)) {
                            let fullName = instance.internalName;
                            instanceName += fullName.substring(fullName.lastIndexOf("<"));
                        }
                        this.ensureModuleExport(instanceName, instance, prefix);
                    }
                }
                break;
            }
            case program_1.ElementKind.CLASS_PROTOTYPE: {
                let instances = element.instances;
                if (instances) {
                    for (let instance of instances.values()) {
                        let instanceName = name;
                        if (instance.is(common_1.CommonFlags.GENERIC)) {
                            let fullName = instance.internalName;
                            instanceName += fullName.substring(fullName.lastIndexOf("<"));
                        }
                        this.ensureModuleExport(instanceName, instance, prefix);
                    }
                }
                break;
            }
            case program_1.ElementKind.PROPERTY_PROTOTYPE: {
                let getter = element.getterPrototype;
                let setter = element.setterPrototype;
                if (getter)
                    this.ensureModuleExport(common_1.GETTER_PREFIX + name, getter, prefix);
                if (setter)
                    this.ensureModuleExport(common_1.SETTER_PREFIX + name, setter, prefix);
                break;
            }
            // export concrete elements
            case program_1.ElementKind.GLOBAL: {
                let isConst = element.is(common_1.CommonFlags.CONST) || element.is(common_1.CommonFlags.STATIC | common_1.CommonFlags.READONLY);
                if (!isConst && !this.options.hasFeature(2 /* MUTABLE_GLOBALS */)) {
                    this.error(diagnostics_1.DiagnosticCode.Cannot_export_a_mutable_global, element.identifierNode.range);
                }
                else {
                    this.module.addGlobalExport(element.internalName, prefix + name);
                }
                break;
            }
            case program_1.ElementKind.ENUMVALUE: {
                if (!element.isImmutable && !this.options.hasFeature(2 /* MUTABLE_GLOBALS */)) {
                    this.error(diagnostics_1.DiagnosticCode.Cannot_export_a_mutable_global, element.identifierNode.range);
                }
                else {
                    this.module.addGlobalExport(element.internalName, prefix + name);
                }
                break;
            }
            case program_1.ElementKind.FUNCTION: {
                let instance = element;
                let signature = instance.signature;
                if (signature.requiredParameters < signature.parameterTypes.length) {
                    // utilize trampoline to fill in omitted arguments
                    instance = this.ensureTrampoline(instance);
                    this.ensureArgcSet();
                }
                if (instance.is(common_1.CommonFlags.COMPILED))
                    this.module.addFunctionExport(instance.internalName, prefix + name);
                break;
            }
            case program_1.ElementKind.PROPERTY: {
                let getter = element.getterInstance;
                if (getter)
                    this.ensureModuleExport(common_1.GETTER_PREFIX + name, getter, prefix);
                let setter = element.setterInstance;
                if (setter)
                    this.ensureModuleExport(common_1.SETTER_PREFIX + name, setter, prefix);
                break;
            }
            case program_1.ElementKind.FIELD: {
                this.ensureModuleFieldGetter(prefix + common_1.GETTER_PREFIX + name, element);
                if (!element.is(common_1.CommonFlags.READONLY)) {
                    this.ensureModuleFieldSetter(prefix + common_1.SETTER_PREFIX + name, element);
                }
                break;
            }
            case program_1.ElementKind.CLASS: {
                // make the class name itself represent its runtime id
                if (!element.type.isUnmanaged) {
                    let module = this.module;
                    let internalName = element.internalName;
                    module.addGlobal(internalName, module_1.NativeType.I32, false, module.i32(element.id));
                    module.addGlobalExport(internalName, prefix + name);
                }
                break;
            }
            // just traverse members below
            case program_1.ElementKind.ENUM:
            case program_1.ElementKind.NAMESPACE:
            case program_1.ElementKind.FILE:
            case program_1.ElementKind.TYPEDEFINITION:
            case program_1.ElementKind.INDEXSIGNATURE: break;
            default: assert(false); // unexpected module export
        }
        // traverse members
        var members = element.members;
        if (members) {
            let subPrefix = prefix + name + (element.kind == program_1.ElementKind.CLASS
                ? common_1.INSTANCE_DELIMITER
                : common_1.STATIC_DELIMITER);
            if (element.kind == program_1.ElementKind.NAMESPACE ||
                element.kind == program_1.ElementKind.FILE) {
                for (let member of members.values()) {
                    if (!member.is(common_1.CommonFlags.EXPORT))
                        continue;
                    this.ensureModuleExport(member.name, member, subPrefix);
                }
            }
            else {
                for (let member of members.values()) {
                    if (member.is(common_1.CommonFlags.PRIVATE))
                        continue;
                    this.ensureModuleExport(member.name, member, subPrefix);
                }
            }
        }
    }
    /** Makes a function to get the value of a field of an exported class. */
    ensureModuleFieldGetter(name, field) {
        var type = field.type;
        var module = this.module;
        var usizeType = this.options.usizeType;
        var loadExpr = module.load(type.byteSize, type.is(1 /* SIGNED */), module.local_get(0, usizeType.toNativeType()), type.toNativeType(), field.memoryOffset);
        // a user-defined getter would return a retained value, so:
        if (type.isManaged)
            loadExpr = this.makeRetain(loadExpr);
        module.addFunction(name, this.ensureFunctionType(null, type, usizeType), null, loadExpr);
        module.addFunctionExport(name, name);
    }
    /** Makes a function to set the value of a field of an exported class. */
    ensureModuleFieldSetter(name, field) {
        var type = field.type;
        var module = this.module;
        var nativeType = type.toNativeType();
        var usizeType = this.options.usizeType;
        var nativeSizeType = usizeType.toNativeType();
        var valueExpr = module.local_get(1, nativeType);
        if (type.isManaged) {
            valueExpr = this.makeRetainRelease(module.load(type.byteSize, false, // oldRef
            module.local_get(0, nativeSizeType), nativeType, field.memoryOffset), valueExpr // newRef
            );
        }
        module.addFunction(name, this.ensureFunctionType([type], types_1.Type.void, usizeType), null, module.store(type.byteSize, module.local_get(0, nativeSizeType), valueExpr, nativeType, field.memoryOffset));
        module.addFunctionExport(name, name);
    }
    // === Elements =================================================================================
    /** Compiles any element. */
    compileElement(element, compileMembers = true) {
        switch (element.kind) {
            case program_1.ElementKind.GLOBAL: {
                this.compileGlobal(element);
                break;
            }
            case program_1.ElementKind.ENUM: {
                this.compileEnum(element);
                break;
            }
            case program_1.ElementKind.FUNCTION_PROTOTYPE: {
                if (!element.is(common_1.CommonFlags.GENERIC)) {
                    this.compileFunctionUsingTypeArguments(element, []);
                }
                break;
            }
            case program_1.ElementKind.CLASS_PROTOTYPE: {
                if (!element.is(common_1.CommonFlags.GENERIC)) {
                    this.compileClassUsingTypeArguments(element, []);
                }
                break;
            }
            case program_1.ElementKind.PROPERTY_PROTOTYPE: {
                let getterPrototype = element.getterPrototype;
                if (getterPrototype) {
                    this.compileFunctionUsingTypeArguments(getterPrototype, []);
                }
                let setterPrototype = element.setterPrototype;
                if (setterPrototype) {
                    this.compileFunctionUsingTypeArguments(setterPrototype, []);
                }
                break;
            }
            case program_1.ElementKind.NAMESPACE:
            case program_1.ElementKind.TYPEDEFINITION:
            case program_1.ElementKind.ENUMVALUE:
            case program_1.ElementKind.INDEXSIGNATURE: break;
            default: assert(false, program_1.ElementKind[element.kind]);
        }
        if (compileMembers)
            this.compileMembers(element);
    }
    /** Compiles an element's members. */
    compileMembers(element) {
        var members = element.members;
        if (members)
            for (let element of members.values())
                this.compileElement(element);
    }
    /** Compiles a file's exports. */
    compileExports(file) {
        var exports = file.exports;
        if (exports)
            for (let element of exports.values())
                this.compileElement(element);
        var exportsStar = file.exportsStar;
        if (exportsStar) {
            for (let exportStar of exportsStar) {
                this.compileFile(exportStar);
                this.compileExports(exportStar);
            }
        }
    }
    // files
    /** Compiles the file matching the specified path. */
    compileFileByPath(normalizedPathWithoutExtension, reportNode) {
        var file;
        var filesByName = this.program.filesByName;
        var pathWithIndex;
        if (filesByName.has(normalizedPathWithoutExtension)) {
            file = filesByName.get(normalizedPathWithoutExtension);
        }
        else if (filesByName.has(pathWithIndex = normalizedPathWithoutExtension + common_1.INDEX_SUFFIX)) {
            file = filesByName.get(pathWithIndex);
        }
        else {
            this.error(diagnostics_1.DiagnosticCode.File_0_not_found, reportNode.range, normalizedPathWithoutExtension);
            return;
        }
        this.compileFile(file);
    }
    /** Compiles the specified file. */
    compileFile(file) {
        if (file.is(common_1.CommonFlags.COMPILED))
            return;
        file.set(common_1.CommonFlags.COMPILED);
        // compile top-level statements within the file's start function
        var startFunction = file.startFunction;
        var previousBody = this.currentBody;
        var startFunctionBody = new Array();
        this.currentBody = startFunctionBody;
        // compile top-level statements
        var previousFlow = this.currentFlow;
        var flow = startFunction.flow;
        this.currentFlow = flow;
        for (let statements = file.source.statements, i = 0, k = statements.length; i < k; ++i) {
            this.compileTopLevelStatement(statements[i], startFunctionBody);
        }
        this.finishAutoreleases(flow, startFunctionBody);
        this.currentFlow = previousFlow;
        this.currentBody = previousBody;
        // if top-level statements are present, make the per-file start function and call it in start
        if (startFunctionBody.length) {
            let module = this.module;
            let locals = startFunction.localsByIndex;
            let numLocals = locals.length;
            let varTypes = new Array(numLocals);
            for (let i = 0; i < numLocals; ++i)
                varTypes[i] = locals[i].type.toNativeType();
            module.addFunction(startFunction.internalName, this.ensureFunctionType(startFunction.signature.parameterTypes, startFunction.signature.returnType), varTypes, startFunctionBody.length > 1
                ? module.block(null, startFunctionBody)
                : startFunctionBody[0]);
            previousBody.push(module.call(startFunction.internalName, null, module_1.NativeType.None));
        }
    }
    // === Globals ==================================================================================
    compileGlobal(global) {
        if (global.is(common_1.CommonFlags.COMPILED))
            return true;
        global.set(common_1.CommonFlags.COMPILED);
        var module = this.module;
        var initExpr = 0;
        var initAutoreleaseSkipped = false;
        var typeNode = global.typeNode;
        var initializerNode = global.initializerNode;
        if (!global.is(common_1.CommonFlags.RESOLVED)) {
            // Resolve type if annotated
            if (typeNode) {
                let resolvedType = this.resolver.resolveType(typeNode, global.parent); // reports
                if (!resolvedType)
                    return false;
                if (resolvedType == types_1.Type.void) {
                    this.error(diagnostics_1.DiagnosticCode.Type_expected, typeNode.range);
                    return false;
                }
                global.setType(resolvedType);
                // Otherwise infer type from initializer
            }
            else if (initializerNode) {
                let previousFlow = this.currentFlow;
                if (global.hasDecorator(program_1.DecoratorFlags.LAZY)) {
                    this.currentFlow = global.file.startFunction.flow;
                }
                initExpr = this.compileExpression(initializerNode, types_1.Type.auto, // reports
                4 /* MUST_WRAP */ | 16 /* WILL_RETAIN */);
                if (this.skippedAutoreleases.has(initExpr))
                    initAutoreleaseSkipped = true;
                this.currentFlow = previousFlow;
                if (this.currentType == types_1.Type.void) {
                    this.error(diagnostics_1.DiagnosticCode.Type_0_is_not_assignable_to_type_1, initializerNode.range, this.currentType.toString(), "<auto>");
                    return false;
                }
                global.setType(this.currentType);
                // Error if there's neither a type nor an initializer
            }
            else {
                this.error(diagnostics_1.DiagnosticCode.Type_expected, global.identifierNode.range.atEnd);
                return false;
            }
        }
        // Handle ambient builtins like '__heap_base' that need to be resolved but are added explicitly
        if (global.is(common_1.CommonFlags.AMBIENT) && global.hasDecorator(program_1.DecoratorFlags.BUILTIN)) {
            if (global.internalName == builtins_1.BuiltinSymbols.heap_base)
                this.runtimeFeatures |= 1 /* HEAP */;
            else if (global.internalName == builtins_1.BuiltinSymbols.rtti_base)
                this.runtimeFeatures |= 2 /* RTTI */;
            return true;
        }
        var type = global.type;
        var nativeType = type.toNativeType();
        var isDeclaredConstant = global.is(common_1.CommonFlags.CONST) || global.is(common_1.CommonFlags.STATIC | common_1.CommonFlags.READONLY);
        var isDeclaredInline = global.hasDecorator(program_1.DecoratorFlags.INLINE);
        // Handle imports
        if (global.is(common_1.CommonFlags.AMBIENT)) {
            // Constant global or mutable globals enabled
            if (isDeclaredConstant || this.options.hasFeature(2 /* MUTABLE_GLOBALS */)) {
                global.set(common_1.CommonFlags.MODULE_IMPORT);
                mangleImportName(global, global.declaration);
                module.addGlobalImport(global.internalName, mangleImportName_moduleName, mangleImportName_elementName, nativeType, !isDeclaredConstant);
                global.set(common_1.CommonFlags.COMPILED);
                return true;
                // Importing mutable globals is not supported in the MVP
            }
            else {
                this.error(diagnostics_1.DiagnosticCode.Feature_0_is_not_enabled, global.declaration.range, "mutable-globals");
            }
            return false;
        }
        // The MVP does not yet support initializer expressions other than constant values (and constant
        // get_globals), hence such initializations must be performed in the start function for now.
        var initializeInStart = false;
        // Evaluate initializer if present
        if (initializerNode) {
            if (!initExpr) {
                let previousFlow = this.currentFlow;
                if (global.hasDecorator(program_1.DecoratorFlags.LAZY)) {
                    this.currentFlow = global.file.startFunction.flow;
                }
                initExpr = this.compileExpression(initializerNode, type, 1 /* CONV_IMPLICIT */ | 4 /* MUST_WRAP */ | 16 /* WILL_RETAIN */ | 32 /* PREFER_STATIC */);
                if (this.skippedAutoreleases.has(initExpr))
                    initAutoreleaseSkipped = true;
                this.currentFlow = previousFlow;
            }
            if (module_1.getExpressionId(initExpr) != module_1.ExpressionId.Const) {
                if (isDeclaredConstant) {
                    initExpr = module.precomputeExpression(initExpr);
                    if (module_1.getExpressionId(initExpr) != module_1.ExpressionId.Const)
                        initializeInStart = true;
                }
                else {
                    initializeInStart = true;
                }
            }
            // Explicitly inline if annotated
            if (isDeclaredInline) {
                if (initializeInStart) {
                    this.warning(diagnostics_1.DiagnosticCode.Mutable_value_cannot_be_inlined, initializerNode.range);
                }
                else {
                    assert(module_1.getExpressionId(initExpr) == module_1.ExpressionId.Const);
                    let exprType = module_1.getExpressionType(initExpr);
                    switch (exprType) {
                        case module_1.NativeType.I32: {
                            global.constantValueKind = 1 /* INTEGER */;
                            global.constantIntegerValue = i64_new(module_1.getConstValueI32(initExpr), 0);
                            break;
                        }
                        case module_1.NativeType.I64: {
                            global.constantValueKind = 1 /* INTEGER */;
                            global.constantIntegerValue = i64_new(module_1.getConstValueI64Low(initExpr), module_1.getConstValueI64High(initExpr));
                            break;
                        }
                        case module_1.NativeType.F32: {
                            global.constantValueKind = 2 /* FLOAT */;
                            global.constantFloatValue = module_1.getConstValueF32(initExpr);
                            break;
                        }
                        case module_1.NativeType.F64: {
                            global.constantValueKind = 2 /* FLOAT */;
                            global.constantFloatValue = module_1.getConstValueF64(initExpr);
                            break;
                        }
                        default: {
                            assert(false);
                            return false;
                        }
                    }
                    global.set(common_1.CommonFlags.INLINED); // inline the value from now on
                }
            }
            // Initialize to zero if there's no initializer
        }
        else {
            initExpr = type.toNativeZero(module);
        }
        var internalName = global.internalName;
        if (initializeInStart) { // initialize to mutable zero and set the actual value in start
            if (isDeclaredInline) {
                this.error(diagnostics_1.DiagnosticCode.Decorator_0_is_not_valid_here, assert(ast_1.findDecorator(ast_1.DecoratorKind.INLINE, global.decoratorNodes)).range, "inline");
            }
            module.addGlobal(internalName, nativeType, true, type.toNativeZero(module));
            if (type.isManaged && !initAutoreleaseSkipped)
                initExpr = this.makeRetain(initExpr);
            this.currentBody.push(module.global_set(internalName, initExpr));
        }
        else if (!isDeclaredInline) { // compile normally
            module.addGlobal(internalName, nativeType, !isDeclaredConstant, initExpr);
        }
        return true;
    }
    // === Enums ====================================================================================
    compileEnum(element) {
        if (element.is(common_1.CommonFlags.COMPILED))
            return true;
        element.set(common_1.CommonFlags.COMPILED);
        var module = this.module;
        var previousParent = this.currentParent;
        this.currentParent = element;
        var previousValue = null;
        var previousValueIsMut = false;
        var isInline = element.is(common_1.CommonFlags.CONST) || element.hasDecorator(program_1.DecoratorFlags.INLINE);
        if (element.members) {
            for (let member of element.members.values()) {
                if (member.kind != program_1.ElementKind.ENUMVALUE)
                    continue; // happens if an enum is also a namespace
                let initInStart = false;
                let val = member;
                let valueNode = val.valueNode;
                val.set(common_1.CommonFlags.COMPILED);
                let previousFlow = this.currentFlow;
                if (element.hasDecorator(program_1.DecoratorFlags.LAZY)) {
                    this.currentFlow = element.file.startFunction.flow;
                }
                let initExpr;
                if (valueNode) {
                    initExpr = this.compileExpression(valueNode, types_1.Type.i32, 1 /* CONV_IMPLICIT */);
                    if (module_1.getExpressionId(initExpr) != module_1.ExpressionId.Const) {
                        initExpr = module.precomputeExpression(initExpr);
                        if (module_1.getExpressionId(initExpr) != module_1.ExpressionId.Const) {
                            if (element.is(common_1.CommonFlags.CONST)) {
                                this.error(diagnostics_1.DiagnosticCode.In_const_enum_declarations_member_initializer_must_be_constant_expression, valueNode.range);
                            }
                            initInStart = true;
                        }
                    }
                }
                else if (previousValue == null) {
                    initExpr = module.i32(0);
                }
                else {
                    if (previousValueIsMut) {
                        this.error(diagnostics_1.DiagnosticCode.Enum_member_must_have_initializer, member.identifierNode.range.atEnd);
                    }
                    initExpr = module.binary(module_1.BinaryOp.AddI32, module.global_get(previousValue.internalName, module_1.NativeType.I32), module.i32(1));
                    initExpr = module.precomputeExpression(initExpr);
                    if (module_1.getExpressionId(initExpr) != module_1.ExpressionId.Const) {
                        if (element.is(common_1.CommonFlags.CONST)) {
                            this.error(diagnostics_1.DiagnosticCode.In_const_enum_declarations_member_initializer_must_be_constant_expression, member.declaration.range);
                        }
                        initInStart = true;
                    }
                }
                this.currentFlow = previousFlow;
                if (initInStart) {
                    module.addGlobal(val.internalName, module_1.NativeType.I32, true, module.i32(0));
                    this.currentBody.push(this.makeGlobalAssignment(val, initExpr, false));
                    previousValueIsMut = true;
                }
                else {
                    if (isInline) {
                        val.setConstantIntegerValue(i64_new(module_1.getConstValueI32(initExpr)), types_1.Type.i32);
                        if (val.is(common_1.CommonFlags.MODULE_EXPORT)) {
                            module.addGlobal(val.internalName, module_1.NativeType.I32, false, initExpr);
                        }
                    }
                    else {
                        module.addGlobal(val.internalName, module_1.NativeType.I32, false, initExpr);
                    }
                    val.isImmutable = true;
                    previousValueIsMut = false;
                }
                previousValue = val;
            }
        }
        this.currentParent = previousParent;
        return true;
    }
    // === Functions ================================================================================
    /** Resolves the specified type arguments prior to compiling the resulting function instance. */
    compileFunctionUsingTypeArguments(prototype, typeArguments, contextualTypeArguments = util_1.makeMap(), alternativeReportNode = null) {
        if (prototype.hasDecorator(program_1.DecoratorFlags.BUILTIN))
            return null;
        var instance = this.resolver.resolveFunctionInclTypeArguments(prototype, typeArguments, prototype.parent, // relative to itself
        contextualTypeArguments, alternativeReportNode || prototype.declaration);
        if (!instance)
            return null;
        if (!this.compileFunction(instance))
            return null; // reports
        return instance;
    }
    /** Either reuses or creates the function type matching the specified signature. */
    ensureFunctionType(parameterTypes, returnType, thisType = null) {
        var numParameters = parameterTypes ? parameterTypes.length : 0;
        var paramTypes;
        var index = 0;
        if (thisType) {
            paramTypes = new Array(1 + numParameters);
            paramTypes[0] = thisType.toNativeType();
            index = 1;
        }
        else {
            paramTypes = new Array(numParameters);
        }
        if (parameterTypes) {
            for (let i = 0; i < numParameters; ++i, ++index) {
                paramTypes[index] = parameterTypes[i].toNativeType();
            }
        }
        var resultType = returnType.toNativeType();
        var module = this.module;
        var typeRef = module.getFunctionTypeBySignature(resultType, paramTypes);
        if (!typeRef) {
            let name = types_1.Signature.makeSignatureString(parameterTypes, returnType, thisType);
            typeRef = module.addFunctionType(name, resultType, paramTypes);
        }
        return typeRef;
    }
    /** Compiles the body of a function within the specified flow. */
    compileFunctionBody(
    /** Function to compile. */
    instance, 
    /** Target array of statements. */
    stmts = null) {
        var module = this.module;
        var bodyNode = assert(instance.prototype.bodyNode);
        var returnType = instance.signature.returnType;
        var flow = this.currentFlow;
        // compile statements
        if (bodyNode.kind == ast_1.NodeKind.BLOCK) {
            stmts = this.compileStatements(bodyNode.statements, true, stmts);
        }
        else {
            // must be an expression statement if not a block
            assert(bodyNode.kind == ast_1.NodeKind.EXPRESSION);
            // must be an arrow function
            assert(instance.prototype.arrowKind);
            // none of the following can be an arrow function
            assert(!instance.isAny(common_1.CommonFlags.CONSTRUCTOR | common_1.CommonFlags.GET | common_1.CommonFlags.SET | common_1.CommonFlags.MAIN));
            let expr = this.compileExpression(bodyNode.expression, returnType, 1 /* CONV_IMPLICIT */);
            if (!stmts)
                stmts = [expr];
            else
                stmts.push(expr);
            if (!flow.is(256 /* TERMINATES */)) { // TODO: detect if returning an autorelease local?
                let indexBefore = stmts.length;
                this.performAutoreleases(flow, stmts);
                this.finishAutoreleases(flow, stmts);
                let canOverflow = flow.canOverflow(expr, returnType);
                let nonNull = flow.isNonnull(expr, returnType);
                if (stmts.length > indexBefore) {
                    let temp = flow.getTempLocal(returnType);
                    if (!canOverflow)
                        flow.setLocalFlag(temp.index, flow_1.LocalFlags.WRAPPED);
                    if (nonNull)
                        flow.setLocalFlag(temp.index, flow_1.LocalFlags.NONNULL);
                    stmts[indexBefore - 1] = module.local_set(temp.index, expr);
                    stmts.push(module.local_get(temp.index, returnType.toNativeType()));
                    flow.freeTempLocal(temp);
                }
                if (!canOverflow)
                    flow.set(2 /* RETURNS_WRAPPED */);
                if (nonNull)
                    flow.set(4 /* RETURNS_NONNULL */);
                flow.set(1 /* RETURNS */ | 256 /* TERMINATES */);
            }
        }
        // make constructors return their instance pointer
        if (instance.is(common_1.CommonFlags.CONSTRUCTOR)) {
            let nativeSizeType = this.options.nativeSizeType;
            assert(instance.is(common_1.CommonFlags.INSTANCE));
            let classInstance = assert(instance.parent);
            assert(classInstance.kind == program_1.ElementKind.CLASS);
            if (!flow.is(256 /* TERMINATES */)) {
                let thisLocal = assert(flow.lookupLocal(common_1.CommonSymbols.this_));
                // if `this` wasn't accessed before, allocate if necessary and initialize `this`
                if (!flow.is(64 /* ALLOCATES */)) {
                    // {
                    //   if (!this) this = <ALLOC>
                    //   this.a = X
                    //   this.b = Y
                    // }
                    stmts.push(module.if(module.unary(nativeSizeType == module_1.NativeType.I64 ? module_1.UnaryOp.EqzI64 : module_1.UnaryOp.EqzI32, module.local_get(thisLocal.index, nativeSizeType)), module.local_set(thisLocal.index, this.makeRetain(this.makeAllocation(classInstance)))));
                    this.makeFieldInitialization(classInstance, stmts);
                }
                this.performAutoreleases(flow, stmts); // `this` is excluded anyway
                this.finishAutoreleases(flow, stmts);
                stmts.push(module.local_get(thisLocal.index, this.options.nativeSizeType));
                flow.set(1 /* RETURNS */ | 4 /* RETURNS_NONNULL */ | 256 /* TERMINATES */);
            }
            // check that super has been called if this is a derived class
            if (classInstance.base && !flow.is(128 /* CALLS_SUPER */)) {
                this.error(diagnostics_1.DiagnosticCode.Constructors_for_derived_classes_must_contain_a_super_call, instance.prototype.declaration.range);
            }
            // if this is a normal function, make sure that all branches terminate
        }
        else if (returnType != types_1.Type.void && !flow.is(256 /* TERMINATES */)) {
            this.error(diagnostics_1.DiagnosticCode.A_function_whose_declared_type_is_not_void_must_return_a_value, instance.prototype.functionTypeNode.returnType.range);
        }
        return stmts;
    }
    /** Compiles a readily resolved function instance. */
    compileFunction(instance) {
        if (instance.is(common_1.CommonFlags.COMPILED))
            return true;
        assert(!(instance.is(common_1.CommonFlags.AMBIENT) && instance.hasDecorator(program_1.DecoratorFlags.BUILTIN)));
        var previousType = this.currentType; // remember to retain it if compiling a function lazily
        instance.set(common_1.CommonFlags.COMPILED);
        var module = this.module;
        var signature = instance.signature;
        var bodyNode = instance.prototype.bodyNode;
        var typeRef = this.ensureFunctionType(signature.parameterTypes, signature.returnType, signature.thisType);
        var funcRef;
        // concrete function
        if (bodyNode) {
            // must not be ambient
            if (instance.is(common_1.CommonFlags.AMBIENT)) {
                this.error(diagnostics_1.DiagnosticCode.An_implementation_cannot_be_declared_in_ambient_contexts, instance.identifierNode.range);
            }
            // cannot have an annotated external name
            if (instance.hasDecorator(program_1.DecoratorFlags.EXTERNAL)) {
                let decoratorNodes = instance.decoratorNodes;
                let decorator = assert(ast_1.findDecorator(ast_1.DecoratorKind.EXTERNAL, decoratorNodes));
                this.error(diagnostics_1.DiagnosticCode.Decorator_0_is_not_valid_here, decorator.range, "external");
            }
            // compile body in this function's context
            let previousFlow = this.currentFlow;
            let flow = instance.flow;
            this.currentFlow = flow;
            let stmts = new Array();
            // retain each argument for as long as the function lives
            let index = 0;
            let thisType = signature.thisType;
            if (thisType) {
                // No need to retain `this` as it can't be reassigned and thus can't become prematurely released
                ++index;
            }
            let parameterTypes = signature.parameterTypes;
            for (let i = 0, k = parameterTypes.length; i < k; ++i, ++index) {
                let type = parameterTypes[i];
                if (type.isManaged) {
                    stmts.push(module.drop(this.makeRetain(module.local_get(index, type.toNativeType()))));
                    flow.setLocalFlag(index, flow_1.LocalFlags.RETAINED | flow_1.LocalFlags.PARAMETER);
                }
            }
            this.compileFunctionBody(instance, stmts);
            if (!flow.is(256 /* TERMINATES */)) {
                this.performAutoreleases(flow, stmts);
                this.finishAutoreleases(flow, stmts);
            }
            this.currentFlow = previousFlow;
            // create the function
            funcRef = module.addFunction(instance.internalName, typeRef, types_1.typesToNativeTypes(instance.additionalLocals), flatten(module, stmts, instance.signature.returnType.toNativeType()));
            // imported function
        }
        else {
            if (!instance.is(common_1.CommonFlags.AMBIENT)) {
                this.error(diagnostics_1.DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration, instance.identifierNode.range);
            }
            instance.set(common_1.CommonFlags.MODULE_IMPORT);
            mangleImportName(instance, instance.declaration); // TODO: check for duplicates
            // create the import
            module.addFunctionImport(instance.internalName, mangleImportName_moduleName, mangleImportName_elementName, typeRef);
            funcRef = module.getFunction(instance.internalName);
        }
        instance.finalize(module, funcRef);
        this.currentType = previousType;
        return true;
    }
    // === Classes ==================================================================================
    compileClassUsingTypeArguments(prototype, typeArguments, contextualTypeArguments = util_1.makeMap(), alternativeReportNode = null) {
        var instance = this.resolver.resolveClassInclTypeArguments(prototype, typeArguments, prototype.parent, // relative to itself
        contextualTypeArguments, alternativeReportNode || prototype.declaration);
        if (!instance)
            return;
        this.compileClass(instance);
    }
    compileClass(instance) {
        if (instance.is(common_1.CommonFlags.COMPILED))
            return true;
        instance.set(common_1.CommonFlags.COMPILED);
        var prototype = instance.prototype;
        var staticMembers = prototype.members;
        if (staticMembers) {
            for (let element of staticMembers.values()) {
                switch (element.kind) {
                    case program_1.ElementKind.GLOBAL: {
                        this.compileGlobal(element);
                        break;
                    }
                    case program_1.ElementKind.FUNCTION_PROTOTYPE: {
                        if (!element.is(common_1.CommonFlags.GENERIC)) {
                            this.compileFunctionUsingTypeArguments(element, [], util_1.makeMap(), element.identifierNode);
                        }
                        break;
                    }
                    case program_1.ElementKind.PROPERTY_PROTOTYPE: {
                        let getter = element.getterPrototype;
                        if (getter) {
                            this.compileFunctionUsingTypeArguments(getter, [], util_1.makeMap(), getter.identifierNode);
                        }
                        let setter = element.setterPrototype;
                        if (setter) {
                            this.compileFunctionUsingTypeArguments(setter, [], util_1.makeMap(), setter.identifierNode);
                        }
                        break;
                    }
                    case program_1.ElementKind.PROPERTY: {
                    }
                }
            }
        }
        var ctorInstance = instance.constructorInstance;
        if (ctorInstance)
            this.compileFunction(ctorInstance);
        var instanceMembers = instance.members;
        if (instanceMembers) {
            for (let element of instanceMembers.values()) {
                switch (element.kind) {
                    case program_1.ElementKind.FUNCTION_PROTOTYPE: {
                        if (!element.is(common_1.CommonFlags.GENERIC)) {
                            this.compileFunctionUsingTypeArguments(element, [], util_1.makeMap(instance.contextualTypeArguments), element.declaration.name);
                        }
                        break;
                    }
                    case program_1.ElementKind.FIELD_PROTOTYPE: {
                        element.set(common_1.CommonFlags.COMPILED);
                        break;
                    }
                    case program_1.ElementKind.PROPERTY: {
                        let getter = element.getterInstance;
                        if (getter)
                            this.compileFunction(getter);
                        let setter = element.setterInstance;
                        if (setter)
                            this.compileFunction(setter);
                        break;
                    }
                }
            }
        }
        return true;
    }
    compileInterfaceDeclaration(declaration, typeArguments, contextualTypeArguments = null, alternativeReportNode = null) {
        // TODO
        this.error(diagnostics_1.DiagnosticCode.Not_implemented, declaration.range);
    }
    // === Memory ===================================================================================
    /** Adds a static memory segment with the specified data. */
    addMemorySegment(buffer, alignment = 8) {
        var memoryOffset = i64_align(this.memoryOffset, alignment);
        var segment = module_1.MemorySegment.create(buffer, memoryOffset);
        this.memorySegments.push(segment);
        this.memoryOffset = i64_add(memoryOffset, i64_new(buffer.length, 0));
        return segment;
    }
    /** Ensures that the specified string exists in static memory and returns a pointer to it. */
    ensureStaticString(stringValue) {
        var program = this.program;
        var rtHeaderSize = program.runtimeHeaderSize;
        var stringInstance = assert(program.stringInstance);
        var stringSegment;
        var segments = this.stringSegments;
        if (segments.has(stringValue)) {
            stringSegment = segments.get(stringValue); // reuse
        }
        else {
            let length = stringValue.length;
            let buffer = new Uint8Array(rtHeaderSize + (length << 1));
            program.writeRuntimeHeader(buffer, 0, stringInstance, length << 1);
            for (let i = 0; i < length; ++i) {
                util_1.writeI16(stringValue.charCodeAt(i), buffer, rtHeaderSize + (i << 1));
            }
            stringSegment = this.addMemorySegment(buffer);
            segments.set(stringValue, stringSegment);
        }
        var ref = i64_add(stringSegment.offset, i64_new(rtHeaderSize));
        this.currentType = stringInstance.type;
        if (this.options.isWasm64) {
            return this.module.i64(i64_low(ref), i64_high(ref));
        }
        else {
            assert(i64_is_u32(ref));
            return this.module.i32(i64_low(ref));
        }
    }
    ensureStaticArrayBuffer(elementType, values) {
        var program = this.program;
        var length = values.length;
        var byteSize = elementType.byteSize;
        var byteLength = length * byteSize;
        var bufferInstance = assert(program.arrayBufferInstance);
        var runtimeHeaderSize = program.runtimeHeaderSize;
        var buf = new Uint8Array(runtimeHeaderSize + byteLength);
        program.writeRuntimeHeader(buf, 0, bufferInstance, byteLength);
        var pos = runtimeHeaderSize;
        var nativeType = elementType.toNativeType();
        switch (nativeType) {
            case module_1.NativeType.I32: {
                switch (byteSize) {
                    case 1: {
                        for (let i = 0; i < length; ++i) {
                            let value = values[i];
                            assert(module_1.getExpressionType(value) == nativeType);
                            assert(module_1.getExpressionId(value) == module_1.ExpressionId.Const);
                            util_1.writeI8(module_1.getConstValueI32(value), buf, pos);
                            pos += 1;
                        }
                        break;
                    }
                    case 2: {
                        for (let i = 0; i < length; ++i) {
                            let value = values[i];
                            assert(module_1.getExpressionType(value) == nativeType);
                            assert(module_1.getExpressionId(value) == module_1.ExpressionId.Const);
                            util_1.writeI16(module_1.getConstValueI32(value), buf, pos);
                            pos += 2;
                        }
                        break;
                    }
                    case 4: {
                        for (let i = 0; i < length; ++i) {
                            let value = values[i];
                            assert(module_1.getExpressionType(value) == nativeType);
                            assert(module_1.getExpressionId(value) == module_1.ExpressionId.Const);
                            util_1.writeI32(module_1.getConstValueI32(value), buf, pos);
                            pos += 4;
                        }
                        break;
                    }
                    default: assert(false);
                }
                break;
            }
            case module_1.NativeType.I64: {
                for (let i = 0; i < length; ++i) {
                    let value = values[i];
                    assert(module_1.getExpressionType(value) == nativeType);
                    assert(module_1.getExpressionId(value) == module_1.ExpressionId.Const);
                    util_1.writeI64(i64_new(module_1.getConstValueI64Low(value), module_1.getConstValueI64High(value)), buf, pos);
                    pos += 8;
                }
                break;
            }
            case module_1.NativeType.F32: {
                for (let i = 0; i < length; ++i) {
                    let value = values[i];
                    assert(module_1.getExpressionType(value) == nativeType);
                    assert(module_1.getExpressionId(value) == module_1.ExpressionId.Const);
                    util_1.writeF32(module_1.getConstValueF32(value), buf, pos);
                    pos += 4;
                }
                break;
            }
            case module_1.NativeType.F64: {
                for (let i = 0; i < length; ++i) {
                    let value = values[i];
                    assert(module_1.getExpressionType(value) == nativeType);
                    assert(module_1.getExpressionId(value) == module_1.ExpressionId.Const);
                    util_1.writeF64(module_1.getConstValueF64(value), buf, pos);
                    pos += 8;
                }
                break;
            }
            default: assert(false);
        }
        assert(pos == buf.length);
        return this.addMemorySegment(buf);
    }
    ensureStaticArrayHeader(elementType, bufferSegment) {
        var program = this.program;
        var runtimeHeaderSize = program.runtimeHeaderSize;
        var arrayPrototype = assert(program.arrayPrototype);
        var arrayInstance = assert(this.resolver.resolveClass(arrayPrototype, [elementType]));
        var arrayInstanceSize = arrayInstance.currentMemoryOffset;
        var bufferLength = bufferSegment.buffer.length - runtimeHeaderSize;
        var arrayLength = i32(bufferLength / elementType.byteSize);
        var buf = new Uint8Array(runtimeHeaderSize + arrayInstanceSize);
        program.writeRuntimeHeader(buf, 0, arrayInstance, arrayInstanceSize);
        var bufferAddress32 = i64_low(bufferSegment.offset) + runtimeHeaderSize;
        assert(!program.options.isWasm64); // TODO
        assert(arrayInstance.writeField("buffer", bufferAddress32, buf, runtimeHeaderSize));
        assert(arrayInstance.writeField("dataStart", bufferAddress32, buf, runtimeHeaderSize));
        assert(arrayInstance.writeField("byteLength", bufferLength, buf, runtimeHeaderSize));
        assert(arrayInstance.writeField("length_", arrayLength, buf, runtimeHeaderSize));
        return this.addMemorySegment(buf);
    }
    // === Table ====================================================================================
    /** Ensures that a table entry exists for the specified function and returns its index. */
    ensureFunctionTableEntry(func) {
        assert(func.is(common_1.CommonFlags.COMPILED));
        if (func.functionTableIndex >= 0) {
            return func.functionTableIndex;
        }
        var functionTable = this.functionTable;
        var index = functionTable.length;
        if (!func.is(common_1.CommonFlags.TRAMPOLINE) && func.signature.requiredParameters < func.signature.parameterTypes.length) {
            // insert the trampoline if the function has optional parameters
            func = this.ensureTrampoline(func);
        }
        functionTable.push(func.internalName);
        func.functionTableIndex = index;
        return index;
    }
    // === Statements ===============================================================================
    compileTopLevelStatement(statement, body) {
        switch (statement.kind) {
            case ast_1.NodeKind.CLASSDECLARATION: {
                let memberStatements = statement.members;
                for (let i = 0, k = memberStatements.length; i < k; ++i) {
                    this.compileTopLevelStatement(memberStatements[i], body);
                }
                break;
            }
            case ast_1.NodeKind.ENUMDECLARATION: {
                let element = this.program.getElementByDeclaration(statement);
                if (element) {
                    assert(element.kind == program_1.ElementKind.ENUM);
                    if (!element.hasDecorator(program_1.DecoratorFlags.LAZY))
                        this.compileEnum(element);
                }
                break;
            }
            case ast_1.NodeKind.NAMESPACEDECLARATION: {
                let element = this.program.getElementByDeclaration(statement);
                if (element) {
                    // any potentiall merged element
                    let previousParent = this.currentParent;
                    this.currentParent = element;
                    let memberStatements = statement.members;
                    for (let i = 0, k = memberStatements.length; i < k; ++i) {
                        this.compileTopLevelStatement(memberStatements[i], body);
                    }
                    this.currentParent = previousParent;
                }
                break;
            }
            case ast_1.NodeKind.VARIABLE: {
                let declarations = statement.declarations;
                for (let i = 0, k = declarations.length; i < k; ++i) {
                    let element = this.program.getElementByDeclaration(declarations[i]);
                    if (element) {
                        assert(element.kind == program_1.ElementKind.GLOBAL);
                        if (!element.is(common_1.CommonFlags.AMBIENT) && // delay imports
                            !element.hasDecorator(program_1.DecoratorFlags.LAZY))
                            this.compileGlobal(element);
                    }
                }
                break;
            }
            case ast_1.NodeKind.FIELDDECLARATION: {
                let element = this.program.getElementByDeclaration(statement);
                if (element !== null && element.kind == program_1.ElementKind.GLOBAL) { // static
                    if (!element.hasDecorator(program_1.DecoratorFlags.LAZY))
                        this.compileGlobal(element);
                }
                break;
            }
            case ast_1.NodeKind.EXPORT: {
                if (statement.internalPath != null) {
                    this.compileFileByPath(statement.internalPath, statement.path);
                }
                break;
            }
            case ast_1.NodeKind.EXPORTDEFAULT: {
                this.compileTopLevelStatement(statement.declaration, body);
                break;
            }
            case ast_1.NodeKind.IMPORT: {
                this.compileFileByPath(statement.internalPath, statement.path);
                break;
            }
            case ast_1.NodeKind.FUNCTIONDECLARATION:
            case ast_1.NodeKind.METHODDECLARATION:
            case ast_1.NodeKind.INTERFACEDECLARATION:
            case ast_1.NodeKind.INDEXSIGNATUREDECLARATION:
            case ast_1.NodeKind.TYPEDECLARATION: break;
            default: { // otherwise a top-level statement that is part of the start function's body
                let stmt = this.compileStatement(statement);
                if (module_1.getExpressionId(stmt) != module_1.ExpressionId.Nop)
                    body.push(stmt);
                break;
            }
        }
    }
    compileStatement(statement, isLastInBody = false) {
        var module = this.module;
        var stmt;
        switch (statement.kind) {
            case ast_1.NodeKind.BLOCK: {
                stmt = this.compileBlockStatement(statement);
                break;
            }
            case ast_1.NodeKind.BREAK: {
                stmt = this.compileBreakStatement(statement);
                break;
            }
            case ast_1.NodeKind.CONTINUE: {
                stmt = this.compileContinueStatement(statement);
                break;
            }
            case ast_1.NodeKind.DO: {
                stmt = this.compileDoStatement(statement);
                break;
            }
            case ast_1.NodeKind.EMPTY: {
                stmt = this.compileEmptyStatement(statement);
                break;
            }
            case ast_1.NodeKind.EXPRESSION: {
                stmt = this.compileExpressionStatement(statement);
                break;
            }
            case ast_1.NodeKind.FOR: {
                stmt = this.compileForStatement(statement);
                break;
            }
            case ast_1.NodeKind.IF: {
                stmt = this.compileIfStatement(statement);
                break;
            }
            case ast_1.NodeKind.RETURN: {
                stmt = this.compileReturnStatement(statement, isLastInBody);
                break;
            }
            case ast_1.NodeKind.SWITCH: {
                stmt = this.compileSwitchStatement(statement);
                break;
            }
            case ast_1.NodeKind.THROW: {
                stmt = this.compileThrowStatement(statement);
                break;
            }
            case ast_1.NodeKind.TRY: {
                stmt = this.compileTryStatement(statement);
                break;
            }
            case ast_1.NodeKind.VARIABLE: {
                stmt = this.compileVariableStatement(statement);
                if (!stmt)
                    stmt = module.nop();
                break;
            }
            case ast_1.NodeKind.VOID: {
                stmt = this.compileVoidStatement(statement);
                break;
            }
            case ast_1.NodeKind.WHILE: {
                stmt = this.compileWhileStatement(statement);
                break;
            }
            case ast_1.NodeKind.TYPEDECLARATION: {
                // TODO: integrate inner type declaration into flow
                this.error(diagnostics_1.DiagnosticCode.Not_implemented, statement.range);
                stmt = module.unreachable();
                break;
            }
            default: {
                assert(false);
                stmt = module.unreachable();
            }
        }
        if (this.options.sourceMap)
            this.addDebugLocation(stmt, statement.range);
        return stmt;
    }
    compileStatements(statements, isBody = false, stmts = null) {
        var numStatements = statements.length;
        if (!stmts) {
            stmts = new Array(numStatements);
            stmts.length = 0;
        }
        var module = this.module;
        var flow = this.currentFlow;
        for (let i = 0; i < numStatements; ++i) {
            let stmt = this.compileStatement(statements[i], isBody && i == numStatements - 1);
            switch (module_1.getExpressionId(stmt)) {
                case module_1.ExpressionId.Block: {
                    if (!module_1.getBlockName(stmt)) {
                        for (let j = 0, k = module_1.getBlockChildCount(stmt); j < k; ++j)
                            stmts.push(module_1.getBlockChild(stmt, j));
                        break;
                    }
                    // fall-through
                }
                default: stmts.push(stmt);
                case module_1.ExpressionId.Nop:
            }
            if (flow.isAny(256 /* TERMINATES */ | 16 /* BREAKS */)) {
                if (module_1.needsExplicitUnreachable(stmt))
                    stmts.push(module.unreachable());
                break;
            }
        }
        return stmts;
    }
    compileBlockStatement(statement) {
        var statements = statement.statements;
        var outerFlow = this.currentFlow;
        var innerFlow = outerFlow.fork();
        this.currentFlow = innerFlow;
        var stmts = this.compileStatements(statements);
        if (!innerFlow.isAny(256 /* TERMINATES */ | 16 /* BREAKS */))
            this.performAutoreleases(innerFlow, stmts);
        innerFlow.freeScopedLocals();
        outerFlow.inherit(innerFlow); // TODO: only if not terminated?
        this.currentFlow = outerFlow;
        return flatten(this.module, stmts, module_1.NativeType.None);
    }
    compileBreakStatement(statement) {
        var module = this.module;
        if (statement.label) {
            this.error(diagnostics_1.DiagnosticCode.Not_implemented, statement.label.range);
            return module.unreachable();
        }
        var flow = this.currentFlow;
        var breakLabel = flow.breakLabel;
        if (breakLabel == null) {
            this.error(diagnostics_1.DiagnosticCode.A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement, statement.range);
            return module.unreachable();
        }
        var stmts = new Array();
        this.performAutoreleases(flow, stmts);
        var parent = flow.parent;
        while (parent !== null && parent.breakLabel == breakLabel) {
            this.performAutoreleases(parent, stmts, /* clearFlags */ false);
            parent = parent.parent;
        }
        flow.freeScopedLocals();
        stmts.push(module.br(breakLabel));
        flow.set(16 /* BREAKS */);
        return flatten(module, stmts, module_1.NativeType.None);
    }
    compileContinueStatement(statement) {
        var module = this.module;
        var label = statement.label;
        if (label) {
            this.error(diagnostics_1.DiagnosticCode.Not_implemented, label.range);
            return module.unreachable();
        }
        // Check if 'continue' is allowed here
        var flow = this.currentFlow;
        var continueLabel = flow.continueLabel;
        if (continueLabel == null) {
            this.error(diagnostics_1.DiagnosticCode.A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement, statement.range);
            return module.unreachable();
        }
        flow.set(32 /* CONTINUES */ | 256 /* TERMINATES */);
        var stmts = new Array();
        this.performAutoreleases(flow, stmts);
        var current = flow.parent;
        while (current && current.continueLabel === continueLabel) {
            this.performAutoreleases(current, stmts, /* clearFlags */ false);
            current = current.parent;
        }
        flow.freeScopedLocals();
        stmts.push(module.br(continueLabel));
        return flatten(module, stmts, module_1.NativeType.None);
    }
    compileDoStatement(statement) {
        var module = this.module;
        var outerFlow = this.currentFlow;
        var label = outerFlow.pushBreakLabel();
        var innerFlow = outerFlow.fork();
        var breakLabel = "break|" + label;
        innerFlow.breakLabel = breakLabel;
        var continueLabel = "continue|" + label;
        innerFlow.continueLabel = continueLabel;
        // Compile the condition before the body in order to...
        var condFlow = outerFlow.fork();
        this.currentFlow = condFlow;
        var condExpr = module.precomputeExpression(this.makeIsTrueish(this.compileExpression(statement.condition, types_1.Type.i32), this.currentType));
        assert(!condFlow.hasScopedLocals);
        // ...unify local states before and after the condition has been executed the first time
        innerFlow.unifyLocalFlags(condFlow);
        this.currentFlow = innerFlow;
        var stmts = new Array();
        if (statement.statement.kind == ast_1.NodeKind.BLOCK) {
            this.compileStatements(statement.statement.statements, false, stmts);
        }
        else {
            stmts.push(this.compileStatement(statement.statement));
        }
        var alwaysFalse = false;
        if (module_1.getExpressionId(condExpr) == module_1.ExpressionId.Const) {
            assert(module_1.getExpressionType(condExpr) == module_1.NativeType.I32);
            if (!module_1.getConstValueI32(condExpr))
                alwaysFalse = true;
        }
        var terminates = innerFlow.is(256 /* TERMINATES */);
        var continues = innerFlow.isAny(32 /* CONTINUES */ | 8192 /* CONDITIONALLY_CONTINUES */);
        var breaks = innerFlow.isAny(16 /* BREAKS */ | 4096 /* CONDITIONALLY_BREAKS */);
        // (block $break            ;; (1) skip if no breaks
        //  (loop $continue         ;; (2) skip if skipping (4) + no continues
        //   (...)                  ;; (3)
        //   (br_if cond $continue) ;; (4) skip if (3) does not fall through or always false
        //  )
        // )
        var fallsThrough = !terminates && !innerFlow.is(16 /* BREAKS */);
        if (fallsThrough) {
            this.performAutoreleases(innerFlow, stmts);
            if (!alwaysFalse) { // (4)
                stmts.push(module.br(continueLabel, condExpr));
            }
        }
        var expr = flatten(module, stmts, module_1.NativeType.None);
        if (fallsThrough && !alwaysFalse || continues) { // (2)
            expr = module.loop(continueLabel, expr);
        }
        if (breaks) { // (1)
            expr = module.block(breakLabel, [expr]);
        }
        // Switch back to the parent flow
        innerFlow.freeScopedLocals();
        outerFlow.popBreakLabel();
        innerFlow.unset(16 /* BREAKS */ |
            4096 /* CONDITIONALLY_BREAKS */ |
            32 /* CONTINUES */ |
            8192 /* CONDITIONALLY_CONTINUES */);
        outerFlow.inherit(innerFlow);
        this.currentFlow = outerFlow;
        return expr;
    }
    compileEmptyStatement(statement) {
        return this.module.nop();
    }
    compileExpressionStatement(statement) {
        return this.compileExpression(statement.expression, types_1.Type.void, 1 /* CONV_IMPLICIT */);
    }
    compileForStatement(statement) {
        var module = this.module;
        // Set up and use the inner flow
        var outerFlow = this.currentFlow;
        var label = outerFlow.pushBreakLabel();
        var innerFlow = outerFlow.fork();
        this.currentFlow = innerFlow;
        // Compile the initializer
        var initializer = statement.initializer;
        var initExpr = 0;
        if (initializer)
            initExpr = this.compileStatement(initializer);
        // Compile the condition
        var condExpr = 0;
        var alwaysTrue = false;
        if (statement.condition) {
            condExpr = module.precomputeExpression(this.makeIsTrueish(this.compileExpression(statement.condition, types_1.Type.bool), this.currentType));
            // Simplify if the condition is constant
            if (module_1.getExpressionId(condExpr) == module_1.ExpressionId.Const) {
                assert(module_1.getExpressionType(condExpr) == module_1.NativeType.I32);
                if (module_1.getConstValueI32(condExpr) == /* false */ 0) {
                    let stmts = new Array();
                    if (initExpr)
                        stmts.push(initExpr);
                    this.performAutoreleases(innerFlow, stmts);
                    innerFlow.freeScopedLocals();
                    outerFlow.popBreakLabel();
                    this.currentFlow = outerFlow;
                    return flatten(module, stmts, module_1.NativeType.None);
                }
                alwaysTrue = true;
            }
        }
        else { // Omitted condition is always true
            condExpr = module.i32(1);
            alwaysTrue = true;
        }
        innerFlow.inheritNonnullIfTrue(condExpr);
        // Compile the incrementor before the body in order to...
        var incrementor = statement.incrementor;
        var incrExpr = 0;
        if (incrementor) {
            let incrFlow = innerFlow.fork();
            this.currentFlow = incrFlow;
            incrExpr = this.compileExpression(incrementor, types_1.Type.void, 1 /* CONV_IMPLICIT */ | 8 /* WILL_DROP */);
            assert(!incrFlow.hasScopedLocals);
            this.currentFlow = innerFlow;
            // ...unify local states before and after the incrementor has been executed the first time
            innerFlow.unifyLocalFlags(incrFlow);
        }
        // Compile body (break: drop out, continue: fall through to incrementor, + loop)
        var bodyFlow = innerFlow.fork();
        this.currentFlow = bodyFlow;
        var breakLabel = innerFlow.breakLabel = "break|" + label;
        bodyFlow.breakLabel = breakLabel;
        bodyFlow.breakLabel = breakLabel;
        var continueLabel = "continue|" + label;
        bodyFlow.continueLabel = continueLabel;
        var loopLabel = "loop|" + label;
        var bodyStatement = statement.statement;
        var stmts = new Array();
        if (bodyStatement.kind == ast_1.NodeKind.BLOCK) {
            this.compileStatements(bodyStatement.statements, false, stmts);
        }
        else {
            stmts.push(this.compileStatement(bodyStatement));
        }
        var terminates = bodyFlow.is(256 /* TERMINATES */);
        var continues = bodyFlow.isAny(32 /* CONTINUES */ | 8192 /* CONDITIONALLY_CONTINUES */);
        var breaks = bodyFlow.isAny(16 /* BREAKS */ | 4096 /* CONDITIONALLY_BREAKS */);
        var fallsThrough = !terminates && !innerFlow.is(16 /* BREAKS */);
        // Finalize body flow
        if (fallsThrough)
            this.performAutoreleases(bodyFlow, stmts);
        bodyFlow.freeScopedLocals();
        innerFlow.inherit(bodyFlow);
        this.currentFlow = innerFlow;
        // (block $break          ;; (1) skip label (needed anyway) if skipping (4) + no breaks
        //  (initializer)         ;; (2) [may be empty]
        //  (loop $loop           ;; (3) skip if (6) does not fall through + no continues
        //   (br_if !cond $break) ;; (4) skip if always true
        //   (block $continue     ;; (5) skip if no continues or nothing else than continue
        //    (...)               ;; (6)
        //   )
        //   (incrementor)        ;; (7) skip if skipping (3) [may be empty]
        //   (br $loop)           ;; (8) skip if skipping (3)
        //  )
        // )
        var needsLabel = !alwaysTrue || breaks;
        var loop = new Array();
        if (!alwaysTrue) { // (4)
            loop.push(module.br(breakLabel, module.unary(module_1.UnaryOp.EqzI32, condExpr)));
        }
        if (continues) { // (5)
            if (stmts.length > 1 || module_1.getExpressionId(stmts[0]) != module_1.ExpressionId.Break) { // otherwise lonely continue
                loop.push(module.block(continueLabel, stmts));
            }
        }
        else {
            for (let i = 0, k = stmts.length; i < k; ++i)
                loop.push(stmts[i]);
        }
        var expr;
        if (fallsThrough || continues) { // (3)
            if (incrExpr)
                loop.push(incrExpr); // (7)
            this.performAutoreleases(innerFlow, loop);
            loop.push(module.br(loopLabel)); // (8)
            if (initExpr) { // (2)
                expr = module.block(needsLabel ? breakLabel : null, [
                    initExpr,
                    module.loop(loopLabel, module.block(null, loop))
                ]);
            }
            else {
                expr = module.block(needsLabel ? breakLabel : null, [
                    module.loop(loopLabel, flatten(module, loop, module_1.NativeType.None))
                ]);
            }
        }
        else {
            if (initExpr)
                loop.unshift(initExpr); // (2)
            this.performAutoreleases(innerFlow, loop);
            expr = module.block(needsLabel ? breakLabel : null, loop);
        }
        // Switch back to the parent flow
        innerFlow.freeScopedLocals();
        outerFlow.popBreakLabel();
        innerFlow.unset(16 /* BREAKS */ |
            4096 /* CONDITIONALLY_BREAKS */ |
            32 /* CONTINUES */ |
            8192 /* CONDITIONALLY_CONTINUES */);
        if (alwaysTrue)
            outerFlow.inherit(innerFlow);
        else
            outerFlow.inheritConditional(innerFlow);
        this.currentFlow = outerFlow;
        return expr;
    }
    compileIfStatement(statement) {
        var module = this.module;
        var ifTrue = statement.ifTrue;
        var ifFalse = statement.ifFalse;
        var outerFlow = this.currentFlow;
        // The condition doesn't initiate a branch yet
        var condExpr = module.precomputeExpression(this.makeIsTrueish(this.compileExpression(statement.condition, types_1.Type.bool), this.currentType));
        // Try to eliminate unnecesssary branches if the condition is constant
        if (module_1.getExpressionId(condExpr) == module_1.ExpressionId.Const &&
            module_1.getExpressionType(condExpr) == module_1.NativeType.I32) {
            return module_1.getConstValueI32(condExpr)
                ? this.compileStatement(ifTrue)
                : ifFalse
                    ? this.compileStatement(ifFalse)
                    : module.nop();
        }
        // Each arm initiates a branch
        var ifTrueStmts = new Array();
        var ifTrueFlow = outerFlow.fork();
        this.currentFlow = ifTrueFlow;
        ifTrueFlow.inheritNonnullIfTrue(condExpr);
        if (ifTrue.kind == ast_1.NodeKind.BLOCK) {
            this.compileStatements(ifTrue.statements, false, ifTrueStmts);
        }
        else {
            ifTrueStmts.push(this.compileStatement(ifTrue));
        }
        if (!ifTrueFlow.isAny(256 /* TERMINATES */ | 16 /* BREAKS */))
            this.performAutoreleases(ifTrueFlow, ifTrueStmts);
        ifTrueFlow.freeScopedLocals();
        this.currentFlow = outerFlow;
        if (ifFalse) {
            let ifFalseFlow = outerFlow.fork();
            this.currentFlow = ifFalseFlow;
            ifFalseFlow.inheritNonnullIfFalse(condExpr);
            let ifFalseStmts = new Array();
            if (ifFalse.kind == ast_1.NodeKind.BLOCK) {
                this.compileStatements(ifFalse.statements, false, ifFalseStmts);
            }
            else {
                ifFalseStmts.push(this.compileStatement(ifFalse));
            }
            if (!ifFalseFlow.isAny(256 /* TERMINATES */ | 16 /* BREAKS */))
                this.performAutoreleases(ifFalseFlow, ifFalseStmts);
            ifFalseFlow.freeScopedLocals();
            this.currentFlow = outerFlow;
            outerFlow.inheritMutual(ifTrueFlow, ifFalseFlow);
            return module.if(condExpr, flatten(module, ifTrueStmts, module_1.NativeType.None), flatten(module, ifFalseStmts, module_1.NativeType.None));
        }
        else {
            outerFlow.inheritConditional(ifTrueFlow);
            if (ifTrueFlow.is(256 /* TERMINATES */))
                outerFlow.inheritNonnullIfFalse(condExpr);
            return module.if(condExpr, flatten(module, ifTrueStmts, module_1.NativeType.None));
        }
        // TODO: Detect neglected condition
        // if (!foo) {
        //   foo = [notNull]
        // }
        // foo // is possibly null
    }
    compileReturnStatement(statement, isLastInBody) {
        var module = this.module;
        var expr = 0;
        var flow = this.currentFlow;
        var returnType = flow.returnType;
        // Remember that this flow returns
        flow.set(1 /* RETURNS */ | 256 /* TERMINATES */);
        var valueExpression = statement.value;
        if (valueExpression) {
            if (returnType == types_1.Type.void) {
                this.error(diagnostics_1.DiagnosticCode.Type_0_is_not_assignable_to_type_1, valueExpression.range, this.currentType.toString(), returnType.toString());
                this.currentType = types_1.Type.void;
                return module.unreachable();
            }
            let constraints = 1 /* CONV_IMPLICIT */;
            if (flow.actualFunction.is(common_1.CommonFlags.MODULE_EXPORT))
                constraints |= 4 /* MUST_WRAP */;
            expr = this.compileExpression(valueExpression, returnType, constraints | 16 /* WILL_RETAIN */);
            // when returning a local, and it is already retained, skip the final set
            // of retaining it as the return value and releasing it as a variable
            if (!this.skippedAutoreleases.has(expr)) {
                if (returnType.isManaged) {
                    if (module_1.getExpressionId(expr) == module_1.ExpressionId.LocalGet) {
                        let index = module_1.getLocalGetIndex(expr);
                        if (flow.isAnyLocalFlag(index, flow_1.LocalFlags.ANY_RETAINED)) {
                            flow.unsetLocalFlag(index, flow_1.LocalFlags.ANY_RETAINED);
                            flow.setLocalFlag(index, flow_1.LocalFlags.RETURNED);
                            this.skippedAutoreleases.add(expr);
                        }
                    }
                }
            }
            // remember return states
            if (!flow.canOverflow(expr, returnType))
                flow.set(2 /* RETURNS_WRAPPED */);
            if (flow.isNonnull(expr, returnType))
                flow.set(4 /* RETURNS_NONNULL */);
        }
        else if (returnType != types_1.Type.void) {
            this.error(diagnostics_1.DiagnosticCode.Type_0_is_not_assignable_to_type_1, statement.range, "void", returnType.toString());
            expr = module.unreachable();
        }
        var stmts = new Array();
        this.performAutoreleases(flow, stmts);
        this.finishAutoreleases(flow, stmts);
        // Make sure that the return value is retained for the caller
        if (returnType.isManaged && !this.skippedAutoreleases.has(expr))
            expr = this.makeRetain(expr);
        if (returnType != types_1.Type.void && stmts.length) {
            let temp = flow.getTempLocal(returnType);
            if (flow.isNonnull(expr, returnType))
                flow.setLocalFlag(temp.index, flow_1.LocalFlags.NONNULL);
            stmts.unshift(module.local_set(temp.index, expr));
            expr = module.local_get(temp.index, returnType.toNativeType());
            flow.freeTempLocal(temp);
        }
        flow.freeScopedLocals();
        // If the last statement anyway, make it the block's return value
        if (isLastInBody && expr && returnType != types_1.Type.void) {
            if (!stmts.length)
                return expr;
            stmts.push(expr);
            return module.block(null, stmts, returnType.toNativeType());
        }
        // When inlining, break to the end of the inlined function's block (no need to wrap)
        if (flow.is(32768 /* INLINE_CONTEXT */)) {
            if (!stmts.length)
                return module.br(assert(flow.inlineReturnLabel), 0, expr);
            stmts.push(module.br(assert(flow.inlineReturnLabel), 0, expr));
            // stmts.push(module.createUnreachable());
            return module.block(null, stmts);
        }
        // Otherwise emit a normal return
        if (!stmts.length)
            return module.return(expr);
        stmts.push(module.return(expr));
        return module.block(null, stmts);
    }
    compileSwitchStatement(statement) {
        var module = this.module;
        var cases = statement.cases;
        var numCases = cases.length;
        if (!numCases) {
            return this.compileExpression(statement.condition, types_1.Type.void, 1 /* CONV_IMPLICIT */);
        }
        // Everything within a switch uses the same break context
        var outerFlow = this.currentFlow;
        var context = outerFlow.pushBreakLabel();
        // introduce a local for evaluating the condition (exactly once)
        var tempLocal = outerFlow.getTempLocal(types_1.Type.u32);
        var tempLocalIndex = tempLocal.index;
        // Prepend initializer to inner block. Does not initiate a new branch, yet.
        var breaks = new Array(1 + numCases);
        breaks[0] = module.local_set(// initializer
        tempLocalIndex, this.compileExpression(statement.condition, types_1.Type.u32, 1 /* CONV_IMPLICIT */));
        // make one br_if per (possibly dynamic) labeled case (binaryen optimizes to br_table where possible)
        var breakIndex = 1;
        var defaultIndex = -1;
        for (let i = 0; i < numCases; ++i) {
            let case_ = cases[i];
            let label = case_.label;
            if (label) {
                breaks[breakIndex++] = module.br("case" + i.toString(10) + "|" + context, module.binary(module_1.BinaryOp.EqI32, module.local_get(tempLocalIndex, module_1.NativeType.I32), this.compileExpression(label, types_1.Type.u32, 1 /* CONV_IMPLICIT */)));
            }
            else {
                defaultIndex = i;
            }
        }
        outerFlow.freeTempLocal(tempLocal);
        // otherwise br to default respectively out of the switch if there is no default case
        breaks[breakIndex] = module.br((defaultIndex >= 0
            ? "case" + defaultIndex.toString(10)
            : "break") + "|" + context);
        // nest blocks in order
        var currentBlock = module.block("case0|" + context, breaks, module_1.NativeType.None);
        var commonCategorical = 511 /* ANY_CATEGORICAL */;
        var commonConditional = 0;
        for (let i = 0; i < numCases; ++i) {
            let case_ = cases[i];
            let statements = case_.statements;
            let numStatements = statements.length;
            // Each switch case initiates a new branch
            let innerFlow = outerFlow.fork();
            this.currentFlow = innerFlow;
            let breakLabel = "break|" + context;
            innerFlow.breakLabel = breakLabel;
            let isLast = i == numCases - 1;
            let nextLabel = isLast ? breakLabel : "case" + (i + 1).toString(10) + "|" + context;
            let stmts = new Array(1 + numStatements);
            stmts[0] = currentBlock;
            let count = 1;
            let terminates = false;
            for (let j = 0; j < numStatements; ++j) {
                let stmt = this.compileStatement(statements[j]);
                if (module_1.getExpressionId(stmt) != module_1.ExpressionId.Nop) {
                    stmts[count++] = stmt;
                }
                if (innerFlow.isAny(256 /* TERMINATES */ | 16 /* BREAKS */)) {
                    if (innerFlow.is(256 /* TERMINATES */))
                        terminates = true;
                    break;
                }
            }
            stmts.length = count;
            if (terminates || isLast || innerFlow.isAny(16 /* BREAKS */ | 4096 /* CONDITIONALLY_BREAKS */)) {
                commonCategorical &= innerFlow.flags;
            }
            commonConditional |= innerFlow.flags & 30208 /* ANY_CONDITIONAL */;
            // Switch back to the parent flow
            if (!terminates)
                this.performAutoreleases(innerFlow, stmts);
            innerFlow.unset(16 /* BREAKS */ |
                4096 /* CONDITIONALLY_BREAKS */);
            innerFlow.freeScopedLocals();
            this.currentFlow = outerFlow;
            currentBlock = module.block(nextLabel, stmts, module_1.NativeType.None); // must be a labeled block
        }
        outerFlow.popBreakLabel();
        // If the switch has a default (guaranteed to handle any value), propagate common flags
        if (defaultIndex >= 0)
            outerFlow.flags |= commonCategorical & ~16 /* BREAKS */;
        outerFlow.flags |= commonConditional & ~4096 /* CONDITIONALLY_BREAKS */;
        // TODO: what about local states?
        return currentBlock;
    }
    compileThrowStatement(statement) {
        var flow = this.currentFlow;
        // Remember that this branch throws
        flow.set(8 /* THROWS */ | 256 /* TERMINATES */);
        var stmts = new Array();
        this.finishAutoreleases(flow, stmts);
        // TODO: requires exception-handling spec.
        var value = statement.value;
        var message = null;
        if (value.kind == ast_1.NodeKind.NEW) {
            let newArgs = value.arguments;
            if (newArgs.length)
                message = newArgs[0]; // FIXME: naively assumes type string
        }
        stmts.push(builtins_1.compileAbort(this, message, statement));
        return flatten(this.module, stmts, module_1.NativeType.None);
    }
    compileTryStatement(statement) {
        // TODO: can't yet support something like: try { return ... } finally { ... }
        // worthwhile to investigate lowering returns to block results (here)?
        this.error(diagnostics_1.DiagnosticCode.Not_implemented, statement.range);
        return this.module.unreachable();
    }
    /** Compiles a variable statement. Returns `0` if an initializer is not necessary. */
    compileVariableStatement(statement) {
        var module = this.module;
        var declarations = statement.declarations;
        var numDeclarations = declarations.length;
        var flow = this.currentFlow;
        var initializers = new Array();
        var resolver = this.resolver;
        for (let i = 0; i < numDeclarations; ++i) {
            let declaration = declarations[i];
            let name = declaration.name.text;
            let type = null;
            let initExpr = 0;
            let initAutoreleaseSkipped = false;
            // Resolve type if annotated
            if (declaration.type) {
                type = resolver.resolveType(// reports
                declaration.type, flow.actualFunction, flow.contextualTypeArguments);
                if (!type)
                    continue;
                if (declaration.initializer) {
                    initExpr = this.compileExpression(declaration.initializer, type, // reports
                    1 /* CONV_IMPLICIT */ | 16 /* WILL_RETAIN */);
                    initAutoreleaseSkipped = this.skippedAutoreleases.has(initExpr);
                }
                // Otherwise infer type from initializer
            }
            else if (declaration.initializer) {
                initExpr = this.compileExpression(declaration.initializer, types_1.Type.auto, 16 /* WILL_RETAIN */); // reports
                initAutoreleaseSkipped = this.skippedAutoreleases.has(initExpr);
                if (this.currentType == types_1.Type.void) {
                    this.error(diagnostics_1.DiagnosticCode.Type_0_is_not_assignable_to_type_1, declaration.range, this.currentType.toString(), "<auto>");
                    continue;
                }
                type = this.currentType;
                // Error if there's neither a type nor an initializer
            }
            else {
                this.error(diagnostics_1.DiagnosticCode.Type_expected, declaration.name.range.atEnd);
                continue;
            }
            // Handle constants, and try to inline if value is static
            let isConst = declaration.is(common_1.CommonFlags.CONST);
            let isStatic = false;
            if (isConst) {
                if (initExpr) {
                    initExpr = module.precomputeExpression(initExpr);
                    if (module_1.getExpressionId(initExpr) == module_1.ExpressionId.Const) {
                        let local = new program_1.Local(name, -1, type, flow.parentFunction);
                        switch (module_1.getExpressionType(initExpr)) {
                            case module_1.NativeType.I32: {
                                local.setConstantIntegerValue(i64_new(module_1.getConstValueI32(initExpr), 0), type);
                                break;
                            }
                            case module_1.NativeType.I64: {
                                local.setConstantIntegerValue(i64_new(module_1.getConstValueI64Low(initExpr), module_1.getConstValueI64High(initExpr)), type);
                                break;
                            }
                            case module_1.NativeType.F32: {
                                local.setConstantFloatValue(module_1.getConstValueF32(initExpr), type);
                                break;
                            }
                            case module_1.NativeType.F64: {
                                local.setConstantFloatValue(module_1.getConstValueF64(initExpr), type);
                                break;
                            }
                            default: {
                                assert(false);
                                return module.unreachable();
                            }
                        }
                        // Create a virtual local that doesn't actually exist in WebAssembly
                        let scopedLocals = flow.scopedLocals;
                        if (!scopedLocals)
                            flow.scopedLocals = scopedLocals = new Map();
                        else if (scopedLocals.has(name)) {
                            let existing = scopedLocals.get(name);
                            this.errorRelated(diagnostics_1.DiagnosticCode.Duplicate_identifier_0, declaration.name.range, existing.declaration.name.range, name);
                            return this.module.unreachable();
                        }
                        scopedLocals.set(name, local);
                        isStatic = true;
                    }
                }
                else {
                    this.error(diagnostics_1.DiagnosticCode._const_declarations_must_be_initialized, declaration.range);
                }
            }
            // Otherwise compile as mutable
            if (!isStatic) {
                let local;
                if (declaration.isAny(common_1.CommonFlags.LET | common_1.CommonFlags.CONST) ||
                    flow.is(32768 /* INLINE_CONTEXT */)) { // here: not top-level
                    let existingLocal = flow.getScopedLocal(name);
                    if (existingLocal) {
                        if (!existingLocal.declaration.range.source.isNative) {
                            this.errorRelated(diagnostics_1.DiagnosticCode.Duplicate_identifier_0, declaration.name.range, existingLocal.declaration.name.range, name);
                        }
                        else { // scoped locals are shared temps that don't track declarations
                            this.error(diagnostics_1.DiagnosticCode.Duplicate_identifier_0, declaration.name.range, name);
                        }
                        local = existingLocal;
                    }
                    else {
                        local = flow.addScopedLocal(name, type);
                    }
                    if (isConst)
                        flow.setLocalFlag(local.index, flow_1.LocalFlags.CONSTANT);
                }
                else {
                    let existing = flow.lookupLocal(name);
                    if (existing) {
                        this.errorRelated(diagnostics_1.DiagnosticCode.Duplicate_identifier_0, declaration.name.range, existing.declaration.name.range, name);
                        continue;
                    }
                    local = flow.parentFunction.addLocal(type, name, declaration);
                    if (isConst)
                        flow.setLocalFlag(local.index, flow_1.LocalFlags.CONSTANT);
                }
                let isManaged = type.isManaged;
                if (initExpr) {
                    if (flow.isNonnull(initExpr, type))
                        flow.setLocalFlag(local.index, flow_1.LocalFlags.NONNULL);
                    if (isManaged) {
                        flow.setLocalFlag(local.index, flow_1.LocalFlags.RETAINED);
                        initializers.push(module.local_set(local.index, initAutoreleaseSkipped
                            ? initExpr
                            : this.makeRetain(initExpr)));
                    }
                    else {
                        initializers.push(module.local_set(local.index, initExpr));
                        if (local.type.is(32 /* SHORT */ | 4 /* INTEGER */)) {
                            if (!flow.canOverflow(initExpr, type))
                                flow.setLocalFlag(local.index, flow_1.LocalFlags.WRAPPED);
                            else
                                flow.unsetLocalFlag(local.index, flow_1.LocalFlags.WRAPPED);
                        }
                    }
                }
                else {
                    if (isManaged) {
                        // This is necessary because the first use (and assign) of the local could be taking place
                        // in a loop, subsequently marking it retained, but the second iteration of the loop
                        // still wouldn't release whatever is assigned in the first. Likewise, if the variable wasn't
                        // initialized but becomes released later on, whatever was stored before would be released.
                        // TODO: Detect this condition inside of a loop instead?
                        initializers.push(module.local_set(local.index, type.toNativeZero(module)));
                        flow.setLocalFlag(local.index, flow_1.LocalFlags.CONDITIONALLY_RETAINED);
                    }
                    else if (local.type.is(32 /* SHORT */ | 4 /* INTEGER */)) {
                        flow.setLocalFlag(local.index, flow_1.LocalFlags.WRAPPED);
                    }
                }
            }
        }
        return initializers.length == 0
            ? 0
            : flatten(module, initializers, module_1.NativeType.None);
    }
    compileVoidStatement(statement) {
        return this.compileExpression(statement.expression, types_1.Type.void, 2 /* CONV_EXPLICIT */ | 8 /* WILL_DROP */);
    }
    compileWhileStatement(statement) {
        var module = this.module;
        var outerFlow = this.currentFlow;
        // Compile condition
        var condExpr = module.precomputeExpression(this.makeIsTrueish(this.compileExpression(statement.condition, types_1.Type.bool), this.currentType));
        // Simplify if the condition is constant
        var alwaysTrue = false;
        if (module_1.getExpressionId(condExpr) == module_1.ExpressionId.Const) {
            assert(module_1.getExpressionType(condExpr) == module_1.NativeType.I32);
            if (!module_1.getConstValueI32(condExpr))
                return module.nop(); // simplify
            alwaysTrue = true;
        }
        // Compile body
        var label = outerFlow.pushBreakLabel();
        var innerFlow = outerFlow.fork();
        this.currentFlow = innerFlow;
        var breakLabel = "break|" + label;
        innerFlow.breakLabel = breakLabel;
        var continueLabel = "continue|" + label;
        innerFlow.continueLabel = continueLabel;
        innerFlow.inheritNonnullIfTrue(condExpr);
        var stmts = new Array();
        if (statement.statement.kind == ast_1.NodeKind.BLOCK) {
            this.compileStatements(statement.statement.statements, false, stmts);
        }
        else {
            stmts.push(this.compileStatement(statement.statement));
        }
        var terminates = innerFlow.is(256 /* TERMINATES */);
        // (block $break          ;; (1) skip if skipping (3) + no breaks
        //  (loop $continue       ;; (2) skip if skipping (5) + no continues
        //   (br_if !cond $break) ;; (3) skip if always true
        //   (...)                ;; (4)
        //   (br $continue)       ;; (5) skip if (4) does not fall through
        //  )
        // )
        var fallsThrough = !terminates && !innerFlow.is(16 /* BREAKS */);
        if (fallsThrough) { // (5)
            this.performAutoreleases(innerFlow, stmts);
            stmts.push(module.br(continueLabel));
        }
        if (!alwaysTrue) { // (3)
            stmts.unshift(module.br(breakLabel, module.unary(module_1.UnaryOp.EqzI32, condExpr)));
        }
        var expr = flatten(module, stmts, module_1.NativeType.None);
        if (fallsThrough || innerFlow.isAny(32 /* CONTINUES */ | 8192 /* CONDITIONALLY_CONTINUES */)) { // (2)
            expr = module.loop(continueLabel, expr);
        }
        if (!alwaysTrue || innerFlow.isAny(16 /* BREAKS */ | 4096 /* CONDITIONALLY_BREAKS */)) { // (1)
            expr = module.block(breakLabel, [expr]);
        }
        // Switch back to the parent flow
        innerFlow.freeScopedLocals();
        outerFlow.popBreakLabel();
        innerFlow.unset(16 /* BREAKS */ |
            4096 /* CONDITIONALLY_BREAKS */ |
            32 /* CONTINUES */ |
            8192 /* CONDITIONALLY_CONTINUES */);
        if (alwaysTrue)
            outerFlow.inherit(innerFlow);
        else
            outerFlow.inheritConditional(innerFlow);
        this.currentFlow = outerFlow;
        return expr;
    }
    // === Expressions ==============================================================================
    /** Compiles the value of an inlined constant element. */
    compileInlineConstant(element, contextualType, constraints) {
        assert(element.is(common_1.CommonFlags.INLINED));
        var type = element.type;
        switch (!(constraints & (1 /* CONV_IMPLICIT */ | 2 /* CONV_EXPLICIT */)) &&
            type.is(4 /* INTEGER */) &&
            contextualType.is(4 /* INTEGER */) &&
            type.size < contextualType.size
            ? (this.currentType = contextualType).kind // essentially precomputes a (sign-)extension
            : (this.currentType = type).kind) {
            case 0 /* I8 */:
            case 1 /* I16 */: {
                let shift = type.computeSmallIntegerShift(types_1.Type.i32);
                return this.module.i32(element.constantValueKind == 1 /* INTEGER */
                    ? i64_low(element.constantIntegerValue) << shift >> shift
                    : 0); // recognized by canOverflow
            }
            case 5 /* U8 */:
            case 6 /* U16 */:
            case 10 /* BOOL */: {
                let mask = element.type.computeSmallIntegerMask(types_1.Type.i32);
                return this.module.i32(element.constantValueKind == 1 /* INTEGER */
                    ? i64_low(element.constantIntegerValue) & mask
                    : 0); // recognized by canOverflow
            }
            case 2 /* I32 */:
            case 7 /* U32 */: {
                return this.module.i32(element.constantValueKind == 1 /* INTEGER */
                    ? i64_low(element.constantIntegerValue)
                    : 0);
            }
            case 4 /* ISIZE */:
            case 9 /* USIZE */: {
                if (!element.program.options.isWasm64) {
                    return this.module.i32(element.constantValueKind == 1 /* INTEGER */
                        ? i64_low(element.constantIntegerValue)
                        : 0);
                }
                // fall-through
            }
            case 3 /* I64 */:
            case 8 /* U64 */: {
                return element.constantValueKind == 1 /* INTEGER */
                    ? this.module.i64(i64_low(element.constantIntegerValue), i64_high(element.constantIntegerValue))
                    : this.module.i64(0);
            }
            case 12 /* F64 */: {
                // monkey-patch for converting built-in floats to f32 implicitly
                if (!(element.hasDecorator(program_1.DecoratorFlags.BUILTIN) && contextualType == types_1.Type.f32)) {
                    return this.module.f64(element.constantFloatValue);
                }
                // otherwise fall-through: basically precomputes f32.demote/f64 of NaN / Infinity
                this.currentType = types_1.Type.f32;
            }
            case 11 /* F32 */: {
                return this.module.f32(element.constantFloatValue);
            }
            default: {
                assert(false);
                return this.module.unreachable();
            }
        }
    }
    compileExpression(expression, contextualType, constraints = 0 /* NONE */) {
        while (expression.kind == ast_1.NodeKind.PARENTHESIZED) { // skip
            expression = expression.expression;
        }
        this.currentType = contextualType;
        if (contextualType == types_1.Type.void)
            constraints |= 8 /* WILL_DROP */;
        var expr;
        switch (expression.kind) {
            case ast_1.NodeKind.ASSERTION: {
                expr = this.compileAssertionExpression(expression, contextualType, constraints);
                break;
            }
            case ast_1.NodeKind.BINARY: {
                expr = this.compileBinaryExpression(expression, contextualType, constraints);
                break;
            }
            case ast_1.NodeKind.CALL: {
                expr = this.compileCallExpression(expression, contextualType, constraints);
                break;
            }
            case ast_1.NodeKind.COMMA: {
                expr = this.compileCommaExpression(expression, contextualType, constraints);
                break;
            }
            case ast_1.NodeKind.ELEMENTACCESS: {
                expr = this.compileElementAccessExpression(expression, contextualType, constraints);
                break;
            }
            case ast_1.NodeKind.FUNCTION: {
                expr = this.compileFunctionExpression(expression, contextualType.signatureReference, constraints);
                break;
            }
            case ast_1.NodeKind.IDENTIFIER:
            case ast_1.NodeKind.FALSE:
            case ast_1.NodeKind.NULL:
            case ast_1.NodeKind.THIS:
            case ast_1.NodeKind.SUPER:
            case ast_1.NodeKind.TRUE: {
                expr = this.compileIdentifierExpression(expression, contextualType, constraints);
                break;
            }
            case ast_1.NodeKind.INSTANCEOF: {
                expr = this.compileInstanceOfExpression(expression, contextualType, constraints);
                break;
            }
            case ast_1.NodeKind.LITERAL: {
                expr = this.compileLiteralExpression(expression, contextualType, constraints);
                break;
            }
            case ast_1.NodeKind.NEW: {
                expr = this.compileNewExpression(expression, contextualType, constraints);
                break;
            }
            case ast_1.NodeKind.PROPERTYACCESS: {
                expr = this.compilePropertyAccessExpression(expression, contextualType, constraints);
                break;
            }
            case ast_1.NodeKind.TERNARY: {
                expr = this.compileTernaryExpression(expression, contextualType, constraints);
                break;
            }
            case ast_1.NodeKind.UNARYPOSTFIX: {
                expr = this.compileUnaryPostfixExpression(expression, contextualType, constraints);
                break;
            }
            case ast_1.NodeKind.UNARYPREFIX: {
                expr = this.compileUnaryPrefixExpression(expression, contextualType, constraints);
                break;
            }
            default: {
                this.error(diagnostics_1.DiagnosticCode.Not_implemented, expression.range);
                expr = this.module.unreachable();
            }
        }
        // ensure conversion and wrapping in case the respective function doesn't on its own
        var currentType = this.currentType;
        var wrap = (constraints & 4 /* MUST_WRAP */) != 0;
        if (currentType != contextualType) {
            if (constraints & 2 /* CONV_EXPLICIT */) {
                expr = this.convertExpression(expr, currentType, contextualType, true, wrap, expression);
                wrap = false;
                this.currentType = contextualType;
            }
            else if (constraints & 1 /* CONV_IMPLICIT */) {
                expr = this.convertExpression(expr, currentType, contextualType, false, wrap, expression);
                wrap = false;
                this.currentType = contextualType;
            }
        }
        if (wrap)
            expr = this.ensureSmallIntegerWrap(expr, currentType);
        // debug location is added here so the caller doesn't have to. means: compilation of an expression
        // must go through this function, with the respective per-kind functions not being used directly.
        if (this.options.sourceMap)
            this.addDebugLocation(expr, expression.range);
        return expr;
    }
    /** Compiles and precomputes an expression, possibly yielding a costant value. */
    precomputeExpression(expression, contextualType, constraints = 0 /* NONE */) {
        return this.module.precomputeExpression(this.compileExpression(expression, contextualType, constraints));
    }
    convertExpression(expr, 
    /** Original type. */
    fromType, 
    /** New type. */
    toType, 
    /** Whether the conversion is explicit.*/
    explicit, 
    /** Whether the result should be wrapped, if a small integer. */
    wrap, reportNode) {
        var module = this.module;
        // void to any
        if (fromType.kind == 15 /* VOID */) {
            assert(toType.kind != 15 /* VOID */); // convertExpression should not be called with void -> void
            this.error(diagnostics_1.DiagnosticCode.Type_0_is_not_assignable_to_type_1, reportNode.range, fromType.toString(), toType.toString());
            return module.unreachable();
        }
        // any to void
        if (toType.kind == 15 /* VOID */)
            return module.drop(expr);
        if (this.currentFlow.isNonnull(expr, fromType))
            fromType = fromType.nonNullableType;
        if (!fromType.isAssignableTo(toType)) {
            if (!explicit) {
                if (fromType.nonNullableType == toType) {
                    this.error(diagnostics_1.DiagnosticCode.Object_is_possibly_null, reportNode.range); // recoverable
                }
                else {
                    this.error(diagnostics_1.DiagnosticCode.Conversion_from_type_0_to_1_requires_an_explicit_cast, reportNode.range, fromType.toString(), toType.toString()); // recoverable
                }
            }
        }
        if (fromType.is(8 /* FLOAT */)) {
            // float to float
            if (toType.is(8 /* FLOAT */)) {
                if (fromType.kind == 11 /* F32 */) {
                    // f32 to f64
                    if (toType.kind == 12 /* F64 */) {
                        expr = module.unary(module_1.UnaryOp.PromoteF32, expr);
                    }
                    // otherwise f32 to f32
                    // f64 to f32
                }
                else if (toType.kind == 11 /* F32 */) {
                    expr = module.unary(module_1.UnaryOp.DemoteF64, expr);
                }
                // otherwise f64 to f64
                // float to int
            }
            else if (toType.is(4 /* INTEGER */)) {
                // f32 to int
                if (fromType.kind == 11 /* F32 */) {
                    if (toType == types_1.Type.bool) {
                        expr = module.binary(module_1.BinaryOp.NeF32, expr, module.f32(0));
                        wrap = false;
                    }
                    else if (toType.is(1 /* SIGNED */)) {
                        if (toType.is(64 /* LONG */)) {
                            expr = module.unary(module_1.UnaryOp.TruncF32ToI64, expr);
                        }
                        else {
                            expr = module.unary(module_1.UnaryOp.TruncF32ToI32, expr);
                        }
                    }
                    else {
                        if (toType.is(64 /* LONG */)) {
                            expr = module.unary(module_1.UnaryOp.TruncF32ToU64, expr);
                        }
                        else {
                            expr = module.unary(module_1.UnaryOp.TruncF32ToU32, expr);
                        }
                    }
                    // f64 to int
                }
                else {
                    if (toType == types_1.Type.bool) {
                        expr = module.binary(module_1.BinaryOp.NeF64, expr, module.f64(0));
                        wrap = false;
                    }
                    else if (toType.is(1 /* SIGNED */)) {
                        if (toType.is(64 /* LONG */)) {
                            expr = module.unary(module_1.UnaryOp.TruncF64ToI64, expr);
                        }
                        else {
                            expr = module.unary(module_1.UnaryOp.TruncF64ToI32, expr);
                        }
                    }
                    else {
                        if (toType.is(64 /* LONG */)) {
                            expr = module.unary(module_1.UnaryOp.TruncF64ToU64, expr);
                        }
                        else {
                            expr = module.unary(module_1.UnaryOp.TruncF64ToU32, expr);
                        }
                    }
                }
                // float to void
            }
            else {
                assert(toType.flags == 0 /* NONE */, "void type expected");
                expr = module.drop(expr);
            }
            // int to float
        }
        else if (fromType.is(4 /* INTEGER */) && toType.is(8 /* FLOAT */)) {
            // int to f32
            if (toType.kind == 11 /* F32 */) {
                if (fromType.is(64 /* LONG */)) {
                    expr = module.unary(fromType.is(1 /* SIGNED */)
                        ? module_1.UnaryOp.ConvertI64ToF32
                        : module_1.UnaryOp.ConvertU64ToF32, expr);
                }
                else {
                    expr = module.unary(fromType.is(1 /* SIGNED */)
                        ? module_1.UnaryOp.ConvertI32ToF32
                        : module_1.UnaryOp.ConvertU32ToF32, expr);
                }
                // int to f64
            }
            else {
                if (fromType.is(64 /* LONG */)) {
                    expr = module.unary(fromType.is(1 /* SIGNED */)
                        ? module_1.UnaryOp.ConvertI64ToF64
                        : module_1.UnaryOp.ConvertU64ToF64, expr);
                }
                else {
                    expr = module.unary(fromType.is(1 /* SIGNED */)
                        ? module_1.UnaryOp.ConvertI32ToF64
                        : module_1.UnaryOp.ConvertU32ToF64, expr);
                }
            }
            // int to int
        }
        else {
            // i64 to ...
            if (fromType.is(64 /* LONG */)) {
                // i64 to i32 or smaller
                if (toType == types_1.Type.bool) {
                    expr = module.binary(module_1.BinaryOp.NeI64, expr, module.i64(0));
                    wrap = false;
                }
                else if (!toType.is(64 /* LONG */)) {
                    expr = module.unary(module_1.UnaryOp.WrapI64, expr); // discards upper bits
                }
                // i32 or smaller to i64
            }
            else if (toType.is(64 /* LONG */)) {
                expr = module.unary(fromType.is(1 /* SIGNED */) ? module_1.UnaryOp.ExtendI32 : module_1.UnaryOp.ExtendU32, this.ensureSmallIntegerWrap(expr, fromType) // must clear garbage bits
                );
                wrap = false;
                // i32 to i32
            }
            else {
                // small i32 to ...
                if (fromType.is(32 /* SHORT */)) {
                    // small i32 to larger i32
                    if (fromType.size < toType.size) {
                        expr = this.ensureSmallIntegerWrap(expr, fromType); // must clear garbage bits
                        wrap = false;
                    }
                }
            }
        }
        this.currentType = toType;
        return wrap
            ? this.ensureSmallIntegerWrap(expr, toType)
            : expr;
    }
    compileAssertionExpression(expression, contextualType, constraints) {
        var inheritedConstraints = constraints & ~(1 /* CONV_IMPLICIT */ | 2 /* CONV_EXPLICIT */);
        switch (expression.assertionKind) {
            case ast_1.AssertionKind.PREFIX:
            case ast_1.AssertionKind.AS: {
                let flow = this.currentFlow;
                let toType = this.resolver.resolveType(// reports
                assert(expression.toType), flow.actualFunction, flow.contextualTypeArguments);
                if (!toType)
                    return this.module.unreachable();
                return this.compileExpression(expression.expression, toType, inheritedConstraints | 2 /* CONV_EXPLICIT */);
            }
            case ast_1.AssertionKind.NONNULL: {
                assert(!expression.toType);
                let expr = this.compileExpression(expression.expression, contextualType.exceptVoid, inheritedConstraints);
                let type = this.currentType;
                if (this.currentFlow.isNonnull(expr, type)) {
                    this.info(diagnostics_1.DiagnosticCode.Expression_is_never_null, expression.expression.range);
                }
                else if (!this.options.noAssert) {
                    let module = this.module;
                    let flow = this.currentFlow;
                    let temp = flow.getTempLocal(type);
                    if (!flow.canOverflow(expr, type))
                        flow.setLocalFlag(temp.index, flow_1.LocalFlags.WRAPPED);
                    flow.setLocalFlag(temp.index, flow_1.LocalFlags.NONNULL);
                    expr = module.if(module.local_tee(temp.index, expr), module.local_get(temp.index, type.toNativeType()), module.unreachable());
                    flow.freeTempLocal(temp);
                }
                this.currentType = this.currentType.nonNullableType;
                return expr;
            }
            default: assert(false);
        }
        return this.module.unreachable();
    }
    compileBinaryExpression(expression, contextualType, constraints) {
        var module = this.module;
        var left = expression.left;
        var right = expression.right;
        var leftExpr;
        var leftType;
        var rightExpr;
        var rightType;
        var commonType;
        var expr;
        var compound = false;
        var operator = expression.operator;
        switch (operator) {
            case tokenizer_1.Token.LESSTHAN: {
                leftExpr = this.compileExpression(left, contextualType);
                leftType = this.currentType;
                // check operator overload
                if (this.currentType.is(256 /* REFERENCE */)) {
                    let classReference = leftType.classReference;
                    if (classReference) {
                        let overload = classReference.lookupOverload(program_1.OperatorKind.LT);
                        if (overload) {
                            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);
                            break;
                        }
                    }
                    this.error(diagnostics_1.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1, expression.range, "<", leftType.toString());
                    return this.module.unreachable();
                }
                rightExpr = this.compileExpression(right, leftType);
                rightType = this.currentType;
                if (commonType = types_1.Type.commonDenominator(leftType, rightType, true)) {
                    leftExpr = this.convertExpression(leftExpr, leftType, leftType = commonType, false, true, // !
                    left);
                    rightExpr = this.convertExpression(rightExpr, rightType, rightType = commonType, false, true, // !
                    right);
                }
                else {
                    this.error(diagnostics_1.DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2, expression.range, "<", leftType.toString(), rightType.toString());
                    this.currentType = contextualType;
                    return module.unreachable();
                }
                switch (commonType.kind) {
                    case 0 /* I8 */:
                    case 1 /* I16 */:
                    case 2 /* I32 */: {
                        expr = module.binary(module_1.BinaryOp.LtI32, leftExpr, rightExpr);
                        break;
                    }
                    case 3 /* I64 */: {
                        expr = module.binary(module_1.BinaryOp.LtI64, leftExpr, rightExpr);
                        break;
                    }
                    case 4 /* ISIZE */: {
                        expr = module.binary(this.options.isWasm64
                            ? module_1.BinaryOp.LtI64
                            : module_1.BinaryOp.LtI32, leftExpr, rightExpr);
                        break;
                    }
                    case 5 /* U8 */:
                    case 6 /* U16 */:
                    case 7 /* U32 */:
                    case 10 /* BOOL */: {
                        expr = module.binary(module_1.BinaryOp.LtU32, leftExpr, rightExpr);
                        break;
                    }
                    case 9 /* USIZE */: {
                        expr = module.binary(this.options.isWasm64
                            ? module_1.BinaryOp.LtU64
                            : module_1.BinaryOp.LtU32, leftExpr, rightExpr);
                        break;
                    }
                    case 8 /* U64 */: {
                        expr = module.binary(module_1.BinaryOp.LtU64, leftExpr, rightExpr);
                        break;
                    }
                    case 11 /* F32 */: {
                        expr = module.binary(module_1.BinaryOp.LtF32, leftExpr, rightExpr);
                        break;
                    }
                    case 12 /* F64 */: {
                        expr = module.binary(module_1.BinaryOp.LtF64, leftExpr, rightExpr);
                        break;
                    }
                    default: {
                        assert(false);
                        expr = module.unreachable();
                    }
                }
                this.currentType = types_1.Type.bool;
                break;
            }
            case tokenizer_1.Token.GREATERTHAN: {
                leftExpr = this.compileExpression(left, contextualType);
                leftType = this.currentType;
                // check operator overload
                if (this.currentType.is(256 /* REFERENCE */)) {
                    let classReference = leftType.classReference;
                    if (classReference) {
                        let overload = classReference.lookupOverload(program_1.OperatorKind.GT);
                        if (overload) {
                            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);
                            break;
                        }
                    }
                    this.error(diagnostics_1.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1, expression.range, ">", leftType.toString());
                    return this.module.unreachable();
                }
                rightExpr = this.compileExpression(right, leftType);
                rightType = this.currentType;
                if (commonType = types_1.Type.commonDenominator(leftType, rightType, true)) {
                    leftExpr = this.convertExpression(leftExpr, leftType, leftType = commonType, false, true, // !
                    left);
                    rightExpr = this.convertExpression(rightExpr, rightType, rightType = commonType, false, true, // !
                    right);
                }
                else {
                    this.error(diagnostics_1.DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2, expression.range, ">", leftType.toString(), rightType.toString());
                    this.currentType = contextualType;
                    return module.unreachable();
                }
                switch (commonType.kind) {
                    case 0 /* I8 */:
                    case 1 /* I16 */:
                    case 2 /* I32 */: {
                        expr = module.binary(module_1.BinaryOp.GtI32, leftExpr, rightExpr);
                        break;
                    }
                    case 4 /* ISIZE */: {
                        expr = module.binary(this.options.isWasm64
                            ? module_1.BinaryOp.GtI64
                            : module_1.BinaryOp.GtI32, leftExpr, rightExpr);
                        break;
                    }
                    case 3 /* I64 */: {
                        expr = module.binary(module_1.BinaryOp.GtI64, leftExpr, rightExpr);
                        break;
                    }
                    case 5 /* U8 */:
                    case 6 /* U16 */:
                    case 7 /* U32 */:
                    case 10 /* BOOL */: {
                        expr = module.binary(module_1.BinaryOp.GtU32, leftExpr, rightExpr);
                        break;
                    }
                    case 9 /* USIZE */: {
                        expr = module.binary(this.options.isWasm64
                            ? module_1.BinaryOp.GtU64
                            : module_1.BinaryOp.GtU32, leftExpr, rightExpr);
                        break;
                    }
                    case 8 /* U64 */: {
                        expr = module.binary(module_1.BinaryOp.GtU64, leftExpr, rightExpr);
                        break;
                    }
                    case 11 /* F32 */: {
                        expr = module.binary(module_1.BinaryOp.GtF32, leftExpr, rightExpr);
                        break;
                    }
                    case 12 /* F64 */: {
                        expr = module.binary(module_1.BinaryOp.GtF64, leftExpr, rightExpr);
                        break;
                    }
                    default: {
                        assert(false);
                        expr = module.unreachable();
                    }
                }
                this.currentType = types_1.Type.bool;
                break;
            }
            case tokenizer_1.Token.LESSTHAN_EQUALS: {
                leftExpr = this.compileExpression(left, contextualType);
                leftType = this.currentType;
                // check operator overload
                if (this.currentType.is(256 /* REFERENCE */)) {
                    let classReference = leftType.classReference;
                    if (classReference) {
                        let overload = classReference.lookupOverload(program_1.OperatorKind.LE);
                        if (overload) {
                            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);
                            break;
                        }
                    }
                    this.error(diagnostics_1.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1, expression.range, "<=", leftType.toString());
                    return this.module.unreachable();
                }
                rightExpr = this.compileExpression(right, leftType);
                rightType = this.currentType;
                if (commonType = types_1.Type.commonDenominator(leftType, rightType, true)) {
                    leftExpr = this.convertExpression(leftExpr, leftType, leftType = commonType, false, true, // !
                    left);
                    rightExpr = this.convertExpression(rightExpr, rightType, rightType = commonType, false, true, // !
                    right);
                }
                else {
                    this.error(diagnostics_1.DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2, expression.range, "<=", leftType.toString(), rightType.toString());
                    this.currentType = contextualType;
                    return module.unreachable();
                }
                switch (commonType.kind) {
                    case 0 /* I8 */:
                    case 1 /* I16 */:
                    case 2 /* I32 */: {
                        expr = module.binary(module_1.BinaryOp.LeI32, leftExpr, rightExpr);
                        break;
                    }
                    case 4 /* ISIZE */: {
                        expr = module.binary(this.options.isWasm64
                            ? module_1.BinaryOp.LeI64
                            : module_1.BinaryOp.LeI32, leftExpr, rightExpr);
                        break;
                    }
                    case 3 /* I64 */: {
                        expr = module.binary(module_1.BinaryOp.LeI64, leftExpr, rightExpr);
                        break;
                    }
                    case 5 /* U8 */:
                    case 6 /* U16 */:
                    case 7 /* U32 */:
                    case 10 /* BOOL */: {
                        expr = module.binary(module_1.BinaryOp.LeU32, leftExpr, rightExpr);
                        break;
                    }
                    case 9 /* USIZE */: {
                        expr = module.binary(this.options.isWasm64
                            ? module_1.BinaryOp.LeU64
                            : module_1.BinaryOp.LeU32, leftExpr, rightExpr);
                        break;
                    }
                    case 8 /* U64 */: {
                        expr = module.binary(module_1.BinaryOp.LeU64, leftExpr, rightExpr);
                        break;
                    }
                    case 11 /* F32 */: {
                        expr = module.binary(module_1.BinaryOp.LeF32, leftExpr, rightExpr);
                        break;
                    }
                    case 12 /* F64 */: {
                        expr = module.binary(module_1.BinaryOp.LeF64, leftExpr, rightExpr);
                        break;
                    }
                    default: {
                        assert(false);
                        expr = module.unreachable();
                    }
                }
                this.currentType = types_1.Type.bool;
                break;
            }
            case tokenizer_1.Token.GREATERTHAN_EQUALS: {
                leftExpr = this.compileExpression(left, contextualType);
                leftType = this.currentType;
                // check operator overload
                if (this.currentType.is(256 /* REFERENCE */)) {
                    let classReference = leftType.classReference;
                    if (classReference) {
                        let overload = classReference.lookupOverload(program_1.OperatorKind.GE);
                        if (overload) {
                            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);
                            break;
                        }
                    }
                    this.error(diagnostics_1.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1, expression.range, ">=", leftType.toString());
                    return this.module.unreachable();
                }
                rightExpr = this.compileExpression(right, leftType);
                rightType = this.currentType;
                if (commonType = types_1.Type.commonDenominator(leftType, rightType, true)) {
                    leftExpr = this.convertExpression(leftExpr, leftType, leftType = commonType, false, true, // !
                    left);
                    rightExpr = this.convertExpression(rightExpr, rightType, rightType = commonType, false, true, // !
                    right);
                }
                else {
                    this.error(diagnostics_1.DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2, expression.range, ">=", leftType.toString(), rightType.toString());
                    this.currentType = contextualType;
                    return module.unreachable();
                }
                switch (commonType.kind) {
                    case 0 /* I8 */:
                    case 1 /* I16 */:
                    case 2 /* I32 */: {
                        expr = module.binary(module_1.BinaryOp.GeI32, leftExpr, rightExpr);
                        break;
                    }
                    case 4 /* ISIZE */: {
                        expr = module.binary(this.options.isWasm64
                            ? module_1.BinaryOp.GeI64
                            : module_1.BinaryOp.GeI32, leftExpr, rightExpr);
                        break;
                    }
                    case 3 /* I64 */: {
                        expr = module.binary(module_1.BinaryOp.GeI64, leftExpr, rightExpr);
                        break;
                    }
                    case 5 /* U8 */:
                    case 6 /* U16 */:
                    case 7 /* U32 */:
                    case 10 /* BOOL */: {
                        expr = module.binary(module_1.BinaryOp.GeU32, leftExpr, rightExpr);
                        break;
                    }
                    case 9 /* USIZE */: {
                        expr = module.binary(this.options.isWasm64
                            ? module_1.BinaryOp.GeU64
                            : module_1.BinaryOp.GeU32, leftExpr, rightExpr);
                        break;
                    }
                    case 8 /* U64 */: {
                        expr = module.binary(module_1.BinaryOp.GeU64, leftExpr, rightExpr);
                        break;
                    }
                    case 11 /* F32 */: {
                        expr = module.binary(module_1.BinaryOp.GeF32, leftExpr, rightExpr);
                        break;
                    }
                    case 12 /* F64 */: {
                        expr = module.binary(module_1.BinaryOp.GeF64, leftExpr, rightExpr);
                        break;
                    }
                    default: {
                        assert(false);
                        expr = module.unreachable();
                    }
                }
                this.currentType = types_1.Type.bool;
                break;
            }
            case tokenizer_1.Token.EQUALS_EQUALS_EQUALS:
            case tokenizer_1.Token.EQUALS_EQUALS: {
                // NOTE that this favors correctness, in terms of emitting a binary expression, over
                // checking for a possible use of unary EQZ. while the most classic of all optimizations,
                // that's not what the source told us to do. for reference, `!left` emits unary EQZ.
                leftExpr = this.compileExpression(left, contextualType);
                leftType = this.currentType;
                // check operator overload
                if (operator == tokenizer_1.Token.EQUALS_EQUALS && this.currentType.is(256 /* REFERENCE */)) {
                    let classReference = leftType.classReference;
                    if (classReference) {
                        let overload = classReference.lookupOverload(program_1.OperatorKind.EQ);
                        if (overload) {
                            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);
                            break;
                        }
                    }
                    // still allow '==' with references
                }
                rightExpr = this.compileExpression(right, leftType);
                rightType = this.currentType;
                if (commonType = types_1.Type.commonDenominator(leftType, rightType, false)) {
                    leftExpr = this.convertExpression(leftExpr, leftType, leftType = commonType, false, true, // !
                    left);
                    rightExpr = this.convertExpression(rightExpr, rightType, rightType = commonType, false, true, // !
                    right);
                }
                else {
                    this.error(diagnostics_1.DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2, expression.range, tokenizer_1.operatorTokenToString(expression.operator), leftType.toString(), rightType.toString());
                    this.currentType = contextualType;
                    return module.unreachable();
                }
                switch (commonType.kind) {
                    case 0 /* I8 */:
                    case 1 /* I16 */:
                    case 2 /* I32 */:
                    case 5 /* U8 */:
                    case 6 /* U16 */:
                    case 7 /* U32 */:
                    case 10 /* BOOL */: {
                        expr = module.binary(module_1.BinaryOp.EqI32, leftExpr, rightExpr);
                        break;
                    }
                    case 9 /* USIZE */:
                    case 4 /* ISIZE */: {
                        expr = module.binary(this.options.isWasm64
                            ? module_1.BinaryOp.EqI64
                            : module_1.BinaryOp.EqI32, leftExpr, rightExpr);
                        break;
                    }
                    case 3 /* I64 */:
                    case 8 /* U64 */: {
                        expr = module.binary(module_1.BinaryOp.EqI64, leftExpr, rightExpr);
                        break;
                    }
                    case 11 /* F32 */: {
                        expr = module.binary(module_1.BinaryOp.EqF32, leftExpr, rightExpr);
                        break;
                    }
                    case 12 /* F64 */: {
                        expr = module.binary(module_1.BinaryOp.EqF64, leftExpr, rightExpr);
                        break;
                    }
                    case 13 /* V128 */: {
                        expr = module.unary(module_1.UnaryOp.AllTrueI8x16, module.binary(module_1.BinaryOp.EqI8x16, leftExpr, rightExpr));
                        break;
                    }
                    case 14 /* ANYREF */: {
                        // TODO: ref.eq
                        this.error(diagnostics_1.DiagnosticCode.Not_implemented, expression.range);
                        expr = module.unreachable();
                        break;
                    }
                    default: {
                        assert(false);
                        expr = module.unreachable();
                    }
                }
                this.currentType = types_1.Type.bool;
                break;
            }
            case tokenizer_1.Token.EXCLAMATION_EQUALS_EQUALS:
            case tokenizer_1.Token.EXCLAMATION_EQUALS: {
                leftExpr = this.compileExpression(left, contextualType);
                leftType = this.currentType;
                // check operator overload
                if (operator == tokenizer_1.Token.EXCLAMATION_EQUALS && this.currentType.is(256 /* REFERENCE */)) {
                    let classReference = leftType.classReference;
                    if (classReference) {
                        let overload = classReference.lookupOverload(program_1.OperatorKind.NE);
                        if (overload) {
                            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);
                            break;
                        }
                    }
                    // still allow '!=' with references
                }
                rightExpr = this.compileExpression(right, leftType);
                rightType = this.currentType;
                if (commonType = types_1.Type.commonDenominator(leftType, rightType, false)) {
                    leftExpr = this.convertExpression(leftExpr, leftType, leftType = commonType, false, true, // !
                    left);
                    rightExpr = this.convertExpression(rightExpr, rightType, rightType = commonType, false, true, // !
                    right);
                }
                else {
                    this.error(diagnostics_1.DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2, expression.range, tokenizer_1.operatorTokenToString(expression.operator), leftType.toString(), rightType.toString());
                    this.currentType = contextualType;
                    return module.unreachable();
                }
                switch (commonType.kind) {
                    case 0 /* I8 */:
                    case 1 /* I16 */:
                    case 2 /* I32 */:
                    case 5 /* U8 */:
                    case 6 /* U16 */:
                    case 7 /* U32 */:
                    case 10 /* BOOL */: {
                        expr = module.binary(module_1.BinaryOp.NeI32, leftExpr, rightExpr);
                        break;
                    }
                    case 9 /* USIZE */:
                    case 4 /* ISIZE */: {
                        expr = module.binary(this.options.isWasm64
                            ? module_1.BinaryOp.NeI64
                            : module_1.BinaryOp.NeI32, leftExpr, rightExpr);
                        break;
                    }
                    case 3 /* I64 */:
                    case 8 /* U64 */: {
                        expr = module.binary(module_1.BinaryOp.NeI64, leftExpr, rightExpr);
                        break;
                    }
                    case 11 /* F32 */: {
                        expr = module.binary(module_1.BinaryOp.NeF32, leftExpr, rightExpr);
                        break;
                    }
                    case 12 /* F64 */: {
                        expr = module.binary(module_1.BinaryOp.NeF64, leftExpr, rightExpr);
                        break;
                    }
                    case 13 /* V128 */: {
                        expr = module.unary(module_1.UnaryOp.AnyTrueI8x16, module.binary(module_1.BinaryOp.NeI8x16, leftExpr, rightExpr));
                        break;
                    }
                    case 14 /* ANYREF */: {
                        // TODO: !ref.eq
                        this.error(diagnostics_1.DiagnosticCode.Not_implemented, expression.range);
                        expr = module.unreachable();
                        break;
                    }
                    default: {
                        assert(false);
                        expr = module.unreachable();
                    }
                }
                this.currentType = types_1.Type.bool;
                break;
            }
            case tokenizer_1.Token.EQUALS: {
                return this.compileAssignment(left, right, contextualType);
            }
            case tokenizer_1.Token.PLUS_EQUALS: compound = true;
            case tokenizer_1.Token.PLUS: {
                leftExpr = this.compileExpression(left, contextualType);
                leftType = this.currentType;
                // check operator overload
                if (this.currentType.is(256 /* REFERENCE */)) {
                    let classReference = leftType.classReference;
                    if (classReference) {
                        let overload = classReference.lookupOverload(program_1.OperatorKind.ADD);
                        if (overload) {
                            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);
                            break;
                        }
                    }
                    this.error(diagnostics_1.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1, expression.range, "+", leftType.toString());
                    return this.module.unreachable();
                }
                if (compound) {
                    rightExpr = this.compileExpression(right, leftType, 1 /* CONV_IMPLICIT */);
                }
                else {
                    rightExpr = this.compileExpression(right, leftType);
                    rightType = this.currentType;
                    if (commonType = types_1.Type.commonDenominator(leftType, rightType, false)) {
                        leftExpr = this.convertExpression(leftExpr, leftType, leftType = commonType, false, false, left);
                        rightExpr = this.convertExpression(rightExpr, rightType, rightType = commonType, false, false, right);
                    }
                    else {
                        this.error(diagnostics_1.DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2, expression.range, "+", leftType.toString(), rightType.toString());
                        this.currentType = contextualType;
                        return module.unreachable();
                    }
                }
                switch (this.currentType.kind) {
                    case 0 /* I8 */: // addition might overflow
                    case 1 /* I16 */: // ^
                    case 5 /* U8 */: // ^
                    case 6 /* U16 */: // ^
                    case 10 /* BOOL */: // ^
                    case 2 /* I32 */:
                    case 7 /* U32 */: {
                        expr = module.binary(module_1.BinaryOp.AddI32, leftExpr, rightExpr);
                        break;
                    }
                    case 9 /* USIZE */:
                    case 4 /* ISIZE */: {
                        expr = module.binary(this.options.isWasm64
                            ? module_1.BinaryOp.AddI64
                            : module_1.BinaryOp.AddI32, leftExpr, rightExpr);
                        break;
                    }
                    case 3 /* I64 */:
                    case 8 /* U64 */: {
                        expr = module.binary(module_1.BinaryOp.AddI64, leftExpr, rightExpr);
                        break;
                    }
                    case 11 /* F32 */: {
                        expr = module.binary(module_1.BinaryOp.AddF32, leftExpr, rightExpr);
                        break;
                    }
                    case 12 /* F64 */: {
                        expr = module.binary(module_1.BinaryOp.AddF64, leftExpr, rightExpr);
                        break;
                    }
                    default: {
                        assert(false);
                        expr = module.unreachable();
                    }
                }
                break;
            }
            case tokenizer_1.Token.MINUS_EQUALS: compound = true;
            case tokenizer_1.Token.MINUS: {
                leftExpr = this.compileExpression(left, contextualType);
                leftType = this.currentType;
                // check operator overload
                if (this.currentType.is(256 /* REFERENCE */)) {
                    let classReference = leftType.classReference;
                    if (classReference) {
                        let overload = classReference.lookupOverload(program_1.OperatorKind.SUB);
                        if (overload) {
                            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);
                            break;
                        }
                    }
                    this.error(diagnostics_1.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1, expression.range, "-", leftType.toString());
                    return this.module.unreachable();
                }
                if (compound) {
                    rightExpr = this.compileExpression(right, leftType, 1 /* CONV_IMPLICIT */);
                    rightType = this.currentType;
                }
                else {
                    rightExpr = this.compileExpression(right, leftType);
                    rightType = this.currentType;
                    if (commonType = types_1.Type.commonDenominator(leftType, rightType, false)) {
                        leftExpr = this.convertExpression(leftExpr, leftType, leftType = commonType, false, false, left);
                        rightExpr = this.convertExpression(rightExpr, rightType, rightType = commonType, false, false, right);
                    }
                    else {
                        this.error(diagnostics_1.DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2, expression.range, "-", leftType.toString(), rightType.toString());
                        this.currentType = contextualType;
                        return module.unreachable();
                    }
                }
                switch (this.currentType.kind) {
                    case 0 /* I8 */: // subtraction might overflow
                    case 1 /* I16 */: // ^
                    case 5 /* U8 */: // ^
                    case 6 /* U16 */: // ^
                    case 10 /* BOOL */: // ^
                    case 2 /* I32 */:
                    case 7 /* U32 */: {
                        expr = module.binary(module_1.BinaryOp.SubI32, leftExpr, rightExpr);
                        break;
                    }
                    case 9 /* USIZE */:
                    case 4 /* ISIZE */: {
                        expr = module.binary(this.options.isWasm64
                            ? module_1.BinaryOp.SubI64
                            : module_1.BinaryOp.SubI32, leftExpr, rightExpr);
                        break;
                    }
                    case 3 /* I64 */:
                    case 8 /* U64 */: {
                        expr = module.binary(module_1.BinaryOp.SubI64, leftExpr, rightExpr);
                        break;
                    }
                    case 11 /* F32 */: {
                        expr = module.binary(module_1.BinaryOp.SubF32, leftExpr, rightExpr);
                        break;
                    }
                    case 12 /* F64 */: {
                        expr = module.binary(module_1.BinaryOp.SubF64, leftExpr, rightExpr);
                        break;
                    }
                    default: {
                        assert(false);
                        expr = module.unreachable();
                    }
                }
                break;
            }
            case tokenizer_1.Token.ASTERISK_EQUALS: compound = true;
            case tokenizer_1.Token.ASTERISK: {
                leftExpr = this.compileExpression(left, contextualType);
                leftType = this.currentType;
                // check operator overload
                if (this.currentType.is(256 /* REFERENCE */)) {
                    let classReference = leftType.classReference;
                    if (classReference) {
                        let overload = classReference.lookupOverload(program_1.OperatorKind.MUL);
                        if (overload) {
                            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);
                            break;
                        }
                    }
                    this.error(diagnostics_1.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1, expression.range, "*", leftType.toString());
                    return this.module.unreachable();
                }
                if (compound) {
                    leftExpr = this.ensureSmallIntegerWrap(leftExpr, leftType);
                    rightExpr = this.compileExpression(right, leftType, 1 /* CONV_IMPLICIT */);
                }
                else {
                    rightExpr = this.compileExpression(right, leftType);
                    rightType = this.currentType;
                    if (commonType = types_1.Type.commonDenominator(leftType, rightType, false)) {
                        leftExpr = this.convertExpression(leftExpr, leftType, leftType = commonType, false, false, left);
                        rightExpr = this.convertExpression(rightExpr, rightType, rightType = commonType, false, false, right);
                    }
                    else {
                        this.error(diagnostics_1.DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2, expression.range, "*", leftType.toString(), rightType.toString());
                        this.currentType = contextualType;
                        return module.unreachable();
                    }
                }
                switch (this.currentType.kind) {
                    case 0 /* I8 */:
                    case 1 /* I16 */:
                    case 5 /* U8 */:
                    case 6 /* U16 */:
                    case 10 /* BOOL */:
                    case 2 /* I32 */:
                    case 7 /* U32 */: {
                        expr = module.binary(module_1.BinaryOp.MulI32, leftExpr, rightExpr);
                        break;
                    }
                    case 9 /* USIZE */:
                    case 4 /* ISIZE */: {
                        expr = module.binary(this.options.isWasm64
                            ? module_1.BinaryOp.MulI64
                            : module_1.BinaryOp.MulI32, leftExpr, rightExpr);
                        break;
                    }
                    case 3 /* I64 */:
                    case 8 /* U64 */: {
                        expr = module.binary(module_1.BinaryOp.MulI64, leftExpr, rightExpr);
                        break;
                    }
                    case 11 /* F32 */: {
                        expr = module.binary(module_1.BinaryOp.MulF32, leftExpr, rightExpr);
                        break;
                    }
                    case 12 /* F64 */: {
                        expr = module.binary(module_1.BinaryOp.MulF64, leftExpr, rightExpr);
                        break;
                    }
                    default: {
                        assert(false);
                        expr = module.unreachable();
                    }
                }
                break;
            }
            case tokenizer_1.Token.ASTERISK_ASTERISK_EQUALS: compound = true;
            case tokenizer_1.Token.ASTERISK_ASTERISK: {
                leftExpr = this.compileExpression(left, contextualType);
                leftType = this.currentType;
                // check operator overload
                if (this.currentType.is(256 /* REFERENCE */)) {
                    let classReference = leftType.classReference;
                    if (classReference) {
                        let overload = classReference.lookupOverload(program_1.OperatorKind.POW);
                        if (overload) {
                            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);
                            break;
                        }
                    }
                    this.error(diagnostics_1.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1, expression.range, "**", leftType.toString());
                    return this.module.unreachable();
                }
                let targetType = leftType;
                let instance;
                // Mathf.pow if lhs is f32 (result is f32)
                if (this.currentType.kind == 11 /* F32 */) {
                    rightExpr = this.compileExpression(right, types_1.Type.f32, 1 /* CONV_IMPLICIT */);
                    rightType = this.currentType;
                    if (!(instance = this.f32PowInstance)) {
                        let namespace = this.program.lookupGlobal(common_1.CommonSymbols.Mathf);
                        if (!namespace) {
                            this.error(diagnostics_1.DiagnosticCode.Cannot_find_name_0, expression.range, "Mathf");
                            expr = module.unreachable();
                            break;
                        }
                        let prototype = namespace.members ? namespace.members.get(common_1.CommonSymbols.pow) : null;
                        if (!prototype) {
                            this.error(diagnostics_1.DiagnosticCode.Cannot_find_name_0, expression.range, "Mathf.pow");
                            expr = module.unreachable();
                            break;
                        }
                        assert(prototype.kind == program_1.ElementKind.FUNCTION_PROTOTYPE);
                        this.f32PowInstance = instance = this.resolver.resolveFunction(prototype, null);
                    }
                    // Math.pow otherwise (result is f64)
                    // TODO: should the result be converted back?
                }
                else {
                    leftExpr = this.convertExpression(leftExpr, this.currentType, types_1.Type.f64, false, false, left);
                    leftType = this.currentType;
                    rightExpr = this.compileExpression(right, types_1.Type.f64, 1 /* CONV_IMPLICIT */);
                    rightType = this.currentType;
                    if (!(instance = this.f64PowInstance)) {
                        let namespace = this.program.lookupGlobal(common_1.CommonSymbols.Math);
                        if (!namespace) {
                            this.error(diagnostics_1.DiagnosticCode.Cannot_find_name_0, expression.range, "Math");
                            expr = module.unreachable();
                            break;
                        }
                        let prototype = namespace.members ? namespace.members.get(common_1.CommonSymbols.pow) : null;
                        if (!prototype) {
                            this.error(diagnostics_1.DiagnosticCode.Cannot_find_name_0, expression.range, "Math.pow");
                            expr = module.unreachable();
                            break;
                        }
                        assert(prototype.kind == program_1.ElementKind.FUNCTION_PROTOTYPE);
                        this.f64PowInstance = instance = this.resolver.resolveFunction(prototype, null);
                    }
                }
                if (!(instance && this.compileFunction(instance))) {
                    expr = module.unreachable();
                }
                else {
                    expr = this.makeCallDirect(instance, [leftExpr, rightExpr], expression);
                    if (compound && targetType != this.currentType) {
                        // this yields a proper error if target is i32 for example
                        expr = this.convertExpression(expr, this.currentType, targetType, false, false, expression);
                    }
                }
                break;
            }
            case tokenizer_1.Token.SLASH_EQUALS: compound = true;
            case tokenizer_1.Token.SLASH: {
                leftExpr = this.compileExpression(left, contextualType);
                leftType = this.currentType;
                // check operator overload
                if (this.currentType.is(256 /* REFERENCE */)) {
                    let classReference = leftType.classReference;
                    if (classReference) {
                        let overload = classReference.lookupOverload(program_1.OperatorKind.DIV);
                        if (overload) {
                            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);
                            break;
                        }
                    }
                    this.error(diagnostics_1.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1, expression.range, "/", leftType.toString());
                    return this.module.unreachable();
                }
                if (compound) {
                    leftExpr = this.ensureSmallIntegerWrap(leftExpr, leftType);
                    rightExpr = this.compileExpression(right, leftType, 1 /* CONV_IMPLICIT */);
                    rightType = this.currentType;
                }
                else {
                    rightExpr = this.compileExpression(right, leftType);
                    rightType = this.currentType;
                    if (commonType = types_1.Type.commonDenominator(leftType, rightType, false)) {
                        leftExpr = this.convertExpression(leftExpr, leftType, leftType = commonType, false, true, // !
                        left);
                        rightExpr = this.convertExpression(rightExpr, rightType, rightType = commonType, false, true, // !
                        right);
                    }
                    else {
                        this.error(diagnostics_1.DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2, expression.range, "/", leftType.toString(), rightType.toString());
                        this.currentType = contextualType;
                        return module.unreachable();
                    }
                }
                switch (this.currentType.kind) {
                    case 0 /* I8 */: // signed div on signed small integers might overflow, e.g. -128/-1
                    case 1 /* I16 */: // ^
                    case 2 /* I32 */: {
                        expr = module.binary(module_1.BinaryOp.DivI32, leftExpr, rightExpr);
                        break;
                    }
                    case 4 /* ISIZE */: {
                        expr = module.binary(this.options.isWasm64
                            ? module_1.BinaryOp.DivI64
                            : module_1.BinaryOp.DivI32, leftExpr, rightExpr);
                        break;
                    }
                    case 3 /* I64 */: {
                        expr = module.binary(module_1.BinaryOp.DivI64, leftExpr, rightExpr);
                        break;
                    }
                    case 5 /* U8 */:
                    case 6 /* U16 */:
                    case 10 /* BOOL */: {
                        expr = module.binary(module_1.BinaryOp.DivU32, leftExpr, rightExpr);
                        break;
                    }
                    case 7 /* U32 */: {
                        expr = module.binary(module_1.BinaryOp.DivU32, leftExpr, rightExpr);
                        break;
                    }
                    case 9 /* USIZE */: {
                        expr = module.binary(this.options.isWasm64
                            ? module_1.BinaryOp.DivU64
                            : module_1.BinaryOp.DivU32, leftExpr, rightExpr);
                        break;
                    }
                    case 8 /* U64 */: {
                        expr = module.binary(module_1.BinaryOp.DivU64, leftExpr, rightExpr);
                        break;
                    }
                    case 11 /* F32 */: {
                        expr = module.binary(module_1.BinaryOp.DivF32, leftExpr, rightExpr);
                        break;
                    }
                    case 12 /* F64 */: {
                        expr = module.binary(module_1.BinaryOp.DivF64, leftExpr, rightExpr);
                        break;
                    }
                    default: {
                        assert(false);
                        expr = module.unreachable();
                    }
                }
                break;
            }
            case tokenizer_1.Token.PERCENT_EQUALS: compound = true;
            case tokenizer_1.Token.PERCENT: {
                leftExpr = this.compileExpression(left, contextualType);
                leftType = this.currentType;
                // check operator overload
                if (this.currentType.is(256 /* REFERENCE */)) {
                    let classReference = leftType.classReference;
                    if (classReference) {
                        let overload = classReference.lookupOverload(program_1.OperatorKind.REM);
                        if (overload) {
                            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);
                            break;
                        }
                    }
                    this.error(diagnostics_1.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1, expression.range, "%", leftType.toString());
                    return this.module.unreachable();
                }
                if (compound) {
                    leftExpr = this.ensureSmallIntegerWrap(leftExpr, leftType);
                    rightExpr = this.compileExpression(right, leftType, 1 /* CONV_IMPLICIT */);
                    rightType = this.currentType;
                }
                else {
                    rightExpr = this.compileExpression(right, leftType);
                    rightType = this.currentType;
                    if (commonType = types_1.Type.commonDenominator(leftType, rightType, false)) {
                        leftExpr = this.convertExpression(leftExpr, leftType, leftType = commonType, false, true, // !
                        left);
                        rightExpr = this.convertExpression(rightExpr, rightType, rightType = commonType, false, true, // !
                        right);
                    }
                    else {
                        this.error(diagnostics_1.DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2, expression.range, "%", leftType.toString(), rightType.toString());
                        this.currentType = contextualType;
                        return module.unreachable();
                    }
                }
                switch (this.currentType.kind) {
                    case 0 /* I8 */:
                    case 1 /* I16 */: {
                        expr = module.binary(module_1.BinaryOp.RemI32, leftExpr, rightExpr);
                        break;
                    }
                    case 2 /* I32 */: {
                        expr = module.binary(module_1.BinaryOp.RemI32, leftExpr, rightExpr);
                        break;
                    }
                    case 4 /* ISIZE */: {
                        expr = module.binary(this.options.isWasm64
                            ? module_1.BinaryOp.RemI64
                            : module_1.BinaryOp.RemI32, leftExpr, rightExpr);
                        break;
                    }
                    case 3 /* I64 */: {
                        expr = module.binary(module_1.BinaryOp.RemI64, leftExpr, rightExpr);
                        break;
                    }
                    case 5 /* U8 */:
                    case 6 /* U16 */:
                    case 10 /* BOOL */: {
                        expr = module.binary(module_1.BinaryOp.RemU32, leftExpr, rightExpr);
                        break;
                    }
                    case 7 /* U32 */: {
                        expr = module.binary(module_1.BinaryOp.RemU32, leftExpr, rightExpr);
                        break;
                    }
                    case 9 /* USIZE */: {
                        expr = module.binary(this.options.isWasm64
                            ? module_1.BinaryOp.RemU64
                            : module_1.BinaryOp.RemU32, leftExpr, rightExpr);
                        break;
                    }
                    case 8 /* U64 */: {
                        expr = module.binary(module_1.BinaryOp.RemU64, leftExpr, rightExpr);
                        break;
                    }
                    case 11 /* F32 */: {
                        let instance = this.f32ModInstance;
                        if (!instance) {
                            let namespace = this.program.lookupGlobal(common_1.CommonSymbols.Mathf);
                            if (!namespace) {
                                this.error(diagnostics_1.DiagnosticCode.Cannot_find_name_0, expression.range, "Mathf");
                                expr = module.unreachable();
                                break;
                            }
                            let prototype = namespace.members ? namespace.members.get(common_1.CommonSymbols.mod) : null;
                            if (!prototype) {
                                this.error(diagnostics_1.DiagnosticCode.Cannot_find_name_0, expression.range, "Mathf.mod");
                                expr = module.unreachable();
                                break;
                            }
                            assert(prototype.kind == program_1.ElementKind.FUNCTION_PROTOTYPE);
                            this.f32ModInstance = instance = this.resolver.resolveFunction(prototype, null);
                        }
                        if (!(instance && this.compileFunction(instance))) {
                            expr = module.unreachable();
                        }
                        else {
                            expr = this.makeCallDirect(instance, [leftExpr, rightExpr], expression);
                        }
                        break;
                    }
                    case 12 /* F64 */: {
                        let instance = this.f64ModInstance;
                        if (!instance) {
                            let namespace = this.program.lookupGlobal(common_1.CommonSymbols.Math);
                            if (!namespace) {
                                this.error(diagnostics_1.DiagnosticCode.Cannot_find_name_0, expression.range, "Math");
                                expr = module.unreachable();
                                break;
                            }
                            let prototype = namespace.members ? namespace.members.get(common_1.CommonSymbols.mod) : null;
                            if (!prototype) {
                                this.error(diagnostics_1.DiagnosticCode.Cannot_find_name_0, expression.range, "Math.mod");
                                expr = module.unreachable();
                                break;
                            }
                            assert(prototype.kind == program_1.ElementKind.FUNCTION_PROTOTYPE);
                            this.f64ModInstance = instance = this.resolver.resolveFunction(prototype, null);
                        }
                        if (!(instance && this.compileFunction(instance))) {
                            expr = module.unreachable();
                        }
                        else {
                            expr = this.makeCallDirect(instance, [leftExpr, rightExpr], expression);
                        }
                        break;
                    }
                    default: {
                        assert(false);
                        expr = module.unreachable();
                    }
                }
                break;
            }
            case tokenizer_1.Token.LESSTHAN_LESSTHAN_EQUALS: compound = true;
            case tokenizer_1.Token.LESSTHAN_LESSTHAN: {
                leftExpr = this.compileExpression(left, contextualType.intType);
                leftType = this.currentType;
                // check operator overload
                if (this.currentType.is(256 /* REFERENCE */)) {
                    let classReference = leftType.classReference;
                    if (classReference) {
                        let overload = classReference.lookupOverload(program_1.OperatorKind.BITWISE_SHL);
                        if (overload) {
                            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);
                            break;
                        }
                    }
                    this.error(diagnostics_1.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1, expression.range, "<<", leftType.toString());
                    return this.module.unreachable();
                }
                rightExpr = this.compileExpression(right, leftType, 1 /* CONV_IMPLICIT */);
                rightType = this.currentType;
                switch (this.currentType.kind) {
                    case 0 /* I8 */:
                    case 1 /* I16 */:
                    case 5 /* U8 */:
                    case 6 /* U16 */:
                    case 10 /* BOOL */:
                    case 2 /* I32 */:
                    case 7 /* U32 */: {
                        expr = module.binary(module_1.BinaryOp.ShlI32, leftExpr, rightExpr);
                        break;
                    }
                    case 3 /* I64 */:
                    case 8 /* U64 */: {
                        expr = module.binary(module_1.BinaryOp.ShlI64, leftExpr, rightExpr);
                        break;
                    }
                    case 9 /* USIZE */:
                    case 4 /* ISIZE */: {
                        expr = module.binary(this.options.isWasm64
                            ? module_1.BinaryOp.ShlI64
                            : module_1.BinaryOp.ShlI32, leftExpr, rightExpr);
                        break;
                    }
                    case 11 /* F32 */:
                    case 12 /* F64 */: {
                        this.error(diagnostics_1.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1, expression.range, "<<", this.currentType.toString());
                        return module.unreachable();
                    }
                    default: {
                        assert(false);
                        expr = module.unreachable();
                    }
                }
                break;
            }
            case tokenizer_1.Token.GREATERTHAN_GREATERTHAN_EQUALS: compound = true;
            case tokenizer_1.Token.GREATERTHAN_GREATERTHAN: {
                leftExpr = this.compileExpression(left, contextualType.intType);
                leftType = this.currentType;
                // check operator overload
                if (this.currentType.is(256 /* REFERENCE */)) {
                    let classReference = leftType.classReference;
                    if (classReference) {
                        let overload = classReference.lookupOverload(program_1.OperatorKind.BITWISE_SHR);
                        if (overload) {
                            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);
                            break;
                        }
                    }
                    this.error(diagnostics_1.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1, expression.range, ">>", leftType.toString());
                    return this.module.unreachable();
                }
                leftExpr = this.ensureSmallIntegerWrap(leftExpr, leftType); // must clear garbage bits
                rightExpr = this.compileExpression(right, leftType, 1 /* CONV_IMPLICIT */);
                rightType = this.currentType;
                switch (this.currentType.kind) {
                    case 0 /* I8 */:
                    case 1 /* I16 */: {
                        expr = module.binary(module_1.BinaryOp.ShrI32, leftExpr, rightExpr);
                        break;
                    }
                    case 2 /* I32 */: {
                        expr = module.binary(module_1.BinaryOp.ShrI32, leftExpr, rightExpr);
                        break;
                    }
                    case 3 /* I64 */: {
                        expr = module.binary(module_1.BinaryOp.ShrI64, leftExpr, rightExpr);
                        break;
                    }
                    case 4 /* ISIZE */: {
                        expr = module.binary(this.options.isWasm64
                            ? module_1.BinaryOp.ShrI64
                            : module_1.BinaryOp.ShrI32, leftExpr, rightExpr);
                        break;
                    }
                    case 5 /* U8 */:
                    case 6 /* U16 */:
                    case 10 /* BOOL */: {
                        expr = module.binary(module_1.BinaryOp.ShrU32, leftExpr, rightExpr);
                        break;
                    }
                    case 7 /* U32 */: {
                        expr = module.binary(module_1.BinaryOp.ShrU32, leftExpr, rightExpr);
                        break;
                    }
                    case 8 /* U64 */: {
                        expr = module.binary(module_1.BinaryOp.ShrU64, leftExpr, rightExpr);
                        break;
                    }
                    case 9 /* USIZE */: {
                        expr = module.binary(this.options.isWasm64
                            ? module_1.BinaryOp.ShrU64
                            : module_1.BinaryOp.ShrU32, leftExpr, rightExpr);
                        break;
                    }
                    case 11 /* F32 */:
                    case 12 /* F64 */: {
                        this.error(diagnostics_1.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1, expression.range, ">>", this.currentType.toString());
                        return module.unreachable();
                    }
                    default: {
                        assert(false);
                        expr = module.unreachable();
                    }
                }
                break;
            }
            case tokenizer_1.Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS: compound = true;
            case tokenizer_1.Token.GREATERTHAN_GREATERTHAN_GREATERTHAN: {
                leftExpr = this.compileExpression(left, contextualType.intType);
                leftType = this.currentType;
                // check operator overload
                if (this.currentType.is(256 /* REFERENCE */)) {
                    let classReference = leftType.classReference;
                    if (classReference) {
                        let overload = classReference.lookupOverload(program_1.OperatorKind.BITWISE_SHR_U);
                        if (overload) {
                            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);
                            break;
                        }
                    }
                    this.error(diagnostics_1.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1, expression.range, ">>>", leftType.toString());
                    return this.module.unreachable();
                }
                leftExpr = this.ensureSmallIntegerWrap(leftExpr, leftType); // must clear garbage bits
                rightExpr = this.compileExpression(right, leftType, 1 /* CONV_IMPLICIT */);
                rightType = this.currentType;
                switch (this.currentType.kind) {
                    case 5 /* U8 */:
                    case 6 /* U16 */:
                    case 10 /* BOOL */: { // assumes that unsigned shr on unsigned small integers does not overflow
                        expr = module.binary(module_1.BinaryOp.ShrU32, leftExpr, rightExpr);
                    }
                    case 0 /* I8 */:
                    case 1 /* I16 */:
                    case 2 /* I32 */:
                    case 7 /* U32 */: {
                        expr = module.binary(module_1.BinaryOp.ShrU32, leftExpr, rightExpr);
                        break;
                    }
                    case 3 /* I64 */:
                    case 8 /* U64 */: {
                        expr = module.binary(module_1.BinaryOp.ShrU64, leftExpr, rightExpr);
                        break;
                    }
                    case 9 /* USIZE */:
                    case 4 /* ISIZE */: {
                        expr = module.binary(this.options.isWasm64
                            ? module_1.BinaryOp.ShrU64
                            : module_1.BinaryOp.ShrU32, leftExpr, rightExpr);
                        break;
                    }
                    case 11 /* F32 */:
                    case 12 /* F64 */: {
                        this.error(diagnostics_1.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1, expression.range, ">>>", this.currentType.toString());
                        return module.unreachable();
                    }
                    default: {
                        assert(false);
                        expr = module.unreachable();
                    }
                }
                break;
            }
            case tokenizer_1.Token.AMPERSAND_EQUALS: compound = true;
            case tokenizer_1.Token.AMPERSAND: {
                leftExpr = this.compileExpression(left, contextualType.intType);
                leftType = this.currentType;
                // check operator overloadd
                if (this.currentType.is(256 /* REFERENCE */)) {
                    let classReference = leftType.classReference;
                    if (classReference) {
                        let overload = classReference.lookupOverload(program_1.OperatorKind.BITWISE_AND);
                        if (overload) {
                            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);
                            break;
                        }
                    }
                    this.error(diagnostics_1.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1, expression.range, "&", leftType.toString());
                    return this.module.unreachable();
                }
                if (compound) {
                    rightExpr = this.compileExpression(right, leftType, 1 /* CONV_IMPLICIT */);
                    rightType = this.currentType;
                }
                else {
                    rightExpr = this.compileExpression(right, leftType);
                    rightType = this.currentType;
                    if (commonType = types_1.Type.commonDenominator(leftType, rightType, false)) {
                        leftExpr = this.convertExpression(leftExpr, leftType, leftType = commonType, false, false, left);
                        rightExpr = this.convertExpression(rightExpr, rightType, rightType = commonType, false, false, right);
                    }
                    else {
                        this.error(diagnostics_1.DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2, expression.range, "&", leftType.toString(), rightType.toString());
                        this.currentType = contextualType;
                        return module.unreachable();
                    }
                }
                switch (this.currentType.kind) {
                    case 0 /* I8 */:
                    case 1 /* I16 */:
                    case 2 /* I32 */:
                    case 5 /* U8 */:
                    case 6 /* U16 */:
                    case 10 /* BOOL */:
                    case 7 /* U32 */: {
                        expr = module.binary(module_1.BinaryOp.AndI32, leftExpr, rightExpr);
                        break;
                    }
                    case 3 /* I64 */:
                    case 8 /* U64 */: {
                        expr = module.binary(module_1.BinaryOp.AndI64, leftExpr, rightExpr);
                        break;
                    }
                    case 9 /* USIZE */:
                    case 4 /* ISIZE */: {
                        expr = module.binary(this.options.isWasm64
                            ? module_1.BinaryOp.AndI64
                            : module_1.BinaryOp.AndI32, leftExpr, rightExpr);
                        break;
                    }
                    case 11 /* F32 */:
                    case 12 /* F64 */: {
                        this.error(diagnostics_1.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1, expression.range, "&", this.currentType.toString());
                        return module.unreachable();
                    }
                    default: {
                        assert(false);
                        expr = module.unreachable();
                    }
                }
                break;
            }
            case tokenizer_1.Token.BAR_EQUALS: compound = true;
            case tokenizer_1.Token.BAR: {
                leftExpr = this.compileExpression(left, contextualType.intType);
                leftType = this.currentType;
                // check operator overload
                if (this.currentType.is(256 /* REFERENCE */)) {
                    let classReference = leftType.classReference;
                    if (classReference) {
                        let overload = classReference.lookupOverload(program_1.OperatorKind.BITWISE_OR);
                        if (overload) {
                            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);
                            break;
                        }
                    }
                    this.error(diagnostics_1.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1, expression.range, "|", leftType.toString());
                    return this.module.unreachable();
                }
                if (compound) {
                    rightExpr = this.compileExpression(right, leftType, 1 /* CONV_IMPLICIT */);
                    rightType = this.currentType;
                }
                else {
                    rightExpr = this.compileExpression(right, leftType);
                    rightType = this.currentType;
                    if (commonType = types_1.Type.commonDenominator(leftType, rightType, false)) {
                        leftExpr = this.convertExpression(leftExpr, leftType, leftType = commonType, false, false, left);
                        rightExpr = this.convertExpression(rightExpr, rightType, rightType = commonType, false, false, right);
                    }
                    else {
                        this.error(diagnostics_1.DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2, expression.range, "|", leftType.toString(), rightType.toString());
                        this.currentType = contextualType;
                        return module.unreachable();
                    }
                }
                switch (this.currentType.kind) {
                    case 0 /* I8 */:
                    case 1 /* I16 */:
                    case 5 /* U8 */:
                    case 6 /* U16 */:
                    case 10 /* BOOL */: {
                        expr = module.binary(module_1.BinaryOp.OrI32, leftExpr, rightExpr);
                        break;
                    }
                    case 2 /* I32 */:
                    case 7 /* U32 */: {
                        expr = module.binary(module_1.BinaryOp.OrI32, leftExpr, rightExpr);
                        break;
                    }
                    case 3 /* I64 */:
                    case 8 /* U64 */: {
                        expr = module.binary(module_1.BinaryOp.OrI64, leftExpr, rightExpr);
                        break;
                    }
                    case 9 /* USIZE */:
                    case 4 /* ISIZE */: {
                        expr = module.binary(this.options.isWasm64
                            ? module_1.BinaryOp.OrI64
                            : module_1.BinaryOp.OrI32, leftExpr, rightExpr);
                        break;
                    }
                    case 11 /* F32 */:
                    case 12 /* F64 */: {
                        this.error(diagnostics_1.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1, expression.range, "|", this.currentType.toString());
                        return module.unreachable();
                    }
                    default: {
                        assert(false);
                        expr = module.unreachable();
                    }
                }
                break;
            }
            case tokenizer_1.Token.CARET_EQUALS: compound = true;
            case tokenizer_1.Token.CARET: {
                leftExpr = this.compileExpression(left, contextualType.intType);
                leftType = this.currentType;
                // check operator overload
                if (this.currentType.is(256 /* REFERENCE */)) {
                    let classReference = leftType.classReference;
                    if (classReference) {
                        let overload = classReference.lookupOverload(program_1.OperatorKind.BITWISE_XOR);
                        if (overload) {
                            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);
                            break;
                        }
                    }
                    this.error(diagnostics_1.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1, expression.range, "^", leftType.toString());
                    return this.module.unreachable();
                }
                if (compound) {
                    rightExpr = this.compileExpression(right, leftType, 1 /* CONV_IMPLICIT */);
                    rightType = this.currentType;
                }
                else {
                    rightExpr = this.compileExpression(right, leftType);
                    rightType = this.currentType;
                    if (commonType = types_1.Type.commonDenominator(leftType, rightType, false)) {
                        leftExpr = this.convertExpression(leftExpr, leftType, leftType = commonType, false, false, left);
                        rightExpr = this.convertExpression(rightExpr, rightType, rightType = commonType, false, false, right);
                    }
                    else {
                        this.error(diagnostics_1.DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2, expression.range, "^", leftType.toString(), rightType.toString());
                        this.currentType = contextualType;
                        return module.unreachable();
                    }
                }
                switch (this.currentType.kind) {
                    case 0 /* I8 */:
                    case 1 /* I16 */:
                    case 5 /* U8 */:
                    case 6 /* U16 */:
                    case 10 /* BOOL */: {
                        expr = module.binary(module_1.BinaryOp.XorI32, leftExpr, rightExpr);
                        break;
                    }
                    case 2 /* I32 */:
                    case 7 /* U32 */: {
                        expr = module.binary(module_1.BinaryOp.XorI32, leftExpr, rightExpr);
                        break;
                    }
                    case 3 /* I64 */:
                    case 8 /* U64 */: {
                        expr = module.binary(module_1.BinaryOp.XorI64, leftExpr, rightExpr);
                        break;
                    }
                    case 9 /* USIZE */:
                    case 4 /* ISIZE */: {
                        expr = module.binary(this.options.isWasm64
                            ? module_1.BinaryOp.XorI64
                            : module_1.BinaryOp.XorI32, leftExpr, rightExpr);
                        break;
                    }
                    case 11 /* F32 */:
                    case 12 /* F64 */: {
                        this.error(diagnostics_1.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1, expression.range, "^", this.currentType.toString());
                        return module.unreachable();
                    }
                    default: {
                        assert(false);
                        expr = module.unreachable();
                    }
                }
                break;
            }
            // logical (no overloading)
            case tokenizer_1.Token.AMPERSAND_AMPERSAND: { // left && right -> (t = left) ? right : t
                let flow = this.currentFlow;
                let inheritedConstraints = constraints & (16 /* WILL_RETAIN */ | 4 /* MUST_WRAP */);
                leftExpr = this.compileExpression(left, contextualType.exceptVoid, inheritedConstraints);
                leftType = this.currentType;
                let rightFlow = flow.fork();
                this.currentFlow = rightFlow;
                rightFlow.inheritNonnullIfTrue(leftExpr);
                rightExpr = this.compileExpression(right, leftType, inheritedConstraints | 1 /* CONV_IMPLICIT */);
                rightType = leftType;
                // simplify if only interested in true or false
                if (contextualType == types_1.Type.bool || contextualType == types_1.Type.void) {
                    rightExpr = this.performAutoreleasesWithValue(rightFlow, rightExpr, rightType);
                    rightFlow.freeScopedLocals();
                    this.currentFlow = flow;
                    this.currentType = types_1.Type.bool;
                    expr = module.if(this.makeIsTrueish(leftExpr, leftType), this.makeIsTrueish(rightExpr, rightType), module.i32(0));
                    // references must properly retain and release, with the same outcome independent of the branch taken
                }
                else if (leftType.isManaged) {
                    let leftAutoreleaseSkipped = this.skippedAutoreleases.has(leftExpr);
                    let rightAutoreleaseSkipped = this.skippedAutoreleases.has(rightExpr);
                    let temp = flow.getTempLocal(leftType);
                    leftExpr = module.local_tee(temp.index, leftExpr);
                    // instead of retaining left and releasing it again in right when right
                    // is taken, we can also just retain left if right is not taken
                    let retainLeftInElse = false;
                    if (leftAutoreleaseSkipped != rightAutoreleaseSkipped) { // xor
                        if (!leftAutoreleaseSkipped) {
                            retainLeftInElse = true;
                        }
                        else {
                            rightExpr = this.makeRetain(rightExpr);
                            rightAutoreleaseSkipped = true;
                        }
                    }
                    else if (!(constraints & 16 /* WILL_RETAIN */)) { // otherwise keep right alive a little longer
                        rightExpr = this.moveAutorelease(rightExpr, rightFlow, flow);
                    }
                    let rightStmts = new Array();
                    if (leftAutoreleaseSkipped) { // left turned out to be true'ish and is dropped
                        rightStmts.unshift(this.makeRelease(module.local_get(temp.index, leftType.toNativeType())));
                    }
                    rightExpr = this.performAutoreleasesWithValue(rightFlow, rightExpr, rightType, rightStmts);
                    rightFlow.freeScopedLocals();
                    this.currentFlow = flow;
                    expr = module.if(this.makeIsTrueish(leftExpr, leftType), rightExpr, retainLeftInElse
                        ? this.makeRetain(module.local_get(temp.index, leftType.toNativeType()))
                        : module.local_get(temp.index, leftType.toNativeType()));
                    if (leftAutoreleaseSkipped || rightAutoreleaseSkipped)
                        this.skippedAutoreleases.add(expr);
                    if (temp)
                        flow.freeTempLocal(temp);
                    // basic values can use more aggressive optimizations
                }
                else {
                    rightExpr = this.performAutoreleasesWithValue(rightFlow, rightExpr, rightType);
                    rightFlow.freeScopedLocals();
                    this.currentFlow = flow;
                    // simplify if cloning left without side effects is possible
                    if (expr = module.cloneExpression(leftExpr, true, 0)) {
                        expr = module.if(this.makeIsTrueish(leftExpr, this.currentType), rightExpr, expr);
                        // if not possible, tee left to a temp
                    }
                    else {
                        let tempLocal = flow.getTempLocal(leftType);
                        if (!flow.canOverflow(leftExpr, leftType))
                            flow.setLocalFlag(tempLocal.index, flow_1.LocalFlags.WRAPPED);
                        if (flow.isNonnull(leftExpr, leftType))
                            flow.setLocalFlag(tempLocal.index, flow_1.LocalFlags.NONNULL);
                        expr = module.if(this.makeIsTrueish(module.local_tee(tempLocal.index, leftExpr), leftType), rightExpr, module.local_get(tempLocal.index, leftType.toNativeType()));
                        flow.freeTempLocal(tempLocal);
                    }
                }
                this.currentType = leftType;
                break;
            }
            case tokenizer_1.Token.BAR_BAR: { // left || right -> ((t = left) ? t : right)
                let flow = this.currentFlow;
                let inheritedConstraints = constraints & (16 /* WILL_RETAIN */ | 4 /* MUST_WRAP */);
                leftExpr = this.compileExpression(left, contextualType.exceptVoid, inheritedConstraints);
                leftType = this.currentType;
                let rightFlow = flow.fork();
                this.currentFlow = rightFlow;
                rightFlow.inheritNonnullIfFalse(leftExpr);
                rightExpr = this.compileExpression(right, leftType, inheritedConstraints | 1 /* CONV_IMPLICIT */);
                rightType = leftType;
                // simplify if only interested in true or false
                if (contextualType == types_1.Type.bool || contextualType == types_1.Type.void) {
                    rightExpr = this.performAutoreleasesWithValue(rightFlow, rightExpr, leftType);
                    rightFlow.freeScopedLocals();
                    this.currentFlow = flow;
                    this.currentType = types_1.Type.bool;
                    expr = module.if(this.makeIsTrueish(leftExpr, leftType), module.i32(1), this.makeIsTrueish(rightExpr, rightType));
                    // references must properly retain and release, with the same outcome independent of the branch taken
                }
                else if (leftType.isManaged) {
                    let leftAutoreleaseSkipped = this.skippedAutoreleases.has(leftExpr);
                    let rightAutoreleaseSkipped = this.skippedAutoreleases.has(rightExpr);
                    let temp = flow.getTempLocal(leftType);
                    leftExpr = module.local_tee(temp.index, leftExpr);
                    // instead of retaining left and releasing it again in right when right
                    // is taken, we can also just retain left if right is not taken
                    let retainLeftInThen = false;
                    if (leftAutoreleaseSkipped != rightAutoreleaseSkipped) { // xor
                        if (!leftAutoreleaseSkipped) {
                            retainLeftInThen = true;
                        }
                        else {
                            rightExpr = this.makeRetain(rightExpr);
                            rightAutoreleaseSkipped = true;
                        }
                    }
                    else if (!(constraints & 16 /* WILL_RETAIN */)) { // otherwise keep right alive a little longer
                        rightExpr = this.moveAutorelease(rightExpr, rightFlow, flow);
                    }
                    let rightStmts = new Array();
                    if (leftAutoreleaseSkipped) { // left turned out to be false'ish and is dropped
                        // TODO: usually, false'ish means left is null, but this might not hold
                        // once implicit conversion with strings is performed and left is "", so:
                        rightStmts.unshift(this.makeRelease(module.local_get(temp.index, leftType.toNativeType())));
                    }
                    rightExpr = this.performAutoreleasesWithValue(rightFlow, rightExpr, rightType, rightStmts);
                    rightFlow.freeScopedLocals();
                    this.currentFlow = flow;
                    expr = module.if(this.makeIsTrueish(leftExpr, leftType), retainLeftInThen
                        ? this.makeRetain(module.local_get(temp.index, leftType.toNativeType()))
                        : module.local_get(temp.index, leftType.toNativeType()), rightExpr);
                    if (leftAutoreleaseSkipped || rightAutoreleaseSkipped)
                        this.skippedAutoreleases.add(expr);
                    if (temp)
                        flow.freeTempLocal(temp);
                    // basic values can use more aggressive optimizations
                }
                else {
                    rightExpr = this.performAutoreleasesWithValue(rightFlow, rightExpr, rightType);
                    rightFlow.freeScopedLocals();
                    this.currentFlow = flow;
                    // simplify if cloning left without side effects is possible
                    if (expr = module.cloneExpression(leftExpr, true, 0)) {
                        expr = module.if(this.makeIsTrueish(leftExpr, leftType), expr, rightExpr);
                        // if not possible, tee left to a temp. local
                    }
                    else {
                        let temp = flow.getTempLocal(leftType);
                        if (!flow.canOverflow(leftExpr, leftType))
                            flow.setLocalFlag(temp.index, flow_1.LocalFlags.WRAPPED);
                        if (flow.isNonnull(leftExpr, leftType))
                            flow.setLocalFlag(temp.index, flow_1.LocalFlags.NONNULL);
                        expr = module.if(this.makeIsTrueish(module.local_tee(temp.index, leftExpr), leftType), module.local_get(temp.index, leftType.toNativeType()), rightExpr);
                        flow.freeTempLocal(temp);
                    }
                }
                this.currentType = leftType;
                break;
            }
            default: {
                assert(false);
                expr = this.module.unreachable();
            }
        }
        if (!compound)
            return expr;
        var resolver = this.resolver;
        var target = resolver.lookupExpression(left, this.currentFlow);
        if (!target)
            return module.unreachable();
        var targetType = resolver.getTypeOfElement(target) || types_1.Type.void;
        if (!this.currentType.isStrictlyAssignableTo(targetType)) {
            this.error(diagnostics_1.DiagnosticCode.Type_0_is_not_assignable_to_type_1, expression.range, this.currentType.toString(), targetType.toString());
            return module.unreachable();
        }
        return this.makeAssignment(target, expr, // TODO: delay release above if possible?
        left, resolver.currentThisExpression, resolver.currentElementExpression, contextualType != types_1.Type.void);
    }
    compileUnaryOverload(operatorInstance, value, valueExpr, reportNode) {
        // FIXME: see comment in compileBinaryOverload below why recompiling on type mismatch
        // is a bad idea currently. so this assumes that the type matches.
        return this.makeCallDirect(operatorInstance, [valueExpr], reportNode, false);
    }
    compileBinaryOverload(operatorInstance, left, leftExpr, right, reportNode) {
        var rightType;
        if (operatorInstance.is(common_1.CommonFlags.INSTANCE)) {
            let classInstance = assert(operatorInstance.parent);
            assert(classInstance.kind == program_1.ElementKind.CLASS);
            rightType = operatorInstance.signature.parameterTypes[0];
        }
        else {
            // FIXME: if LHS type differs we can't recompile left because that'd completely confuse
            // local states, like having retained locals that actually do not even exist, possibly
            // releasing something random in that local before and evil things like that. Hence this
            // assumes that LHS type matches, which in turn means that static overloads must be
            // guaranteed to never mismatch LHS type, which in turn means that we can't have shiny
            // things like multiple static overloads for different combinations of LHS/RHS types.
            // We might want that at some point of course, but requires to complete the resolver so
            // it can actually resolve every kind of expression without ever having to recompile.
            rightType = operatorInstance.signature.parameterTypes[1];
        }
        var rightExpr = this.compileExpression(right, rightType, 1 /* CONV_IMPLICIT */);
        return this.makeCallDirect(operatorInstance, [leftExpr, rightExpr], reportNode);
    }
    compileAssignment(expression, valueExpression, contextualType) {
        var program = this.program;
        var resolver = program.resolver;
        var flow = this.currentFlow;
        var target = resolver.lookupExpression(expression, flow); // reports
        if (!target)
            return this.module.unreachable();
        var thisExpression = resolver.currentThisExpression;
        var elementExpression = resolver.currentElementExpression;
        // to compile just the value, we need to know the target's type
        var targetType;
        switch (target.kind) {
            case program_1.ElementKind.GLOBAL: {
                // not yet compiled if a static field compiled as a global
                if (!this.compileGlobal(target))
                    return this.module.unreachable(); // reports
                // fall-through
            }
            case program_1.ElementKind.LOCAL:
            case program_1.ElementKind.FIELD: {
                targetType = target.type;
                if (target.hasDecorator(program_1.DecoratorFlags.UNSAFE))
                    this.checkUnsafe(expression);
                break;
            }
            case program_1.ElementKind.PROPERTY_PROTOTYPE: { // static property
                let setterPrototype = target.setterPrototype;
                if (!setterPrototype) {
                    this.error(diagnostics_1.DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property, expression.range, target.internalName);
                    return this.module.unreachable();
                }
                let setterInstance = this.resolver.resolveFunction(setterPrototype, null, util_1.makeMap(), resolver_1.ReportMode.REPORT);
                if (!setterInstance)
                    return this.module.unreachable();
                assert(setterInstance.signature.parameterTypes.length == 1); // parser must guarantee this
                targetType = setterInstance.signature.parameterTypes[0];
                if (setterPrototype.hasDecorator(program_1.DecoratorFlags.UNSAFE))
                    this.checkUnsafe(expression);
                break;
            }
            case program_1.ElementKind.PROPERTY: { // instance property
                let setterInstance = target.setterInstance;
                if (!setterInstance) {
                    this.error(diagnostics_1.DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property, expression.range, target.internalName);
                    return this.module.unreachable();
                }
                assert(setterInstance.signature.parameterTypes.length == 1); // parser must guarantee this
                targetType = setterInstance.signature.parameterTypes[0];
                if (setterInstance.hasDecorator(program_1.DecoratorFlags.UNSAFE))
                    this.checkUnsafe(expression);
                break;
            }
            case program_1.ElementKind.INDEXSIGNATURE: {
                let parent = target.parent;
                assert(parent.kind == program_1.ElementKind.CLASS);
                let isUnchecked = flow.is(65536 /* UNCHECKED_CONTEXT */);
                let indexedSet = parent.lookupOverload(program_1.OperatorKind.INDEXED_SET, isUnchecked);
                if (!indexedSet) {
                    let indexedGet = parent.lookupOverload(program_1.OperatorKind.INDEXED_GET, isUnchecked);
                    if (!indexedGet) {
                        this.error(diagnostics_1.DiagnosticCode.Index_signature_is_missing_in_type_0, expression.range, parent.internalName);
                    }
                    else {
                        this.error(diagnostics_1.DiagnosticCode.Index_signature_in_type_0_only_permits_reading, expression.range, parent.internalName);
                    }
                    return this.module.unreachable();
                }
                assert(indexedSet.signature.parameterTypes.length == 2); // parser must guarantee this
                targetType = indexedSet.signature.parameterTypes[1]; // 2nd parameter is the element
                if (indexedSet.hasDecorator(program_1.DecoratorFlags.UNSAFE))
                    this.checkUnsafe(expression);
                break;
            }
            default: {
                this.error(diagnostics_1.DiagnosticCode.Not_implemented, expression.range);
                return this.module.unreachable();
            }
        }
        // compile the value and do the assignment
        assert(targetType != types_1.Type.void);
        return this.makeAssignment(target, this.compileExpression(valueExpression, targetType, 1 /* CONV_IMPLICIT */ | 16 /* WILL_RETAIN */), expression, thisExpression, elementExpression, contextualType != types_1.Type.void);
    }
    /** Makes an assignment expression or block, assigning a value to a target. */
    makeAssignment(
    /** Target element, e.g. a Local. */
    target, 
    /** Value expression that has been compiled in a previous step already. */
    valueExpr, 
    /** Expression reference. Has already been compiled to `valueExpr`. */
    valueExpression, 
    /** `this` expression reference if a field or property set. */
    thisExpression, 
    /** Index expression reference if an indexed set. */
    indexExpression, 
    /** Whether to tee the value. */
    tee) {
        var module = this.module;
        var flow = this.currentFlow;
        // NOTE: Only locals, globals and fields can make use of skipped autoreleases while
        // everything else must insert the skipped autorelease now. See (*)
        switch (target.kind) {
            case program_1.ElementKind.LOCAL: {
                if (flow.isLocalFlag(target.index, flow_1.LocalFlags.CONSTANT, true)) {
                    this.error(diagnostics_1.DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property, valueExpression.range, target.internalName);
                    this.currentType = tee ? target.type : types_1.Type.void;
                    return module.unreachable();
                }
                return this.makeLocalAssignment(target, valueExpr, tee);
            }
            case program_1.ElementKind.GLOBAL: {
                if (!this.compileGlobal(target))
                    return module.unreachable();
                if (target.isAny(common_1.CommonFlags.CONST | common_1.CommonFlags.READONLY)) {
                    this.error(diagnostics_1.DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property, valueExpression.range, target.internalName);
                    this.currentType = tee ? target.type : types_1.Type.void;
                    return module.unreachable();
                }
                return this.makeGlobalAssignment(target, valueExpr, tee);
            }
            case program_1.ElementKind.FIELD: {
                let initializerNode = target.initializerNode;
                if (target.is(common_1.CommonFlags.READONLY) &&
                    !(flow.actualFunction.is(common_1.CommonFlags.CONSTRUCTOR) ||
                        initializerNode)) {
                    this.error(diagnostics_1.DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property, valueExpression.range, target.internalName);
                    return module.unreachable();
                }
                return this.makeFieldAssignment(target, valueExpr, 
                // FIXME: explicit type (currently fails due to missing null checking)
                this.compileExpression(assert(thisExpression), this.options.usizeType), tee);
            }
            case program_1.ElementKind.PROPERTY_PROTOTYPE: { // static property
                if (this.skippedAutoreleases.has(valueExpr))
                    valueExpr = this.makeAutorelease(valueExpr, flow); // (*)
                let setterPrototype = target.setterPrototype;
                if (!setterPrototype) {
                    this.error(diagnostics_1.DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property, valueExpression.range, target.internalName);
                    return module.unreachable();
                }
                let setterInstance = this.resolver.resolveFunction(setterPrototype, null, util_1.makeMap(), resolver_1.ReportMode.REPORT);
                if (!setterInstance)
                    return module.unreachable();
                // call just the setter if the return value isn't of interest
                if (!tee)
                    return this.makeCallDirect(setterInstance, [valueExpr], valueExpression);
                // otherwise call the setter first, then the getter
                let getterPrototype = assert(target.getterPrototype); // must be present
                let getterInstance = this.resolver.resolveFunction(getterPrototype, null, util_1.makeMap(), resolver_1.ReportMode.REPORT);
                if (!getterInstance)
                    return module.unreachable();
                let returnType = getterInstance.signature.returnType;
                let nativeReturnType = returnType.toNativeType();
                return module.block(null, [
                    this.makeCallDirect(setterInstance, [valueExpr], valueExpression),
                    this.makeCallDirect(getterInstance, null, valueExpression) // sets currentType
                ], nativeReturnType);
            }
            case program_1.ElementKind.PROPERTY: { // instance property
                if (this.skippedAutoreleases.has(valueExpr))
                    valueExpr = this.makeAutorelease(valueExpr, flow); // (*)
                let setterInstance = target.setterInstance;
                if (!setterInstance) {
                    this.error(diagnostics_1.DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property, valueExpression.range, target.internalName);
                    return module.unreachable();
                }
                // call just the setter if the return value isn't of interest
                if (!tee) {
                    let thisExpr = this.compileExpression(assert(thisExpression), this.options.usizeType);
                    return this.makeCallDirect(setterInstance, [thisExpr, valueExpr], valueExpression);
                }
                // otherwise call the setter first, then the getter
                let getterInstance = assert(target.getterInstance); // must be present
                let returnType = getterInstance.signature.returnType;
                let nativeReturnType = returnType.toNativeType();
                let thisExpr = this.compileExpression(assert(thisExpression), this.options.usizeType);
                let temp = flow.getTempLocal(returnType);
                let ret = module.block(null, [
                    this.makeCallDirect(setterInstance, [
                        module.local_tee(temp.index, thisExpr),
                        valueExpr
                    ], valueExpression),
                    this.makeCallDirect(getterInstance, [
                        module.local_get(temp.index, nativeReturnType)
                    ], valueExpression)
                ], nativeReturnType);
                flow.freeTempLocal(temp);
                return ret;
            }
            case program_1.ElementKind.INDEXSIGNATURE: {
                if (this.skippedAutoreleases.has(valueExpr))
                    valueExpr = this.makeAutorelease(valueExpr, flow); // (*)
                let isUnchecked = flow.is(65536 /* UNCHECKED_CONTEXT */);
                let parent = target.parent;
                assert(parent.kind == program_1.ElementKind.CLASS);
                let indexedGet = parent.lookupOverload(program_1.OperatorKind.INDEXED_GET, isUnchecked);
                if (!indexedGet) {
                    this.error(diagnostics_1.DiagnosticCode.Index_signature_is_missing_in_type_0, valueExpression.range, parent.internalName);
                    return module.unreachable();
                }
                let indexedSet = parent.lookupOverload(program_1.OperatorKind.INDEXED_SET, isUnchecked);
                if (!indexedSet) {
                    this.error(diagnostics_1.DiagnosticCode.Index_signature_in_type_0_only_permits_reading, valueExpression.range, parent.internalName);
                    this.currentType = tee ? indexedGet.signature.returnType : types_1.Type.void;
                    return module.unreachable();
                }
                let targetType = parent.type;
                let thisExpr = this.compileExpression(assert(thisExpression), this.options.usizeType);
                let elementExpr = this.compileExpression(assert(indexExpression), types_1.Type.i32, 1 /* CONV_IMPLICIT */);
                if (tee) {
                    let tempTarget = flow.getTempLocal(targetType);
                    let tempElement = flow.getTempLocal(this.currentType);
                    let returnType = indexedGet.signature.returnType;
                    flow.freeTempLocal(tempTarget);
                    let ret = module.block(null, [
                        this.makeCallDirect(indexedSet, [
                            module.local_tee(tempTarget.index, thisExpr),
                            module.local_tee(tempElement.index, elementExpr),
                            valueExpr
                        ], valueExpression),
                        this.makeCallDirect(indexedGet, [
                            module.local_get(tempTarget.index, tempTarget.type.toNativeType()),
                            module.local_get(tempElement.index, tempElement.type.toNativeType())
                        ], valueExpression)
                    ], returnType.toNativeType());
                    flow.freeTempLocal(tempElement);
                    flow.freeTempLocal(tempTarget);
                    return ret;
                }
                else {
                    return this.makeCallDirect(indexedSet, [
                        thisExpr,
                        elementExpr,
                        valueExpr
                    ], valueExpression);
                }
            }
        }
        this.error(diagnostics_1.DiagnosticCode.Not_implemented, valueExpression.range);
        return module.unreachable();
    }
    /** Makes an assignment to a local, possibly retaining and releasing affected references and keeping track of wrap and null states. */
    makeLocalAssignment(
    /** The local to assign to. */
    local, 
    /** The value to assign. */
    valueExpr, 
    /** Whether to tee the value. */
    tee) {
        var type = local.type;
        assert(type != types_1.Type.void);
        var flow = this.currentFlow;
        var localIndex = local.index;
        if (type.is(512 /* NULLABLE */)) {
            if (flow.isNonnull(valueExpr, type))
                flow.setLocalFlag(localIndex, flow_1.LocalFlags.NONNULL);
            else
                flow.unsetLocalFlag(localIndex, flow_1.LocalFlags.NONNULL);
        }
        flow.setLocalFlag(localIndex, flow_1.LocalFlags.WRITTENTO);
        if (type.isManaged) {
            let module = this.module;
            let nativeType = type.toNativeType();
            if (flow.isAnyLocalFlag(localIndex, flow_1.LocalFlags.ANY_RETAINED)) {
                if (this.skippedAutoreleases.has(valueExpr)) {
                    valueExpr = this.makeSkippedRelease(module.local_get(localIndex, nativeType), // oldRef
                    valueExpr // newRef
                    );
                    if (tee) { // TEE(local = __skippedRelease(local, value))
                        this.currentType = type;
                        return module.local_tee(localIndex, valueExpr);
                    }
                    else { // local = __skippedRelease(local, value)
                        this.currentType = types_1.Type.void;
                        return module.local_set(localIndex, valueExpr);
                    }
                }
                else {
                    valueExpr = this.makeRetainRelease(module.local_get(localIndex, nativeType), // oldRef
                    valueExpr // newRef
                    );
                    if (tee) { // TEE(local = __retainRelease(local, value))
                        this.currentType = type;
                        return module.local_tee(localIndex, valueExpr);
                    }
                    else { // local = __retainRelease(local, value)
                        this.currentType = types_1.Type.void;
                        return module.local_set(localIndex, valueExpr);
                    }
                }
            }
            else {
                flow.unsetLocalFlag(localIndex, flow_1.LocalFlags.CONDITIONALLY_RETAINED);
                flow.setLocalFlag(localIndex, flow_1.LocalFlags.RETAINED);
                if (!this.skippedAutoreleases.has(valueExpr))
                    valueExpr = this.makeRetain(valueExpr);
                if (tee) { // TEE(local = __retain(value, local))
                    this.currentType = type;
                    return module.local_tee(localIndex, valueExpr);
                }
                else { // local = __retain(value, local)
                    this.currentType = types_1.Type.void;
                    return module.local_set(localIndex, valueExpr);
                }
            }
        }
        else {
            if (type.is(32 /* SHORT */ | 4 /* INTEGER */)) {
                if (!flow.canOverflow(valueExpr, type))
                    flow.setLocalFlag(localIndex, flow_1.LocalFlags.WRAPPED);
                else
                    flow.unsetLocalFlag(localIndex, flow_1.LocalFlags.WRAPPED);
            }
            if (tee) { // TEE(local = value)
                this.currentType = type;
                return this.module.local_tee(localIndex, valueExpr);
            }
            else { // local = value
                this.currentType = types_1.Type.void;
                return this.module.local_set(localIndex, valueExpr);
            }
        }
    }
    /** Makes an assignment to a global, possibly retaining and releasing affected references. */
    makeGlobalAssignment(
    /** The global to assign to. */
    global, 
    /** The value to assign. */
    valueExpr, 
    /** Whether to tee the value. */
    tee) {
        var module = this.module;
        var type = global.type;
        assert(type != types_1.Type.void);
        var nativeType = type.toNativeType();
        if (type.isManaged) {
            if (this.skippedAutoreleases.has(valueExpr)) {
                if (tee) { // (global = __skippedRelease(global, value)), global
                    this.currentType = type;
                    return module.block(null, [
                        module.global_set(global.internalName, this.makeSkippedRelease(module.global_get(global.internalName, nativeType), // oldRef
                        valueExpr // newRef
                        )),
                        module.global_get(global.internalName, nativeType)
                    ], nativeType);
                }
                else { // global = __skippedRelease(global, value)
                    this.currentType = types_1.Type.void;
                    return module.global_set(global.internalName, this.makeSkippedRelease(module.global_get(global.internalName, nativeType), // oldRef
                    valueExpr // newRef
                    ));
                }
            }
            else {
                if (tee) { // (global = __retainRelease(global, value)), global
                    this.currentType = type;
                    return module.block(null, [
                        module.global_set(global.internalName, this.makeRetainRelease(module.global_get(global.internalName, nativeType), // oldRef
                        valueExpr // newRef
                        )),
                        module.global_get(global.internalName, nativeType)
                    ], nativeType);
                }
                else { // global = __retainRelease(global, value)
                    this.currentType = types_1.Type.void;
                    return module.global_set(global.internalName, this.makeRetainRelease(module.global_get(global.internalName, nativeType), // oldRef
                    valueExpr // newRef
                    ));
                }
            }
        }
        else {
            valueExpr = this.ensureSmallIntegerWrap(valueExpr, type); // globals must be wrapped
            if (tee) { // (global = value), global
                this.currentType = type;
                return module.block(null, [
                    module.global_set(global.internalName, valueExpr),
                    module.global_get(global.internalName, nativeType)
                ], nativeType);
            }
            else { // global = value
                this.currentType = types_1.Type.void;
                return module.global_set(global.internalName, valueExpr);
            }
        }
    }
    /** Makes an assignment to a field, possibly retaining and releasing affected references. */
    makeFieldAssignment(
    /** The field to assign to. */
    field, 
    /** The value to assign. */
    valueExpr, 
    /** The value of `this`. */
    thisExpr, 
    /** Whether to tee the value. */
    tee) {
        var module = this.module;
        var flow = this.currentFlow;
        var fieldType = field.type;
        var nativeFieldType = fieldType.toNativeType();
        assert(field.parent.kind == program_1.ElementKind.CLASS);
        var thisType = field.parent.type;
        var nativeThisType = thisType.toNativeType();
        if (fieldType.isManaged && thisType.isManaged) {
            let tempThis = flow.getTempLocal(thisType);
            if (this.skippedAutoreleases.has(valueExpr)) {
                if (tee) { // ((t1 = this).field = __skippedRelease(t1.field, t2 = value)), t2
                    let tempValue = flow.getTempLocal(fieldType);
                    if (!flow.canOverflow(valueExpr, fieldType))
                        flow.setLocalFlag(tempValue.index, flow_1.LocalFlags.WRAPPED);
                    if (flow.isNonnull(valueExpr, fieldType))
                        flow.setLocalFlag(tempValue.index, flow_1.LocalFlags.NONNULL);
                    let ret = module.block(null, [
                        module.store(fieldType.byteSize, module.local_tee(tempThis.index, thisExpr), this.makeSkippedRelease(module.load(fieldType.byteSize, fieldType.is(1 /* SIGNED */), // oldRef
                        module.local_get(tempThis.index, nativeThisType), nativeFieldType, field.memoryOffset), module.local_tee(tempValue.index, valueExpr)), nativeFieldType, field.memoryOffset),
                        module.local_get(tempValue.index, nativeFieldType)
                    ], nativeFieldType);
                    flow.freeTempLocal(tempValue);
                    flow.freeTempLocal(tempThis);
                    this.currentType = fieldType;
                    return ret;
                }
                else { // (t1 = this).field = __skippedRelease(t1.field, value)
                    flow.freeTempLocal(tempThis);
                    this.currentType = types_1.Type.void;
                    return module.store(fieldType.byteSize, module.local_tee(tempThis.index, thisExpr), this.makeSkippedRelease(module.load(fieldType.byteSize, fieldType.is(1 /* SIGNED */), // oldRef
                    module.local_get(tempThis.index, nativeThisType), nativeFieldType, field.memoryOffset), valueExpr), nativeFieldType, field.memoryOffset);
                }
            }
            else {
                if (tee) { // ((t1 = this).field = __retainRelease(t1.field, t2 = value)), t2
                    let tempValue = flow.getTempLocal(fieldType);
                    if (!flow.canOverflow(valueExpr, fieldType))
                        flow.setLocalFlag(tempValue.index, flow_1.LocalFlags.WRAPPED);
                    if (flow.isNonnull(valueExpr, fieldType))
                        flow.setLocalFlag(tempValue.index, flow_1.LocalFlags.NONNULL);
                    let ret = module.block(null, [
                        module.store(fieldType.byteSize, module.local_tee(tempThis.index, thisExpr), this.makeRetainRelease(module.load(fieldType.byteSize, fieldType.is(1 /* SIGNED */), // oldRef
                        module.local_get(tempThis.index, nativeThisType), nativeFieldType, field.memoryOffset), module.local_tee(tempValue.index, valueExpr) // newRef
                        ), nativeFieldType, field.memoryOffset),
                        module.local_get(tempValue.index, nativeFieldType)
                    ], nativeFieldType);
                    flow.freeTempLocal(tempValue);
                    flow.freeTempLocal(tempThis);
                    this.currentType = fieldType;
                    return ret;
                }
                else { // (t1 = this).field = __retainRelease(t1.field, value)
                    flow.freeTempLocal(tempThis);
                    this.currentType = types_1.Type.void;
                    return module.store(fieldType.byteSize, module.local_tee(tempThis.index, thisExpr), this.makeRetainRelease(module.load(fieldType.byteSize, fieldType.is(1 /* SIGNED */), // oldRef
                    module.local_get(tempThis.index, nativeThisType), nativeFieldType, field.memoryOffset), valueExpr // newRef
                    ), nativeFieldType, field.memoryOffset);
                }
            }
        }
        else {
            if (tee) { // (this.field = (t1 = value)), t1
                let tempValue = flow.getTempLocal(fieldType);
                if (!flow.canOverflow(valueExpr, fieldType))
                    flow.setLocalFlag(tempValue.index, flow_1.LocalFlags.WRAPPED);
                if (flow.isNonnull(valueExpr, fieldType))
                    flow.setLocalFlag(tempValue.index, flow_1.LocalFlags.NONNULL);
                let ret = module.block(null, [
                    module.store(fieldType.byteSize, thisExpr, module.local_tee(tempValue.index, valueExpr), nativeFieldType, field.memoryOffset),
                    module.local_get(tempValue.index, nativeFieldType)
                ], nativeFieldType);
                flow.freeTempLocal(tempValue);
                this.currentType = fieldType;
                return ret;
            }
            else { // this.field = value
                this.currentType = types_1.Type.void;
                return module.store(fieldType.byteSize, thisExpr, valueExpr, nativeFieldType, field.memoryOffset);
            }
        }
    }
    /** Compiles a call expression according to the specified context. */
    compileCallExpression(
    /** Call expression to compile. */
    expression, 
    /** Contextual type indicating the return type the caller expects, if any. */
    contextualType, 
    /** Constraints indicating contextual conditions. */
    constraints) {
        var module = this.module;
        var flow = this.currentFlow;
        // handle call to super
        if (expression.expression.kind == ast_1.NodeKind.SUPER) {
            let flow = this.currentFlow;
            let actualFunction = flow.actualFunction;
            if (!actualFunction.is(common_1.CommonFlags.CONSTRUCTOR)) {
                this.error(diagnostics_1.DiagnosticCode.Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors, expression.range);
                return module.unreachable();
            }
            let classInstance = assert(actualFunction.parent);
            assert(classInstance.kind == program_1.ElementKind.CLASS);
            let baseClassInstance = assert(classInstance.base);
            let thisLocal = assert(flow.lookupLocal(common_1.CommonSymbols.this_));
            let nativeSizeType = this.options.nativeSizeType;
            // {
            //   this = super(this || <ALLOC>, ...args)
            //   this.a = X
            //   this.b = Y
            // }
            let theCall = this.compileCallDirect(this.ensureConstructor(baseClassInstance, expression), expression.arguments, expression, module.if(module.local_get(thisLocal.index, nativeSizeType), module.local_get(thisLocal.index, nativeSizeType), this.makeRetain(this.makeAllocation(classInstance))), 16 /* WILL_RETAIN */);
            assert(this.skippedAutoreleases.has(theCall)); // guaranteed
            let stmts = [
                module.local_set(thisLocal.index, theCall)
            ];
            this.makeFieldInitialization(classInstance, stmts);
            // check that super had been called before accessing `this`
            if (flow.isAny(64 /* ALLOCATES */ |
                16384 /* CONDITIONALLY_ALLOCATES */)) {
                this.error(diagnostics_1.DiagnosticCode._super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class, expression.range);
                return module.unreachable();
            }
            flow.set(64 /* ALLOCATES */ | 128 /* CALLS_SUPER */);
            this.currentType = types_1.Type.void;
            return module.block(null, stmts);
        }
        // otherwise resolve normally
        var target = this.resolver.lookupExpression(expression.expression, flow); // reports
        if (!target)
            return module.unreachable();
        var signature;
        var indexArg;
        switch (target.kind) {
            // direct call: concrete function
            case program_1.ElementKind.FUNCTION_PROTOTYPE: {
                let prototype = target;
                // builtins handle present respectively omitted type arguments on their own
                if (prototype.hasDecorator(program_1.DecoratorFlags.BUILTIN)) {
                    return this.compileCallExpressionBuiltin(prototype, expression, contextualType);
                }
                let thisExpression = this.resolver.currentThisExpression;
                let instance = this.resolver.maybeInferCall(expression, prototype, flow);
                if (!instance)
                    return this.module.unreachable();
                return this.compileCallDirect(instance, expression.arguments, expression, instance.is(common_1.CommonFlags.INSTANCE)
                    ? this.compileExpression(assert(thisExpression), this.options.usizeType)
                    : 0, constraints);
            }
            // indirect call: index argument with signature (non-generic, can't be inlined)
            case program_1.ElementKind.LOCAL: {
                if (signature = target.type.signatureReference) {
                    if (target.is(common_1.CommonFlags.INLINED)) {
                        indexArg = module.i32(i64_low(target.constantIntegerValue));
                    }
                    else {
                        indexArg = module.local_get(target.index, module_1.NativeType.I32);
                    }
                    break;
                }
                else {
                    this.error(diagnostics_1.DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures, expression.range, target.type.toString());
                    return module.unreachable();
                }
            }
            case program_1.ElementKind.GLOBAL: {
                if (signature = target.type.signatureReference) {
                    indexArg = module.global_get(target.internalName, target.type.toNativeType());
                    break;
                }
                else {
                    this.error(diagnostics_1.DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures, expression.range, target.type.toString());
                    return module.unreachable();
                }
            }
            case program_1.ElementKind.FIELD: {
                let type = target.type;
                if (signature = type.signatureReference) {
                    let thisExpression = assert(this.resolver.currentThisExpression);
                    let thisExpr = this.compileExpression(thisExpression, this.options.usizeType);
                    indexArg = module.load(4, false, thisExpr, module_1.NativeType.I32, target.memoryOffset);
                    break;
                }
                else {
                    this.error(diagnostics_1.DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures, expression.range, type.toString());
                    return module.unreachable();
                }
            }
            case program_1.ElementKind.FUNCTION_TARGET: {
                signature = target.signature;
                indexArg = this.compileExpression(expression.expression, target.type, 1 /* CONV_IMPLICIT */);
                break;
            }
            case program_1.ElementKind.PROPERTY_PROTOTYPE: { // static property
                let getterPrototype = assert(target.getterPrototype);
                let getterInstance = this.resolver.resolveFunction(getterPrototype, null);
                if (!getterInstance)
                    return module.unreachable();
                indexArg = this.compileCallDirect(getterInstance, [], expression.expression);
                signature = this.currentType.signatureReference;
                if (!signature) {
                    this.error(diagnostics_1.DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures, expression.range, this.currentType.toString());
                    return module.unreachable();
                }
                break;
            }
            case program_1.ElementKind.PROPERTY: { // instance property
                let getterInstance = assert(target.getterInstance);
                indexArg = this.compileCallDirect(getterInstance, [], expression.expression, this.compileExpression(assert(this.resolver.currentThisExpression), this.options.usizeType));
                signature = this.currentType.signatureReference;
                if (!signature) {
                    this.error(diagnostics_1.DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures, expression.range, this.currentType.toString());
                    return module.unreachable();
                }
                break;
            }
            // not supported
            default: {
                let type = this.resolver.getTypeOfElement(target);
                if (type) {
                    this.error(diagnostics_1.DiagnosticCode.Type_0_has_no_call_signatures, expression.range, type.toString());
                }
                else {
                    this.error(diagnostics_1.DiagnosticCode.Expression_cannot_be_represented_by_a_type, expression.range);
                }
                return module.unreachable();
            }
        }
        return this.compileCallIndirect(signature, indexArg, expression.arguments, expression, 0, contextualType == types_1.Type.void);
    }
    compileCallExpressionBuiltin(prototype, expression, contextualType) {
        if (prototype.hasDecorator(program_1.DecoratorFlags.UNSAFE))
            this.checkUnsafe(expression);
        var typeArguments = null;
        // builtins handle omitted type arguments on their own. if present, however, resolve them here
        // and pass them to the builtin, even if it's still up to the builtin how to handle them.
        var typeParameterNodes = prototype.typeParameterNodes;
        var typeArgumentNodes = expression.typeArguments;
        if (expression.typeArguments) {
            if (!prototype.is(common_1.CommonFlags.GENERIC)) {
                this.error(diagnostics_1.DiagnosticCode.Type_0_is_not_generic, expression.range, prototype.internalName);
            }
            typeArguments = this.resolver.resolveTypeArguments(assert(typeParameterNodes), typeArgumentNodes, this.currentFlow.actualFunction.parent, util_1.makeMap(this.currentFlow.contextualTypeArguments), expression);
        }
        // now compile the builtin, which usually returns a block of code that replaces the call.
        return builtins_1.compileCall(this, prototype, typeArguments, expression.arguments, contextualType, expression);
    }
    /**
     * Checks that a call with the given number as arguments can be performed according to the
     * specified signature.
     */
    checkCallSignature(signature, numArguments, hasThis, reportNode) {
        // cannot call an instance method without a `this` argument (TODO: `.call`?)
        var thisType = signature.thisType;
        if (hasThis != (thisType != null)) {
            this.error(diagnostics_1.DiagnosticCode.The_this_types_of_each_signature_are_incompatible, reportNode.range);
            return false;
        }
        // not yet implemented (TODO: maybe some sort of an unmanaged/lightweight array?)
        var hasRest = signature.hasRest;
        if (hasRest) {
            this.error(diagnostics_1.DiagnosticCode.Not_implemented, reportNode.range);
            return false;
        }
        var minimum = signature.requiredParameters;
        var maximum = signature.parameterTypes.length;
        // must at least be called with required arguments
        if (numArguments < minimum) {
            this.error(minimum < maximum
                ? diagnostics_1.DiagnosticCode.Expected_at_least_0_arguments_but_got_1
                : diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, reportNode.range, minimum.toString(), numArguments.toString());
            return false;
        }
        // must not be called with more than the maximum arguments
        if (numArguments > maximum && !hasRest) {
            this.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, reportNode.range, maximum.toString(), numArguments.toString());
            return false;
        }
        return true;
    }
    /** Checks that an unsafe expression is allowed. */
    checkUnsafe(reportNode) {
        // Library files may always use unsafe features
        if (this.options.noUnsafe && !reportNode.range.source.isLibrary) {
            this.error(diagnostics_1.DiagnosticCode.Operation_is_unsafe, reportNode.range);
        }
    }
    /** Compiles a direct call to a concrete function. */
    compileCallDirect(instance, argumentExpressions, reportNode, thisArg = 0, constraints = 0 /* NONE */) {
        var numArguments = argumentExpressions.length;
        var signature = instance.signature;
        if (!this.checkCallSignature(// reports
        signature, numArguments, thisArg != 0, reportNode)) {
            this.currentType = signature.returnType;
            return this.module.unreachable();
        }
        if (instance.hasDecorator(program_1.DecoratorFlags.UNSAFE))
            this.checkUnsafe(reportNode);
        // Inline if explicitly requested
        if (instance.hasDecorator(program_1.DecoratorFlags.INLINE)) {
            assert(!instance.is(common_1.CommonFlags.TRAMPOLINE)); // doesn't make sense
            if (this.currentInlineFunctions.includes(instance)) {
                this.warning(diagnostics_1.DiagnosticCode.Function_0_cannot_be_inlined_into_itself, reportNode.range, instance.internalName);
            }
            else {
                this.currentInlineFunctions.push(instance);
                let parameterTypes = signature.parameterTypes;
                assert(numArguments <= parameterTypes.length);
                // compile argument expressions
                let args = new Array(numArguments);
                for (let i = 0; i < numArguments; ++i) {
                    args[i] = this.compileExpression(argumentExpressions[i], parameterTypes[i], 1 /* CONV_IMPLICIT */ | 16 /* WILL_RETAIN */);
                }
                // make the inlined call (is aware of autoreleases)
                let expr = this.makeCallInline(instance, args, thisArg, (constraints & 8 /* WILL_DROP */) != 0);
                if (this.currentType.isManaged) {
                    if (!(constraints & 16 /* WILL_RETAIN */)) {
                        expr = this.makeAutorelease(expr, this.currentFlow);
                    }
                    else {
                        this.skippedAutoreleases.add(expr);
                    }
                }
                this.currentInlineFunctions.pop();
                return expr;
            }
        }
        // Otherwise compile to just a call
        var numArgumentsInclThis = thisArg ? numArguments + 1 : numArguments;
        var operands = new Array(numArgumentsInclThis);
        var index = 0;
        if (thisArg) {
            operands[0] = thisArg;
            index = 1;
        }
        var parameterTypes = signature.parameterTypes;
        for (let i = 0; i < numArguments; ++i, ++index) {
            operands[index] = this.compileExpression(argumentExpressions[i], parameterTypes[i], 1 /* CONV_IMPLICIT */);
        }
        assert(index == numArgumentsInclThis);
        if (signature.returnType.isManaged) {
            if (constraints & 8 /* WILL_DROP */) {
                // Skip autorelease and simply release
                return this.makeCallDirect(instance, operands, reportNode, true);
            }
            else if (constraints & 16 /* WILL_RETAIN */) {
                // Skip autorelease and remember
                let expr = this.makeCallDirect(instance, operands, reportNode, false, true);
                this.skippedAutoreleases.add(expr);
                return expr;
            }
            else {
                return this.makeCallDirect(instance, operands, reportNode, false, false);
            }
        }
        return this.makeCallDirect(instance, operands, reportNode, (constraints & 8 /* WILL_DROP */) != 0);
    }
    makeCallInline(instance, operands, thisArg = 0, immediatelyDropped = false) {
        var module = this.module;
        var numArguments = operands ? operands.length : 0;
        var signature = instance.signature;
        var parameterTypes = signature.parameterTypes;
        var numParameters = parameterTypes.length;
        // Create a new inline flow and use it to compile the function as a block
        var previousFlow = this.currentFlow;
        var flow = flow_1.Flow.createInline(previousFlow.parentFunction, instance);
        var body = [];
        var usedLocals = new Set();
        // Prepare compiled arguments right to left, keeping track of used locals.
        for (let i = numArguments - 1; i >= 0; --i) {
            // This is necessary because a later expression must not set an earlier argument local, which
            // is also just a temporary, when being executed. Take for example `t1=1, t2=(t1 = 2)`, where
            // the right expression would reassign the foregoing argument local. So, we iterate from right
            // to left, remembering what's used later, and don't use these for earlier arguments, making
            // the example above essentially `t2=1, t1=(t1 = 2)`.
            let paramExpr = operands[i];
            let paramType = parameterTypes[i];
            let argumentLocal = flow.addScopedLocal(signature.getParameterName(i), paramType, usedLocals);
            flow_1.findUsedLocals(paramExpr, usedLocals);
            // inlining is aware of wrap/nonnull states:
            if (!previousFlow.canOverflow(paramExpr, paramType))
                flow.setLocalFlag(argumentLocal.index, flow_1.LocalFlags.WRAPPED);
            if (flow.isNonnull(paramExpr, paramType))
                flow.setLocalFlag(argumentLocal.index, flow_1.LocalFlags.NONNULL);
            // inlining is aware of skipped autoreleases:
            if (paramType.isManaged) {
                if (!this.skippedAutoreleases.has(paramExpr))
                    paramExpr = this.makeRetain(paramExpr);
                flow.setLocalFlag(argumentLocal.index, flow_1.LocalFlags.RETAINED);
            }
            body.unshift(module.local_set(argumentLocal.index, paramExpr));
        }
        if (thisArg) {
            let classInstance = assert(instance.parent);
            assert(classInstance.kind == program_1.ElementKind.CLASS);
            let thisType = assert(instance.signature.thisType);
            let thisLocal = flow.addScopedLocal(common_1.CommonSymbols.this_, thisType, usedLocals);
            // No need to retain `this` as it can't be reassigned and thus can't become prematurely released
            body.unshift(module.local_set(thisLocal.index, thisArg));
            let baseInstance = classInstance.base;
            if (baseInstance)
                flow.addScopedAlias(common_1.CommonSymbols.super_, baseInstance.type, thisLocal.index);
        }
        else {
            assert(!instance.signature.thisType);
        }
        // Compile omitted arguments with final argument locals blocked. Doesn't need to take care of
        // side-effects within earlier expressions because these already happened on set.
        this.currentFlow = flow;
        for (let i = numArguments; i < numParameters; ++i) {
            let initType = parameterTypes[i];
            let initExpr = this.compileExpression(assert(instance.prototype.functionTypeNode.parameters[i].initializer), initType, 1 /* CONV_IMPLICIT */ | 16 /* WILL_RETAIN */);
            let argumentLocal = flow.addScopedLocal(signature.getParameterName(i), initType);
            if (!flow.canOverflow(initExpr, initType))
                flow.setLocalFlag(argumentLocal.index, flow_1.LocalFlags.WRAPPED);
            if (flow.isNonnull(initExpr, initType))
                flow.setLocalFlag(argumentLocal.index, flow_1.LocalFlags.NONNULL);
            if (initType.isManaged) {
                flow.setLocalFlag(argumentLocal.index, flow_1.LocalFlags.RETAINED);
                if (!this.skippedAutoreleases.has(initExpr))
                    initExpr = this.makeRetain(initExpr);
            }
            body.push(module.local_set(argumentLocal.index, initExpr));
        }
        // Compile the called function's body in the scope of the inlined flow
        this.compileFunctionBody(instance, body);
        // Free any new scoped locals and reset to the original flow
        if (!flow.is(256 /* TERMINATES */)) {
            this.performAutoreleases(flow, body);
            this.finishAutoreleases(flow, body);
        }
        flow.freeScopedLocals();
        var returnType = flow.returnType;
        this.currentFlow = previousFlow;
        // Create an outer block that we can break to when returning a value out of order
        var expr = module.block(flow.inlineReturnLabel, body, returnType.toNativeType());
        this.currentType = returnType;
        if (returnType.isManaged) {
            if (immediatelyDropped) {
                expr = this.makeRelease(expr);
                this.currentType = types_1.Type.void;
            }
        }
        return expr;
    }
    /** Gets the trampoline for the specified function. */
    ensureTrampoline(original) {
        // A trampoline is a function that takes a fixed amount of operands with some of them possibly
        // being zeroed. It takes one additional argument denoting the number of actual operands
        // provided to the call, and takes appropriate steps to initialize zeroed operands to their
        // default values using the optional parameter initializers of the original function. Doing so
        // allows calls to functions with optional parameters to circumvent the trampoline when all
        // parameters are provided as a fast route, respectively setting up omitted operands in a proper
        // context otherwise.
        var trampoline = original.trampoline;
        if (trampoline)
            return trampoline;
        var originalSignature = original.signature;
        var originalName = original.internalName;
        var originalParameterTypes = originalSignature.parameterTypes;
        var originalParameterDeclarations = original.prototype.functionTypeNode.parameters;
        var returnType = originalSignature.returnType;
        var thisType = originalSignature.thisType;
        var isInstance = original.is(common_1.CommonFlags.INSTANCE);
        // arguments excl. `this`, operands incl. `this`
        var minArguments = originalSignature.requiredParameters;
        var minOperands = minArguments;
        var maxArguments = originalParameterTypes.length;
        var maxOperands = maxArguments;
        if (isInstance) {
            ++minOperands;
            ++maxOperands;
        }
        var numOptional = assert(maxOperands - minOperands);
        var forwardedOperands = new Array(minOperands);
        var operandIndex = 0;
        // forward `this` if applicable
        var module = this.module;
        if (isInstance) {
            forwardedOperands[0] = module.local_get(0, this.options.nativeSizeType);
            operandIndex = 1;
        }
        // forward required arguments
        for (let i = 0; i < minArguments; ++i, ++operandIndex) {
            forwardedOperands[operandIndex] = module.local_get(operandIndex, originalParameterTypes[i].toNativeType());
        }
        assert(operandIndex == minOperands);
        // create the trampoline element
        var trampolineSignature = new types_1.Signature(this.program, originalParameterTypes, returnType, thisType);
        trampolineSignature.requiredParameters = maxArguments;
        trampolineSignature.parameterNames = originalSignature.parameterNames;
        trampoline = new program_1.Function(original.name + "|trampoline", original.prototype, trampolineSignature, original.contextualTypeArguments);
        trampoline.set(original.flags | common_1.CommonFlags.TRAMPOLINE | common_1.CommonFlags.COMPILED);
        original.trampoline = trampoline;
        // compile initializers of omitted arguments in scope of the trampoline function
        // this is necessary because initializers might need additional locals and a proper this context
        var previousFlow = this.currentFlow;
        var flow = trampoline.flow;
        this.currentFlow = flow;
        // create a br_table switching over the number of optional parameters provided
        var numNames = numOptional + 1; // incl. outer block
        var names = new Array(numNames);
        var ofN = "of" + numOptional.toString(10);
        for (let i = 0; i < numNames; ++i) {
            let label = i.toString(10) + ofN;
            names[i] = label;
        }
        var body = module.block(names[0], [
            module.block("outOfRange", [
                module.switch(names, "outOfRange", 
                // condition is number of provided optional arguments, so subtract required arguments
                minArguments
                    ? module.binary(module_1.BinaryOp.SubI32, module.global_get(builtins_1.BuiltinSymbols.argc, module_1.NativeType.I32), module.i32(minArguments))
                    : module.global_get(builtins_1.BuiltinSymbols.argc, module_1.NativeType.I32))
            ]),
            module.unreachable()
        ]);
        for (let i = 0; i < numOptional; ++i, ++operandIndex) {
            let type = originalParameterTypes[minArguments + i];
            let declaration = originalParameterDeclarations[minArguments + i];
            let initializer = declaration.initializer;
            let initExpr;
            if (initializer) {
                initExpr = module.local_set(operandIndex, this.compileExpression(initializer, type, 1 /* CONV_IMPLICIT */));
            }
            else {
                this.error(diagnostics_1.DiagnosticCode.Optional_parameter_must_have_an_initializer, declaration.range);
                initExpr = module.unreachable();
            }
            body = module.block(names[i + 1], [
                body,
                initExpr,
            ]);
            forwardedOperands[operandIndex] = module.local_get(operandIndex, type.toNativeType());
        }
        assert(operandIndex == maxOperands);
        var stmts = [body];
        var theCall = module.call(originalName, forwardedOperands, returnType.toNativeType());
        if (returnType != types_1.Type.void) {
            this.performAutoreleasesWithValue(flow, theCall, returnType, stmts);
        }
        else {
            stmts.push(theCall);
            this.performAutoreleases(flow, stmts);
        }
        flow.freeScopedLocals();
        this.currentFlow = previousFlow;
        var funcRef = module.addFunction(trampoline.internalName, this.ensureFunctionType(trampolineSignature.parameterTypes, returnType, thisType), types_1.typesToNativeTypes(trampoline.additionalLocals), module.block(null, stmts, returnType.toNativeType()));
        trampoline.finalize(module, funcRef);
        return trampoline;
    }
    /** Makes sure that the argument count helper global is present and returns its name. */
    ensureArgcVar() {
        if (!this.argcVar) {
            let module = this.module;
            this.argcVar = module.addGlobal(builtins_1.BuiltinSymbols.argc, module_1.NativeType.I32, true, module.i32(0));
        }
        return builtins_1.BuiltinSymbols.argc;
    }
    /** Makes sure that the argument count helper setter is present and returns its name. */
    ensureArgcSet() {
        if (!this.argcSet) {
            let module = this.module;
            this.argcSet = module.addFunction(builtins_1.BuiltinSymbols.setargc, this.ensureFunctionType([types_1.Type.u32], types_1.Type.void), null, module.global_set(this.ensureArgcVar(), module.local_get(0, module_1.NativeType.I32)));
            module.addFunctionExport(builtins_1.BuiltinSymbols.setargc, "__setargc");
        }
        return builtins_1.BuiltinSymbols.setargc;
    }
    // <reference-counting>
    /** Makes retain call, retaining the expression's value. */
    makeRetain(expr) {
        var retainInstance = this.program.retainInstance;
        this.compileFunction(retainInstance);
        return this.module.call(retainInstance.internalName, [expr], this.options.nativeSizeType);
    }
    /** Makes a retainRelease call, retaining the new expression's value and releasing the old expression's value, in this order. */
    makeRetainRelease(oldExpr, newExpr) {
        // if ((t1=newExpr) != (t2=oldExpr)) {
        //   __retain(t1);
        //   __release(t2);
        // }, t1
        var module = this.module;
        var flow = this.currentFlow;
        var usizeType = this.options.usizeType;
        var nativeSizeType = this.options.nativeSizeType;
        var temp1 = flow.getTempLocal(usizeType, flow_1.findUsedLocals(oldExpr));
        var temp2 = flow.getTempLocal(usizeType);
        var ret = module.block(null, [
            module.if(module.binary(nativeSizeType == module_1.NativeType.I64 ? module_1.BinaryOp.NeI64 : module_1.BinaryOp.NeI32, module.local_tee(temp1.index, newExpr), module.local_tee(temp2.index, oldExpr)), module.block(null, [
                module.drop(this.makeRetain(module.local_get(temp1.index, nativeSizeType))),
                this.makeRelease(module.local_get(temp2.index, nativeSizeType))
            ])),
            module.local_get(temp1.index, nativeSizeType)
        ], nativeSizeType);
        flow.freeTempLocal(temp2);
        flow.freeTempLocal(temp1);
        return ret;
    }
    /** Makes a skippedRelease call, ignoring the new expression's value and releasing the old expression's value, in this order. */
    makeSkippedRelease(oldExpr, newExpr) {
        // TODO: this helper can be eliminated altogether if the current logic holds
        // (t1=newExpr), __release(oldExpr), t1
        var module = this.module;
        var flow = this.currentFlow;
        var usizeType = this.options.usizeType;
        var nativeSizeType = this.options.nativeSizeType;
        var temp = flow.getTempLocal(usizeType, flow_1.findUsedLocals(oldExpr));
        var ret = module.block(null, [
            module.local_set(temp.index, newExpr),
            this.makeRelease(oldExpr),
            module.local_get(temp.index, nativeSizeType)
        ], nativeSizeType);
        flow.freeTempLocal(temp);
        return ret;
    }
    /** Makes a release call, releasing the expression's value. Changes the current type to void.*/
    makeRelease(expr) {
        var releaseInstance = this.program.releaseInstance;
        this.compileFunction(releaseInstance);
        return this.module.call(releaseInstance.internalName, [expr], module_1.NativeType.None);
    }
    /** Makes an automatic release call at the end of the current flow. */
    makeAutorelease(expr, flow = this.currentFlow) {
        // FIXME: loses track of nonNull state?
        return this.module.local_tee(flow.getAutoreleaseLocal(this.options.usizeType).index, expr);
    }
    /** Attempts to undo a final autorelease, returning the index of the previously retaining variable or -1 if not possible. */
    undoAutorelease(expr, flow) {
        // NOTE: Can't remove the local.tee completely because it's already compiled
        // and a child of something else. Preventing the final release however should
        // make it optimize away.
        switch (module_1.getExpressionId(expr)) {
            case module_1.ExpressionId.LocalSet: { // local.tee(__retain(expr))
                if (module_1.isLocalTee(expr)) {
                    let index = module_1.getLocalSetIndex(expr);
                    if (flow.isAnyLocalFlag(index, flow_1.LocalFlags.ANY_RETAINED)) {
                        // Assumes that the expression actually belongs to the flow and that
                        // top-level autoreleases are never undone. While that's true, it's
                        // not necessary to check presence in scopedLocals.
                        flow.unsetLocalFlag(index, flow_1.LocalFlags.ANY_RETAINED);
                        return index;
                    }
                }
                break;
            }
            case module_1.ExpressionId.Block: { // { ..., local.tee(__retain(expr)) }
                if (module_1.getBlockName(expr) === null) { // must not be a break target
                    let count = module_1.getBlockChildCount(expr);
                    if (count) {
                        return this.undoAutorelease(module_1.getBlockChild(expr, count - 1), flow);
                    }
                }
                break;
            }
        }
        return -1;
    }
    /**
     * Attemps to move a final autorelease from one flow to a parent.
     * It is crucial that from flow hasn't processed autoreleases yet because otherwise the final
     * retain would have been written already.
     */
    moveAutorelease(expr, fromInnerFlow, toOuterFlow) {
        // NOTE: While this avoids an unnecessary set of retain and release, it cannot
        // eliminate the now unnecessary temporary local.tee because it is already part of
        // another expression in the tree. But optimizing should collapse locals again.
        var index = this.undoAutorelease(expr, fromInnerFlow);
        return ~index
            ? this.makeAutorelease(expr, toOuterFlow) // undone, can skip the retain
            : this.makeAutorelease(this.makeRetain(expr), toOuterFlow);
    }
    /** Performs any queued autoreleases in the specified flow. */
    performAutoreleases(flow, stmts, clearFlags = true) {
        var scopedLocals = flow.scopedLocals;
        if (scopedLocals) {
            let module = this.module;
            for (let local of scopedLocals.values()) {
                if (local.is(common_1.CommonFlags.SCOPED)) { // otherwise an alias
                    let localIndex = local.index;
                    if (flow.isAnyLocalFlag(localIndex, flow_1.LocalFlags.ANY_RETAINED)) {
                        if (clearFlags)
                            flow.unsetLocalFlag(localIndex, flow_1.LocalFlags.ANY_RETAINED);
                        stmts.push(this.makeRelease(module.local_get(localIndex, local.type.toNativeType())));
                    }
                }
            }
        }
    }
    /** Performs any queued autoreleases in the specified flow and returns the value. */
    performAutoreleasesWithValue(flow, valueExpr, valueType, stmts = null, clearFlags = true) {
        if (!stmts)
            stmts = new Array();
        stmts.push(this.module.nop());
        var lengthBefore = stmts.length;
        this.performAutoreleases(flow, stmts, clearFlags);
        if (stmts.length > lengthBefore) {
            let nativeType = valueType.toNativeType();
            let temp = flow.getTempLocal(valueType);
            if (!flow.canOverflow(valueExpr, valueType))
                flow.setLocalFlag(temp.index, flow_1.LocalFlags.WRAPPED);
            if (flow.isNonnull(valueExpr, valueType))
                flow.setLocalFlag(temp.index, flow_1.LocalFlags.NONNULL);
            let module = this.module;
            stmts[lengthBefore - 1] = module.local_set(temp.index, valueExpr); // nop -> set
            stmts.push(module.local_get(temp.index, nativeType) // append get
            );
            let ret = module.block(null, stmts, nativeType);
            flow.freeTempLocal(temp);
            return ret;
        }
        else if (stmts.length > 1) {
            stmts[lengthBefore - 1] = valueExpr; // nop -> value
            return this.module.block(null, stmts, valueType.toNativeType());
        }
        return valueExpr;
    }
    /** Finishes any queued top-level autoreleases in the actual function of the specified flow. */
    finishAutoreleases(flow, stmts) {
        var module = this.module;
        if (flow.is(32768 /* INLINE_CONTEXT */)) {
            // traverse to the top-most flow containing the inlined function's
            // locals as scoped locals and release these instead.
            let parent;
            while (parent = flow.parent)
                flow = parent;
            this.performAutoreleases(flow, stmts, false);
        }
        else {
            for (let local of flow.parentFunction.localsByIndex) {
                let localIndex = local.index;
                if (flow.isAnyLocalFlag(localIndex, flow_1.LocalFlags.ANY_RETAINED)) {
                    flow.unsetLocalFlag(localIndex, flow_1.LocalFlags.ANY_RETAINED);
                    stmts.push(this.makeRelease(module.local_get(localIndex, local.type.toNativeType())));
                }
            }
        }
    }
    // </reference-counting>
    /** Creates a direct call to the specified function. */
    makeCallDirect(instance, operands, reportNode, immediatelyDropped = false, 
    /** Skip the usual autorelease and manage this at the callsite instead. */
    skipAutorelease = false) {
        if (instance.hasDecorator(program_1.DecoratorFlags.INLINE)) {
            assert(!instance.is(common_1.CommonFlags.TRAMPOLINE)); // doesn't make sense
            if (this.currentInlineFunctions.includes(instance)) {
                this.warning(diagnostics_1.DiagnosticCode.Function_0_cannot_be_inlined_into_itself, reportNode.range, instance.internalName);
            }
            else {
                this.currentInlineFunctions.push(instance);
                let expr;
                if (instance.is(common_1.CommonFlags.INSTANCE)) {
                    let theOperands = assert(operands);
                    assert(theOperands.length);
                    expr = this.makeCallInline(instance, theOperands.slice(1), theOperands[0], immediatelyDropped);
                }
                else {
                    expr = this.makeCallInline(instance, operands, 0, immediatelyDropped);
                }
                if (this.currentType.isManaged) {
                    if (!skipAutorelease) {
                        expr = this.makeAutorelease(expr, this.currentFlow);
                    }
                    else {
                        this.skippedAutoreleases.add(expr);
                    }
                }
                this.currentInlineFunctions.pop();
                return expr;
            }
        }
        var numOperands = operands ? operands.length : 0;
        var numArguments = numOperands;
        var minArguments = instance.signature.requiredParameters;
        var minOperands = minArguments;
        var maxArguments = instance.signature.parameterTypes.length;
        var maxOperands = maxArguments;
        if (instance.is(common_1.CommonFlags.INSTANCE)) {
            ++minOperands;
            ++maxOperands;
            --numArguments;
        }
        assert(numOperands >= minOperands);
        var module = this.module;
        if (!this.compileFunction(instance))
            return module.unreachable();
        var returnType = instance.signature.returnType;
        var isCallImport = instance.is(common_1.CommonFlags.MODULE_IMPORT);
        // fill up omitted arguments with their initializers, if constant, otherwise with zeroes.
        if (numOperands < maxOperands) {
            if (!operands) {
                operands = new Array(maxOperands);
                operands.length = 0;
            }
            let parameterTypes = instance.signature.parameterTypes;
            let parameterNodes = instance.prototype.functionTypeNode.parameters;
            assert(parameterNodes.length == parameterTypes.length);
            let allOptionalsAreConstant = true;
            for (let i = numArguments; i < maxArguments; ++i) {
                let initializer = parameterNodes[i].initializer;
                if (initializer) {
                    if (ast_1.nodeIsConstantValue(initializer.kind)) {
                        operands.push(this.compileExpression(parameterNodes[i].initializer, parameterTypes[i], 1 /* CONV_IMPLICIT */));
                        continue;
                    }
                    let resolved = this.resolver.lookupExpression(initializer, instance.flow, parameterTypes[i]);
                    if (resolved) {
                        if (resolved.kind == program_1.ElementKind.GLOBAL) {
                            let global = resolved;
                            if (this.compileGlobal(global)) {
                                if (global.is(common_1.CommonFlags.INLINED)) {
                                    operands.push(this.compileInlineConstant(global, parameterTypes[i], 1 /* CONV_IMPLICIT */));
                                }
                                else {
                                    operands.push(this.convertExpression(module.global_get(global.internalName, global.type.toNativeType()), global.type, parameterTypes[i], false, false, initializer));
                                }
                                continue;
                            }
                        }
                    }
                }
                operands.push(parameterTypes[i].toNativeZero(module));
                allOptionalsAreConstant = false;
            }
            if (!allOptionalsAreConstant) {
                if (!isCallImport) {
                    let original = instance;
                    instance = this.ensureTrampoline(instance);
                    if (!this.compileFunction(instance))
                        return module.unreachable();
                    instance.flow.flags = original.flow.flags;
                    let nativeReturnType = returnType.toNativeType();
                    let expr = module.call(instance.internalName, operands, nativeReturnType);
                    this.currentType = returnType;
                    if (returnType.isManaged) {
                        if (immediatelyDropped) {
                            expr = this.makeRelease(expr);
                            this.currentType = types_1.Type.void;
                        }
                        else if (!skipAutorelease) {
                            expr = this.makeAutorelease(expr);
                        }
                        else {
                            this.skippedAutoreleases.add(expr);
                        }
                    }
                    return module.block(null, [
                        module.global_set(this.ensureArgcVar(), module.i32(numArguments)),
                        expr
                    ], this.currentType.toNativeType());
                }
            }
        }
        // If the return value is of a reference type it has not yet been released but is in flight
        // which is equivalent to a skipped autorelease. Hence, insert either a release if it is
        // dropped anyway, preserve the skipped autorelease if explicitly requested or autorelease now.
        var expr = module.call(instance.internalName, operands, returnType.toNativeType());
        this.currentType = returnType;
        if (returnType.isManaged) {
            if (immediatelyDropped) {
                expr = this.makeRelease(expr);
                this.currentType = types_1.Type.void;
            }
            else if (!skipAutorelease) {
                expr = this.makeAutorelease(expr);
            }
        }
        return expr;
    }
    /** Compiles an indirect call using an index argument and a signature. */
    compileCallIndirect(signature, indexArg, argumentExpressions, reportNode, thisArg = 0, immediatelyDropped = false) {
        var numArguments = argumentExpressions.length;
        if (!this.checkCallSignature(// reports
        signature, numArguments, thisArg != 0, reportNode)) {
            return this.module.unreachable();
        }
        var numArgumentsInclThis = thisArg ? numArguments + 1 : numArguments;
        var operands = new Array(numArgumentsInclThis);
        var index = 0;
        if (thisArg) {
            operands[0] = thisArg;
            index = 1;
        }
        var parameterTypes = signature.parameterTypes;
        for (let i = 0; i < numArguments; ++i, ++index) {
            operands[index] = this.compileExpression(argumentExpressions[i], parameterTypes[i], 1 /* CONV_IMPLICIT */);
        }
        assert(index == numArgumentsInclThis);
        return this.makeCallIndirect(signature, indexArg, operands, immediatelyDropped);
    }
    /** Creates an indirect call to the function at `indexArg` in the function table. */
    makeCallIndirect(signature, indexArg, operands = null, immediatelyDropped = false) {
        var numOperands = operands ? operands.length : 0;
        var numArguments = numOperands;
        var minArguments = signature.requiredParameters;
        var minOperands = minArguments;
        var maxArguments = signature.parameterTypes.length;
        var maxOperands = maxArguments;
        if (signature.thisType) {
            ++minOperands;
            ++maxOperands;
            --numArguments;
        }
        assert(numOperands >= minOperands);
        this.ensureFunctionType(signature.parameterTypes, signature.returnType, signature.thisType);
        var module = this.module;
        // fill up omitted arguments with zeroes
        if (numOperands < maxOperands) {
            if (!operands) {
                operands = new Array(maxOperands);
                operands.length = 0;
            }
            let parameterTypes = signature.parameterTypes;
            for (let i = numArguments; i < maxArguments; ++i) {
                operands.push(parameterTypes[i].toNativeZero(module));
            }
        }
        var returnType = signature.returnType;
        var expr = module.call_indirect(indexArg, operands, signature.toSignatureString());
        this.currentType = returnType;
        if (returnType.isManaged) {
            if (immediatelyDropped) {
                expr = this.makeRelease(expr);
                this.currentType = types_1.Type.void;
            }
            else {
                expr = this.makeAutorelease(expr);
            }
        }
        return module.block(null, [
            module.global_set(this.ensureArgcVar(), // might be calling a trampoline
            module.i32(numArguments)),
            expr
        ], this.currentType.toNativeType()); // not necessarily wrapped
    }
    compileCommaExpression(expression, contextualType, constraints) {
        var expressions = expression.expressions;
        var numExpressions = expressions.length;
        var exprs = new Array(numExpressions--);
        for (let i = 0; i < numExpressions; ++i) {
            exprs[i] = this.compileExpression(expressions[i], types_1.Type.void, // drop all except last
            1 /* CONV_IMPLICIT */ | 8 /* WILL_DROP */);
        }
        exprs[numExpressions] = this.compileExpression(expressions[numExpressions], contextualType, constraints);
        return this.module.block(null, exprs, this.currentType.toNativeType());
    }
    compileElementAccessExpression(expression, contextualType, constraints) {
        var module = this.module;
        var targetExpression = expression.expression;
        var targetType = this.resolver.resolveExpression(targetExpression, this.currentFlow); // reports
        if (targetType) {
            if (targetType.is(256 /* REFERENCE */)) {
                let classReference = targetType.classReference;
                if (classReference) {
                    let indexedGet = classReference.lookupOverload(program_1.OperatorKind.INDEXED_GET, this.currentFlow.is(65536 /* UNCHECKED_CONTEXT */));
                    if (indexedGet) {
                        let thisArg = this.compileExpression(targetExpression, classReference.type, 1 /* CONV_IMPLICIT */);
                        return this.compileCallDirect(indexedGet, [
                            expression.elementExpression
                        ], expression, thisArg, constraints);
                    }
                }
            }
            this.error(diagnostics_1.DiagnosticCode.Index_signature_is_missing_in_type_0, expression.expression.range, targetType.toString());
        }
        return module.unreachable();
    }
    compileFunctionExpression(expression, contextualSignature, constraints) {
        var declaration = expression.declaration.clone(); // generic contexts can have multiple
        assert(!declaration.typeParameters); // function expression cannot be generic
        var flow = this.currentFlow;
        var actualFunction = flow.actualFunction;
        var prototype = new program_1.FunctionPrototype(declaration.name.text.length
            ? declaration.name.text
            : "anonymous|" + (actualFunction.nextAnonymousId++).toString(10), actualFunction, declaration, program_1.DecoratorFlags.NONE);
        var instance;
        var contextualTypeArguments = util_1.makeMap(flow.contextualTypeArguments);
        // compile according to context. this differs from a normal function in that omitted parameter
        // and return types can be inferred and omitted arguments can be replaced with dummies.
        if (contextualSignature) {
            let signatureNode = prototype.functionTypeNode;
            let parameterNodes = signatureNode.parameters;
            let numPresentParameters = parameterNodes.length;
            // must not require more than the maximum number of parameters
            let parameterTypes = contextualSignature.parameterTypes;
            let numParameters = parameterTypes.length;
            if (numPresentParameters > numParameters) {
                this.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, expression.range, numParameters.toString(), numPresentParameters.toString());
                return this.module.unreachable();
            }
            // check non-omitted parameter types
            let parameterNames = new Array(numPresentParameters);
            for (let i = 0; i < numPresentParameters; ++i) {
                let parameterNode = parameterNodes[i];
                parameterNames[i] = parameterNode.name.text; // use actual name
                if (!ast_1.isTypeOmitted(parameterNode.type)) {
                    let resolvedType = this.resolver.resolveType(parameterNode.type, actualFunction.parent, contextualTypeArguments);
                    if (!resolvedType)
                        return this.module.unreachable();
                    if (!parameterTypes[i].isStrictlyAssignableTo(resolvedType)) {
                        this.error(diagnostics_1.DiagnosticCode.Type_0_is_not_assignable_to_type_1, parameterNode.range, parameterTypes[i].toString(), resolvedType.toString());
                        return this.module.unreachable();
                    }
                }
                // any unused parameters are inherited but ignored
            }
            // check non-omitted return type
            let returnType = contextualSignature.returnType;
            if (!ast_1.isTypeOmitted(signatureNode.returnType)) {
                let resolvedType = this.resolver.resolveType(signatureNode.returnType, actualFunction.parent, contextualTypeArguments);
                if (!resolvedType)
                    return this.module.unreachable();
                if (returnType == types_1.Type.void
                    ? resolvedType != types_1.Type.void
                    : !resolvedType.isStrictlyAssignableTo(returnType)) {
                    this.error(diagnostics_1.DiagnosticCode.Type_0_is_not_assignable_to_type_1, signatureNode.returnType.range, resolvedType.toString(), returnType.toString());
                    return this.module.unreachable();
                }
            }
            // check explicit this type
            let thisType = contextualSignature.thisType;
            let thisTypeNode = signatureNode.explicitThisType;
            if (thisTypeNode) {
                if (!thisType) {
                    this.error(diagnostics_1.DiagnosticCode._this_cannot_be_referenced_in_current_location, thisTypeNode.range);
                    return this.module.unreachable();
                }
                let resolvedType = this.resolver.resolveType(thisTypeNode, actualFunction.parent, contextualTypeArguments);
                if (!resolvedType)
                    return this.module.unreachable();
                if (!thisType.isStrictlyAssignableTo(resolvedType)) {
                    this.error(diagnostics_1.DiagnosticCode.Type_0_is_not_assignable_to_type_1, thisTypeNode.range, thisType.toString(), resolvedType.toString());
                    return this.module.unreachable();
                }
            }
            let signature = new types_1.Signature(this.program, parameterTypes, returnType, thisType);
            signature.requiredParameters = numParameters; // !
            signature.parameterNames = parameterNames;
            instance = new program_1.Function(prototype.name, prototype, signature, contextualTypeArguments);
            if (!this.compileFunction(instance))
                return this.module.unreachable();
            this.currentType = contextualSignature.type;
            // otherwise compile like a normal function
        }
        else {
            instance = this.compileFunctionUsingTypeArguments(prototype, [], contextualTypeArguments);
            if (!instance)
                return this.module.unreachable();
            this.currentType = instance.signature.type;
        }
        var index = this.ensureFunctionTableEntry(instance); // reports
        return index < 0
            ? this.module.unreachable()
            : this.module.i32(index);
    }
    /** Makes sure the enclosing source file of the specified expression has been compiled. */
    maybeCompileEnclosingSource(expression) {
        var internalPath = expression.range.source.internalPath;
        var filesByName = this.program.filesByName;
        assert(filesByName.has(internalPath));
        var enclosingFile = filesByName.get(internalPath);
        if (!enclosingFile.is(common_1.CommonFlags.COMPILED)) {
            this.compileFileByPath(internalPath, expression);
        }
    }
    /**
     * Compiles an identifier in the specified context.
     * @param retainConstantType Retains the type of inlined constants if `true`, otherwise
     *  precomputes them according to context.
     */
    compileIdentifierExpression(expression, contextualType, constraints) {
        var module = this.module;
        var flow = this.currentFlow;
        var actualFunction = flow.actualFunction;
        // check special keywords first
        switch (expression.kind) {
            case ast_1.NodeKind.NULL: {
                let options = this.options;
                if (contextualType.is(256 /* REFERENCE */)) {
                    let classReference = contextualType.classReference;
                    if (classReference) {
                        this.currentType = classReference.type.asNullable();
                        return options.isWasm64 ? module.i64(0) : module.i32(0);
                    }
                    let signatureReference = contextualType.signatureReference;
                    if (signatureReference) {
                        this.currentType = signatureReference.type.asNullable();
                        return module.i32(0);
                    }
                    // TODO: anyref context yields <usize>0
                }
                this.currentType = options.usizeType;
                return options.isWasm64
                    ? module.i64(0)
                    : module.i32(0);
            }
            case ast_1.NodeKind.TRUE: {
                this.currentType = types_1.Type.bool;
                return module.i32(1);
            }
            case ast_1.NodeKind.FALSE: {
                this.currentType = types_1.Type.bool;
                return module.i32(0);
            }
            case ast_1.NodeKind.THIS: {
                if (actualFunction.is(common_1.CommonFlags.INSTANCE)) {
                    let thisLocal = assert(flow.lookupLocal(common_1.CommonSymbols.this_));
                    let classInstance = assert(actualFunction.parent);
                    assert(classInstance.kind == program_1.ElementKind.CLASS);
                    let nativeSizeType = this.options.nativeSizeType;
                    if (actualFunction.is(common_1.CommonFlags.CONSTRUCTOR)) {
                        if (!flow.is(64 /* ALLOCATES */)) {
                            flow.set(64 /* ALLOCATES */);
                            // {
                            //   if (!this) this = <ALLOC>
                            //   this.a = X
                            //   this.b = Y
                            //   return this
                            // }
                            let stmts = [
                                module.if(module.unary(nativeSizeType == module_1.NativeType.I64 ? module_1.UnaryOp.EqzI64 : module_1.UnaryOp.EqzI32, module.local_get(thisLocal.index, nativeSizeType)), module.local_set(thisLocal.index, this.makeRetain(this.makeAllocation(classInstance))))
                            ];
                            this.makeFieldInitialization(classInstance, stmts);
                            stmts.push(module.local_get(thisLocal.index, nativeSizeType));
                            this.currentType = thisLocal.type;
                            return module.block(null, stmts, nativeSizeType);
                        }
                    }
                    // if not a constructor, `this` type can differ
                    let thisType = assert(actualFunction.signature.thisType);
                    this.currentType = thisType;
                    return module.local_get(thisLocal.index, thisType.toNativeType());
                }
                this.error(diagnostics_1.DiagnosticCode._this_cannot_be_referenced_in_current_location, expression.range);
                this.currentType = this.options.usizeType;
                return module.unreachable();
            }
            case ast_1.NodeKind.SUPER: {
                let flow = this.currentFlow;
                let actualFunction = flow.actualFunction;
                if (actualFunction.is(common_1.CommonFlags.CONSTRUCTOR)) {
                    if (!flow.is(128 /* CALLS_SUPER */)) {
                        // TS1034 in the parser effectively limits this to property accesses
                        this.error(diagnostics_1.DiagnosticCode._super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class, expression.range);
                    }
                }
                if (flow.is(32768 /* INLINE_CONTEXT */)) {
                    let scopedThis = flow.lookupLocal(common_1.CommonSymbols.this_);
                    if (scopedThis) {
                        let scopedThisClass = assert(scopedThis.type.classReference);
                        let base = scopedThisClass.base;
                        if (base) {
                            this.currentType = base.type;
                            return module.local_get(scopedThis.index, base.type.toNativeType());
                        }
                    }
                }
                if (actualFunction.is(common_1.CommonFlags.INSTANCE)) {
                    let classInstance = assert(actualFunction.parent);
                    assert(classInstance.kind == program_1.ElementKind.CLASS);
                    let baseClassInstance = classInstance.base;
                    if (baseClassInstance) {
                        let superType = baseClassInstance.type;
                        this.currentType = superType;
                        return module.local_get(0, superType.toNativeType());
                    }
                }
                this.error(diagnostics_1.DiagnosticCode._super_can_only_be_referenced_in_a_derived_class, expression.range);
                this.currentType = this.options.usizeType;
                return module.unreachable();
            }
        }
        this.maybeCompileEnclosingSource(expression);
        // otherwise resolve
        var target = this.resolver.lookupIdentifierExpression(// reports
        expression, flow, this.currentParent || actualFunction);
        if (!target)
            return module.unreachable();
        switch (target.kind) {
            case program_1.ElementKind.LOCAL: {
                let type = target.type;
                if (target.parent != flow.parentFunction) {
                    // Closures are not yet supported
                    this.error(diagnostics_1.DiagnosticCode.Not_implemented, expression.range);
                    this.currentType = type;
                    return module.unreachable();
                }
                assert(type != types_1.Type.void);
                if (target.is(common_1.CommonFlags.INLINED)) {
                    return this.compileInlineConstant(target, contextualType, constraints);
                }
                let localIndex = target.index;
                assert(localIndex >= 0);
                if (type.is(512 /* NULLABLE */) && flow.isLocalFlag(localIndex, flow_1.LocalFlags.NONNULL, false)) {
                    type = type.nonNullableType;
                }
                this.currentType = type;
                return this.module.local_get(localIndex, type.toNativeType());
            }
            case program_1.ElementKind.GLOBAL: {
                if (!this.compileGlobal(target)) { // reports; not yet compiled if a static field
                    return this.module.unreachable();
                }
                let type = target.type;
                assert(type != types_1.Type.void);
                if (target.is(common_1.CommonFlags.INLINED)) {
                    return this.compileInlineConstant(target, contextualType, constraints);
                }
                this.currentType = type;
                return this.module.global_get(target.internalName, type.toNativeType());
            }
            case program_1.ElementKind.ENUMVALUE: { // here: if referenced from within the same enum
                if (!target.is(common_1.CommonFlags.COMPILED)) {
                    this.error(diagnostics_1.DiagnosticCode.A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums, expression.range);
                    this.currentType = types_1.Type.i32;
                    return this.module.unreachable();
                }
                this.currentType = types_1.Type.i32;
                if (target.is(common_1.CommonFlags.INLINED)) {
                    assert(target.constantValueKind == 1 /* INTEGER */);
                    return this.module.i32(i64_low(target.constantIntegerValue));
                }
                return this.module.global_get(target.internalName, module_1.NativeType.I32);
            }
            case program_1.ElementKind.FUNCTION_PROTOTYPE: {
                let instance = this.resolver.resolveFunction(target, null, util_1.makeMap(flow.contextualTypeArguments));
                if (!(instance && this.compileFunction(instance)))
                    return module.unreachable();
                let index = this.ensureFunctionTableEntry(instance);
                this.currentType = instance.signature.type;
                return this.module.i32(index);
            }
        }
        this.error(diagnostics_1.DiagnosticCode.Not_implemented, expression.range);
        return this.module.unreachable();
    }
    compileInstanceOfExpression(expression, contextualType, constraints) {
        var module = this.module;
        // NOTE that this differs from TypeScript in that the rhs is a type, not an expression. at the
        // time of implementation, this seemed more useful because dynamic rhs expressions are not
        // possible in AS anyway. also note that the code generated below must preserve side-effects of
        // the LHS expression even when the result is a constant, i.e. return a block dropping `expr`.
        var expr = this.compileExpression(expression.expression, this.options.usizeType);
        var actualType = this.currentType;
        var expectedType = this.resolver.resolveType(expression.isType, this.currentFlow.actualFunction);
        this.currentType = types_1.Type.bool;
        if (!expectedType)
            return module.unreachable();
        // instanceof <basic> - must be exact
        if (!expectedType.is(256 /* REFERENCE */)) {
            return module.block(null, [
                module.drop(expr),
                module.i32(actualType == expectedType ? 1 : 0)
            ], module_1.NativeType.I32);
        }
        // <basic> instanceof <reference> - always false
        if (!actualType.is(256 /* REFERENCE */)) {
            return module.block(null, [
                module.drop(expr),
                module.i32(0)
            ], module_1.NativeType.I32);
        }
        // both LHS and RHS are references now
        var nativeSizeType = actualType.toNativeType();
        // <nullable> instanceof <nonNullable> - LHS must be != 0
        if (actualType.is(512 /* NULLABLE */) && !expectedType.is(512 /* NULLABLE */)) {
            // downcast - check statically
            if (actualType.nonNullableType.isAssignableTo(expectedType)) {
                return module.binary(nativeSizeType == module_1.NativeType.I64
                    ? module_1.BinaryOp.NeI64
                    : module_1.BinaryOp.NeI32, expr, actualType.toNativeZero(module));
            }
            // upcast - check dynamically
            if (expectedType.isAssignableTo(actualType)) {
                let program = this.program;
                if (!(actualType.isUnmanaged || expectedType.isUnmanaged)) {
                    let flow = this.currentFlow;
                    let temp = flow.getTempLocal(actualType);
                    let instanceofInstance = assert(program.instanceofInstance);
                    this.compileFunction(instanceofInstance);
                    let ret = module.if(module.unary(nativeSizeType == module_1.NativeType.I64
                        ? module_1.UnaryOp.EqzI64
                        : module_1.UnaryOp.EqzI32, module.local_tee(temp.index, expr)), module.i32(0), this.makeCallDirect(instanceofInstance, [
                        module.local_get(temp.index, nativeSizeType),
                        module.i32(expectedType.classReference.id)
                    ], expression));
                    flow.freeTempLocal(temp);
                    return ret;
                }
                else {
                    this.error(diagnostics_1.DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2, expression.range, "instanceof", actualType.toString(), expectedType.toString());
                }
            }
            // either none or both nullable
        }
        else {
            // downcast - check statically
            if (actualType.isAssignableTo(expectedType)) {
                return module.block(null, [
                    this.convertExpression(expr, actualType, types_1.Type.void, false, false, expression.expression),
                    module.i32(1)
                ], module_1.NativeType.I32);
                // upcast - check dynamically
            }
            else if (expectedType.isAssignableTo(actualType)) {
                let program = this.program;
                if (!(actualType.isUnmanaged || expectedType.isUnmanaged)) {
                    // FIXME: the temp local and the if can be removed here once flows
                    // perform null checking, which would error earlier when checking
                    // uninitialized (thus zero) `var a: A` to be an instance of something.
                    let flow = this.currentFlow;
                    let temp = flow.getTempLocal(actualType);
                    let instanceofInstance = assert(program.instanceofInstance);
                    this.compileFunction(instanceofInstance);
                    let ret = module.if(module.unary(nativeSizeType == module_1.NativeType.I64
                        ? module_1.UnaryOp.EqzI64
                        : module_1.UnaryOp.EqzI32, module.local_tee(temp.index, expr)), module.i32(0), this.makeCallDirect(instanceofInstance, [
                        module.local_get(temp.index, nativeSizeType),
                        module.i32(expectedType.classReference.id)
                    ], expression));
                    flow.freeTempLocal(temp);
                    return ret;
                }
                else {
                    this.error(diagnostics_1.DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2, expression.range, "instanceof", actualType.toString(), expectedType.toString());
                }
            }
        }
        // false
        return module.block(null, [
            module.drop(expr),
            module.i32(0)
        ], module_1.NativeType.I32);
    }
    compileLiteralExpression(expression, contextualType, constraints, implicitlyNegate = false) {
        var module = this.module;
        switch (expression.literalKind) {
            case ast_1.LiteralKind.ARRAY: {
                assert(!implicitlyNegate);
                let classType = contextualType.classReference;
                if (classType) {
                    if (classType.prototype == this.program.arrayPrototype) {
                        return this.compileArrayLiteral(assert(classType.typeArguments)[0], expression.elementExpressions, constraints, expression);
                    }
                }
                this.error(diagnostics_1.DiagnosticCode.The_type_argument_for_type_parameter_0_cannot_be_inferred_from_the_usage_Consider_specifying_the_type_arguments_explicitly, expression.range, "T");
                return module.unreachable();
            }
            case ast_1.LiteralKind.FLOAT: {
                let floatValue = expression.value;
                if (implicitlyNegate) {
                    floatValue = -floatValue;
                }
                if (contextualType == types_1.Type.f32) {
                    return module.f32(floatValue);
                }
                this.currentType = types_1.Type.f64;
                return module.f64(floatValue);
            }
            case ast_1.LiteralKind.INTEGER: {
                let intValue = expression.value;
                if (implicitlyNegate) {
                    intValue = i64_sub(i64_new(0), intValue);
                }
                let type = this.resolver.determineIntegerLiteralType(intValue, contextualType);
                this.currentType = type;
                switch (type.kind) {
                    case 4 /* ISIZE */: if (!this.options.isWasm64)
                        return module.i32(i64_low(intValue));
                    case 3 /* I64 */: return module.i64(i64_low(intValue), i64_high(intValue));
                    case 9 /* USIZE */: if (!this.options.isWasm64)
                        return module.i32(i64_low(intValue));
                    case 8 /* U64 */: return module.i64(i64_low(intValue), i64_high(intValue));
                    case 11 /* F32 */: return module.f32(i64_to_f32(intValue));
                    case 12 /* F64 */: return module.f64(i64_to_f64(intValue));
                    default: return module.i32(i64_low(intValue));
                }
            }
            case ast_1.LiteralKind.STRING: {
                assert(!implicitlyNegate);
                return this.compileStringLiteral(expression);
            }
            case ast_1.LiteralKind.OBJECT: {
                assert(!implicitlyNegate);
                return this.compileObjectLiteral(expression, contextualType);
            }
            // case LiteralKind.REGEXP:
        }
        this.error(diagnostics_1.DiagnosticCode.Not_implemented, expression.range);
        this.currentType = contextualType;
        return module.unreachable();
    }
    compileStringLiteral(expression) {
        return this.ensureStaticString(expression.value);
    }
    compileArrayLiteral(elementType, expressions, constraints, reportNode) {
        var module = this.module;
        var program = this.program;
        var arrayPrototype = assert(program.arrayPrototype);
        var arrayInstance = assert(this.resolver.resolveClass(arrayPrototype, [elementType]));
        var arrayBufferInstance = assert(program.arrayBufferInstance);
        var arrayType = arrayInstance.type;
        var flow = this.currentFlow;
        // block those here so compiling expressions doesn't conflict
        var tempThis = flow.getTempLocal(arrayType);
        var tempDataStart = flow.getTempLocal(arrayBufferInstance.type);
        // compile value expressions and find out whether all are constant
        var length = expressions.length;
        var values = new Array(length);
        var isStatic = true;
        var nativeElementType = elementType.toNativeType();
        for (let i = 0; i < length; ++i) {
            let expression = expressions[i];
            let expr = expression
                ? module.precomputeExpression(this.compileExpression(expression, elementType, 1 /* CONV_IMPLICIT */))
                : elementType.toNativeZero(module);
            if (module_1.getExpressionId(expr) == module_1.ExpressionId.Const) {
                assert(module_1.getExpressionType(expr) == nativeElementType);
            }
            else {
                isStatic = false;
            }
            values[i] = expr;
        }
        // if the array is static, make a static arraybuffer segment
        if (isStatic) {
            flow.freeTempLocal(tempThis);
            flow.freeTempLocal(tempDataStart);
            let runtimeHeaderSize = program.runtimeHeaderSize;
            let bufferSegment = this.ensureStaticArrayBuffer(elementType, values);
            let bufferAddress = i64_add(bufferSegment.offset, i64_new(runtimeHeaderSize));
            // make both the buffer and array header static if assigned to a global. this can't be done
            // if inside of a function because each invocation must create a new array reference then.
            if (constraints & 32 /* PREFER_STATIC */) {
                let arraySegment = this.ensureStaticArrayHeader(elementType, bufferSegment);
                let arrayAddress = i64_add(arraySegment.offset, i64_new(runtimeHeaderSize));
                this.currentType = arrayType;
                return program.options.isWasm64
                    ? this.module.i64(i64_low(arrayAddress), i64_high(arrayAddress))
                    : this.module.i32(i64_low(arrayAddress));
                // otherwise allocate a new array header and make it wrap a copy of the static buffer
            }
            else {
                // makeArray(length, alignLog2, classId, staticBuffer)
                let expr = this.makeCallDirect(program.allocArrayInstance, [
                    module.i32(length),
                    program.options.isWasm64
                        ? module.i64(elementType.alignLog2)
                        : module.i32(elementType.alignLog2),
                    module.i32(arrayInstance.id),
                    program.options.isWasm64
                        ? module.i64(i64_low(bufferAddress), i64_high(bufferAddress))
                        : module.i32(i64_low(bufferAddress))
                ], reportNode);
                this.currentType = arrayType;
                return this.makeAutorelease(this.makeRetain(expr));
            }
        }
        // otherwise compile an explicit instantiation with indexed sets
        var setter = arrayInstance.lookupOverload(program_1.OperatorKind.INDEXED_SET, true);
        if (!setter) {
            flow.freeTempLocal(tempThis);
            flow.freeTempLocal(tempDataStart);
            this.error(diagnostics_1.DiagnosticCode.Index_signature_in_type_0_only_permits_reading, reportNode.range, arrayInstance.internalName);
            this.currentType = arrayType;
            return module.unreachable();
        }
        var nativeArrayType = arrayType.toNativeType();
        var stmts = new Array();
        // tempThis = makeArray(length, alignLog2, classId, source = 0)
        stmts.push(module.local_set(tempThis.index, this.makeCallDirect(program.allocArrayInstance, [
            module.i32(length),
            program.options.isWasm64
                ? module.i64(elementType.alignLog2)
                : module.i32(elementType.alignLog2),
            module.i32(arrayInstance.id),
            program.options.isWasm64
                ? module.i64(0)
                : module.i32(0)
        ], reportNode)));
        // tempData = tempThis.dataStart
        var dataStart = assert(arrayInstance.lookupInSelf("dataStart"));
        assert(dataStart.kind == program_1.ElementKind.FIELD);
        stmts.push(module.local_set(tempDataStart.index, module.load(arrayType.byteSize, false, module.local_get(tempThis.index, nativeArrayType), nativeArrayType, dataStart.memoryOffset)));
        var isManaged = elementType.isManaged;
        for (let i = 0, alignLog2 = elementType.alignLog2; i < length; ++i) {
            let valueExpr = values[i];
            if (isManaged) {
                // value = __retain(value)
                valueExpr = this.makeRetain(valueExpr);
            }
            // store<T>(tempData, value, immOffset)
            stmts.push(module.store(elementType.byteSize, module.local_get(tempDataStart.index, nativeArrayType), valueExpr, nativeElementType, i << alignLog2));
        }
        // -> tempThis
        stmts.push(module.local_get(tempThis.index, nativeArrayType));
        flow.freeTempLocal(tempThis);
        flow.freeTempLocal(tempDataStart);
        this.currentType = arrayType;
        return module.block(null, stmts, nativeArrayType);
    }
    compileObjectLiteral(expression, contextualType) {
        var module = this.module;
        // contextual type must be a class
        var classReference = contextualType.classReference;
        if (!classReference || classReference.is(common_1.CommonFlags.ABSTRACT)) {
            this.error(diagnostics_1.DiagnosticCode.Type_0_is_not_assignable_to_type_1, expression.range, "<object>", contextualType.toString());
            return module.unreachable();
        }
        // if present, check that the constructor is compatible with object literals
        var ctor = classReference.constructorInstance;
        if (ctor) {
            // TODO: if the constructor requires parameters, check whether these are given as part of the
            // object literal and use them to call the ctor while not generating a store.
            if (ctor.signature.requiredParameters) {
                this.error(diagnostics_1.DiagnosticCode.Constructor_of_class_0_must_not_require_any_arguments, expression.range, classReference.toString());
                return module.unreachable();
            }
            if (ctor.is(common_1.CommonFlags.PRIVATE)) {
                this.error(diagnostics_1.DiagnosticCode.Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration, expression.range, classReference.toString());
                return module.unreachable();
            }
            if (ctor.is(common_1.CommonFlags.PROTECTED)) {
                this.error(diagnostics_1.DiagnosticCode.Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration, expression.range, classReference.toString());
                return module.unreachable();
            }
            if (ctor.hasDecorator(program_1.DecoratorFlags.UNSAFE))
                this.checkUnsafe(expression);
        }
        // check and compile field values
        var names = expression.names;
        var numNames = names.length;
        var values = expression.values;
        var members = classReference.members;
        var hasErrors = false;
        var exprs = new Array(numNames + 2);
        var flow = this.currentFlow;
        var tempLocal = flow.getAutoreleaseLocal(this.options.usizeType);
        assert(numNames == values.length);
        for (let i = 0, k = numNames; i < k; ++i) {
            let member = members ? members.get(names[i].text) : null;
            if (!member || member.kind != program_1.ElementKind.FIELD) {
                this.error(diagnostics_1.DiagnosticCode.Property_0_does_not_exist_on_type_1, names[i].range, names[i].text, classReference.toString());
                hasErrors = true;
                continue;
            }
            let type = member.type;
            exprs[i + 1] = this.module.store(// TODO: handle setters as well
            type.byteSize, this.module.local_get(tempLocal.index, this.options.nativeSizeType), this.compileExpression(values[i], member.type, 1 /* CONV_IMPLICIT */), type.toNativeType(), member.memoryOffset);
        }
        this.currentType = classReference.type.nonNullableType;
        if (hasErrors)
            return module.unreachable();
        // allocate a new instance first and assign 'this' to the temp. local
        exprs[0] = module.local_set(tempLocal.index, this.makeRetain(this.makeAllocation(classReference)));
        // once all field values have been set, return 'this'
        exprs[exprs.length - 1] = module.local_get(tempLocal.index, this.options.nativeSizeType);
        this.currentType = classReference.type;
        return module.block(null, exprs, this.options.nativeSizeType);
    }
    compileNewExpression(expression, contextualType, constraints) {
        var module = this.module;
        var flow = this.currentFlow;
        // obtain the class being instantiated
        var target = this.resolver.lookupExpression(// reports
        expression.expression, flow);
        if (!target)
            return module.unreachable();
        if (target.kind != program_1.ElementKind.CLASS_PROTOTYPE) {
            this.error(diagnostics_1.DiagnosticCode.This_expression_is_not_constructable, expression.expression.range);
            return this.module.unreachable();
        }
        var classPrototype = target;
        var classInstance = null;
        var typeArguments = expression.typeArguments;
        var classReference;
        if (!typeArguments &&
            (classReference = contextualType.classReference) !== null &&
            classReference.is(common_1.CommonFlags.GENERIC)) {
            classInstance = this.resolver.resolveClass(classPrototype, classReference.typeArguments, util_1.makeMap(flow.contextualTypeArguments));
        }
        else {
            classInstance = this.resolver.resolveClassInclTypeArguments(classPrototype, typeArguments, flow.actualFunction.parent, // relative to caller
            util_1.makeMap(flow.contextualTypeArguments), expression);
        }
        if (!classInstance)
            return module.unreachable();
        if (contextualType == types_1.Type.void)
            constraints |= 8 /* WILL_DROP */;
        return this.compileInstantiate(classInstance, expression.arguments, constraints, expression);
    }
    /** Gets the compiled constructor of the specified class or generates one if none is present. */
    ensureConstructor(classInstance, reportNode) {
        var instance = classInstance.constructorInstance;
        if (instance) {
            // do not attempt to compile it if inlined anyway
            if (!instance.hasDecorator(program_1.DecoratorFlags.INLINE))
                this.compileFunction(instance);
            return instance;
        }
        // clone base constructor if a derived class
        var baseClass = classInstance.base;
        if (baseClass) {
            let baseCtor = this.ensureConstructor(baseClass, reportNode);
            instance = new program_1.Function(common_1.CommonSymbols.constructor, new program_1.FunctionPrototype(common_1.CommonSymbols.constructor, classInstance, 
            // declaration is important, i.e. to access optional parameter initializers
            baseCtor.declaration.clone()), baseCtor.signature, null);
            // otherwise make a default constructor
        }
        else {
            instance = new program_1.Function(common_1.CommonSymbols.constructor, new program_1.FunctionPrototype(common_1.CommonSymbols.constructor, classInstance, this.program.makeNativeFunctionDeclaration(common_1.CommonSymbols.constructor, common_1.CommonFlags.INSTANCE | common_1.CommonFlags.CONSTRUCTOR)), new types_1.Signature(this.program, null, classInstance.type, classInstance.type), null);
        }
        instance.internalName = classInstance.internalName + common_1.INSTANCE_DELIMITER + "constructor";
        instance.set(common_1.CommonFlags.COMPILED);
        instance.prototype.setResolvedInstance("", instance);
        classInstance.constructorInstance = instance;
        var previousFlow = this.currentFlow;
        var flow = instance.flow;
        this.currentFlow = flow;
        // generate body
        var signature = instance.signature;
        var module = this.module;
        var nativeSizeType = this.options.nativeSizeType;
        var stmts = new Array();
        // {
        //   if (!this) this = <ALLOC>
        //   IF_DERIVED: this = super(this, ...args)
        //   this.a = X
        //   this.b = Y
        //   return this
        // }
        var allocExpr = this.makeAllocation(classInstance);
        if (classInstance.type.isManaged)
            allocExpr = this.makeRetain(allocExpr);
        stmts.push(module.if(module.unary(nativeSizeType == module_1.NativeType.I64 ? module_1.UnaryOp.EqzI64 : module_1.UnaryOp.EqzI32, module.local_get(0, nativeSizeType)), module.local_set(0, allocExpr)));
        if (baseClass) {
            let parameterTypes = signature.parameterTypes;
            let numParameters = parameterTypes.length;
            let operands = new Array(1 + numParameters);
            operands[0] = module.local_get(0, nativeSizeType);
            for (let i = 0; i < numParameters; ++i) {
                operands[i + 1] = module.local_get(i + 1, parameterTypes[i].toNativeType());
            }
            // TODO: base constructor might be inlined, but makeCallDirect can't do this
            stmts.push(module.local_set(0, this.makeCallDirect(assert(baseClass.constructorInstance), operands, reportNode, false, true)));
        }
        this.makeFieldInitialization(classInstance, stmts);
        var body = this.performAutoreleasesWithValue(flow, module.local_get(0, nativeSizeType), classInstance.type, stmts);
        flow.freeScopedLocals();
        this.currentFlow = previousFlow;
        // make the function
        var typeRef = this.ensureFunctionType(signature.parameterTypes, signature.returnType, signature.thisType);
        var locals = instance.localsByIndex;
        var varTypes = new Array(); // of temp. vars added while compiling initializers
        var numOperands = 1 + signature.parameterTypes.length;
        var numLocals = locals.length;
        if (numLocals > numOperands) {
            for (let i = numOperands; i < numLocals; ++i)
                varTypes.push(locals[i].type.toNativeType());
        }
        var funcRef = module.addFunction(instance.internalName, typeRef, varTypes, body);
        instance.finalize(module, funcRef);
        return instance;
    }
    compileInstantiate(
    /** Class to instantiate. */
    classInstance, 
    /** Constructor arguments. */
    argumentExpressions, 
    /** Contextual flags. */
    constraints, 
    /** Node to report on. */
    reportNode) {
        var ctor = this.ensureConstructor(classInstance, reportNode);
        if (ctor.hasDecorator(program_1.DecoratorFlags.UNSAFE))
            this.checkUnsafe(reportNode);
        var expr = this.compileCallDirect(// no need for another autoreleased local
        ctor, argumentExpressions, reportNode, this.options.usizeType.toNativeZero(this.module), constraints);
        if (module_1.getExpressionType(expr) != module_1.NativeType.None) { // possibly IMM_DROPPED
            this.currentType = classInstance.type; // important because a super ctor could be called
        }
        return expr;
    }
    /**
     * Compiles a property access in the specified context.
     * @param retainConstantType Retains the type of inlined constants if `true`, otherwise
     *  precomputes them according to context.
     */
    compilePropertyAccessExpression(expression, ctxType, constraints) {
        var module = this.module;
        var flow = this.currentFlow;
        this.maybeCompileEnclosingSource(expression);
        var resolver = this.resolver;
        var target = resolver.lookupExpression(expression, flow, ctxType); // reports
        if (!target)
            return module.unreachable();
        if (target.hasDecorator(program_1.DecoratorFlags.UNSAFE))
            this.checkUnsafe(expression);
        switch (target.kind) {
            case program_1.ElementKind.GLOBAL: { // static field
                if (!this.compileGlobal(target))
                    return module.unreachable(); // reports
                let globalType = target.type;
                assert(globalType != types_1.Type.void);
                if (target.is(common_1.CommonFlags.INLINED)) {
                    return this.compileInlineConstant(target, ctxType, constraints);
                }
                this.currentType = globalType;
                return module.global_get(target.internalName, globalType.toNativeType());
            }
            case program_1.ElementKind.ENUMVALUE: { // enum value
                let theEnum = assert(target.parent);
                assert(theEnum.kind == program_1.ElementKind.ENUM);
                if (!this.compileEnum(theEnum)) {
                    this.currentType = types_1.Type.i32;
                    return this.module.unreachable();
                }
                this.currentType = types_1.Type.i32;
                if (target.is(common_1.CommonFlags.INLINED)) {
                    assert(target.constantValueKind == 1 /* INTEGER */);
                    return this.compileInlineConstant(target, ctxType, constraints);
                }
                assert(target.type == types_1.Type.i32);
                return module.global_get(target.internalName, module_1.NativeType.I32);
            }
            case program_1.ElementKind.FIELD: { // instance field
                assert(target.memoryOffset >= 0);
                let thisExpr = this.compileExpression(assert(this.resolver.currentThisExpression), this.options.usizeType);
                this.currentType = target.type;
                return module.load(target.type.byteSize, target.type.is(1 /* SIGNED */ | 4 /* INTEGER */), thisExpr, target.type.toNativeType(), target.memoryOffset);
            }
            case program_1.ElementKind.PROPERTY_PROTOTYPE: { // static property
                let getterPrototype = target.getterPrototype;
                if (getterPrototype) {
                    let getter = this.resolver.resolveFunction(getterPrototype, null);
                    if (getter)
                        return this.compileCallDirect(getter, [], expression, 0);
                }
                return module.unreachable();
            }
            case program_1.ElementKind.PROPERTY: { // instance property
                let getterInstance = assert(target.getterInstance);
                return this.compileCallDirect(getterInstance, [], expression, this.compileExpression(assert(this.resolver.currentThisExpression), this.options.usizeType));
            }
            case program_1.ElementKind.FUNCTION_PROTOTYPE: {
                let prototype = target;
                if (prototype.is(common_1.CommonFlags.STATIC)) {
                    let instance = this.compileFunctionUsingTypeArguments(prototype, [], util_1.makeMap(), expression);
                    if (instance == null) {
                        return module.unreachable();
                    }
                    else {
                        this.currentType = instance.type;
                        return module.i32(this.ensureFunctionTableEntry(instance));
                    }
                }
                this.error(diagnostics_1.DiagnosticCode.Cannot_access_method_0_without_calling_it_as_it_requires_this_to_be_set, expression.range, prototype.name);
                return module.unreachable();
            }
        }
        this.error(diagnostics_1.DiagnosticCode.Not_implemented, expression.range);
        return module.unreachable();
    }
    compileTernaryExpression(expression, ctxType, constraints) {
        var ifThen = expression.ifThen;
        var ifElse = expression.ifElse;
        var outerFlow = this.currentFlow;
        var condExpr = this.module.precomputeExpression(this.makeIsTrueish(this.compileExpression(expression.condition, types_1.Type.bool), this.currentType));
        // Try to eliminate unnecesssary branches if the condition is constant
        // FIXME: skips common denominator, inconsistently picking left type
        if (module_1.getExpressionId(condExpr) == module_1.ExpressionId.Const &&
            module_1.getExpressionType(condExpr) == module_1.NativeType.I32) {
            return module_1.getConstValueI32(condExpr)
                ? this.compileExpression(ifThen, ctxType)
                : this.compileExpression(ifElse, ctxType);
        }
        var inheritedConstraints = constraints & 16 /* WILL_RETAIN */;
        var ifThenFlow = outerFlow.fork();
        this.currentFlow = ifThenFlow;
        var ifThenExpr = this.compileExpression(ifThen, ctxType, inheritedConstraints);
        var ifThenType = this.currentType;
        var IfThenAutoreleaseSkipped = this.skippedAutoreleases.has(ifThenExpr);
        var ifElseFlow = outerFlow.fork();
        this.currentFlow = ifElseFlow;
        var ifElseExpr = this.compileExpression(ifElse, ctxType, inheritedConstraints);
        var ifElseType = this.currentType;
        var ifElseAutoreleaseSkipped = this.skippedAutoreleases.has(ifElseExpr);
        var commonType = types_1.Type.commonDenominator(ifThenType, ifElseType, false);
        if (!commonType) {
            this.error(diagnostics_1.DiagnosticCode.Type_0_is_not_assignable_to_type_1, ifElse.range, ifElseType.toString(), ifThenType.toString());
            this.currentType = ctxType;
            return this.module.unreachable();
        }
        ifThenExpr = this.convertExpression(ifThenExpr, ifThenType, commonType, false, false, ifThen);
        ifElseExpr = this.convertExpression(ifElseExpr, ifElseType, commonType, false, false, ifElse);
        this.currentType = commonType;
        if (IfThenAutoreleaseSkipped != ifElseAutoreleaseSkipped) { // unify to both skipped
            if (!IfThenAutoreleaseSkipped) {
                ifThenExpr = this.makeRetain(ifThenExpr);
                IfThenAutoreleaseSkipped = true;
            }
            else {
                ifElseExpr = this.makeRetain(ifElseExpr);
                ifElseAutoreleaseSkipped = true;
            }
        }
        else if (!IfThenAutoreleaseSkipped && commonType.isManaged) { // keep alive a little longer
            // if (!(constraints & Constraints.WILL_RETAIN)) {
            ifThenExpr = this.moveAutorelease(ifThenExpr, ifThenFlow, outerFlow);
            ifElseExpr = this.moveAutorelease(ifElseExpr, ifElseFlow, outerFlow);
            // }
        }
        ifThenExpr = this.performAutoreleasesWithValue(ifThenFlow, ifThenExpr, commonType);
        ifThenFlow.freeScopedLocals();
        ifElseExpr = this.performAutoreleasesWithValue(ifElseFlow, ifElseExpr, commonType);
        ifElseFlow.freeScopedLocals();
        this.currentFlow = outerFlow;
        outerFlow.inheritMutual(ifThenFlow, ifElseFlow);
        var expr = this.module.if(condExpr, ifThenExpr, ifElseExpr);
        assert(IfThenAutoreleaseSkipped == ifElseAutoreleaseSkipped);
        if (IfThenAutoreleaseSkipped)
            this.skippedAutoreleases.add(expr);
        return expr;
    }
    compileUnaryPostfixExpression(expression, contextualType, constraints) {
        var module = this.module;
        var flow = this.currentFlow;
        // make a getter for the expression (also obtains the type)
        var getValue = this.compileExpression(// reports
        expression.operand, contextualType.exceptVoid, 0 /* NONE */);
        // shortcut if compiling the getter already failed
        if (module_1.getExpressionId(getValue) == module_1.ExpressionId.Unreachable)
            return getValue;
        // if the value isn't dropped, a temp. local is required to remember the original value,
        // except if a static overload is found, which reverses the use of a temp. (see below)
        var tempLocal = null;
        if (contextualType != types_1.Type.void) {
            tempLocal = flow.getTempLocal(this.currentType);
            getValue = module.local_tee(tempLocal.index, getValue);
        }
        var expr;
        switch (expression.operator) {
            case tokenizer_1.Token.PLUS_PLUS: {
                // check operator overload
                if (this.currentType.is(256 /* REFERENCE */)) {
                    let classReference = this.currentType.classReference;
                    if (classReference) {
                        let overload = classReference.lookupOverload(program_1.OperatorKind.POSTFIX_INC);
                        if (overload) {
                            let isInstance = overload.is(common_1.CommonFlags.INSTANCE);
                            if (tempLocal !== null && !isInstance) { // revert: static overload simply returns
                                getValue = module_1.getLocalSetValue(getValue);
                                flow.freeTempLocal(tempLocal);
                                tempLocal = null;
                            }
                            expr = this.compileUnaryOverload(overload, expression.operand, getValue, expression);
                            if (isInstance)
                                break;
                            return expr; // here
                        }
                    }
                    this.error(diagnostics_1.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1, expression.range, "++", this.currentType.toString());
                    if (tempLocal)
                        flow.freeTempLocal(tempLocal);
                    return module.unreachable();
                }
                switch (this.currentType.kind) {
                    case 0 /* I8 */:
                    case 1 /* I16 */:
                    case 2 /* I32 */:
                    case 5 /* U8 */:
                    case 6 /* U16 */:
                    case 7 /* U32 */:
                    case 10 /* BOOL */: {
                        expr = module.binary(module_1.BinaryOp.AddI32, getValue, module.i32(1));
                        break;
                    }
                    case 9 /* USIZE */:
                    case 4 /* ISIZE */: {
                        let options = this.options;
                        expr = module.binary(options.isWasm64
                            ? module_1.BinaryOp.AddI64
                            : module_1.BinaryOp.AddI32, getValue, this.currentType.toNativeOne(module));
                        break;
                    }
                    case 3 /* I64 */:
                    case 8 /* U64 */: {
                        expr = module.binary(module_1.BinaryOp.AddI64, getValue, module.i64(1));
                        break;
                    }
                    case 11 /* F32 */: {
                        expr = module.binary(module_1.BinaryOp.AddF32, getValue, module.f32(1));
                        break;
                    }
                    case 12 /* F64 */: {
                        expr = module.binary(module_1.BinaryOp.AddF64, getValue, module.f64(1));
                        break;
                    }
                    default: {
                        this.error(diagnostics_1.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1, expression.range, "++", this.currentType.toString());
                        return module.unreachable();
                    }
                }
                break;
            }
            case tokenizer_1.Token.MINUS_MINUS: {
                // check operator overload
                if (this.currentType.is(256 /* REFERENCE */)) {
                    let classReference = this.currentType.classReference;
                    if (classReference) {
                        let overload = classReference.lookupOverload(program_1.OperatorKind.POSTFIX_DEC);
                        if (overload) {
                            let isInstance = overload.is(common_1.CommonFlags.INSTANCE);
                            if (tempLocal !== null && !isInstance) { // revert: static overload simply returns
                                getValue = module_1.getLocalSetValue(getValue);
                                flow.freeTempLocal(tempLocal);
                                tempLocal = null;
                            }
                            expr = this.compileUnaryOverload(overload, expression.operand, getValue, expression);
                            if (overload.is(common_1.CommonFlags.INSTANCE))
                                break;
                            return expr; // here
                        }
                    }
                    this.error(diagnostics_1.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1, expression.range, "--", this.currentType.toString());
                    if (tempLocal)
                        flow.freeTempLocal(tempLocal);
                    return module.unreachable();
                }
                switch (this.currentType.kind) {
                    case 0 /* I8 */:
                    case 1 /* I16 */:
                    case 2 /* I32 */:
                    case 5 /* U8 */:
                    case 6 /* U16 */:
                    case 7 /* U32 */:
                    case 10 /* BOOL */: {
                        expr = module.binary(module_1.BinaryOp.SubI32, getValue, module.i32(1));
                        break;
                    }
                    case 9 /* USIZE */:
                    case 4 /* ISIZE */: {
                        let options = this.options;
                        expr = module.binary(options.isWasm64
                            ? module_1.BinaryOp.SubI64
                            : module_1.BinaryOp.SubI32, getValue, this.currentType.toNativeOne(module));
                        break;
                    }
                    case 3 /* I64 */:
                    case 8 /* U64 */: {
                        expr = module.binary(module_1.BinaryOp.SubI64, getValue, module.i64(1));
                        break;
                    }
                    case 11 /* F32 */: {
                        expr = module.binary(module_1.BinaryOp.SubF32, getValue, module.f32(1));
                        break;
                    }
                    case 12 /* F64 */: {
                        expr = module.binary(module_1.BinaryOp.SubF64, getValue, module.f64(1));
                        break;
                    }
                    default: {
                        this.error(diagnostics_1.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1, expression.range, "--", this.currentType.toString());
                        return module.unreachable();
                    }
                }
                break;
            }
            default: {
                assert(false);
                return module.unreachable();
            }
        }
        var resolver = this.resolver;
        var target = resolver.lookupExpression(expression.operand, flow); // reports
        if (!target) {
            if (tempLocal)
                flow.freeTempLocal(tempLocal);
            return module.unreachable();
        }
        // simplify if dropped anyway
        if (!tempLocal) {
            return this.makeAssignment(target, expr, expression.operand, resolver.currentThisExpression, resolver.currentElementExpression, false);
        }
        // otherwise use the temp. local for the intermediate value (always possibly overflows)
        var setValue = this.makeAssignment(target, expr, // includes a tee of getValue to tempLocal
        expression.operand, resolver.currentThisExpression, resolver.currentElementExpression, false);
        this.currentType = tempLocal.type;
        flow.freeTempLocal(tempLocal);
        var nativeType = tempLocal.type.toNativeType();
        return module.block(null, [
            setValue,
            module.local_get(tempLocal.index, nativeType)
        ], nativeType); // result of 'x++' / 'x--' might overflow
    }
    compileUnaryPrefixExpression(expression, contextualType, constraints) {
        var module = this.module;
        var compound = false;
        var expr;
        switch (expression.operator) {
            case tokenizer_1.Token.PLUS: {
                expr = this.compileExpression(expression.operand, contextualType.exceptVoid, 0 /* NONE */);
                // check operator overload
                if (this.currentType.is(256 /* REFERENCE */)) {
                    let classReference = this.currentType.classReference;
                    if (classReference) {
                        let overload = classReference.lookupOverload(program_1.OperatorKind.PLUS);
                        if (overload)
                            return this.compileUnaryOverload(overload, expression.operand, expr, expression);
                    }
                    this.error(diagnostics_1.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1, expression.range, "+", this.currentType.toString());
                    return module.unreachable();
                }
                // nop
                break;
            }
            case tokenizer_1.Token.MINUS: {
                if (expression.operand.kind == ast_1.NodeKind.LITERAL && (expression.operand.literalKind == ast_1.LiteralKind.INTEGER ||
                    expression.operand.literalKind == ast_1.LiteralKind.FLOAT)) {
                    // implicitly negate integer and float literals. also enables proper checking of literal ranges.
                    expr = this.compileLiteralExpression(expression.operand, contextualType, 0 /* NONE */, true);
                    // compileExpression normally does this:
                    if (this.options.sourceMap)
                        this.addDebugLocation(expr, expression.range);
                    break;
                }
                expr = this.compileExpression(expression.operand, contextualType.exceptVoid, 0 /* NONE */);
                // check operator overload
                if (this.currentType.is(256 /* REFERENCE */)) {
                    let classReference = this.currentType.classReference;
                    if (classReference) {
                        let overload = classReference.lookupOverload(program_1.OperatorKind.MINUS);
                        if (overload)
                            return this.compileUnaryOverload(overload, expression.operand, expr, expression);
                    }
                    this.error(diagnostics_1.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1, expression.range, "-", this.currentType.toString());
                    return module.unreachable();
                }
                switch (this.currentType.kind) {
                    case 0 /* I8 */:
                    case 1 /* I16 */:
                    case 2 /* I32 */:
                    case 5 /* U8 */:
                    case 6 /* U16 */:
                    case 7 /* U32 */:
                    case 10 /* BOOL */: {
                        expr = module.binary(module_1.BinaryOp.SubI32, module.i32(0), expr);
                        break;
                    }
                    case 9 /* USIZE */:
                    case 4 /* ISIZE */: {
                        expr = module.binary(this.options.isWasm64
                            ? module_1.BinaryOp.SubI64
                            : module_1.BinaryOp.SubI32, this.currentType.toNativeZero(module), expr);
                        break;
                    }
                    case 3 /* I64 */:
                    case 8 /* U64 */: {
                        expr = module.binary(module_1.BinaryOp.SubI64, module.i64(0), expr);
                        break;
                    }
                    case 11 /* F32 */: {
                        expr = module.unary(module_1.UnaryOp.NegF32, expr);
                        break;
                    }
                    case 12 /* F64 */: {
                        expr = module.unary(module_1.UnaryOp.NegF64, expr);
                        break;
                    }
                    default: {
                        this.error(diagnostics_1.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1, expression.range, "-", this.currentType.toString());
                        expr = module.unreachable();
                    }
                }
                break;
            }
            case tokenizer_1.Token.PLUS_PLUS: {
                compound = true;
                expr = this.compileExpression(expression.operand, contextualType.exceptVoid, 0 /* NONE */);
                // check operator overload
                if (this.currentType.is(256 /* REFERENCE */)) {
                    let classReference = this.currentType.classReference;
                    if (classReference) {
                        let overload = classReference.lookupOverload(program_1.OperatorKind.PREFIX_INC);
                        if (overload) {
                            expr = this.compileUnaryOverload(overload, expression.operand, expr, expression);
                            if (overload.is(common_1.CommonFlags.INSTANCE))
                                break; // re-assign
                            return expr; // skip re-assign
                        }
                    }
                    this.error(diagnostics_1.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1, expression.range, "++", this.currentType.toString());
                    return module.unreachable();
                }
                switch (this.currentType.kind) {
                    case 0 /* I8 */:
                    case 1 /* I16 */:
                    case 2 /* I32 */:
                    case 5 /* U8 */:
                    case 6 /* U16 */:
                    case 7 /* U32 */:
                    case 10 /* BOOL */: {
                        expr = module.binary(module_1.BinaryOp.AddI32, expr, this.module.i32(1));
                        break;
                    }
                    case 9 /* USIZE */:
                    case 4 /* ISIZE */: {
                        expr = module.binary(this.options.isWasm64
                            ? module_1.BinaryOp.AddI64
                            : module_1.BinaryOp.AddI32, expr, this.currentType.toNativeOne(module));
                        break;
                    }
                    case 3 /* I64 */:
                    case 8 /* U64 */: {
                        expr = module.binary(module_1.BinaryOp.AddI64, expr, module.i64(1));
                        break;
                    }
                    case 11 /* F32 */: {
                        expr = module.binary(module_1.BinaryOp.AddF32, expr, module.f32(1));
                        break;
                    }
                    case 12 /* F64 */: {
                        expr = module.binary(module_1.BinaryOp.AddF64, expr, module.f64(1));
                        break;
                    }
                    default: {
                        this.error(diagnostics_1.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1, expression.range, "++", this.currentType.toString());
                        expr = module.unreachable();
                    }
                }
                break;
            }
            case tokenizer_1.Token.MINUS_MINUS: {
                compound = true;
                expr = this.compileExpression(expression.operand, contextualType.exceptVoid, 0 /* NONE */);
                // check operator overload
                if (this.currentType.is(256 /* REFERENCE */)) {
                    let classReference = this.currentType.classReference;
                    if (classReference) {
                        let overload = classReference.lookupOverload(program_1.OperatorKind.PREFIX_DEC);
                        if (overload) {
                            expr = this.compileUnaryOverload(overload, expression.operand, expr, expression);
                            if (overload.is(common_1.CommonFlags.INSTANCE))
                                break; // re-assign
                            return expr; // skip re-assign
                        }
                    }
                    this.error(diagnostics_1.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1, expression.range, "--", this.currentType.toString());
                    return module.unreachable();
                }
                switch (this.currentType.kind) {
                    case 0 /* I8 */:
                    case 1 /* I16 */:
                    case 2 /* I32 */:
                    case 5 /* U8 */:
                    case 6 /* U16 */:
                    case 7 /* U32 */:
                    case 10 /* BOOL */: {
                        expr = module.binary(module_1.BinaryOp.SubI32, expr, module.i32(1));
                        break;
                    }
                    case 9 /* USIZE */:
                    case 4 /* ISIZE */: {
                        expr = module.binary(this.options.isWasm64
                            ? module_1.BinaryOp.SubI64
                            : module_1.BinaryOp.SubI32, expr, this.currentType.toNativeOne(module));
                        break;
                    }
                    case 3 /* I64 */:
                    case 8 /* U64 */: {
                        expr = module.binary(module_1.BinaryOp.SubI64, expr, module.i64(1));
                        break;
                    }
                    case 11 /* F32 */: {
                        expr = module.binary(module_1.BinaryOp.SubF32, expr, module.f32(1));
                        break;
                    }
                    case 12 /* F64 */: {
                        expr = module.binary(module_1.BinaryOp.SubF64, expr, module.f64(1));
                        break;
                    }
                    default: {
                        this.error(diagnostics_1.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1, expression.range, "--", this.currentType.toString());
                        expr = module.unreachable();
                    }
                }
                break;
            }
            case tokenizer_1.Token.EXCLAMATION: {
                expr = this.compileExpression(expression.operand, contextualType.exceptVoid, 0 /* NONE */);
                // check operator overload
                if (this.currentType.is(256 /* REFERENCE */)) {
                    let classReference = this.currentType.classReference;
                    if (classReference) {
                        let overload = classReference.lookupOverload(program_1.OperatorKind.NOT);
                        if (overload)
                            return this.compileUnaryOverload(overload, expression.operand, expr, expression);
                    }
                    // allow '!' for references even without an overload
                }
                expr = module.unary(module_1.UnaryOp.EqzI32, this.makeIsTrueish(expr, this.currentType));
                this.currentType = types_1.Type.bool;
                break;
            }
            case tokenizer_1.Token.TILDE: {
                expr = this.compileExpression(expression.operand, contextualType == types_1.Type.void
                    ? types_1.Type.i32
                    : contextualType.is(8 /* FLOAT */)
                        ? types_1.Type.i64
                        : contextualType, 0 /* NONE */);
                // check operator overload
                if (this.currentType.is(256 /* REFERENCE */)) {
                    let classReference = this.currentType.classReference;
                    if (classReference) {
                        let overload = classReference.lookupOverload(program_1.OperatorKind.BITWISE_NOT);
                        if (overload)
                            return this.compileUnaryOverload(overload, expression.operand, expr, expression);
                    }
                    this.error(diagnostics_1.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1, expression.range, "~", this.currentType.toString());
                    return module.unreachable();
                }
                else {
                    expr = this.convertExpression(expr, this.currentType, this.currentType.intType, false, false, expression.operand);
                }
                switch (this.currentType.kind) {
                    case 0 /* I8 */:
                    case 1 /* I16 */:
                    case 2 /* I32 */:
                    case 5 /* U8 */:
                    case 6 /* U16 */:
                    case 7 /* U32 */:
                    case 10 /* BOOL */: {
                        expr = module.binary(module_1.BinaryOp.XorI32, expr, module.i32(-1));
                        break;
                    }
                    case 9 /* USIZE */:
                    case 4 /* ISIZE */: {
                        expr = module.binary(this.options.isWasm64
                            ? module_1.BinaryOp.XorI64
                            : module_1.BinaryOp.XorI32, expr, this.currentType.toNativeNegOne(module));
                        break;
                    }
                    case 3 /* I64 */:
                    case 8 /* U64 */: {
                        expr = module.binary(module_1.BinaryOp.XorI64, expr, module.i64(-1, -1));
                        break;
                    }
                    default: {
                        this.error(diagnostics_1.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1, expression.range, "~", this.currentType.toString());
                        expr = module.unreachable();
                    }
                }
                break;
            }
            case tokenizer_1.Token.TYPEOF: {
                return this.compileTypeof(expression, contextualType, constraints);
            }
            default: {
                assert(false);
                return module.unreachable();
            }
        }
        if (!compound)
            return expr;
        var resolver = this.resolver;
        var target = resolver.lookupExpression(expression.operand, this.currentFlow);
        if (!target)
            return module.unreachable();
        return this.makeAssignment(target, expr, expression.operand, resolver.currentThisExpression, resolver.currentElementExpression, contextualType != types_1.Type.void);
    }
    compileTypeof(expression, contextualType, constraints) {
        var operand = expression.operand;
        var expr = 0;
        var stringInstance = this.program.stringInstance;
        var typeString;
        if (operand.kind == ast_1.NodeKind.NULL) {
            typeString = "object"; // special since `null` without type context is usize
        }
        else {
            let element = this.resolver.lookupExpression(operand, this.currentFlow, types_1.Type.auto, resolver_1.ReportMode.SWALLOW);
            if (!element) {
                switch (operand.kind) {
                    case ast_1.NodeKind.PROPERTYACCESS:
                    case ast_1.NodeKind.ELEMENTACCESS: {
                        operand = operand.kind == ast_1.NodeKind.PROPERTYACCESS
                            ? operand.expression
                            : operand.expression;
                        let targetType = this.resolver.resolveExpression(operand, this.currentFlow, types_1.Type.auto, resolver_1.ReportMode.REPORT);
                        if (!targetType) {
                            this.currentType = stringInstance.type;
                            return this.module.unreachable();
                        }
                        expr = this.compileExpression(operand, types_1.Type.auto); // might have side-effects
                        break;
                    }
                    case ast_1.NodeKind.IDENTIFIER: break; // ignore error
                    default: expr = this.compileExpression(operand, types_1.Type.auto); // trigger error
                }
                typeString = "undefined";
            }
            else {
                switch (element.kind) {
                    case program_1.ElementKind.CLASS_PROTOTYPE:
                    case program_1.ElementKind.NAMESPACE:
                    case program_1.ElementKind.ENUM: {
                        typeString = "object";
                        break;
                    }
                    case program_1.ElementKind.FUNCTION_PROTOTYPE: {
                        typeString = "function";
                        break;
                    }
                    default: {
                        expr = this.compileExpression(operand, types_1.Type.auto);
                        let type = this.currentType;
                        expr = this.convertExpression(expr, type, types_1.Type.void, true, false, operand);
                        if (type.is(256 /* REFERENCE */)) {
                            let signatureReference = type.signatureReference;
                            if (signatureReference) {
                                typeString = "function";
                            }
                            else {
                                let classReference = type.classReference;
                                if (classReference) {
                                    if (classReference.prototype === stringInstance.prototype) {
                                        typeString = "string";
                                    }
                                    else {
                                        typeString = "object";
                                    }
                                }
                                else {
                                    typeString = "anyref"; // TODO?
                                }
                            }
                        }
                        else if (type == types_1.Type.bool) {
                            typeString = "boolean";
                        }
                        else if (type.isAny(8 /* FLOAT */ | 4 /* INTEGER */)) {
                            typeString = "number";
                        }
                        else {
                            typeString = "undefined"; // failed to compile?
                        }
                        break;
                    }
                }
            }
        }
        this.currentType = stringInstance.type;
        return expr
            ? this.module.block(null, [expr, this.ensureStaticString(typeString)], this.options.nativeSizeType)
            : this.ensureStaticString(typeString);
    }
    /** Makes sure that a 32-bit integer value is wrapped to a valid value of the specified type. */
    ensureSmallIntegerWrap(expr, type) {
        var module = this.module;
        var flow = this.currentFlow;
        switch (type.kind) {
            case 0 /* I8 */: {
                if (flow.canOverflow(expr, type)) {
                    expr = this.options.hasFeature(1 /* SIGN_EXTENSION */)
                        ? module.unary(module_1.UnaryOp.ExtendI8ToI32, expr)
                        : module.binary(module_1.BinaryOp.ShrI32, module.binary(module_1.BinaryOp.ShlI32, expr, module.i32(24)), module.i32(24));
                }
                break;
            }
            case 1 /* I16 */: {
                if (flow.canOverflow(expr, type)) {
                    expr = this.options.hasFeature(1 /* SIGN_EXTENSION */)
                        ? module.unary(module_1.UnaryOp.ExtendI16ToI32, expr)
                        : module.binary(module_1.BinaryOp.ShrI32, module.binary(module_1.BinaryOp.ShlI32, expr, module.i32(16)), module.i32(16));
                }
                break;
            }
            case 5 /* U8 */: {
                if (flow.canOverflow(expr, type)) {
                    expr = module.binary(module_1.BinaryOp.AndI32, expr, module.i32(0xff));
                }
                break;
            }
            case 6 /* U16 */: {
                if (flow.canOverflow(expr, type)) {
                    expr = module.binary(module_1.BinaryOp.AndI32, expr, module.i32(0xffff));
                }
                break;
            }
            case 10 /* BOOL */: {
                if (flow.canOverflow(expr, type)) {
                    // bool is special in that it compares to 0 instead of masking with 0x1
                    expr = module.binary(module_1.BinaryOp.NeI32, expr, module.i32(0));
                }
                break;
            }
        }
        return expr;
    }
    /** Adds the debug location of the specified expression at the specified range to the source map. */
    addDebugLocation(expr, range) {
        var parentFunction = this.currentFlow.parentFunction;
        var source = range.source;
        if (source.debugInfoIndex < 0)
            source.debugInfoIndex = this.module.addDebugInfoFile(source.normalizedPath);
        range.debugInfoRef = expr;
        parentFunction.debugLocations.push(range);
    }
    // === Specialized code generation ==============================================================
    /** Creates a comparison whether an expression is 'true' in a broader sense. */
    makeIsTrueish(expr, type) {
        var module = this.module;
        switch (type.kind) {
            case 0 /* I8 */:
            case 1 /* I16 */:
            case 5 /* U8 */:
            case 6 /* U16 */: {
                expr = this.ensureSmallIntegerWrap(expr, type);
                // fall-through
            }
            case 10 /* BOOL */: // not a mask, just != 0
            case 2 /* I32 */:
            case 7 /* U32 */: {
                return expr;
            }
            case 3 /* I64 */:
            case 8 /* U64 */: {
                return module.binary(module_1.BinaryOp.NeI64, expr, module.i64(0));
            }
            case 9 /* USIZE */: if (this.skippedAutoreleases.has(expr))
                expr = this.makeAutorelease(expr);
            case 4 /* ISIZE */: {
                return type.size == 64
                    ? module.binary(module_1.BinaryOp.NeI64, expr, module.i64(0))
                    : expr;
            }
            case 11 /* F32 */: {
                // (x != 0.0) & (x == x)
                let flow = this.currentFlow;
                let temp = flow.getTempLocal(types_1.Type.f32);
                let ret = module.binary(module_1.BinaryOp.AndI32, module.binary(module_1.BinaryOp.NeF32, module.local_tee(temp.index, expr), module.f32(0)), module.binary(module_1.BinaryOp.EqF32, module.local_get(temp.index, module_1.NativeType.F32), module.local_get(temp.index, module_1.NativeType.F32)));
                flow.freeTempLocal(temp);
                return ret;
            }
            case 12 /* F64 */: {
                // (x != 0.0) & (x == x)
                let flow = this.currentFlow;
                let temp = flow.getTempLocal(types_1.Type.f64);
                let ret = module.binary(module_1.BinaryOp.AndI32, module.binary(module_1.BinaryOp.NeF64, module.local_tee(temp.index, expr), module.f64(0)), module.binary(module_1.BinaryOp.EqF64, module.local_get(temp.index, module_1.NativeType.F64), module.local_get(temp.index, module_1.NativeType.F64)));
                flow.freeTempLocal(temp);
                return ret;
            }
            // case TypeKind.ANYREF: {
            //   TODO: !ref.is_null
            // }
            default: {
                assert(false);
                return module.i32(0);
            }
        }
    }
    /** Makes an allocation suitable to hold the data of an instance of the given class. */
    makeAllocation(classInstance) {
        // TODO: investigate if it's possible to allocate with RC=1 immediately
        var program = this.program;
        assert(classInstance.program == program);
        var module = this.module;
        var options = this.options;
        this.currentType = classInstance.type;
        var allocInstance = program.allocInstance;
        this.compileFunction(allocInstance);
        return module.call(allocInstance.internalName, [
            options.isWasm64
                ? module.i64(classInstance.currentMemoryOffset)
                : module.i32(classInstance.currentMemoryOffset),
            module.i32(classInstance.hasDecorator(program_1.DecoratorFlags.UNMANAGED)
                ? 0
                : classInstance.id)
        ], options.nativeSizeType);
    }
    /** Makes the initializers for a class's fields. */
    makeFieldInitialization(classInstance, stmts = []) {
        var members = classInstance.members;
        if (!members)
            return [];
        var module = this.module;
        var flow = this.currentFlow;
        var isInline = flow.is(32768 /* INLINE_CONTEXT */);
        var thisLocalIndex = isInline
            ? assert(flow.lookupLocal(common_1.CommonSymbols.this_)).index
            : 0;
        var nativeSizeType = this.options.nativeSizeType;
        for (let member of members.values()) {
            if (member.kind != program_1.ElementKind.FIELD || // not a field
                member.parent != classInstance // inherited field
            )
                continue;
            let field = member;
            assert(!field.isAny(common_1.CommonFlags.CONST));
            let fieldType = field.type;
            let nativeFieldType = fieldType.toNativeType();
            let fieldPrototype = field.prototype;
            let initializerNode = fieldPrototype.initializerNode;
            let parameterIndex = fieldPrototype.parameterIndex;
            let initExpr;
            if (initializerNode) { // use initializer
                initExpr = this.compileExpression(initializerNode, fieldType, // reports
                1 /* CONV_IMPLICIT */ | 16 /* WILL_RETAIN */);
                if (fieldType.isManaged && !this.skippedAutoreleases.has(initExpr)) {
                    initExpr = this.makeRetain(initExpr);
                }
            }
            else if (parameterIndex >= 0) { // initialized via parameter (here: a local)
                initExpr = module.local_get(isInline
                    ? assert(flow.lookupLocal(field.name)).index
                    : 1 + parameterIndex, // this is local 0
                nativeFieldType);
                if (fieldType.isManaged)
                    initExpr = this.makeRetain(initExpr);
            }
            else { // initialize with zero
                initExpr = fieldType.toNativeZero(module);
            }
            stmts.push(module.store(fieldType.byteSize, module.local_get(thisLocalIndex, nativeSizeType), initExpr, nativeFieldType, field.memoryOffset));
        }
        return stmts;
    }
    makeInstanceOfClass(expr, classInstance) {
        var module = this.module;
        var flow = this.currentFlow;
        var idTemp = flow.getTempLocal(types_1.Type.i32);
        var idExpr = module.load(4, false, module.binary(module_1.BinaryOp.SubI32, expr, module.i32(this.program.runtimeHeaderSize)), module_1.NativeType.I32);
        var label = "instanceof_" + classInstance.name + "|" + flow.pushBreakLabel();
        var conditions = [];
        conditions.push(module.drop(// br_if returns the value too
        module.br(label, module.binary(module_1.BinaryOp.EqI32, // classId == class.id
        module.local_tee(idTemp.index, idExpr), module.i32(classInstance.id)), module.i32(1) // ? true
        )));
        // TODO: insert conditions for all possible subclasses (i.e. cat is also animal)
        // TODO: simplify if there are none
        conditions.push(module.i32(0) // : false
        );
        flow.freeTempLocal(idTemp);
        flow.popBreakLabel();
        return module.block(label, conditions, module_1.NativeType.I32);
    }
}
exports.Compiler = Compiler;
// helpers
function mangleImportName(element, declaration) {
    // by default, use the file name as the module name
    mangleImportName_moduleName = declaration.range.source.simplePath;
    // and the internal name of the element within that file as the element name
    mangleImportName_elementName = program_1.mangleInternalName(element.name, element.parent, element.is(common_1.CommonFlags.INSTANCE), true);
    if (!element.hasDecorator(program_1.DecoratorFlags.EXTERNAL))
        return;
    var program = element.program;
    var decorator = assert(ast_1.findDecorator(ast_1.DecoratorKind.EXTERNAL, declaration.decorators));
    var args = decorator.arguments;
    if (args && args.length) {
        let arg = args[0];
        // if one argument is given, override just the element name
        // if two arguments are given, override both module and element name
        if (arg.kind == ast_1.NodeKind.LITERAL && arg.literalKind == ast_1.LiteralKind.STRING) {
            mangleImportName_elementName = arg.value;
            if (args.length >= 2) {
                arg = args[1];
                if (arg.kind == ast_1.NodeKind.LITERAL && arg.literalKind == ast_1.LiteralKind.STRING) {
                    mangleImportName_moduleName = mangleImportName_elementName;
                    mangleImportName_elementName = arg.value;
                    if (args.length > 2) {
                        program.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, decorator.range, "2", args.length.toString());
                    }
                }
                else {
                    program.error(diagnostics_1.DiagnosticCode.String_literal_expected, arg.range);
                }
            }
        }
        else {
            program.error(diagnostics_1.DiagnosticCode.String_literal_expected, arg.range);
        }
    }
    else {
        program.error(diagnostics_1.DiagnosticCode.Expected_at_least_0_arguments_but_got_1, decorator.range, "1", "0");
    }
}
var mangleImportName_moduleName;
var mangleImportName_elementName;
/** Flattens a series of expressions to a nop, a single statement or a block depending on statement count. */
function flatten(module, stmts, type) {
    var length = stmts.length;
    if (length == 0)
        return module.nop(); // usually filtered out again
    if (length == 1) {
        let single = stmts[0];
        if (module_1.getExpressionType(single) == type)
            return single;
        if (module_1.getExpressionId(single) == module_1.ExpressionId.Block) {
            let count = module_1.getBlockChildCount(single);
            let children = new Array(count);
            for (let i = 0; i < count; ++i)
                children[i] = module_1.getBlockChild(single, i);
            return module.block(module_1.getBlockName(single), children, type);
        }
    }
    return module.block(null, stmts, type == module_1.NativeType.Auto
        ? module_1.getExpressionType(stmts[length - 1])
        : type);
}
exports.flatten = flatten;


/***/ }),

/***/ "./src/decompiler.ts":
/*!***************************!*\
  !*** ./src/decompiler.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * A decompiler that generates low-level AssemblyScript from WebAssembly binaries.
 * @module decompiler
 */ /***/
Object.defineProperty(exports, "__esModule", { value: true });
const module_1 = __webpack_require__(/*! ./module */ "./src/module.ts");
// TODO :-)
class Decompiler {
    constructor() {
        this.text = [];
        this.functionId = 0;
    }
    static decompile(module) {
        var decompiler = new Decompiler();
        decompiler.decompile(module);
        return decompiler.finish();
    }
    /** Decompiles a module to an AST that can then be serialized. */
    decompile(module) {
        throw new Error("not implemented");
    }
    decompileFunction(func) {
        var name = module_1.getFunctionName(func) || "$" + this.functionId.toString(10);
        var body = module_1.getFunctionBody(func);
        this.push("function ");
        this.push(name);
        this.push("(");
        for (let i = 0, k = module_1.getFunctionParamCount(func); i < k; ++i) {
            if (i > 0)
                this.push(", ");
            this.push("$");
            this.push(i.toString(10));
            this.push(": ");
            this.push(nativeTypeToType(module_1.getFunctionParamType(func, i)));
        }
        this.push("): ");
        this.push(nativeTypeToType(module_1.getFunctionResultType(func)));
        this.push(" ");
        if (module_1.getExpressionId(body) != module_1.ExpressionId.Block) {
            this.push("{\n");
        }
        this.decompileExpression(body);
        if (module_1.getExpressionId(body) != module_1.ExpressionId.Block) {
            this.push("\n}\n");
        }
        ++this.functionId;
    }
    decompileExpression(expr) {
        var id = module_1.getExpressionId(expr);
        var type = module_1.getExpressionType(expr);
        var nested;
        var string;
        var i, k;
        switch (id) {
            case module_1.ExpressionId.Block: { // TODO: magic
                if ((string = module_1.getBlockName(expr)) != null) {
                    this.push(string);
                    this.push(": ");
                }
                this.push("{\n");
                k = module_1.getBlockChildCount(expr);
                for (i = 0; i < k; ++i) {
                    this.decompileExpression(module_1.getBlockChild(expr, i));
                }
                this.push("}\n");
                return;
            }
            case module_1.ExpressionId.If: {
                if (type == module_1.NativeType.None) {
                    this.push("if (");
                    this.decompileExpression(module_1.getIfCondition(expr));
                    this.push(") ");
                    this.decompileExpression(module_1.getIfTrue(expr));
                    if (nested = module_1.getIfFalse(expr)) {
                        this.push(" else ");
                        this.decompileExpression(nested);
                    }
                }
                else {
                    this.decompileExpression(module_1.getIfCondition(expr));
                    this.push(" ? ");
                    this.decompileExpression(module_1.getIfTrue(expr));
                    this.push(" : ");
                    this.decompileExpression(module_1.getIfFalse(expr));
                }
                return;
            }
            case module_1.ExpressionId.Loop: {
                if ((string = module_1.getLoopName(expr)) != null) {
                    this.push(string);
                    this.push(": ");
                }
                this.push("do ");
                this.decompileExpression(module_1.getLoopBody(expr));
                this.push("while (0);\n");
            }
            case module_1.ExpressionId.Break: {
                if (nested = module_1.getBreakCondition(expr)) {
                    this.push("if (");
                    this.decompileExpression(nested);
                    this.push(") ");
                }
                if ((string = module_1.getBreakName(expr)) != null) {
                    this.push("break ");
                    this.push(string);
                    this.push(";\n");
                }
                else {
                    this.push("break;\n");
                }
                return;
            }
            case module_1.ExpressionId.Switch:
            case module_1.ExpressionId.Call:
            case module_1.ExpressionId.CallIndirect: {
                throw new Error("not implemented");
            }
            case module_1.ExpressionId.LocalGet: {
                this.push("$");
                this.push(module_1.getLocalGetIndex(expr).toString(10));
                return;
            }
            case module_1.ExpressionId.LocalSet: {
                this.push("$");
                this.push(module_1.getLocalSetIndex(expr).toString(10));
                this.push(" = ");
                this.decompileExpression(module_1.getLocalSetValue(expr));
                return;
            }
            case module_1.ExpressionId.GlobalGet:
            case module_1.ExpressionId.GlobalSet: {
                throw new Error("not implemented");
            }
            case module_1.ExpressionId.Load: {
                this.push("load<");
                this.push(nativeTypeToType(type));
                this.push(">(");
                this.push(module_1.getLoadOffset(expr).toString(10));
                this.push(" + ");
                this.decompileExpression(module_1.getLoadPtr(expr));
                this.push(")");
                return;
            }
            case module_1.ExpressionId.Store: {
                this.push("store<");
                this.push(nativeTypeToType(type));
                this.push(">(");
                this.push(module_1.getStoreOffset(expr).toString(10));
                this.push(" + ");
                this.decompileExpression(module_1.getStorePtr(expr));
                this.push(", ");
                this.decompileExpression(module_1.getStoreValue(expr));
                this.push(")");
                return;
            }
            case module_1.ExpressionId.Const: {
                switch (type) {
                    case module_1.NativeType.I32: {
                        this.push(module_1.getConstValueI32(expr).toString(10));
                        return;
                    }
                    case module_1.NativeType.I64: {
                        this.push(i64_to_string(i64_new(module_1.getConstValueI64Low(expr), module_1.getConstValueI64High(expr))));
                        return;
                    }
                    case module_1.NativeType.F32: {
                        this.push(module_1.getConstValueF32(expr).toString(10));
                        return;
                    }
                    case module_1.NativeType.F64: {
                        this.push(module_1.getConstValueF64(expr).toString(10));
                        return;
                    }
                }
                break;
            }
            case module_1.ExpressionId.Unary: {
                switch (module_1.getUnaryOp(expr)) {
                    case module_1.UnaryOp.ClzI32: {
                        this.push("clz<i32>(");
                        this.decompileExpression(module_1.getUnaryValue(expr));
                        this.push(")");
                        return;
                    }
                    case module_1.UnaryOp.CtzI32: {
                        this.push("ctz<i32>(");
                        this.decompileExpression(module_1.getUnaryValue(expr));
                        this.push(")");
                        return;
                    }
                    case module_1.UnaryOp.PopcntI32: {
                        this.push("popcnt<i32>(");
                        this.decompileExpression(module_1.getUnaryValue(expr));
                        this.push(")");
                        return;
                    }
                    case module_1.UnaryOp.NegF32:
                    case module_1.UnaryOp.NegF64: {
                        this.push("-");
                        this.decompileExpression(module_1.getUnaryValue(expr));
                        return;
                    }
                    case module_1.UnaryOp.AbsF32: {
                        this.push("abs<f32>(");
                        this.decompileExpression(module_1.getUnaryValue(expr));
                        this.push(")");
                        return;
                    }
                    case module_1.UnaryOp.CeilF32: {
                        this.push("ceil<f32>(");
                        this.decompileExpression(module_1.getUnaryValue(expr));
                        this.push(")");
                        return;
                    }
                    case module_1.UnaryOp.FloorF32: {
                        this.push("floor<f32>(");
                        this.decompileExpression(module_1.getUnaryValue(expr));
                        this.push(")");
                        return;
                    }
                    case module_1.UnaryOp.TruncF32: {
                        this.push("trunc<f32>(");
                        this.decompileExpression(module_1.getUnaryValue(expr));
                        this.push(")");
                        return;
                    }
                    case module_1.UnaryOp.NearestF32: {
                        this.push("nearest<i32>(");
                        this.decompileExpression(module_1.getUnaryValue(expr));
                        this.push(")");
                        return;
                    }
                    case module_1.UnaryOp.SqrtF32: {
                        this.push("sqrt<f32>(");
                        this.decompileExpression(module_1.getUnaryValue(expr));
                        this.push(")");
                        return;
                    }
                    case module_1.UnaryOp.EqzI32:
                    case module_1.UnaryOp.EqzI64: {
                        this.push("!");
                        this.decompileExpression(module_1.getUnaryValue(expr));
                        return;
                    }
                    case module_1.UnaryOp.ClzI64: {
                        this.push("clz<i64>(");
                        this.decompileExpression(module_1.getUnaryValue(expr));
                        this.push(")");
                        return;
                    }
                    case module_1.UnaryOp.CtzI64: {
                        this.push("ctz<i64>(");
                        this.decompileExpression(module_1.getUnaryValue(expr));
                        this.push(")");
                        return;
                    }
                    case module_1.UnaryOp.PopcntI64: {
                        this.push("popcnt<i64>(");
                        this.decompileExpression(module_1.getUnaryValue(expr));
                        this.push(")");
                        return;
                    }
                    case module_1.UnaryOp.AbsF64: {
                        this.push("abs<f64>(");
                        this.decompileExpression(module_1.getUnaryValue(expr));
                        this.push(")");
                        return;
                    }
                    case module_1.UnaryOp.CeilF64: {
                        this.push("ceil<f64>(");
                        this.decompileExpression(module_1.getUnaryValue(expr));
                        this.push(")");
                        return;
                    }
                    case module_1.UnaryOp.FloorF64: {
                        this.push("floor<f64>(");
                        this.decompileExpression(module_1.getUnaryValue(expr));
                        this.push(")");
                        return;
                    }
                    case module_1.UnaryOp.TruncF64: {
                        this.push("trunc<f64>(");
                        this.decompileExpression(module_1.getUnaryValue(expr));
                        this.push(")");
                        return;
                    }
                    case module_1.UnaryOp.NearestF64: {
                        this.push("nearest<f64>(");
                        this.decompileExpression(module_1.getUnaryValue(expr));
                        this.push(")");
                        return;
                    }
                    case module_1.UnaryOp.SqrtF64: {
                        this.push("sqrt<f64>(");
                        this.decompileExpression(module_1.getUnaryValue(expr));
                        this.push(")");
                        return;
                    }
                    case module_1.UnaryOp.ExtendI32: {
                        this.push("<i64>");
                        this.decompileExpression(module_1.getUnaryValue(expr));
                        return;
                    }
                    case module_1.UnaryOp.ExtendU32: {
                        this.push("<i64><u64>");
                        this.decompileExpression(module_1.getUnaryValue(expr));
                        return;
                    }
                    case module_1.UnaryOp.WrapI64: {
                        this.push("<i32>");
                        this.decompileExpression(module_1.getUnaryValue(expr));
                        return;
                    }
                    case module_1.UnaryOp.TruncF32ToI32: {
                        this.push("<i32>");
                        this.decompileExpression(module_1.getUnaryValue(expr));
                        return;
                    }
                    case module_1.UnaryOp.TruncF32ToI64: {
                        this.push("<i64>");
                        this.decompileExpression(module_1.getUnaryValue(expr));
                        return;
                    }
                    case module_1.UnaryOp.TruncF32ToU32: {
                        this.push("<i32><u32>");
                        this.decompileExpression(module_1.getUnaryValue(expr));
                        return;
                    }
                    case module_1.UnaryOp.TruncF32ToU64: {
                        this.push("<i64><u64>");
                        this.decompileExpression(module_1.getUnaryValue(expr));
                        return;
                    }
                    case module_1.UnaryOp.TruncF64ToI32: {
                        this.push("<i32>");
                        this.decompileExpression(module_1.getUnaryValue(expr));
                        return;
                    }
                    case module_1.UnaryOp.TruncF64ToI64: {
                        this.push("<i64>");
                        this.decompileExpression(module_1.getUnaryValue(expr));
                        return;
                    }
                    case module_1.UnaryOp.TruncF64ToU32: {
                        this.push("<i32><u32>");
                        this.decompileExpression(module_1.getUnaryValue(expr));
                        return;
                    }
                    case module_1.UnaryOp.TruncF64ToU64: {
                        this.push("<i64><u64>");
                        this.decompileExpression(module_1.getUnaryValue(expr));
                        return;
                    }
                    case module_1.UnaryOp.ReinterpretF32: {
                        this.push("reinterpret<f32,i32>(");
                        this.decompileExpression(module_1.getUnaryValue(expr));
                        this.push(")");
                        return;
                    }
                    case module_1.UnaryOp.ReinterpretF64: {
                        this.push("reinterpret<f64,i64>(");
                        this.decompileExpression(module_1.getUnaryValue(expr));
                        this.push(")");
                        return;
                    }
                    case module_1.UnaryOp.ConvertI32ToF32: {
                        this.push("<f32>");
                        this.decompileExpression(module_1.getUnaryValue(expr));
                        return;
                    }
                    case module_1.UnaryOp.ConvertI32ToF64: {
                        this.push("<f64>");
                        this.decompileExpression(module_1.getUnaryValue(expr));
                        return;
                    }
                    case module_1.UnaryOp.ConvertU32ToF32: {
                        this.push("<f32><u32>");
                        this.decompileExpression(module_1.getUnaryValue(expr));
                        return;
                    }
                    case module_1.UnaryOp.ConvertU32ToF64: {
                        this.push("<f64><u32>");
                        this.decompileExpression(module_1.getUnaryValue(expr));
                        return;
                    }
                    case module_1.UnaryOp.ConvertI64ToF32: {
                        this.push("<f32>");
                        this.decompileExpression(module_1.getUnaryValue(expr));
                        return;
                    }
                    case module_1.UnaryOp.ConvertI64ToF64: {
                        this.push("<f64>");
                        this.decompileExpression(module_1.getUnaryValue(expr));
                        return;
                    }
                    case module_1.UnaryOp.ConvertU64ToF32: {
                        this.push("<f32><u64>");
                        this.decompileExpression(module_1.getUnaryValue(expr));
                        return;
                    }
                    case module_1.UnaryOp.ConvertU64ToF64: {
                        this.push("<f64><u64>");
                        this.decompileExpression(module_1.getUnaryValue(expr));
                        return;
                    }
                    case module_1.UnaryOp.PromoteF32: {
                        this.push("<f64>");
                        this.decompileExpression(module_1.getUnaryValue(expr));
                        return;
                    }
                    case module_1.UnaryOp.DemoteF64: {
                        this.push("<f32>");
                        this.decompileExpression(module_1.getUnaryValue(expr));
                        return;
                    }
                    case module_1.UnaryOp.ReinterpretI32: {
                        this.push("reinterpret<i32,f32>(");
                        this.decompileExpression(module_1.getUnaryValue(expr));
                        this.push(")");
                        return;
                    }
                    case module_1.UnaryOp.ReinterpretI64: {
                        this.push("reinterpret<i64,f64>(");
                        this.decompileExpression(module_1.getUnaryValue(expr));
                        this.push(")");
                        return;
                    }
                }
                break;
            }
            case module_1.ExpressionId.Binary: { // TODO: precedence
                switch (module_1.getBinaryOp(expr)) {
                    case module_1.BinaryOp.AddI32:
                    case module_1.BinaryOp.AddI64:
                    case module_1.BinaryOp.AddF32:
                    case module_1.BinaryOp.AddF64: {
                        this.decompileExpression(module_1.getBinaryLeft(expr));
                        this.push(" + ");
                        this.decompileExpression(module_1.getBinaryRight(expr));
                        return;
                    }
                    case module_1.BinaryOp.SubI32:
                    case module_1.BinaryOp.SubI64:
                    case module_1.BinaryOp.SubF32:
                    case module_1.BinaryOp.SubF64: {
                        this.decompileExpression(module_1.getBinaryLeft(expr));
                        this.push(" - ");
                        this.decompileExpression(module_1.getBinaryRight(expr));
                        return;
                    }
                    case module_1.BinaryOp.MulI32:
                    case module_1.BinaryOp.MulI64:
                    case module_1.BinaryOp.MulF32:
                    case module_1.BinaryOp.MulF64: {
                        this.decompileExpression(module_1.getBinaryLeft(expr));
                        this.push(" * ");
                        this.decompileExpression(module_1.getBinaryRight(expr));
                        return;
                    }
                    case module_1.BinaryOp.DivI32:
                    case module_1.BinaryOp.DivI64:
                    case module_1.BinaryOp.DivF32:
                    case module_1.BinaryOp.DivF64: {
                        this.decompileExpression(module_1.getBinaryLeft(expr));
                        this.push(" / ");
                        this.decompileExpression(module_1.getBinaryRight(expr));
                        return;
                    }
                    case module_1.BinaryOp.DivU32: {
                        this.push("<i32>(<u32>");
                        this.decompileExpression(module_1.getBinaryLeft(expr));
                        this.push(" / <u32>");
                        this.decompileExpression(module_1.getBinaryRight(expr));
                        this.push(")");
                        return;
                    }
                    case module_1.BinaryOp.RemI32:
                    case module_1.BinaryOp.RemI64: {
                        this.decompileExpression(module_1.getBinaryLeft(expr));
                        this.push(" % ");
                        this.decompileExpression(module_1.getBinaryRight(expr));
                        return;
                    }
                    case module_1.BinaryOp.RemU32: {
                        this.push("<i32>(<u32>");
                        this.decompileExpression(module_1.getBinaryLeft(expr));
                        this.push(" / <u32>");
                        this.decompileExpression(module_1.getBinaryRight(expr));
                        this.push(")");
                        return;
                    }
                    case module_1.BinaryOp.AndI32:
                    case module_1.BinaryOp.AndI64: {
                        this.decompileExpression(module_1.getBinaryLeft(expr));
                        this.push(" & ");
                        this.decompileExpression(module_1.getBinaryRight(expr));
                        return;
                    }
                    case module_1.BinaryOp.OrI32:
                    case module_1.BinaryOp.OrI64: {
                        this.decompileExpression(module_1.getBinaryLeft(expr));
                        this.push(" | ");
                        this.decompileExpression(module_1.getBinaryRight(expr));
                        return;
                    }
                    case module_1.BinaryOp.XorI32:
                    case module_1.BinaryOp.XorI64: {
                        this.decompileExpression(module_1.getBinaryLeft(expr));
                        this.push(" ^ ");
                        this.decompileExpression(module_1.getBinaryRight(expr));
                        return;
                    }
                    case module_1.BinaryOp.ShlI32:
                    case module_1.BinaryOp.ShlI64: {
                        this.decompileExpression(module_1.getBinaryLeft(expr));
                        this.push(" << ");
                        this.decompileExpression(module_1.getBinaryRight(expr));
                        return;
                    }
                    case module_1.BinaryOp.ShrU32:
                    case module_1.BinaryOp.ShrU64: {
                        this.decompileExpression(module_1.getBinaryLeft(expr));
                        this.push(" >>> ");
                        this.decompileExpression(module_1.getBinaryRight(expr));
                        return;
                    }
                    case module_1.BinaryOp.ShrI32:
                    case module_1.BinaryOp.ShrI64: {
                        this.decompileExpression(module_1.getBinaryLeft(expr));
                        this.push(" >> ");
                        this.decompileExpression(module_1.getBinaryRight(expr));
                        return;
                    }
                    case module_1.BinaryOp.RotlI32: {
                        this.push("rotl<i32>(");
                        this.decompileExpression(module_1.getBinaryLeft(expr));
                        this.push(", ");
                        this.decompileExpression(module_1.getBinaryRight(expr));
                        this.push(")");
                        return;
                    }
                    case module_1.BinaryOp.RotrI32: {
                        this.push("rotr<i32>(");
                        this.decompileExpression(module_1.getBinaryLeft(expr));
                        this.push(", ");
                        this.decompileExpression(module_1.getBinaryRight(expr));
                        this.push(")");
                        return;
                    }
                    case module_1.BinaryOp.EqI32:
                    case module_1.BinaryOp.EqI64:
                    case module_1.BinaryOp.EqF32:
                    case module_1.BinaryOp.EqF64: {
                        this.decompileExpression(module_1.getBinaryLeft(expr));
                        this.push(" == ");
                        this.decompileExpression(module_1.getBinaryRight(expr));
                        return;
                    }
                    case module_1.BinaryOp.NeI32:
                    case module_1.BinaryOp.NeI64:
                    case module_1.BinaryOp.NeF32:
                    case module_1.BinaryOp.NeF64: {
                        this.decompileExpression(module_1.getBinaryLeft(expr));
                        this.push(" != ");
                        this.decompileExpression(module_1.getBinaryRight(expr));
                        return;
                    }
                    case module_1.BinaryOp.LtI32:
                    case module_1.BinaryOp.LtI64:
                    case module_1.BinaryOp.LtF32:
                    case module_1.BinaryOp.LtF64: {
                        this.decompileExpression(module_1.getBinaryLeft(expr));
                        this.push(" < ");
                        this.decompileExpression(module_1.getBinaryRight(expr));
                        return;
                    }
                    case module_1.BinaryOp.LtU32: {
                        this.push("<u32>");
                        this.decompileExpression(module_1.getBinaryLeft(expr));
                        this.push(" < <u32>");
                        this.decompileExpression(module_1.getBinaryRight(expr));
                        return;
                    }
                    case module_1.BinaryOp.LeI32:
                    case module_1.BinaryOp.LeI64:
                    case module_1.BinaryOp.LeF32:
                    case module_1.BinaryOp.LeF64: {
                        this.decompileExpression(module_1.getBinaryLeft(expr));
                        this.push(" <= ");
                        this.decompileExpression(module_1.getBinaryRight(expr));
                        return;
                    }
                    case module_1.BinaryOp.LeU32: {
                        this.push("<u32>");
                        this.decompileExpression(module_1.getBinaryLeft(expr));
                        this.push(" <= <u32>");
                        this.decompileExpression(module_1.getBinaryRight(expr));
                        return;
                    }
                    case module_1.BinaryOp.GtI32:
                    case module_1.BinaryOp.GtI64:
                    case module_1.BinaryOp.GtF32:
                    case module_1.BinaryOp.GtF64: {
                        this.decompileExpression(module_1.getBinaryLeft(expr));
                        this.push(" > ");
                        this.decompileExpression(module_1.getBinaryRight(expr));
                        return;
                    }
                    case module_1.BinaryOp.GtU32: {
                        this.push("<u32>");
                        this.decompileExpression(module_1.getBinaryLeft(expr));
                        this.push(" > <u32>");
                        this.decompileExpression(module_1.getBinaryRight(expr));
                        return;
                    }
                    case module_1.BinaryOp.GeI32:
                    case module_1.BinaryOp.GeI64:
                    case module_1.BinaryOp.GeF32:
                    case module_1.BinaryOp.GeF64: {
                        this.decompileExpression(module_1.getBinaryLeft(expr));
                        this.push(" >= ");
                        this.decompileExpression(module_1.getBinaryRight(expr));
                        return;
                    }
                    case module_1.BinaryOp.GeU32: {
                        this.push("<u32>");
                        this.decompileExpression(module_1.getBinaryLeft(expr));
                        this.push(" >= <u32>");
                        this.decompileExpression(module_1.getBinaryRight(expr));
                        return;
                    }
                    case module_1.BinaryOp.DivU64: {
                        this.push("<u64>");
                        this.decompileExpression(module_1.getBinaryLeft(expr));
                        this.push(" / <u64>");
                        this.decompileExpression(module_1.getBinaryRight(expr));
                        return;
                    }
                    case module_1.BinaryOp.RemU64: {
                        this.push("<u64>");
                        this.decompileExpression(module_1.getBinaryLeft(expr));
                        this.push(" % <u64>");
                        this.decompileExpression(module_1.getBinaryRight(expr));
                        return;
                    }
                    case module_1.BinaryOp.RotlI64: {
                        this.push("rotl<i64>(");
                        this.decompileExpression(module_1.getBinaryLeft(expr));
                        this.push(", ");
                        this.decompileExpression(module_1.getBinaryRight(expr));
                        this.push(")");
                        return;
                    }
                    case module_1.BinaryOp.RotrI64: {
                        this.push("rotr<i64>(");
                        this.decompileExpression(module_1.getBinaryLeft(expr));
                        this.push(", ");
                        this.decompileExpression(module_1.getBinaryRight(expr));
                        this.push(")");
                        return;
                    }
                    case module_1.BinaryOp.LtU64: {
                        this.push("<u64>");
                        this.decompileExpression(module_1.getBinaryLeft(expr));
                        this.push(" < <u64>");
                        this.decompileExpression(module_1.getBinaryRight(expr));
                        return;
                    }
                    case module_1.BinaryOp.LeU64: {
                        this.push("<u64>");
                        this.decompileExpression(module_1.getBinaryLeft(expr));
                        this.push(" <= <u64>");
                        this.decompileExpression(module_1.getBinaryRight(expr));
                        return;
                    }
                    case module_1.BinaryOp.GtU64: {
                        this.push("<u64>");
                        this.decompileExpression(module_1.getBinaryLeft(expr));
                        this.push(" > <u64>");
                        this.decompileExpression(module_1.getBinaryRight(expr));
                        return;
                    }
                    case module_1.BinaryOp.GeU64: {
                        this.push("<u64>");
                        this.decompileExpression(module_1.getBinaryLeft(expr));
                        this.push(" >= <u64>");
                        this.decompileExpression(module_1.getBinaryRight(expr));
                        return;
                    }
                    case module_1.BinaryOp.CopysignF32: {
                        this.push("copysign<f32>(");
                        this.decompileExpression(module_1.getBinaryLeft(expr));
                        this.push(", ");
                        this.decompileExpression(module_1.getBinaryRight(expr));
                        this.push(")");
                        return;
                    }
                    case module_1.BinaryOp.MinF32: {
                        this.push("min<f32>(");
                        this.decompileExpression(module_1.getBinaryLeft(expr));
                        this.push(", ");
                        this.decompileExpression(module_1.getBinaryRight(expr));
                        this.push(")");
                        return;
                    }
                    case module_1.BinaryOp.MaxF32: {
                        this.push("max<f32>(");
                        this.decompileExpression(module_1.getBinaryLeft(expr));
                        this.push(", ");
                        this.decompileExpression(module_1.getBinaryRight(expr));
                        this.push(")");
                        return;
                    }
                    case module_1.BinaryOp.CopysignF64: {
                        this.push("copysign<f64>(");
                        this.decompileExpression(module_1.getBinaryLeft(expr));
                        this.push(", ");
                        this.decompileExpression(module_1.getBinaryRight(expr));
                        this.push(")");
                        return;
                    }
                    case module_1.BinaryOp.MinF64: {
                        this.push("min<f64>(");
                        this.decompileExpression(module_1.getBinaryLeft(expr));
                        this.push(", ");
                        this.decompileExpression(module_1.getBinaryRight(expr));
                        this.push(")");
                        return;
                    }
                    case module_1.BinaryOp.MaxF64: {
                        this.push("max<f64>(");
                        this.decompileExpression(module_1.getBinaryLeft(expr));
                        this.push(", ");
                        this.decompileExpression(module_1.getBinaryRight(expr));
                        this.push(")");
                        return;
                    }
                }
                return;
            }
            case module_1.ExpressionId.Select: {
                this.push("select<");
                this.push(nativeTypeToType(type));
                this.push(">(");
                this.decompileExpression(module_1.getSelectThen(expr));
                this.push(", ");
                this.decompileExpression(module_1.getSelectElse(expr));
                this.push(", ");
                this.decompileExpression(module_1.getSelectCondition(expr));
                this.push(")");
                return;
            }
            case module_1.ExpressionId.Drop: {
                this.decompileExpression(module_1.getDropValue(expr));
                this.push(";\n");
                return;
            }
            case module_1.ExpressionId.Return: {
                if (nested = module_1.getReturnValue(expr)) {
                    this.push("return ");
                    this.decompileExpression(nested);
                    this.push(";\n");
                }
                else {
                    this.push("return;\n");
                }
                return;
            }
            case module_1.ExpressionId.Host: {
                switch (module_1.getHostOp(expr)) {
                    case module_1.HostOp.MemorySize: {
                        this.push("memory.size()");
                        return;
                    }
                    case module_1.HostOp.MemoryGrow: {
                        this.push("memory.grow(");
                        this.decompileExpression(module_1.getHostOperand(expr, 0));
                        this.push(")");
                        return;
                    }
                }
                break;
            }
            case module_1.ExpressionId.Nop: {
                this.push(";\n");
                return;
            }
            case module_1.ExpressionId.Unreachable: {
                this.push("unreachable()");
                return;
            }
            case module_1.ExpressionId.AtomicCmpxchg:
            case module_1.ExpressionId.AtomicRMW:
            case module_1.ExpressionId.AtomicWait:
            case module_1.ExpressionId.AtomicNotify:
        }
        throw new Error("not implemented");
    }
    push(text) {
        // mostly here so we can add debugging if necessary
        this.text.push(text);
    }
    finish() {
        var ret = this.text.join("");
        this.text = [];
        return ret;
    }
}
exports.Decompiler = Decompiler;
function nativeTypeToType(type) {
    switch (type) {
        case module_1.NativeType.None: return "void";
        case module_1.NativeType.I32: return "i32";
        case module_1.NativeType.I64: return "i64";
        case module_1.NativeType.F32: return "f32";
        case module_1.NativeType.F64: return "f64";
        case module_1.NativeType.V128: return "v128";
        case module_1.NativeType.Unreachable: throw new Error("unreachable type");
        case module_1.NativeType.Auto: throw new Error("auto type");
        default: throw new Error("unexpected type");
    }
}


/***/ }),

/***/ "./src/definitions.ts":
/*!****************************!*\
  !*** ./src/definitions.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Definition builders for WebIDL and TypeScript.
 * @module definitions
 */ /***/
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = __webpack_require__(/*! ./common */ "./src/common.ts");
const program_1 = __webpack_require__(/*! ./program */ "./src/program.ts");
const ast_1 = __webpack_require__(/*! ./ast */ "./src/ast.ts");
const util_1 = __webpack_require__(/*! ./util */ "./src/util/index.ts");
/** Walker base class. */
class ExportsWalker {
    /** Constructs a new Element walker. */
    constructor(program, includePrivate = false) {
        /** Already seen elements. */
        this.seen = new Map();
        this.program = program;
        this.includePrivate;
    }
    /** Walks all elements and calls the respective handlers. */
    walk() {
        for (let file of this.program.filesByName.values()) {
            if (file.source.sourceKind == ast_1.SourceKind.USER_ENTRY)
                this.visitFile(file);
        }
    }
    /** Visits all exported elements of a file. */
    visitFile(file) {
        var members = file.exports;
        if (members) {
            for (let [name, member] of members)
                this.visitElement(name, member);
        }
        var exportsStar = file.exportsStar;
        if (exportsStar) {
            for (let exportStar of exportsStar)
                this.visitFile(exportStar);
        }
    }
    /** Visits an element.*/
    visitElement(name, element) {
        if (element.is(common_1.CommonFlags.PRIVATE) && !this.includePrivate)
            return;
        var seen = this.seen;
        if (seen.has(element)) {
            this.visitAlias(name, element, seen.get(element));
            return;
        }
        seen.set(element, name);
        switch (element.kind) {
            case program_1.ElementKind.GLOBAL: {
                if (element.is(common_1.CommonFlags.COMPILED))
                    this.visitGlobal(name, element);
                break;
            }
            case program_1.ElementKind.ENUM: {
                if (element.is(common_1.CommonFlags.COMPILED))
                    this.visitEnum(name, element);
                break;
            }
            case program_1.ElementKind.FUNCTION_PROTOTYPE: {
                this.visitFunctionInstances(name, element);
                break;
            }
            case program_1.ElementKind.CLASS_PROTOTYPE: {
                this.visitClassInstances(name, element);
                break;
            }
            case program_1.ElementKind.FIELD: {
                if (element.is(common_1.CommonFlags.COMPILED))
                    this.visitField(name, element);
                break;
            }
            case program_1.ElementKind.PROPERTY_PROTOTYPE: {
                this.visitPropertyInstances(name, element);
                break;
            }
            case program_1.ElementKind.PROPERTY: {
                let prop = element;
                let getter = prop.getterInstance;
                if (getter)
                    this.visitFunction(name, getter);
                let setter = prop.setterInstance;
                if (setter)
                    this.visitFunction(name, setter);
                break;
            }
            case program_1.ElementKind.NAMESPACE: {
                if (hasCompiledMember(element))
                    this.visitNamespace(name, element);
                break;
            }
            case program_1.ElementKind.TYPEDEFINITION: break;
            default: assert(false);
        }
    }
    visitFunctionInstances(name, element) {
        var instances = element.instances;
        if (instances) {
            for (let instance of instances.values()) {
                if (instance.is(common_1.CommonFlags.COMPILED))
                    this.visitFunction(name, instance);
            }
        }
    }
    visitClassInstances(name, element) {
        var instances = element.instances;
        if (instances) {
            for (let instance of instances.values()) {
                if (instance.is(common_1.CommonFlags.COMPILED))
                    this.visitClass(name, instance);
            }
        }
    }
    visitPropertyInstances(name, element) {
        // var instances = element.instances;
        // if (instances) {
        //   for (let instance of instances.values()) {
        //     if (instance.is(CommonFlags.COMPILED)) this.visitProperty(<Property>instance);
        //   }
        // }
        assert(false);
    }
}
exports.ExportsWalker = ExportsWalker;
/** A WebIDL definitions builder. */
class IDLBuilder extends ExportsWalker {
    /** Constructs a new WebIDL builder. */
    constructor(program, includePrivate = false) {
        super(program, includePrivate);
        this.sb = [];
        this.indentLevel = 0;
    }
    /** Builds WebIDL definitions for the specified program. */
    static build(program) {
        return new IDLBuilder(program).build();
    }
    visitGlobal(name, element) {
        var sb = this.sb;
        var isConst = element.is(common_1.CommonFlags.INLINED);
        util_1.indent(sb, this.indentLevel);
        if (isConst)
            sb.push("const ");
        sb.push(this.typeToString(element.type));
        sb.push(" ");
        sb.push(name);
        if (isConst) {
            switch (element.constantValueKind) {
                case 1 /* INTEGER */: {
                    sb.push(" = ");
                    sb.push(i64_to_string(element.constantIntegerValue));
                    break;
                }
                case 2 /* FLOAT */: {
                    sb.push(" = ");
                    sb.push(element.constantFloatValue.toString());
                    break;
                }
                default: assert(false);
            }
        }
        sb.push(";\n");
    }
    visitEnum(name, element) {
        var sb = this.sb;
        util_1.indent(sb, this.indentLevel++);
        sb.push("interface ");
        sb.push(name);
        sb.push(" {\n");
        var members = element.members;
        if (members) {
            for (let [name, member] of members) {
                if (member.kind == program_1.ElementKind.ENUMVALUE) {
                    let isConst = member.is(common_1.CommonFlags.INLINED);
                    util_1.indent(sb, this.indentLevel);
                    if (isConst)
                        sb.push("const ");
                    else
                        sb.push("readonly ");
                    sb.push("unsigned long ");
                    sb.push(name);
                    if (isConst) {
                        sb.push(" = ");
                        assert(member.constantValueKind == 1 /* INTEGER */);
                        sb.push(i64_low(member.constantIntegerValue).toString(10));
                    }
                    sb.push(";\n");
                }
            }
            for (let member of members.values()) {
                if (member.kind != program_1.ElementKind.ENUMVALUE)
                    this.visitElement(member.name, member);
            }
        }
        util_1.indent(sb, --this.indentLevel);
        sb.push("}\n");
    }
    visitFunction(name, element) {
        var sb = this.sb;
        var signature = element.signature;
        util_1.indent(sb, this.indentLevel);
        sb.push(this.typeToString(signature.returnType));
        sb.push(" ");
        sb.push(name);
        sb.push("(");
        var parameters = signature.parameterTypes;
        var numParameters = parameters.length;
        // var requiredParameters = signature.requiredParameters;
        for (let i = 0; i < numParameters; ++i) {
            if (i)
                sb.push(", ");
            // if (i >= requiredParameters) sb.push("optional ");
            sb.push(this.typeToString(parameters[i]));
            sb.push(" ");
            sb.push(signature.getParameterName(i));
        }
        sb.push(");\n");
        var members = element.members;
        if (members && members.size) {
            util_1.indent(sb, this.indentLevel);
            sb.push("interface ");
            sb.push(element.name);
            sb.push(" {\n");
            for (let member of members.values())
                this.visitElement(member.name, member);
            util_1.indent(sb, --this.indentLevel);
            sb.push("}\n");
        }
    }
    visitClass(name, element) {
        var sb = this.sb;
        util_1.indent(sb, this.indentLevel++);
        sb.push("interface ");
        sb.push(name);
        sb.push(" {\n");
        // TODO
        util_1.indent(sb, --this.indentLevel);
        sb.push("}\n");
    }
    visitInterface(name, element) {
        this.visitClass(name, element);
    }
    visitField(name, element) {
        // TODO
    }
    visitNamespace(name, element) {
        var sb = this.sb;
        util_1.indent(sb, this.indentLevel++);
        sb.push("interface ");
        sb.push(name);
        sb.push(" {\n");
        var members = element.members;
        if (members) {
            for (let member of members.values())
                this.visitElement(member.name, member);
        }
        util_1.indent(sb, --this.indentLevel);
        sb.push("}\n");
    }
    visitAlias(name, element, originalName) {
        // TODO
    }
    typeToString(type) {
        switch (type.kind) {
            case 0 /* I8 */: return "byte";
            case 1 /* I16 */: return "short";
            case 2 /* I32 */: return "long";
            case 3 /* I64 */: return "long long";
            case 4 /* ISIZE */: return this.program.options.isWasm64 ? "long long" : "long";
            case 5 /* U8 */: return "octet";
            case 6 /* U16 */: return "unsigned short";
            case 7 /* U32 */: return "unsigned long";
            // ^ TODO: function types
            case 8 /* U64 */: return "unsigned long long";
            case 9 /* USIZE */: return this.program.options.isWasm64 ? "unsigned long long" : "unsigned long";
            // ^ TODO: class types
            case 10 /* BOOL */: return "boolean";
            case 11 /* F32 */: return "unrestricted float";
            case 12 /* F64 */: return "unrestricted double";
            case 15 /* VOID */: return "void";
            default: {
                assert(false);
                return "";
            }
        }
    }
    build() {
        var sb = this.sb;
        sb.push("interface ASModule {\n");
        ++this.indentLevel;
        this.walk();
        --this.indentLevel;
        sb.push("}\n");
        return sb.join("");
    }
}
exports.IDLBuilder = IDLBuilder;
/** A TypeScript definitions builder. */
class TSDBuilder extends ExportsWalker {
    /** Constructs a new WebIDL builder. */
    constructor(program, includePrivate = false) {
        super(program, includePrivate);
        this.sb = [];
        this.indentLevel = 0;
        this.unknown = new Set();
    }
    /** Builds TypeScript definitions for the specified program. */
    static build(program) {
        return new TSDBuilder(program).build();
    }
    visitGlobal(name, element) {
        var sb = this.sb;
        var isConst = element.is(common_1.CommonFlags.INLINED);
        util_1.indent(sb, this.indentLevel);
        if (element.is(common_1.CommonFlags.STATIC)) {
            if (isConst)
                sb.push("static readonly ");
            else
                sb.push("static ");
        }
        else {
            if (isConst)
                sb.push("export const ");
            else
                sb.push("export var ");
        }
        sb.push(name);
        sb.push(": ");
        sb.push(this.typeToString(element.type));
        sb.push(";\n");
        this.visitNamespace(name, element);
    }
    visitEnum(name, element) {
        var sb = this.sb;
        util_1.indent(sb, this.indentLevel++);
        sb.push("export enum ");
        sb.push(name);
        sb.push(" {\n");
        var members = element.members;
        if (members) {
            let numMembers = members.size;
            for (let [name, member] of members) {
                if (member.kind == program_1.ElementKind.ENUMVALUE) {
                    util_1.indent(sb, this.indentLevel);
                    sb.push(name);
                    if (member.is(common_1.CommonFlags.INLINED)) {
                        sb.push(" = ");
                        assert(member.constantValueKind == 1 /* INTEGER */);
                        sb.push(i64_low(member.constantIntegerValue).toString(10));
                    }
                    sb.push(",\n");
                    --numMembers;
                }
            }
            if (numMembers)
                this.visitNamespace(name, element);
        }
        util_1.indent(sb, --this.indentLevel);
        sb.push("}\n");
    }
    visitFunction(name, element) {
        if (element.isAny(common_1.CommonFlags.PRIVATE | common_1.CommonFlags.SET))
            return;
        var sb = this.sb;
        var signature = element.signature;
        util_1.indent(sb, this.indentLevel);
        if (element.is(common_1.CommonFlags.PROTECTED))
            sb.push("protected ");
        if (element.is(common_1.CommonFlags.STATIC))
            sb.push("static ");
        if (element.is(common_1.CommonFlags.GET)) {
            sb.push("get ");
            sb.push(name); // 'get:funcName' internally
            sb.push("(): ");
            sb.push(this.typeToString(signature.returnType));
            sb.push(";\n");
            return;
        }
        else {
            if (!element.isAny(common_1.CommonFlags.STATIC | common_1.CommonFlags.INSTANCE))
                sb.push("export function ");
            sb.push(name);
        }
        sb.push("(");
        var parameters = signature.parameterTypes;
        var numParameters = parameters.length;
        // var requiredParameters = signature.requiredParameters;
        for (let i = 0; i < numParameters; ++i) {
            if (i)
                sb.push(", ");
            // if (i >= requiredParameters) sb.push("optional ");
            sb.push(signature.getParameterName(i));
            sb.push(": ");
            sb.push(this.typeToString(parameters[i]));
        }
        if (element.isAny(common_1.CommonFlags.CONSTRUCTOR | common_1.CommonFlags.SET)) {
            sb.push(")");
        }
        else {
            sb.push("): ");
            sb.push(this.typeToString(signature.returnType));
        }
        sb.push(";\n");
        this.visitNamespace(name, element);
    }
    visitClass(name, element) {
        var sb = this.sb;
        var isInterface = element.kind == program_1.ElementKind.INTERFACE;
        util_1.indent(sb, this.indentLevel++);
        if (isInterface) {
            sb.push("export interface ");
        }
        else {
            if (element.is(common_1.CommonFlags.ABSTRACT))
                sb.push("abstract ");
            sb.push("export class ");
        }
        sb.push(name);
        // var base = element.base;
        // if (base && base.is(CommonFlags.COMPILED | CommonFlags.MODULE_EXPORT)) {
        //   sb.push(" extends ");
        //   sb.push(base.name); // TODO: fqn
        // }
        sb.push(" {\n");
        var staticMembers = element.prototype.members;
        if (staticMembers) {
            for (let member of staticMembers.values())
                this.visitElement(member.name, member);
        }
        var instanceMembers = element.members;
        if (instanceMembers) {
            for (let member of instanceMembers.values())
                this.visitElement(member.name, member);
        }
        util_1.indent(sb, --this.indentLevel);
        sb.push("}\n");
    }
    visitInterface(name, element) {
        this.visitClass(name, element);
    }
    visitField(name, element) {
        if (element.is(common_1.CommonFlags.PRIVATE))
            return;
        var sb = this.sb;
        util_1.indent(sb, this.indentLevel);
        if (element.is(common_1.CommonFlags.PROTECTED))
            sb.push("protected ");
        if (element.is(common_1.CommonFlags.STATIC))
            sb.push("static ");
        if (element.is(common_1.CommonFlags.READONLY))
            sb.push("readonly ");
        sb.push(name);
        sb.push(": ");
        sb.push(this.typeToString(element.type));
        sb.push(";\n");
    }
    visitNamespace(name, element) {
        var members = element.members;
        if (members && members.size) {
            let sb = this.sb;
            util_1.indent(sb, this.indentLevel++);
            sb.push("export namespace ");
            sb.push(name);
            sb.push(" {\n");
            for (let member of members.values())
                this.visitElement(member.name, member);
            util_1.indent(sb, --this.indentLevel);
            sb.push("}\n");
        }
    }
    visitAlias(name, element, originalName) {
        var sb = this.sb;
        util_1.indent(sb, this.indentLevel);
        sb.push("export const ");
        sb.push(name);
        sb.push(": typeof ");
        sb.push(originalName);
        sb.push(";\n");
    }
    typeToString(type) {
        switch (type.kind) {
            case 0 /* I8 */: return "i8";
            case 1 /* I16 */: return "i16";
            case 2 /* I32 */: return "i32";
            case 3 /* I64 */: return "I64";
            case 4 /* ISIZE */: return this.program.options.isWasm64 ? "I64" : "i32";
            case 5 /* U8 */: return "u8";
            case 6 /* U16 */: return "u16";
            case 7 /* U32 */: return "u32";
            // ^ TODO: function types
            case 8 /* U64 */: return "U64";
            case 9 /* USIZE */: return this.program.options.isWasm64 ? "U64" : "u32";
            // ^ TODO: class types
            case 10 /* BOOL */: return "bool";
            case 11 /* F32 */: return "f32";
            case 12 /* F64 */: return "f64";
            case 13 /* V128 */: return "v128";
            case 15 /* VOID */: return "void";
            default: {
                assert(false);
                return "any";
            }
        }
    }
    build() {
        var sb = this.sb;
        sb.push("declare module ASModule {\n");
        sb.push("  type i8 = number;\n");
        sb.push("  type i16 = number;\n");
        sb.push("  type i32 = number;\n");
        sb.push("  type u8 = number;\n");
        sb.push("  type u16 = number;\n");
        sb.push("  type u32 = number;\n");
        sb.push("  type f32 = number;\n");
        sb.push("  type f64 = number;\n");
        sb.push("  type bool = any;\n");
        ++this.indentLevel;
        this.walk();
        --this.indentLevel;
        sb.push("}\n");
        sb.push("export default ASModule;\n");
        return this.sb.join("");
    }
}
exports.TSDBuilder = TSDBuilder;
// helpers
/** Tests if a namespace-like element has at least one compiled member. */
function hasCompiledMember(element) {
    var members = element.members;
    if (members) {
        for (let member of members.values()) {
            switch (member.kind) {
                case program_1.ElementKind.FUNCTION_PROTOTYPE: {
                    let instances = member.instances;
                    if (instances) {
                        for (let instance of instances.values()) {
                            if (instance.is(common_1.CommonFlags.COMPILED))
                                return true;
                        }
                    }
                    break;
                }
                case program_1.ElementKind.CLASS_PROTOTYPE: {
                    let instances = member.instances;
                    if (instances) {
                        for (let instance of instances.values()) {
                            if (instance.is(common_1.CommonFlags.COMPILED))
                                return true;
                        }
                    }
                    break;
                }
                default: {
                    if (member.is(common_1.CommonFlags.COMPILED) || hasCompiledMember(member))
                        return true;
                    break;
                }
            }
        }
    }
    return false;
}


/***/ }),

/***/ "./src/diagnosticMessages.generated.ts":
/*!*********************************************!*\
  !*** ./src/diagnosticMessages.generated.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Generated from diagnosticsMessages.json. Do not edit.
 * @module diagnostics
 */ /***/
Object.defineProperty(exports, "__esModule", { value: true });
/* tslint:disable:max-line-length */
/** Enum of available diagnostic codes. */
var DiagnosticCode;
(function (DiagnosticCode) {
    DiagnosticCode[DiagnosticCode["Not_implemented"] = 100] = "Not_implemented";
    DiagnosticCode[DiagnosticCode["Operation_is_unsafe"] = 101] = "Operation_is_unsafe";
    DiagnosticCode[DiagnosticCode["User_defined_0"] = 102] = "User_defined_0";
    DiagnosticCode[DiagnosticCode["Feature_0_is_not_enabled"] = 103] = "Feature_0_is_not_enabled";
    DiagnosticCode[DiagnosticCode["Conversion_from_type_0_to_1_requires_an_explicit_cast"] = 200] = "Conversion_from_type_0_to_1_requires_an_explicit_cast";
    DiagnosticCode[DiagnosticCode["Conversion_from_type_0_to_1_will_require_an_explicit_cast_when_switching_between_32_64_bit"] = 201] = "Conversion_from_type_0_to_1_will_require_an_explicit_cast_when_switching_between_32_64_bit";
    DiagnosticCode[DiagnosticCode["Type_0_cannot_be_changed_to_type_1"] = 202] = "Type_0_cannot_be_changed_to_type_1";
    DiagnosticCode[DiagnosticCode["Operation_0_cannot_be_applied_to_type_1"] = 203] = "Operation_0_cannot_be_applied_to_type_1";
    DiagnosticCode[DiagnosticCode["Basic_type_0_cannot_be_nullable"] = 204] = "Basic_type_0_cannot_be_nullable";
    DiagnosticCode[DiagnosticCode["Cannot_export_a_mutable_global"] = 205] = "Cannot_export_a_mutable_global";
    DiagnosticCode[DiagnosticCode["Mutable_value_cannot_be_inlined"] = 206] = "Mutable_value_cannot_be_inlined";
    DiagnosticCode[DiagnosticCode["Unmanaged_classes_cannot_extend_managed_classes_and_vice_versa"] = 207] = "Unmanaged_classes_cannot_extend_managed_classes_and_vice_versa";
    DiagnosticCode[DiagnosticCode["Unmanaged_classes_cannot_implement_interfaces"] = 208] = "Unmanaged_classes_cannot_implement_interfaces";
    DiagnosticCode[DiagnosticCode["Invalid_regular_expression_flags"] = 209] = "Invalid_regular_expression_flags";
    DiagnosticCode[DiagnosticCode["Expression_is_never_null"] = 210] = "Expression_is_never_null";
    DiagnosticCode[DiagnosticCode["Class_0_is_sealed_and_cannot_be_extended"] = 211] = "Class_0_is_sealed_and_cannot_be_extended";
    DiagnosticCode[DiagnosticCode["Decorator_0_is_not_valid_here"] = 212] = "Decorator_0_is_not_valid_here";
    DiagnosticCode[DiagnosticCode["Duplicate_decorator"] = 213] = "Duplicate_decorator";
    DiagnosticCode[DiagnosticCode["Type_0_is_illegal_in_this_context"] = 214] = "Type_0_is_illegal_in_this_context";
    DiagnosticCode[DiagnosticCode["Optional_parameter_must_have_an_initializer"] = 215] = "Optional_parameter_must_have_an_initializer";
    DiagnosticCode[DiagnosticCode["Constructor_of_class_0_must_not_require_any_arguments"] = 216] = "Constructor_of_class_0_must_not_require_any_arguments";
    DiagnosticCode[DiagnosticCode["Function_0_cannot_be_inlined_into_itself"] = 217] = "Function_0_cannot_be_inlined_into_itself";
    DiagnosticCode[DiagnosticCode["Cannot_access_method_0_without_calling_it_as_it_requires_this_to_be_set"] = 218] = "Cannot_access_method_0_without_calling_it_as_it_requires_this_to_be_set";
    DiagnosticCode[DiagnosticCode["Optional_properties_are_not_supported"] = 219] = "Optional_properties_are_not_supported";
    DiagnosticCode[DiagnosticCode["Expression_must_be_a_compile_time_constant"] = 220] = "Expression_must_be_a_compile_time_constant";
    DiagnosticCode[DiagnosticCode["Type_0_is_not_a_function_index_or_function_reference"] = 221] = "Type_0_is_not_a_function_index_or_function_reference";
    DiagnosticCode[DiagnosticCode["_0_must_be_a_value_between_1_and_2_inclusive"] = 222] = "_0_must_be_a_value_between_1_and_2_inclusive";
    DiagnosticCode[DiagnosticCode["_0_must_be_a_power_of_two"] = 223] = "_0_must_be_a_power_of_two";
    DiagnosticCode[DiagnosticCode["_0_is_not_a_valid_operator"] = 224] = "_0_is_not_a_valid_operator";
    DiagnosticCode[DiagnosticCode["Expression_cannot_be_represented_by_a_type"] = 225] = "Expression_cannot_be_represented_by_a_type";
    DiagnosticCode[DiagnosticCode["Unterminated_string_literal"] = 1002] = "Unterminated_string_literal";
    DiagnosticCode[DiagnosticCode["Identifier_expected"] = 1003] = "Identifier_expected";
    DiagnosticCode[DiagnosticCode["_0_expected"] = 1005] = "_0_expected";
    DiagnosticCode[DiagnosticCode["A_file_cannot_have_a_reference_to_itself"] = 1006] = "A_file_cannot_have_a_reference_to_itself";
    DiagnosticCode[DiagnosticCode["Trailing_comma_not_allowed"] = 1009] = "Trailing_comma_not_allowed";
    DiagnosticCode[DiagnosticCode["Unexpected_token"] = 1012] = "Unexpected_token";
    DiagnosticCode[DiagnosticCode["A_rest_parameter_must_be_last_in_a_parameter_list"] = 1014] = "A_rest_parameter_must_be_last_in_a_parameter_list";
    DiagnosticCode[DiagnosticCode["Parameter_cannot_have_question_mark_and_initializer"] = 1015] = "Parameter_cannot_have_question_mark_and_initializer";
    DiagnosticCode[DiagnosticCode["A_required_parameter_cannot_follow_an_optional_parameter"] = 1016] = "A_required_parameter_cannot_follow_an_optional_parameter";
    DiagnosticCode[DiagnosticCode["Statements_are_not_allowed_in_ambient_contexts"] = 1036] = "Statements_are_not_allowed_in_ambient_contexts";
    DiagnosticCode[DiagnosticCode["Initializers_are_not_allowed_in_ambient_contexts"] = 1039] = "Initializers_are_not_allowed_in_ambient_contexts";
    DiagnosticCode[DiagnosticCode["_0_modifier_cannot_be_used_here"] = 1042] = "_0_modifier_cannot_be_used_here";
    DiagnosticCode[DiagnosticCode["A_rest_parameter_cannot_be_optional"] = 1047] = "A_rest_parameter_cannot_be_optional";
    DiagnosticCode[DiagnosticCode["A_rest_parameter_cannot_have_an_initializer"] = 1048] = "A_rest_parameter_cannot_have_an_initializer";
    DiagnosticCode[DiagnosticCode["A_set_accessor_must_have_exactly_one_parameter"] = 1049] = "A_set_accessor_must_have_exactly_one_parameter";
    DiagnosticCode[DiagnosticCode["A_set_accessor_parameter_cannot_have_an_initializer"] = 1052] = "A_set_accessor_parameter_cannot_have_an_initializer";
    DiagnosticCode[DiagnosticCode["A_get_accessor_cannot_have_parameters"] = 1054] = "A_get_accessor_cannot_have_parameters";
    DiagnosticCode[DiagnosticCode["Enum_member_must_have_initializer"] = 1061] = "Enum_member_must_have_initializer";
    DiagnosticCode[DiagnosticCode["Type_parameters_cannot_appear_on_a_constructor_declaration"] = 1092] = "Type_parameters_cannot_appear_on_a_constructor_declaration";
    DiagnosticCode[DiagnosticCode["Type_annotation_cannot_appear_on_a_constructor_declaration"] = 1093] = "Type_annotation_cannot_appear_on_a_constructor_declaration";
    DiagnosticCode[DiagnosticCode["An_accessor_cannot_have_type_parameters"] = 1094] = "An_accessor_cannot_have_type_parameters";
    DiagnosticCode[DiagnosticCode["A_set_accessor_cannot_have_a_return_type_annotation"] = 1095] = "A_set_accessor_cannot_have_a_return_type_annotation";
    DiagnosticCode[DiagnosticCode["Type_parameter_list_cannot_be_empty"] = 1098] = "Type_parameter_list_cannot_be_empty";
    DiagnosticCode[DiagnosticCode["A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement"] = 1104] = "A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement";
    DiagnosticCode[DiagnosticCode["A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement"] = 1105] = "A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement";
    DiagnosticCode[DiagnosticCode["A_return_statement_can_only_be_used_within_a_function_body"] = 1108] = "A_return_statement_can_only_be_used_within_a_function_body";
    DiagnosticCode[DiagnosticCode["Expression_expected"] = 1109] = "Expression_expected";
    DiagnosticCode[DiagnosticCode["Type_expected"] = 1110] = "Type_expected";
    DiagnosticCode[DiagnosticCode["A_default_clause_cannot_appear_more_than_once_in_a_switch_statement"] = 1113] = "A_default_clause_cannot_appear_more_than_once_in_a_switch_statement";
    DiagnosticCode[DiagnosticCode["Duplicate_label_0"] = 1114] = "Duplicate_label_0";
    DiagnosticCode[DiagnosticCode["An_export_assignment_cannot_have_modifiers"] = 1120] = "An_export_assignment_cannot_have_modifiers";
    DiagnosticCode[DiagnosticCode["Octal_literals_are_not_allowed_in_strict_mode"] = 1121] = "Octal_literals_are_not_allowed_in_strict_mode";
    DiagnosticCode[DiagnosticCode["Digit_expected"] = 1124] = "Digit_expected";
    DiagnosticCode[DiagnosticCode["Hexadecimal_digit_expected"] = 1125] = "Hexadecimal_digit_expected";
    DiagnosticCode[DiagnosticCode["Unexpected_end_of_text"] = 1126] = "Unexpected_end_of_text";
    DiagnosticCode[DiagnosticCode["Invalid_character"] = 1127] = "Invalid_character";
    DiagnosticCode[DiagnosticCode["_case_or_default_expected"] = 1130] = "_case_or_default_expected";
    DiagnosticCode[DiagnosticCode["_super_must_be_followed_by_an_argument_list_or_member_access"] = 1034] = "_super_must_be_followed_by_an_argument_list_or_member_access";
    DiagnosticCode[DiagnosticCode["A_declare_modifier_cannot_be_used_in_an_already_ambient_context"] = 1038] = "A_declare_modifier_cannot_be_used_in_an_already_ambient_context";
    DiagnosticCode[DiagnosticCode["Type_argument_expected"] = 1140] = "Type_argument_expected";
    DiagnosticCode[DiagnosticCode["String_literal_expected"] = 1141] = "String_literal_expected";
    DiagnosticCode[DiagnosticCode["Line_break_not_permitted_here"] = 1142] = "Line_break_not_permitted_here";
    DiagnosticCode[DiagnosticCode["Declaration_expected"] = 1146] = "Declaration_expected";
    DiagnosticCode[DiagnosticCode["_const_declarations_must_be_initialized"] = 1155] = "_const_declarations_must_be_initialized";
    DiagnosticCode[DiagnosticCode["Unterminated_regular_expression_literal"] = 1161] = "Unterminated_regular_expression_literal";
    DiagnosticCode[DiagnosticCode["Interface_declaration_cannot_have_implements_clause"] = 1176] = "Interface_declaration_cannot_have_implements_clause";
    DiagnosticCode[DiagnosticCode["Binary_digit_expected"] = 1177] = "Binary_digit_expected";
    DiagnosticCode[DiagnosticCode["Octal_digit_expected"] = 1178] = "Octal_digit_expected";
    DiagnosticCode[DiagnosticCode["An_implementation_cannot_be_declared_in_ambient_contexts"] = 1183] = "An_implementation_cannot_be_declared_in_ambient_contexts";
    DiagnosticCode[DiagnosticCode["An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive"] = 1198] = "An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive";
    DiagnosticCode[DiagnosticCode["Unterminated_Unicode_escape_sequence"] = 1199] = "Unterminated_Unicode_escape_sequence";
    DiagnosticCode[DiagnosticCode["Decorators_are_not_valid_here"] = 1206] = "Decorators_are_not_valid_here";
    DiagnosticCode[DiagnosticCode["_abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration"] = 1242] = "_abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration";
    DiagnosticCode[DiagnosticCode["Method_0_cannot_have_an_implementation_because_it_is_marked_abstract"] = 1245] = "Method_0_cannot_have_an_implementation_because_it_is_marked_abstract";
    DiagnosticCode[DiagnosticCode["A_definite_assignment_assertion_is_not_permitted_in_this_context"] = 1255] = "A_definite_assignment_assertion_is_not_permitted_in_this_context";
    DiagnosticCode[DiagnosticCode["A_class_may_only_extend_another_class"] = 1311] = "A_class_may_only_extend_another_class";
    DiagnosticCode[DiagnosticCode["A_parameter_property_cannot_be_declared_using_a_rest_parameter"] = 1317] = "A_parameter_property_cannot_be_declared_using_a_rest_parameter";
    DiagnosticCode[DiagnosticCode["Duplicate_identifier_0"] = 2300] = "Duplicate_identifier_0";
    DiagnosticCode[DiagnosticCode["Cannot_find_name_0"] = 2304] = "Cannot_find_name_0";
    DiagnosticCode[DiagnosticCode["Module_0_has_no_exported_member_1"] = 2305] = "Module_0_has_no_exported_member_1";
    DiagnosticCode[DiagnosticCode["Generic_type_0_requires_1_type_argument_s"] = 2314] = "Generic_type_0_requires_1_type_argument_s";
    DiagnosticCode[DiagnosticCode["Type_0_is_not_generic"] = 2315] = "Type_0_is_not_generic";
    DiagnosticCode[DiagnosticCode["Type_0_is_not_assignable_to_type_1"] = 2322] = "Type_0_is_not_assignable_to_type_1";
    DiagnosticCode[DiagnosticCode["Index_signature_is_missing_in_type_0"] = 2329] = "Index_signature_is_missing_in_type_0";
    DiagnosticCode[DiagnosticCode["_this_cannot_be_referenced_in_current_location"] = 2332] = "_this_cannot_be_referenced_in_current_location";
    DiagnosticCode[DiagnosticCode["_super_can_only_be_referenced_in_a_derived_class"] = 2335] = "_super_can_only_be_referenced_in_a_derived_class";
    DiagnosticCode[DiagnosticCode["Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors"] = 2337] = "Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors";
    DiagnosticCode[DiagnosticCode["Property_0_does_not_exist_on_type_1"] = 2339] = "Property_0_does_not_exist_on_type_1";
    DiagnosticCode[DiagnosticCode["Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures"] = 2349] = "Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures";
    DiagnosticCode[DiagnosticCode["This_expression_is_not_constructable"] = 2351] = "This_expression_is_not_constructable";
    DiagnosticCode[DiagnosticCode["A_function_whose_declared_type_is_not_void_must_return_a_value"] = 2355] = "A_function_whose_declared_type_is_not_void_must_return_a_value";
    DiagnosticCode[DiagnosticCode["The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access"] = 2357] = "The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access";
    DiagnosticCode[DiagnosticCode["The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access"] = 2364] = "The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access";
    DiagnosticCode[DiagnosticCode["Operator_0_cannot_be_applied_to_types_1_and_2"] = 2365] = "Operator_0_cannot_be_applied_to_types_1_and_2";
    DiagnosticCode[DiagnosticCode["A_super_call_must_be_the_first_statement_in_the_constructor"] = 2376] = "A_super_call_must_be_the_first_statement_in_the_constructor";
    DiagnosticCode[DiagnosticCode["Constructors_for_derived_classes_must_contain_a_super_call"] = 2377] = "Constructors_for_derived_classes_must_contain_a_super_call";
    DiagnosticCode[DiagnosticCode["_get_and_set_accessor_must_have_the_same_type"] = 2380] = "_get_and_set_accessor_must_have_the_same_type";
    DiagnosticCode[DiagnosticCode["Constructor_implementation_is_missing"] = 2390] = "Constructor_implementation_is_missing";
    DiagnosticCode[DiagnosticCode["Function_implementation_is_missing_or_not_immediately_following_the_declaration"] = 2391] = "Function_implementation_is_missing_or_not_immediately_following_the_declaration";
    DiagnosticCode[DiagnosticCode["Multiple_constructor_implementations_are_not_allowed"] = 2392] = "Multiple_constructor_implementations_are_not_allowed";
    DiagnosticCode[DiagnosticCode["Duplicate_function_implementation"] = 2393] = "Duplicate_function_implementation";
    DiagnosticCode[DiagnosticCode["Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local"] = 2395] = "Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local";
    DiagnosticCode[DiagnosticCode["A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged"] = 2434] = "A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged";
    DiagnosticCode[DiagnosticCode["The_type_argument_for_type_parameter_0_cannot_be_inferred_from_the_usage_Consider_specifying_the_type_arguments_explicitly"] = 2453] = "The_type_argument_for_type_parameter_0_cannot_be_inferred_from_the_usage_Consider_specifying_the_type_arguments_explicitly";
    DiagnosticCode[DiagnosticCode["Type_0_has_no_property_1"] = 2460] = "Type_0_has_no_property_1";
    DiagnosticCode[DiagnosticCode["The_0_operator_cannot_be_applied_to_type_1"] = 2469] = "The_0_operator_cannot_be_applied_to_type_1";
    DiagnosticCode[DiagnosticCode["In_const_enum_declarations_member_initializer_must_be_constant_expression"] = 2474] = "In_const_enum_declarations_member_initializer_must_be_constant_expression";
    DiagnosticCode[DiagnosticCode["Export_declaration_conflicts_with_exported_declaration_of_0"] = 2484] = "Export_declaration_conflicts_with_exported_declaration_of_0";
    DiagnosticCode[DiagnosticCode["Object_is_possibly_null"] = 2531] = "Object_is_possibly_null";
    DiagnosticCode[DiagnosticCode["Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property"] = 2540] = "Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property";
    DiagnosticCode[DiagnosticCode["The_target_of_an_assignment_must_be_a_variable_or_a_property_access"] = 2541] = "The_target_of_an_assignment_must_be_a_variable_or_a_property_access";
    DiagnosticCode[DiagnosticCode["Index_signature_in_type_0_only_permits_reading"] = 2542] = "Index_signature_in_type_0_only_permits_reading";
    DiagnosticCode[DiagnosticCode["Expected_0_arguments_but_got_1"] = 2554] = "Expected_0_arguments_but_got_1";
    DiagnosticCode[DiagnosticCode["Expected_at_least_0_arguments_but_got_1"] = 2555] = "Expected_at_least_0_arguments_but_got_1";
    DiagnosticCode[DiagnosticCode["Expected_0_type_arguments_but_got_1"] = 2558] = "Expected_0_type_arguments_but_got_1";
    DiagnosticCode[DiagnosticCode["A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums"] = 2651] = "A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums";
    DiagnosticCode[DiagnosticCode["Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration"] = 2673] = "Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration";
    DiagnosticCode[DiagnosticCode["Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration"] = 2674] = "Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration";
    DiagnosticCode[DiagnosticCode["The_this_types_of_each_signature_are_incompatible"] = 2685] = "The_this_types_of_each_signature_are_incompatible";
    DiagnosticCode[DiagnosticCode["Namespace_0_has_no_exported_member_1"] = 2694] = "Namespace_0_has_no_exported_member_1";
    DiagnosticCode[DiagnosticCode["Required_type_parameters_may_not_follow_optional_type_parameters"] = 2706] = "Required_type_parameters_may_not_follow_optional_type_parameters";
    DiagnosticCode[DiagnosticCode["Duplicate_property_0"] = 2718] = "Duplicate_property_0";
    DiagnosticCode[DiagnosticCode["Type_0_has_no_call_signatures"] = 2757] = "Type_0_has_no_call_signatures";
    DiagnosticCode[DiagnosticCode["File_0_not_found"] = 6054] = "File_0_not_found";
    DiagnosticCode[DiagnosticCode["Numeric_separators_are_not_allowed_here"] = 6188] = "Numeric_separators_are_not_allowed_here";
    DiagnosticCode[DiagnosticCode["Multiple_consecutive_numeric_separators_are_not_permitted"] = 6189] = "Multiple_consecutive_numeric_separators_are_not_permitted";
    DiagnosticCode[DiagnosticCode["_super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class"] = 17009] = "_super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class";
    DiagnosticCode[DiagnosticCode["_super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class"] = 17011] = "_super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class";
})(DiagnosticCode = exports.DiagnosticCode || (exports.DiagnosticCode = {}));
/** Translates a diagnostic code to its respective string. */
function diagnosticCodeToString(code) {
    switch (code) {
        case 100: return "Not implemented.";
        case 101: return "Operation is unsafe.";
        case 102: return "User-defined: {0}";
        case 103: return "Feature '{0}' is not enabled.";
        case 200: return "Conversion from type '{0}' to '{1}' requires an explicit cast.";
        case 201: return "Conversion from type '{0}' to '{1}' will require an explicit cast when switching between 32/64-bit.";
        case 202: return "Type '{0}' cannot be changed to type '{1}'.";
        case 203: return "Operation '{0}' cannot be applied to type '{1}'.";
        case 204: return "Basic type '{0}' cannot be nullable.";
        case 205: return "Cannot export a mutable global.";
        case 206: return "Mutable value cannot be inlined.";
        case 207: return "Unmanaged classes cannot extend managed classes and vice-versa.";
        case 208: return "Unmanaged classes cannot implement interfaces.";
        case 209: return "Invalid regular expression flags.";
        case 210: return "Expression is never 'null'.";
        case 211: return "Class '{0}' is sealed and cannot be extended.";
        case 212: return "Decorator '{0}' is not valid here.";
        case 213: return "Duplicate decorator.";
        case 214: return "Type '{0}' is illegal in this context.";
        case 215: return "Optional parameter must have an initializer.";
        case 216: return "Constructor of class '{0}' must not require any arguments.";
        case 217: return "Function '{0}' cannot be inlined into itself.";
        case 218: return "Cannot access method '{0}' without calling it as it requires 'this' to be set.";
        case 219: return "Optional properties are not supported.";
        case 220: return "Expression must be a compile-time constant.";
        case 221: return "Type '{0}' is not a function index or function reference.";
        case 222: return "'{0}' must be a value between '{1}' and '{2}' inclusive.";
        case 223: return "'{0}' must be a power of two.";
        case 224: return "'{0}' is not a valid operator.";
        case 225: return "Expression cannot be represented by a type.";
        case 1002: return "Unterminated string literal.";
        case 1003: return "Identifier expected.";
        case 1005: return "'{0}' expected.";
        case 1006: return "A file cannot have a reference to itself.";
        case 1009: return "Trailing comma not allowed.";
        case 1012: return "Unexpected token.";
        case 1014: return "A rest parameter must be last in a parameter list.";
        case 1015: return "Parameter cannot have question mark and initializer.";
        case 1016: return "A required parameter cannot follow an optional parameter.";
        case 1036: return "Statements are not allowed in ambient contexts.";
        case 1039: return "Initializers are not allowed in ambient contexts.";
        case 1042: return "'{0}' modifier cannot be used here.";
        case 1047: return "A rest parameter cannot be optional.";
        case 1048: return "A rest parameter cannot have an initializer.";
        case 1049: return "A 'set' accessor must have exactly one parameter.";
        case 1052: return "A 'set' accessor parameter cannot have an initializer.";
        case 1054: return "A 'get' accessor cannot have parameters.";
        case 1061: return "Enum member must have initializer.";
        case 1092: return "Type parameters cannot appear on a constructor declaration.";
        case 1093: return "Type annotation cannot appear on a constructor declaration.";
        case 1094: return "An accessor cannot have type parameters.";
        case 1095: return "A 'set' accessor cannot have a return type annotation.";
        case 1098: return "Type parameter list cannot be empty.";
        case 1104: return "A 'continue' statement can only be used within an enclosing iteration statement.";
        case 1105: return "A 'break' statement can only be used within an enclosing iteration or switch statement.";
        case 1108: return "A 'return' statement can only be used within a function body.";
        case 1109: return "Expression expected.";
        case 1110: return "Type expected.";
        case 1113: return "A 'default' clause cannot appear more than once in a 'switch' statement.";
        case 1114: return "Duplicate label '{0}'.";
        case 1120: return "An export assignment cannot have modifiers.";
        case 1121: return "Octal literals are not allowed in strict mode.";
        case 1124: return "Digit expected.";
        case 1125: return "Hexadecimal digit expected.";
        case 1126: return "Unexpected end of text.";
        case 1127: return "Invalid character.";
        case 1130: return "'case' or 'default' expected.";
        case 1034: return "'super' must be followed by an argument list or member access.";
        case 1038: return "A 'declare' modifier cannot be used in an already ambient context.";
        case 1140: return "Type argument expected.";
        case 1141: return "String literal expected.";
        case 1142: return "Line break not permitted here.";
        case 1146: return "Declaration expected.";
        case 1155: return "'const' declarations must be initialized.";
        case 1161: return "Unterminated regular expression literal.";
        case 1176: return "Interface declaration cannot have 'implements' clause.";
        case 1177: return "Binary digit expected.";
        case 1178: return "Octal digit expected.";
        case 1183: return "An implementation cannot be declared in ambient contexts.";
        case 1198: return "An extended Unicode escape value must be between 0x0 and 0x10FFFF inclusive.";
        case 1199: return "Unterminated Unicode escape sequence.";
        case 1206: return "Decorators are not valid here.";
        case 1242: return "'abstract' modifier can only appear on a class, method, or property declaration.";
        case 1245: return "Method '{0}' cannot have an implementation because it is marked abstract.";
        case 1255: return "A definite assignment assertion '!' is not permitted in this context.";
        case 1311: return "A class may only extend another class.";
        case 1317: return "A parameter property cannot be declared using a rest parameter.";
        case 2300: return "Duplicate identifier '{0}'.";
        case 2304: return "Cannot find name '{0}'.";
        case 2305: return "Module '{0}' has no exported member '{1}'.";
        case 2314: return "Generic type '{0}' requires {1} type argument(s).";
        case 2315: return "Type '{0}' is not generic.";
        case 2322: return "Type '{0}' is not assignable to type '{1}'.";
        case 2329: return "Index signature is missing in type '{0}'.";
        case 2332: return "'this' cannot be referenced in current location.";
        case 2335: return "'super' can only be referenced in a derived class.";
        case 2337: return "Super calls are not permitted outside constructors or in nested functions inside constructors.";
        case 2339: return "Property '{0}' does not exist on type '{1}'.";
        case 2349: return "Cannot invoke an expression whose type lacks a call signature. Type '{0}' has no compatible call signatures.";
        case 2351: return "This expression is not constructable.";
        case 2355: return "A function whose declared type is not 'void' must return a value.";
        case 2357: return "The operand of an increment or decrement operator must be a variable or a property access.";
        case 2364: return "The left-hand side of an assignment expression must be a variable or a property access.";
        case 2365: return "Operator '{0}' cannot be applied to types '{1}' and '{2}'.";
        case 2376: return "A 'super' call must be the first statement in the constructor.";
        case 2377: return "Constructors for derived classes must contain a 'super' call.";
        case 2380: return "'get' and 'set' accessor must have the same type.";
        case 2390: return "Constructor implementation is missing.";
        case 2391: return "Function implementation is missing or not immediately following the declaration.";
        case 2392: return "Multiple constructor implementations are not allowed.";
        case 2393: return "Duplicate function implementation.";
        case 2395: return "Individual declarations in merged declaration '{0}' must be all exported or all local.";
        case 2434: return "A namespace declaration cannot be located prior to a class or function with which it is merged.";
        case 2453: return "The type argument for type parameter '{0}' cannot be inferred from the usage. Consider specifying the type arguments explicitly.";
        case 2460: return "Type '{0}' has no property '{1}'.";
        case 2469: return "The '{0}' operator cannot be applied to type '{1}'.";
        case 2474: return "In 'const' enum declarations member initializer must be constant expression.";
        case 2484: return "Export declaration conflicts with exported declaration of '{0}'.";
        case 2531: return "Object is possibly 'null'.";
        case 2540: return "Cannot assign to '{0}' because it is a constant or a read-only property.";
        case 2541: return "The target of an assignment must be a variable or a property access.";
        case 2542: return "Index signature in type '{0}' only permits reading.";
        case 2554: return "Expected {0} arguments, but got {1}.";
        case 2555: return "Expected at least {0} arguments, but got {1}.";
        case 2558: return "Expected {0} type arguments, but got {1}.";
        case 2651: return "A member initializer in a enum declaration cannot reference members declared after it, including members defined in other enums.";
        case 2673: return "Constructor of class '{0}' is private and only accessible within the class declaration.";
        case 2674: return "Constructor of class '{0}' is protected and only accessible within the class declaration.";
        case 2685: return "The 'this' types of each signature are incompatible.";
        case 2694: return "Namespace '{0}' has no exported member '{1}'.";
        case 2706: return "Required type parameters may not follow optional type parameters.";
        case 2718: return "Duplicate property '{0}'.";
        case 2757: return "Type '{0}' has no call signatures.";
        case 6054: return "File '{0}' not found.";
        case 6188: return "Numeric separators are not allowed here.";
        case 6189: return "Multiple consecutive numeric separators are not permitted.";
        case 17009: return "'super' must be called before accessing 'this' in the constructor of a derived class.";
        case 17011: return "'super' must be called before accessing a property of 'super' in the constructor of a derived class.";
        default: return "";
    }
}
exports.diagnosticCodeToString = diagnosticCodeToString;


/***/ }),

/***/ "./src/diagnostics.ts":
/*!****************************!*\
  !*** ./src/diagnostics.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Shared diagnostic handling inherited by the parser and the compiler.
 * @module diagnostics
 * @preferred
 */ /***/
Object.defineProperty(exports, "__esModule", { value: true });
const diagnosticMessages_generated_1 = __webpack_require__(/*! ./diagnosticMessages.generated */ "./src/diagnosticMessages.generated.ts");
const util_1 = __webpack_require__(/*! ./util */ "./src/util/index.ts");
var diagnosticMessages_generated_2 = __webpack_require__(/*! ./diagnosticMessages.generated */ "./src/diagnosticMessages.generated.ts");
exports.DiagnosticCode = diagnosticMessages_generated_2.DiagnosticCode;
exports.diagnosticCodeToString = diagnosticMessages_generated_2.diagnosticCodeToString;
/** Indicates the category of a {@link DiagnosticMessage}. */
var DiagnosticCategory;
(function (DiagnosticCategory) {
    /** Informatory message. */
    DiagnosticCategory[DiagnosticCategory["INFO"] = 0] = "INFO";
    /** Warning message. */
    DiagnosticCategory[DiagnosticCategory["WARNING"] = 1] = "WARNING";
    /** Error message. */
    DiagnosticCategory[DiagnosticCategory["ERROR"] = 2] = "ERROR";
})(DiagnosticCategory = exports.DiagnosticCategory || (exports.DiagnosticCategory = {}));
/** Returns the string representation of the specified diagnostic category. */
function diagnosticCategoryToString(category) {
    switch (category) {
        case DiagnosticCategory.INFO: return "INFO";
        case DiagnosticCategory.WARNING: return "WARNING";
        case DiagnosticCategory.ERROR: return "ERROR";
        default: {
            assert(false);
            return "";
        }
    }
}
exports.diagnosticCategoryToString = diagnosticCategoryToString;
/** ANSI escape sequence for blue foreground. */
exports.COLOR_BLUE = "\u001b[96m";
/** ANSI escape sequence for yellow foreground. */
exports.COLOR_YELLOW = "\u001b[93m";
/** ANSI escape sequence for red foreground. */
exports.COLOR_RED = "\u001b[91m";
/** ANSI escape sequence to reset the foreground color. */
exports.COLOR_RESET = "\u001b[0m";
/** Returns the ANSI escape sequence for the specified category. */
function diagnosticCategoryToColor(category) {
    switch (category) {
        case DiagnosticCategory.INFO: return exports.COLOR_BLUE;
        case DiagnosticCategory.WARNING: return exports.COLOR_YELLOW;
        case DiagnosticCategory.ERROR: return exports.COLOR_RED;
        default: {
            assert(false);
            return "";
        }
    }
}
exports.diagnosticCategoryToColor = diagnosticCategoryToColor;
/** Represents a diagnostic message. */
class DiagnosticMessage {
    /** Constructs a new diagnostic message. */
    constructor(code, category, message) {
        /** Respective source range, if any. */
        this.range = null;
        /** Related range, if any. */
        this.relatedRange = null;
        this.code = code;
        this.category = category;
        this.message = message;
    }
    /** Creates a new diagnostic message of the specified category. */
    static create(code, category, arg0 = null, arg1 = null, arg2 = null) {
        var message = diagnosticMessages_generated_1.diagnosticCodeToString(code);
        if (arg0 != null)
            message = message.replace("{0}", arg0);
        if (arg1 != null)
            message = message.replace("{1}", arg1);
        if (arg2 != null)
            message = message.replace("{2}", arg2);
        return new DiagnosticMessage(code, category, message);
    }
    /** Creates a new informatory diagnostic message. */
    static createInfo(code, arg0 = null, arg1 = null) {
        return DiagnosticMessage.create(code, DiagnosticCategory.INFO, arg0, arg1);
    }
    /** Creates a new warning diagnostic message. */
    static createWarning(code, arg0 = null, arg1 = null) {
        return DiagnosticMessage.create(code, DiagnosticCategory.WARNING, arg0, arg1);
    }
    /** Creates a new error diagnostic message. */
    static createError(code, arg0 = null, arg1 = null) {
        return DiagnosticMessage.create(code, DiagnosticCategory.ERROR, arg0, arg1);
    }
    /** Adds a source range to this message. */
    withRange(range) {
        this.range = range;
        return this;
    }
    /** Adds a related source range to this message. */
    withRelatedRange(range) {
        this.relatedRange = range;
        return this;
    }
    /** Converts this message to a string. */
    toString() {
        if (this.range) {
            return (diagnosticCategoryToString(this.category) +
                " " +
                this.code.toString(10) +
                ": \"" +
                this.message +
                "\" in " +
                this.range.source.normalizedPath +
                ":" +
                this.range.line.toString(10) +
                ":" +
                this.range.column.toString(10));
        }
        return (diagnosticCategoryToString(this.category) +
            " " +
            this.code.toString(10) +
            ": " +
            this.message);
    }
}
exports.DiagnosticMessage = DiagnosticMessage;
/** Formats a diagnostic message, optionally with terminal colors and source context. */
function formatDiagnosticMessage(message, useColors = false, showContext = false) {
    // general information
    var sb = [];
    if (useColors)
        sb.push(diagnosticCategoryToColor(message.category));
    sb.push(diagnosticCategoryToString(message.category));
    if (useColors)
        sb.push(exports.COLOR_RESET);
    sb.push(message.code < 1000 ? " AS" : " TS");
    sb.push(message.code.toString(10));
    sb.push(": ");
    sb.push(message.message);
    // include range information if available
    if (message.range) {
        // include context information if requested
        let range = message.range;
        if (showContext) {
            sb.push("\n");
            sb.push(formatDiagnosticContext(range, useColors));
        }
        sb.push("\n");
        sb.push(" in ");
        sb.push(range.source.normalizedPath);
        sb.push("(");
        sb.push(range.line.toString(10));
        sb.push(",");
        sb.push(range.column.toString(10));
        sb.push(")");
        let relatedRange = message.relatedRange;
        if (relatedRange) {
            if (showContext) {
                sb.push("\n");
                sb.push(formatDiagnosticContext(relatedRange, useColors));
            }
            sb.push("\n");
            sb.push(" in ");
            sb.push(relatedRange.source.normalizedPath);
            sb.push("(");
            sb.push(relatedRange.line.toString(10));
            sb.push(",");
            sb.push(relatedRange.column.toString(10));
            sb.push(")");
        }
    }
    return sb.join("");
}
exports.formatDiagnosticMessage = formatDiagnosticMessage;
/** Formats the diagnostic context for the specified range, optionally with terminal colors. */
function formatDiagnosticContext(range, useColors = false) {
    var text = range.source.text;
    var len = text.length;
    var start = range.start;
    var end = range.end;
    while (start > 0 && !util_1.isLineBreak(text.charCodeAt(start - 1)))
        start--;
    while (end < len && !util_1.isLineBreak(text.charCodeAt(end)))
        end++;
    var sb = [
        "\n ",
        text.substring(start, end),
        "\n "
    ];
    while (start < range.start) {
        sb.push(" ");
        start++;
    }
    if (useColors)
        sb.push(exports.COLOR_RED);
    if (range.start == range.end) {
        sb.push("^");
    }
    else {
        while (start++ < range.end) {
            if (util_1.isLineBreak(text.charCodeAt(start))) {
                sb.push(start == range.start + 1 ? "^" : "~");
                break;
            }
            sb.push("~");
        }
    }
    if (useColors)
        sb.push(exports.COLOR_RESET);
    return sb.join("");
}
exports.formatDiagnosticContext = formatDiagnosticContext;
/** Base class of all diagnostic emitters. */
class DiagnosticEmitter {
    /** Initializes this diagnostic emitter. */
    constructor(diagnostics = null) {
        this.diagnostics = diagnostics ? diagnostics : new Array();
    }
    /** Emits a diagnostic message of the specified category. */
    emitDiagnostic(code, category, range, relatedRange, arg0 = null, arg1 = null, arg2 = null) {
        var message = DiagnosticMessage.create(code, category, arg0, arg1, arg2).withRange(range);
        if (relatedRange)
            message.relatedRange = relatedRange;
        this.diagnostics.push(message);
        // console.log(formatDiagnosticMessage(message, true, true) + "\n"); // temporary
        // console.log(<string>new Error("stack").stack);
    }
    /** Emits an informatory diagnostic message. */
    info(code, range, arg0 = null, arg1 = null, arg2 = null) {
        this.emitDiagnostic(code, DiagnosticCategory.INFO, range, null, arg0, arg1, arg2);
    }
    /** Emits an informatory diagnostic message with a related range. */
    infoRelated(code, range, relatedRange, arg0 = null, arg1 = null, arg2 = null) {
        this.emitDiagnostic(code, DiagnosticCategory.INFO, range, relatedRange, arg0, arg1, arg2);
    }
    /** Emits a warning diagnostic message. */
    warning(code, range, arg0 = null, arg1 = null, arg2 = null) {
        this.emitDiagnostic(code, DiagnosticCategory.WARNING, range, null, arg0, arg1, arg2);
    }
    /** Emits a warning diagnostic message with a related range. */
    warningRelated(code, range, relatedRange, arg0 = null, arg1 = null, arg2 = null) {
        this.emitDiagnostic(code, DiagnosticCategory.WARNING, range, relatedRange, arg0, arg1, arg2);
    }
    /** Emits an error diagnostic message. */
    error(code, range, arg0 = null, arg1 = null, arg2 = null) {
        this.emitDiagnostic(code, DiagnosticCategory.ERROR, range, null, arg0, arg1, arg2);
    }
    /** Emits an error diagnostic message with a related range. */
    errorRelated(code, range, relatedRange, arg0 = null, arg1 = null, arg2 = null) {
        this.emitDiagnostic(code, DiagnosticCategory.ERROR, range, relatedRange, arg0, arg1, arg2);
    }
}
exports.DiagnosticEmitter = DiagnosticEmitter;


/***/ }),

/***/ "./src/flow.ts":
/*!*********************!*\
  !*** ./src/flow.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * A control flow analyzer.
 * @module flow
 */ /***/
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = __webpack_require__(/*! ./types */ "./src/types.ts");
const program_1 = __webpack_require__(/*! ./program */ "./src/program.ts");
const module_1 = __webpack_require__(/*! ./module */ "./src/module.ts");
const common_1 = __webpack_require__(/*! ./common */ "./src/common.ts");
const diagnostics_1 = __webpack_require__(/*! ./diagnostics */ "./src/diagnostics.ts");
/** Control flow flags indicating specific conditions. */
var FlowFlags;
(function (FlowFlags) {
    /** No specific conditions. */
    FlowFlags[FlowFlags["NONE"] = 0] = "NONE";
    // categorical
    /** This flow returns. */
    FlowFlags[FlowFlags["RETURNS"] = 1] = "RETURNS";
    /** This flow returns a wrapped value. */
    FlowFlags[FlowFlags["RETURNS_WRAPPED"] = 2] = "RETURNS_WRAPPED";
    /** This flow returns a non-null value. */
    FlowFlags[FlowFlags["RETURNS_NONNULL"] = 4] = "RETURNS_NONNULL";
    /** This flow throws. */
    FlowFlags[FlowFlags["THROWS"] = 8] = "THROWS";
    /** This flow breaks. */
    FlowFlags[FlowFlags["BREAKS"] = 16] = "BREAKS";
    /** This flow continues. */
    FlowFlags[FlowFlags["CONTINUES"] = 32] = "CONTINUES";
    /** This flow allocates. Constructors only. */
    FlowFlags[FlowFlags["ALLOCATES"] = 64] = "ALLOCATES";
    /** This flow calls super. Constructors only. */
    FlowFlags[FlowFlags["CALLS_SUPER"] = 128] = "CALLS_SUPER";
    /** This flow terminates (returns, throws or continues). */
    FlowFlags[FlowFlags["TERMINATES"] = 256] = "TERMINATES";
    // conditional
    /** This flow conditionally returns in a child flow. */
    FlowFlags[FlowFlags["CONDITIONALLY_RETURNS"] = 512] = "CONDITIONALLY_RETURNS";
    /** This flow conditionally throws in a child flow. */
    FlowFlags[FlowFlags["CONDITIONALLY_THROWS"] = 1024] = "CONDITIONALLY_THROWS";
    /** This flow conditionally terminates in a child flow. */
    FlowFlags[FlowFlags["CONDITIONALLY_TERMINATES"] = 2048] = "CONDITIONALLY_TERMINATES";
    /** This flow conditionally breaks in a child flow. */
    FlowFlags[FlowFlags["CONDITIONALLY_BREAKS"] = 4096] = "CONDITIONALLY_BREAKS";
    /** This flow conditionally continues in a child flow. */
    FlowFlags[FlowFlags["CONDITIONALLY_CONTINUES"] = 8192] = "CONDITIONALLY_CONTINUES";
    /** This flow conditionally allocates in a child flow. Constructors only. */
    FlowFlags[FlowFlags["CONDITIONALLY_ALLOCATES"] = 16384] = "CONDITIONALLY_ALLOCATES";
    // special
    /** This is an inlining flow. */
    FlowFlags[FlowFlags["INLINE_CONTEXT"] = 32768] = "INLINE_CONTEXT";
    /** This is a flow with explicitly disabled bounds checking. */
    FlowFlags[FlowFlags["UNCHECKED_CONTEXT"] = 65536] = "UNCHECKED_CONTEXT";
    // masks
    /** Any categorical flag. */
    FlowFlags[FlowFlags["ANY_CATEGORICAL"] = 511] = "ANY_CATEGORICAL";
    /** Any conditional flag. */
    FlowFlags[FlowFlags["ANY_CONDITIONAL"] = 30208] = "ANY_CONDITIONAL";
})(FlowFlags = exports.FlowFlags || (exports.FlowFlags = {}));
/** Flags indicating the current state of a local. */
var LocalFlags;
(function (LocalFlags) {
    /** No specific conditions. */
    LocalFlags[LocalFlags["NONE"] = 0] = "NONE";
    /** Local is constant. */
    LocalFlags[LocalFlags["CONSTANT"] = 1] = "CONSTANT";
    /** Local is a function parameter. */
    LocalFlags[LocalFlags["PARAMETER"] = 2] = "PARAMETER";
    /** Local is properly wrapped. Relevant for small integers. */
    LocalFlags[LocalFlags["WRAPPED"] = 4] = "WRAPPED";
    /** Local is non-null. */
    LocalFlags[LocalFlags["NONNULL"] = 8] = "NONNULL";
    /** Local is read from. */
    LocalFlags[LocalFlags["READFROM"] = 16] = "READFROM";
    /** Local is written to. */
    LocalFlags[LocalFlags["WRITTENTO"] = 32] = "WRITTENTO";
    /** Local is retained. */
    LocalFlags[LocalFlags["RETAINED"] = 64] = "RETAINED";
    /** Local is returned. */
    LocalFlags[LocalFlags["RETURNED"] = 128] = "RETURNED";
    /** Local is conditionally read from. */
    LocalFlags[LocalFlags["CONDITIONALLY_READFROM"] = 256] = "CONDITIONALLY_READFROM";
    /** Local is conditionally written to. */
    LocalFlags[LocalFlags["CONDITIONALLY_WRITTENTO"] = 512] = "CONDITIONALLY_WRITTENTO";
    /** Local must be conditionally retained. */
    LocalFlags[LocalFlags["CONDITIONALLY_RETAINED"] = 1024] = "CONDITIONALLY_RETAINED";
    /** Local is conditionally returned. */
    LocalFlags[LocalFlags["CONDITIONALLY_RETURNED"] = 2048] = "CONDITIONALLY_RETURNED";
    /** Any categorical flag. */
    LocalFlags[LocalFlags["ANY_CATEGORICAL"] = 255] = "ANY_CATEGORICAL";
    /** Any conditional flag. */
    LocalFlags[LocalFlags["ANY_CONDITIONAL"] = 3904] = "ANY_CONDITIONAL";
    /** Any written to flag. */
    LocalFlags[LocalFlags["ANY_WRITTENTO"] = 544] = "ANY_WRITTENTO";
    /** Any retained flag. */
    LocalFlags[LocalFlags["ANY_RETAINED"] = 1088] = "ANY_RETAINED";
    /** Any returned flag. */
    LocalFlags[LocalFlags["ANY_RETURNED"] = 2176] = "ANY_RETURNED";
})(LocalFlags = exports.LocalFlags || (exports.LocalFlags = {}));
(function (LocalFlags) {
    function join(left, right) {
        return ((left & LocalFlags.ANY_CATEGORICAL) & (right & LocalFlags.ANY_CATEGORICAL))
            | (left & LocalFlags.ANY_CONDITIONAL) | (right & LocalFlags.ANY_CONDITIONAL);
    }
    LocalFlags.join = join;
})(LocalFlags = exports.LocalFlags || (exports.LocalFlags = {}));
/** Flags indicating the current state of a field. */
var FieldFlags;
(function (FieldFlags) {
    /** No specific conditions. */
    FieldFlags[FieldFlags["NONE"] = 0] = "NONE";
    /** Field is initialized. Relevant in constructors. */
    FieldFlags[FieldFlags["INITIALIZED"] = 1] = "INITIALIZED";
    /** Field is conditionally initialized. Relevant in constructors. */
    FieldFlags[FieldFlags["CONDITIONALLY_INITIALIZED"] = 2] = "CONDITIONALLY_INITIALIZED";
    /** Any categorical flag. */
    FieldFlags[FieldFlags["ANY_CATEGORICAL"] = 1] = "ANY_CATEGORICAL";
    /** Any conditional flag. */
    FieldFlags[FieldFlags["ANY_CONDITIONAL"] = 2] = "ANY_CONDITIONAL";
})(FieldFlags = exports.FieldFlags || (exports.FieldFlags = {}));
(function (FieldFlags) {
    function join(left, right) {
        return ((left & FieldFlags.ANY_CATEGORICAL) & (right & FieldFlags.ANY_CATEGORICAL))
            | (left & FieldFlags.ANY_CONDITIONAL) | (right & FieldFlags.ANY_CONDITIONAL);
    }
    FieldFlags.join = join;
})(FieldFlags = exports.FieldFlags || (exports.FieldFlags = {}));
/** A control flow evaluator. */
class Flow {
    constructor() {
        /** Scoped local variables. */
        this.scopedLocals = null;
        /** Field flags. Relevant in constructors. */
        this.fieldFlags = null;
    }
    /** Creates the parent flow of the specified function. */
    static create(parentFunction) {
        var flow = new Flow();
        flow.parent = null;
        flow.flags = 0 /* NONE */;
        flow.parentFunction = parentFunction;
        flow.continueLabel = null;
        flow.breakLabel = null;
        flow.returnType = parentFunction.signature.returnType;
        flow.contextualTypeArguments = parentFunction.contextualTypeArguments;
        flow.localFlags = [];
        flow.inlineFunction = null;
        flow.inlineReturnLabel = null;
        return flow;
    }
    /** Creates an inline flow within `parentFunction`. */
    static createInline(parentFunction, inlineFunction) {
        var flow = Flow.create(parentFunction);
        flow.set(32768 /* INLINE_CONTEXT */);
        flow.inlineFunction = inlineFunction;
        flow.inlineReturnLabel = inlineFunction.internalName + "|inlined." + (inlineFunction.nextInlineId++).toString(10);
        flow.returnType = inlineFunction.signature.returnType;
        flow.contextualTypeArguments = inlineFunction.contextualTypeArguments;
        return flow;
    }
    /** Gets the actual function being compiled, The inlined function when inlining, otherwise the parent function. */
    get actualFunction() {
        return this.inlineFunction || this.parentFunction;
    }
    /** Tests if this flow has the specified flag or flags. */
    is(flag) { return (this.flags & flag) == flag; }
    /** Tests if this flow has one of the specified flags. */
    isAny(flag) { return (this.flags & flag) != 0; }
    /** Sets the specified flag or flags. */
    set(flag) { this.flags |= flag; }
    /** Unsets the specified flag or flags. */
    unset(flag) { this.flags &= ~flag; }
    /** Forks this flow to a child flow. */
    fork() {
        var branch = new Flow();
        branch.parent = this;
        branch.flags = this.flags;
        branch.parentFunction = this.parentFunction;
        branch.continueLabel = this.continueLabel;
        branch.breakLabel = this.breakLabel;
        branch.returnType = this.returnType;
        branch.contextualTypeArguments = this.contextualTypeArguments;
        branch.localFlags = this.localFlags.slice();
        branch.inlineFunction = this.inlineFunction;
        branch.inlineReturnLabel = this.inlineReturnLabel;
        return branch;
    }
    /** Gets a free temporary local of the specified type. */
    getTempLocal(type, except = null) {
        var parentFunction = this.parentFunction;
        var temps;
        switch (type.toNativeType()) {
            case module_1.NativeType.I32: {
                temps = parentFunction.tempI32s;
                break;
            }
            case module_1.NativeType.I64: {
                temps = parentFunction.tempI64s;
                break;
            }
            case module_1.NativeType.F32: {
                temps = parentFunction.tempF32s;
                break;
            }
            case module_1.NativeType.F64: {
                temps = parentFunction.tempF64s;
                break;
            }
            case module_1.NativeType.V128: {
                temps = parentFunction.tempV128s;
                break;
            }
            case module_1.NativeType.Anyref: {
                temps = parentFunction.tempAnyrefs;
                break;
            }
            default: throw new Error("concrete type expected");
        }
        var local;
        if (except) {
            if (temps && temps.length) {
                for (let i = 0, k = temps.length; i < k; ++i) {
                    if (!except.has(temps[i].index)) {
                        local = temps[i];
                        let k = temps.length - 1;
                        while (i < k)
                            unchecked(temps[i] = temps[i++ + 1]);
                        temps.length = k;
                        local.type = type;
                        local.flags = common_1.CommonFlags.NONE;
                        this.unsetLocalFlag(local.index, ~0);
                        return local;
                    }
                }
            }
            local = parentFunction.addLocal(type);
        }
        else {
            if (temps && temps.length) {
                local = temps.pop();
                local.type = type;
                local.flags = common_1.CommonFlags.NONE;
            }
            else {
                local = parentFunction.addLocal(type);
            }
        }
        this.unsetLocalFlag(local.index, ~0);
        return local;
    }
    /** Gets a local that sticks around until this flow is exited, and then released. */
    getAutoreleaseLocal(type, except = null) {
        var local = this.getTempLocal(type, except);
        local.set(common_1.CommonFlags.SCOPED);
        var scopedLocals = this.scopedLocals;
        if (!scopedLocals)
            this.scopedLocals = scopedLocals = new Map();
        scopedLocals.set("~auto" + (this.parentFunction.nextAutoreleaseId++), local);
        this.setLocalFlag(local.index, LocalFlags.RETAINED);
        return local;
    }
    /** Frees the temporary local for reuse. */
    freeTempLocal(local) {
        if (local.is(common_1.CommonFlags.INLINED))
            return;
        assert(local.index >= 0);
        var parentFunction = this.parentFunction;
        var temps;
        assert(local.type != null); // internal error
        switch (local.type.toNativeType()) {
            case module_1.NativeType.I32: {
                temps = parentFunction.tempI32s || (parentFunction.tempI32s = []);
                break;
            }
            case module_1.NativeType.I64: {
                temps = parentFunction.tempI64s || (parentFunction.tempI64s = []);
                break;
            }
            case module_1.NativeType.F32: {
                temps = parentFunction.tempF32s || (parentFunction.tempF32s = []);
                break;
            }
            case module_1.NativeType.F64: {
                temps = parentFunction.tempF64s || (parentFunction.tempF64s = []);
                break;
            }
            case module_1.NativeType.V128: {
                temps = parentFunction.tempV128s || (parentFunction.tempV128s = []);
                break;
            }
            case module_1.NativeType.Anyref: {
                temps = parentFunction.tempAnyrefs || (parentFunction.tempAnyrefs = []);
                break;
            }
            default: throw new Error("concrete type expected");
        }
        assert(local.index >= 0);
        temps.push(local);
    }
    /** Gets the scoped local of the specified name. */
    getScopedLocal(name) {
        var scopedLocals = this.scopedLocals;
        if (scopedLocals && scopedLocals.has(name))
            return scopedLocals.get(name);
        return null;
    }
    /** Adds a new scoped local of the specified name. */
    addScopedLocal(name, type, except = null) {
        var scopedLocal = this.getTempLocal(type, except);
        var scopedLocals = this.scopedLocals;
        if (!scopedLocals)
            this.scopedLocals = scopedLocals = new Map();
        else
            assert(!scopedLocals.has(name));
        scopedLocal.set(common_1.CommonFlags.SCOPED);
        scopedLocals.set(name, scopedLocal);
        return scopedLocal;
    }
    /** Adds a new scoped alias for the specified local. For example `super` aliased to the `this` local. */
    addScopedAlias(name, type, index, reportNode = null) {
        if (!this.scopedLocals)
            this.scopedLocals = new Map();
        else {
            let existingLocal = this.scopedLocals.get(name);
            if (existingLocal) {
                if (reportNode) {
                    if (!existingLocal.declaration.range.source.isNative) {
                        this.parentFunction.program.errorRelated(diagnostics_1.DiagnosticCode.Duplicate_identifier_0, reportNode.range, existingLocal.declaration.name.range, name);
                    }
                    else {
                        this.parentFunction.program.error(diagnostics_1.DiagnosticCode.Duplicate_identifier_0, reportNode.range, name);
                    }
                }
                return existingLocal;
            }
        }
        assert(index < this.parentFunction.localsByIndex.length);
        var scopedAlias = new program_1.Local(name, index, type, this.parentFunction);
        // not flagged as SCOPED as it must not be free'd when the flow is finalized
        this.scopedLocals.set(name, scopedAlias);
        return scopedAlias;
    }
    /** Tests if this flow has any scoped locals that must be free'd. */
    get hasScopedLocals() {
        if (this.scopedLocals) {
            for (let scopedLocal of this.scopedLocals.values()) {
                if (scopedLocal.is(common_1.CommonFlags.SCOPED)) { // otherwise an alias
                    return true;
                }
            }
        }
        return false;
    }
    /** Frees this flow's scoped variables and returns its parent flow. */
    freeScopedLocals() {
        if (this.scopedLocals) {
            for (let scopedLocal of this.scopedLocals.values()) {
                if (scopedLocal.is(common_1.CommonFlags.SCOPED)) { // otherwise an alias
                    this.freeTempLocal(scopedLocal);
                }
            }
            this.scopedLocals = null;
        }
    }
    /** Looks up the local of the specified name in the current scope. */
    lookupLocal(name) {
        var current = this;
        var scope;
        do
            if ((scope = current.scopedLocals) && (scope.has(name)))
                return scope.get(name);
        while (current = current.parent);
        return this.parentFunction.localsByName.get(name);
    }
    /** Looks up the element with the specified name relative to the scope of this flow. */
    lookup(name) {
        var element = this.lookupLocal(name);
        if (element)
            return element;
        return this.actualFunction.lookup(name);
    }
    /** Tests if the local at the specified index has the specified flag or flags. */
    isLocalFlag(index, flag, defaultIfInlined = true) {
        if (index < 0)
            return defaultIfInlined;
        var localFlags = this.localFlags;
        return index < localFlags.length && (unchecked(this.localFlags[index]) & flag) == flag;
    }
    /** Tests if the local at the specified index has any of the specified flags. */
    isAnyLocalFlag(index, flag, defaultIfInlined = true) {
        if (index < 0)
            return defaultIfInlined;
        var localFlags = this.localFlags;
        return index < localFlags.length && (unchecked(this.localFlags[index]) & flag) != 0;
    }
    /** Sets the specified flag or flags on the local at the specified index. */
    setLocalFlag(index, flag) {
        if (index < 0)
            return;
        var localFlags = this.localFlags;
        var flags = index < localFlags.length ? unchecked(localFlags[index]) : 0;
        this.localFlags[index] = flags | flag;
    }
    /** Unsets the specified flag or flags on the local at the specified index. */
    unsetLocalFlag(index, flag) {
        if (index < 0)
            return;
        var localFlags = this.localFlags;
        var flags = index < localFlags.length ? unchecked(localFlags[index]) : 0;
        this.localFlags[index] = flags & ~flag;
    }
    /** Pushes a new break label to the stack, for example when entering a loop that one can `break` from. */
    pushBreakLabel() {
        var parentFunction = this.parentFunction;
        var id = parentFunction.nextBreakId++;
        var stack = parentFunction.breakStack;
        if (!stack)
            parentFunction.breakStack = [id];
        else
            stack.push(id);
        return parentFunction.breakLabel = id.toString(10);
    }
    /** Pops the most recent break label from the stack. */
    popBreakLabel() {
        var parentFunction = this.parentFunction;
        var stack = assert(parentFunction.breakStack);
        var length = assert(stack.length);
        stack.pop();
        if (length > 1) {
            parentFunction.breakLabel = stack[length - 2].toString(10);
        }
        else {
            parentFunction.breakLabel = null;
            parentFunction.breakStack = null;
        }
    }
    /** Inherits flags and local wrap states from the specified flow (e.g. blocks). */
    inherit(other) {
        this.flags |= other.flags & (511 /* ANY_CATEGORICAL */ | 30208 /* ANY_CONDITIONAL */);
        this.localFlags = other.localFlags; // no need to slice because other flow is finished
    }
    /** Inherits categorical flags as conditional flags from the specified flow (e.g. then without else). */
    inheritConditional(other) {
        this.set(other.flags & 30208 /* ANY_CONDITIONAL */);
        if (other.is(1 /* RETURNS */)) {
            this.set(512 /* CONDITIONALLY_RETURNS */);
        }
        if (other.is(8 /* THROWS */)) {
            this.set(1024 /* CONDITIONALLY_THROWS */);
        }
        if (other.is(16 /* BREAKS */) && other.breakLabel == this.breakLabel) {
            this.set(4096 /* CONDITIONALLY_BREAKS */);
        }
        if (other.is(32 /* CONTINUES */) && other.continueLabel == this.continueLabel) {
            this.set(8192 /* CONDITIONALLY_CONTINUES */);
        }
        if (other.is(64 /* ALLOCATES */)) {
            this.set(16384 /* CONDITIONALLY_ALLOCATES */);
        }
        var localFlags = other.localFlags;
        for (let i = 0, k = localFlags.length; i < k; ++i) {
            let flags = localFlags[i];
            this.setLocalFlag(i, flags & LocalFlags.ANY_CONDITIONAL);
            if (flags & LocalFlags.RETAINED)
                this.setLocalFlag(i, LocalFlags.CONDITIONALLY_RETAINED);
            if (flags & LocalFlags.READFROM)
                this.setLocalFlag(i, LocalFlags.CONDITIONALLY_READFROM);
            if (flags & LocalFlags.WRITTENTO)
                this.setLocalFlag(i, LocalFlags.CONDITIONALLY_WRITTENTO);
            if (flags & LocalFlags.RETURNED)
                this.setLocalFlag(i, LocalFlags.CONDITIONALLY_RETURNED);
        }
    }
    /** Inherits mutual flags and local wrap states from the specified flows (e.g. then with else). */
    inheritMutual(left, right) {
        // categorical flags set in both arms
        this.set(left.flags & right.flags & 511 /* ANY_CATEGORICAL */);
        // conditional flags set in any arm
        this.set(left.flags & 30208 /* ANY_CONDITIONAL */);
        this.set(right.flags & 30208 /* ANY_CONDITIONAL */);
        // categorical flags in either arm as conditional
        this.inheritConditional(left);
        this.inheritConditional(right);
        // categorical local flags set in both arms / conditional local flags set in at least one arm
        var leftLocalFlags = left.localFlags;
        var numLeftLocalFlags = leftLocalFlags.length;
        var rightLocalFlags = right.localFlags;
        var numRightLocalFlags = rightLocalFlags.length;
        var combinedFlags = new Array(max(numLeftLocalFlags, numRightLocalFlags));
        for (let i = 0; i < numLeftLocalFlags; ++i) {
            combinedFlags[i] = LocalFlags.join(unchecked(leftLocalFlags[i]), i < numRightLocalFlags
                ? unchecked(rightLocalFlags[i])
                : 0);
        }
        for (let i = numLeftLocalFlags; i < numRightLocalFlags; ++i) {
            combinedFlags[i] = LocalFlags.join(0, unchecked(rightLocalFlags[i]));
        }
        this.localFlags = combinedFlags;
    }
    /** Unifies local flags between this and the other flow. */
    unifyLocalFlags(other) {
        var numThisLocalFlags = this.localFlags.length;
        var numOtherLocalFlags = other.localFlags.length;
        for (let i = 0, k = min(numThisLocalFlags, numOtherLocalFlags); i < k; ++i) {
            if (this.isLocalFlag(i, LocalFlags.WRAPPED) != other.isLocalFlag(i, LocalFlags.WRAPPED)) {
                this.unsetLocalFlag(i, LocalFlags.WRAPPED); // assume not wrapped
            }
            if (this.isLocalFlag(i, LocalFlags.NONNULL) != other.isLocalFlag(i, LocalFlags.NONNULL)) {
                this.unsetLocalFlag(i, LocalFlags.NONNULL); // assume possibly null
            }
            assert(
            // having different retain states would be a problem because the compiler
            // either can't release a retained local or would release a non-retained local
            this.isAnyLocalFlag(i, LocalFlags.ANY_RETAINED) == other.isAnyLocalFlag(i, LocalFlags.ANY_RETAINED));
        }
    }
    /** Checks if an expression of the specified type is known to be non-null, even if the type might be nullable. */
    isNonnull(expr, type) {
        if (!type.is(512 /* NULLABLE */))
            return true;
        // below, only teeLocal/getLocal are relevant because these are the only expressions that
        // depend on a dynamic nullable state (flag = LocalFlags.NONNULL), while everything else
        // has already been handled by the nullable type check above.
        switch (module_1.getExpressionId(expr)) {
            case module_1.ExpressionId.LocalSet: {
                if (!module_1.isLocalTee(expr))
                    break;
                let local = this.parentFunction.localsByIndex[module_1.getLocalSetIndex(expr)];
                return !local.type.is(512 /* NULLABLE */) || this.isLocalFlag(local.index, LocalFlags.NONNULL, false);
            }
            case module_1.ExpressionId.LocalGet: {
                let local = this.parentFunction.localsByIndex[module_1.getLocalGetIndex(expr)];
                return !local.type.is(512 /* NULLABLE */) || this.isLocalFlag(local.index, LocalFlags.NONNULL, false);
            }
        }
        return false;
    }
    /** Updates local states to reflect that this branch is only taken when `expr` is true-ish. */
    inheritNonnullIfTrue(expr) {
        // A: `expr` is true-ish -> Q: how did that happen?
        switch (module_1.getExpressionId(expr)) {
            case module_1.ExpressionId.LocalSet: {
                if (!module_1.isLocalTee(expr))
                    break;
                let local = this.parentFunction.localsByIndex[module_1.getLocalSetIndex(expr)];
                this.setLocalFlag(local.index, LocalFlags.NONNULL);
                this.inheritNonnullIfTrue(module_1.getLocalSetValue(expr)); // must have been true-ish as well
                break;
            }
            case module_1.ExpressionId.LocalGet: {
                let local = this.parentFunction.localsByIndex[module_1.getLocalGetIndex(expr)];
                this.setLocalFlag(local.index, LocalFlags.NONNULL);
                break;
            }
            case module_1.ExpressionId.If: {
                let ifFalse = module_1.getIfFalse(expr);
                if (!ifFalse)
                    break;
                if (module_1.getExpressionId(ifFalse) == module_1.ExpressionId.Const) {
                    // Logical AND: (if (condition ifTrue 0))
                    // the only way this had become true is if condition and ifTrue are true
                    if ((module_1.getExpressionType(ifFalse) == module_1.NativeType.I32 && module_1.getConstValueI32(ifFalse) == 0) ||
                        (module_1.getExpressionType(ifFalse) == module_1.NativeType.I64 && module_1.getConstValueI64Low(ifFalse) == 0 && module_1.getConstValueI64High(ifFalse) == 0)) {
                        this.inheritNonnullIfTrue(module_1.getIfCondition(expr));
                        this.inheritNonnullIfTrue(module_1.getIfTrue(expr));
                    }
                }
                break;
            }
            case module_1.ExpressionId.Unary: {
                switch (module_1.getUnaryOp(expr)) {
                    case module_1.UnaryOp.EqzI32:
                    case module_1.UnaryOp.EqzI64: {
                        this.inheritNonnullIfFalse(module_1.getUnaryValue(expr)); // !value -> value must have been false
                        break;
                    }
                }
                break;
            }
            case module_1.ExpressionId.Binary: {
                switch (module_1.getBinaryOp(expr)) {
                    case module_1.BinaryOp.EqI32: {
                        let left = module_1.getBinaryLeft(expr);
                        let right = module_1.getBinaryRight(expr);
                        if (module_1.getExpressionId(left) == module_1.ExpressionId.Const && module_1.getConstValueI32(left) != 0) {
                            this.inheritNonnullIfTrue(right); // TRUE == right -> right must have been true
                        }
                        else if (module_1.getExpressionId(right) == module_1.ExpressionId.Const && module_1.getConstValueI32(right) != 0) {
                            this.inheritNonnullIfTrue(left); // left == TRUE -> left must have been true
                        }
                        break;
                    }
                    case module_1.BinaryOp.EqI64: {
                        let left = module_1.getBinaryLeft(expr);
                        let right = module_1.getBinaryRight(expr);
                        if (module_1.getExpressionId(left) == module_1.ExpressionId.Const && (module_1.getConstValueI64Low(left) != 0 || module_1.getConstValueI64High(left) != 0)) {
                            this.inheritNonnullIfTrue(right); // TRUE == right -> right must have been true
                        }
                        else if (module_1.getExpressionId(right) == module_1.ExpressionId.Const && (module_1.getConstValueI64Low(right) != 0 && module_1.getConstValueI64High(right) != 0)) {
                            this.inheritNonnullIfTrue(left); // left == TRUE -> left must have been true
                        }
                        break;
                    }
                    case module_1.BinaryOp.NeI32: {
                        let left = module_1.getBinaryLeft(expr);
                        let right = module_1.getBinaryRight(expr);
                        if (module_1.getExpressionId(left) == module_1.ExpressionId.Const && module_1.getConstValueI32(left) == 0) {
                            this.inheritNonnullIfTrue(right); // FALSE != right -> right must have been true
                        }
                        else if (module_1.getExpressionId(right) == module_1.ExpressionId.Const && module_1.getConstValueI32(right) == 0) {
                            this.inheritNonnullIfTrue(left); // left != FALSE -> left must have been true
                        }
                        break;
                    }
                    case module_1.BinaryOp.NeI64: {
                        let left = module_1.getBinaryLeft(expr);
                        let right = module_1.getBinaryRight(expr);
                        if (module_1.getExpressionId(left) == module_1.ExpressionId.Const && module_1.getConstValueI64Low(left) == 0 && module_1.getConstValueI64High(left) == 0) {
                            this.inheritNonnullIfTrue(right); // FALSE != right -> right must have been true
                        }
                        else if (module_1.getExpressionId(right) == module_1.ExpressionId.Const && module_1.getConstValueI64Low(right) == 0 && module_1.getConstValueI64High(right) == 0) {
                            this.inheritNonnullIfTrue(left); // left != FALSE -> left must have been true
                        }
                        break;
                    }
                }
                break;
            }
            case module_1.ExpressionId.Call: {
                let name = module_1.getCallTarget(expr);
                let program = this.parentFunction.program;
                switch (name) {
                    case program.retainInstance.internalName: {
                        this.inheritNonnullIfTrue(module_1.getCallOperand(expr, 0));
                        break;
                    }
                }
                break;
            }
        }
    }
    /** Updates local states to reflect that this branch is only taken when `expr` is false-ish. */
    inheritNonnullIfFalse(expr) {
        // A: `expr` is false-ish -> Q: how did that happen?
        switch (module_1.getExpressionId(expr)) {
            case module_1.ExpressionId.Unary: {
                switch (module_1.getUnaryOp(expr)) {
                    case module_1.UnaryOp.EqzI32:
                    case module_1.UnaryOp.EqzI64: {
                        this.inheritNonnullIfTrue(module_1.getUnaryValue(expr)); // !value -> value must have been true
                        break;
                    }
                }
                break;
            }
            case module_1.ExpressionId.If: {
                let ifTrue = module_1.getIfTrue(expr);
                if (module_1.getExpressionId(ifTrue) == module_1.ExpressionId.Const) {
                    let ifFalse = module_1.getIfFalse(expr);
                    if (!ifFalse)
                        break;
                    // Logical OR: (if (condition 1 ifFalse))
                    // the only way this had become false is if condition and ifFalse are false
                    if ((module_1.getExpressionType(ifTrue) == module_1.NativeType.I32 && module_1.getConstValueI32(ifTrue) != 0) ||
                        (module_1.getExpressionType(ifTrue) == module_1.NativeType.I64 && (module_1.getConstValueI64Low(ifTrue) != 0 || module_1.getConstValueI64High(ifTrue) != 0))) {
                        this.inheritNonnullIfFalse(module_1.getIfCondition(expr));
                        this.inheritNonnullIfFalse(module_1.getIfFalse(expr));
                    }
                }
                break;
            }
            case module_1.ExpressionId.Binary: {
                switch (module_1.getBinaryOp(expr)) {
                    // remember: we want to know how the _entire_ expression became FALSE (!)
                    case module_1.BinaryOp.EqI32: {
                        let left = module_1.getBinaryLeft(expr);
                        let right = module_1.getBinaryRight(expr);
                        if (module_1.getExpressionId(left) == module_1.ExpressionId.Const && module_1.getConstValueI32(left) == 0) {
                            this.inheritNonnullIfTrue(right); // FALSE == right -> right must have been true
                        }
                        else if (module_1.getExpressionId(right) == module_1.ExpressionId.Const && module_1.getConstValueI32(right) == 0) {
                            this.inheritNonnullIfTrue(left); // left == FALSE -> left must have been true
                        }
                        break;
                    }
                    case module_1.BinaryOp.EqI64: {
                        let left = module_1.getBinaryLeft(expr);
                        let right = module_1.getBinaryRight(expr);
                        if (module_1.getExpressionId(left) == module_1.ExpressionId.Const && module_1.getConstValueI64Low(left) == 0 && module_1.getConstValueI64High(left) == 0) {
                            this.inheritNonnullIfTrue(right); // FALSE == right -> right must have been true
                        }
                        else if (module_1.getExpressionId(right) == module_1.ExpressionId.Const && module_1.getConstValueI64Low(right) == 0 && module_1.getConstValueI64High(right) == 0) {
                            this.inheritNonnullIfTrue(left); // left == FALSE -> left must have been true
                        }
                        break;
                    }
                    case module_1.BinaryOp.NeI32: {
                        let left = module_1.getBinaryLeft(expr);
                        let right = module_1.getBinaryRight(expr);
                        if (module_1.getExpressionId(left) == module_1.ExpressionId.Const && module_1.getConstValueI32(left) != 0) {
                            this.inheritNonnullIfTrue(right); // TRUE != right -> right must have been true
                        }
                        else if (module_1.getExpressionId(right) == module_1.ExpressionId.Const && module_1.getConstValueI32(right) != 0) {
                            this.inheritNonnullIfTrue(left); // left != TRUE -> left must have been true
                        }
                        break;
                    }
                    case module_1.BinaryOp.NeI64: {
                        let left = module_1.getBinaryLeft(expr);
                        let right = module_1.getBinaryRight(expr);
                        if (module_1.getExpressionId(left) == module_1.ExpressionId.Const && (module_1.getConstValueI64Low(left) != 0 || module_1.getConstValueI64High(left) != 0)) {
                            this.inheritNonnullIfTrue(right); // TRUE != right -> right must have been true for this to become false
                        }
                        else if (module_1.getExpressionId(right) == module_1.ExpressionId.Const && (module_1.getConstValueI64Low(right) != 0 || module_1.getConstValueI64High(right) != 0)) {
                            this.inheritNonnullIfTrue(left); // left != TRUE -> left must have been true for this to become false
                        }
                        break;
                    }
                }
                break;
            }
        }
    }
    /**
     * Tests if an expression can possibly overflow in the context of this flow. Assumes that the
     * expression might already have overflown and returns `false` only if the operation neglects
     * any possible combination of garbage bits being present.
     */
    canOverflow(expr, type) {
        // TODO: the following catches most common and a few uncommon cases, but there are additional
        // opportunities here, obviously.
        assert(type != types_1.Type.void);
        // types other than i8, u8, i16, u16 and bool do not overflow
        if (!type.is(32 /* SHORT */ | 4 /* INTEGER */))
            return false;
        var operand;
        switch (module_1.getExpressionId(expr)) {
            // overflows if the local isn't wrapped or the conversion does
            case module_1.ExpressionId.LocalGet: {
                let local = this.parentFunction.localsByIndex[module_1.getLocalGetIndex(expr)];
                return !this.isLocalFlag(local.index, LocalFlags.WRAPPED, true)
                    || canConversionOverflow(local.type, type);
            }
            // overflows if the value does
            case module_1.ExpressionId.LocalSet: { // tee
                assert(module_1.isLocalTee(expr));
                return this.canOverflow(module_1.getLocalSetValue(expr), type);
            }
            // overflows if the conversion does (globals are wrapped on set)
            case module_1.ExpressionId.GlobalGet: {
                // TODO: this is inefficient because it has to read a string
                let global = assert(this.parentFunction.program.elementsByName.get(assert(module_1.getGlobalGetName(expr))));
                assert(global.kind == program_1.ElementKind.GLOBAL);
                return canConversionOverflow(assert(global.type), type);
            }
            case module_1.ExpressionId.Binary: {
                switch (module_1.getBinaryOp(expr)) {
                    // comparisons do not overflow (result is 0 or 1)
                    case module_1.BinaryOp.EqI32:
                    case module_1.BinaryOp.EqI64:
                    case module_1.BinaryOp.EqF32:
                    case module_1.BinaryOp.EqF64:
                    case module_1.BinaryOp.NeI32:
                    case module_1.BinaryOp.NeI64:
                    case module_1.BinaryOp.NeF32:
                    case module_1.BinaryOp.NeF64:
                    case module_1.BinaryOp.LtI32:
                    case module_1.BinaryOp.LtU32:
                    case module_1.BinaryOp.LtI64:
                    case module_1.BinaryOp.LtU64:
                    case module_1.BinaryOp.LtF32:
                    case module_1.BinaryOp.LtF64:
                    case module_1.BinaryOp.LeI32:
                    case module_1.BinaryOp.LeU32:
                    case module_1.BinaryOp.LeI64:
                    case module_1.BinaryOp.LeU64:
                    case module_1.BinaryOp.LeF32:
                    case module_1.BinaryOp.LeF64:
                    case module_1.BinaryOp.GtI32:
                    case module_1.BinaryOp.GtU32:
                    case module_1.BinaryOp.GtI64:
                    case module_1.BinaryOp.GtU64:
                    case module_1.BinaryOp.GtF32:
                    case module_1.BinaryOp.GtF64:
                    case module_1.BinaryOp.GeI32:
                    case module_1.BinaryOp.GeU32:
                    case module_1.BinaryOp.GeI64:
                    case module_1.BinaryOp.GeU64:
                    case module_1.BinaryOp.GeF32:
                    case module_1.BinaryOp.GeF64: return false;
                    // result won't overflow if one side is 0 or if one side is 1 and the other wrapped
                    case module_1.BinaryOp.MulI32: {
                        return !((module_1.getExpressionId(operand = module_1.getBinaryLeft(expr)) == module_1.ExpressionId.Const &&
                            (module_1.getConstValueI32(operand) == 0 ||
                                (module_1.getConstValueI32(operand) == 1 &&
                                    !this.canOverflow(module_1.getBinaryRight(expr), type)))) || (module_1.getExpressionId(operand = module_1.getBinaryRight(expr)) == module_1.ExpressionId.Const &&
                            (module_1.getConstValueI32(operand) == 0 ||
                                (module_1.getConstValueI32(operand) == 1 &&
                                    !this.canOverflow(module_1.getBinaryLeft(expr), type)))));
                    }
                    // result won't overflow if one side is a constant less than this type's mask or one side
                    // is wrapped
                    case module_1.BinaryOp.AndI32: {
                        // note that computeSmallIntegerMask returns the mask minus the MSB for signed types
                        // because signed value garbage bits must be guaranteed to be equal to the MSB.
                        return !(((module_1.getExpressionId(operand = module_1.getBinaryLeft(expr)) == module_1.ExpressionId.Const &&
                            module_1.getConstValueI32(operand) <= type.computeSmallIntegerMask(types_1.Type.i32)) || !this.canOverflow(operand, type)) || ((module_1.getExpressionId(operand = module_1.getBinaryRight(expr)) == module_1.ExpressionId.Const &&
                            module_1.getConstValueI32(operand) <= type.computeSmallIntegerMask(types_1.Type.i32)) || !this.canOverflow(operand, type)));
                    }
                    // overflows if the shift doesn't clear potential garbage bits
                    case module_1.BinaryOp.ShlI32: {
                        let shift = 32 - type.size;
                        return module_1.getExpressionId(operand = module_1.getBinaryRight(expr)) != module_1.ExpressionId.Const
                            || module_1.getConstValueI32(operand) < shift;
                    }
                    // overflows if the value does and the shift doesn't clear potential garbage bits
                    case module_1.BinaryOp.ShrI32: {
                        let shift = 32 - type.size;
                        return this.canOverflow(module_1.getBinaryLeft(expr), type) && (module_1.getExpressionId(operand = module_1.getBinaryRight(expr)) != module_1.ExpressionId.Const ||
                            module_1.getConstValueI32(operand) < shift);
                    }
                    // overflows if the shift does not clear potential garbage bits. if an unsigned value is
                    // wrapped, it can't overflow.
                    case module_1.BinaryOp.ShrU32: {
                        let shift = 32 - type.size;
                        return type.is(1 /* SIGNED */)
                            ? !(module_1.getExpressionId(operand = module_1.getBinaryRight(expr)) == module_1.ExpressionId.Const &&
                                module_1.getConstValueI32(operand) > shift // must clear MSB
                            )
                            : this.canOverflow(module_1.getBinaryLeft(expr), type) && !(module_1.getExpressionId(operand = module_1.getBinaryRight(expr)) == module_1.ExpressionId.Const &&
                                module_1.getConstValueI32(operand) >= shift // can leave MSB
                            );
                    }
                    // overflows if any side does
                    case module_1.BinaryOp.DivU32:
                    case module_1.BinaryOp.RemI32:
                    case module_1.BinaryOp.RemU32: {
                        return this.canOverflow(module_1.getBinaryLeft(expr), type)
                            || this.canOverflow(module_1.getBinaryRight(expr), type);
                    }
                }
                break;
            }
            case module_1.ExpressionId.Unary: {
                switch (module_1.getUnaryOp(expr)) {
                    // comparisons do not overflow (result is 0 or 1)
                    case module_1.UnaryOp.EqzI32:
                    case module_1.UnaryOp.EqzI64: return false;
                    // overflow if the maximum result (32) cannot be represented in the target type
                    case module_1.UnaryOp.ClzI32:
                    case module_1.UnaryOp.CtzI32:
                    case module_1.UnaryOp.PopcntI32: return type.size < 7;
                }
                break;
            }
            // overflows if the value cannot be represented in the target type
            case module_1.ExpressionId.Const: {
                let value = 0;
                switch (module_1.getExpressionType(expr)) {
                    case module_1.NativeType.I32: {
                        value = module_1.getConstValueI32(expr);
                        break;
                    }
                    case module_1.NativeType.I64: {
                        value = module_1.getConstValueI64Low(expr);
                        break;
                    } // discards upper bits
                    case module_1.NativeType.F32: {
                        value = i32(module_1.getConstValueF32(expr));
                        break;
                    }
                    case module_1.NativeType.F64: {
                        value = i32(module_1.getConstValueF64(expr));
                        break;
                    }
                    default: assert(false);
                }
                switch (type.kind) {
                    case 0 /* I8 */: return value < i8.MIN_VALUE || value > i8.MAX_VALUE;
                    case 1 /* I16 */: return value < i16.MIN_VALUE || value > i16.MAX_VALUE;
                    case 5 /* U8 */: return value < 0 || value > u8.MAX_VALUE;
                    case 6 /* U16 */: return value < 0 || value > u16.MAX_VALUE;
                    case 10 /* BOOL */: return (value & ~1) != 0;
                }
                break;
            }
            // overflows if the conversion does
            case module_1.ExpressionId.Load: {
                let fromType;
                let signed = module_1.isLoadSigned(expr);
                switch (module_1.getLoadBytes(expr)) {
                    case 1: {
                        fromType = signed ? types_1.Type.i8 : types_1.Type.u8;
                        break;
                    }
                    case 2: {
                        fromType = signed ? types_1.Type.i16 : types_1.Type.u16;
                        break;
                    }
                    default: {
                        fromType = signed ? types_1.Type.i32 : types_1.Type.u32;
                        break;
                    }
                }
                return canConversionOverflow(fromType, type);
            }
            // overflows if the result does, which is either
            // - the last expression of the block, by contract, if the block doesn't have a label
            // - the last expression or the value of an inner br if the block has a label (TODO)
            case module_1.ExpressionId.Block: {
                if (!module_1.getBlockName(expr)) {
                    let size = assert(module_1.getBlockChildCount(expr));
                    let last = module_1.getBlockChild(expr, size - 1);
                    return this.canOverflow(last, type);
                }
                break;
            }
            // overflows if either side does
            case module_1.ExpressionId.If: {
                return this.canOverflow(module_1.getIfTrue(expr), type)
                    || this.canOverflow(assert(module_1.getIfFalse(expr)), type);
            }
            // overflows if either side does
            case module_1.ExpressionId.Select: {
                return this.canOverflow(module_1.getSelectThen(expr), type)
                    || this.canOverflow(module_1.getSelectElse(expr), type);
            }
            // overflows if the call does not return a wrapped value or the conversion does
            case module_1.ExpressionId.Call: {
                let program = this.parentFunction.program;
                let instancesByName = program.instancesByName;
                let instanceName = assert(module_1.getCallTarget(expr));
                if (instancesByName.has(instanceName)) {
                    let instance = instancesByName.get(instanceName);
                    assert(instance.kind == program_1.ElementKind.FUNCTION);
                    let returnType = instance.signature.returnType;
                    return !instance.flow.is(2 /* RETURNS_WRAPPED */)
                        || canConversionOverflow(returnType, type);
                }
                return false; // assume no overflow for builtins
            }
            // doesn't technically overflow
            case module_1.ExpressionId.Unreachable: return false;
        }
        return true;
    }
    toString() {
        var levels = 0;
        var parent = this.parent;
        while (parent) {
            parent = parent.parent;
            ++levels;
        }
        return "Flow(" + this.actualFunction + ")[" + levels.toString() + "]";
    }
}
exports.Flow = Flow;
/** Tests if a conversion from one type to another can technically overflow. */
function canConversionOverflow(fromType, toType) {
    return !fromType.is(4 /* INTEGER */) // non-i32 locals or returns
        || fromType.size > toType.size
        || fromType.is(1 /* SIGNED */) != toType.is(1 /* SIGNED */);
}
/** Finds all indexes of locals used in the specified expression. */
function findUsedLocals(expr, used = new Set()) {
    module_1.traverse(expr, used, findUsedLocalsVisit);
    return used;
}
exports.findUsedLocals = findUsedLocals;
/** A visitor function for use with `traverse` that finds all indexes of used locals. */
function findUsedLocalsVisit(expr, used) {
    switch (module_1.getExpressionId(expr)) {
        case module_1.ExpressionId.LocalGet: {
            used.add(module_1.getLocalGetIndex(expr));
            break;
        }
        case module_1.ExpressionId.LocalSet: {
            used.add(module_1.getLocalSetIndex(expr));
            // fall-through for value
        }
        default: module_1.traverse(expr, used, findUsedLocalsVisit);
    }
}


/***/ }),

/***/ "./src/glue/js/binaryen.js":
/*!*********************************!*\
  !*** ./src/glue/js/binaryen.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Copy Binaryen exports to global scope

const binaryen = global.Binaryen || __webpack_require__(/*! binaryen */ "binaryen");
global.binaryen = binaryen;

for (var key in binaryen) {
  if (key.startsWith("_Binaryen") || key.startsWith("_Relooper")) global[key] = binaryen[key];
}

// Utilize Binaryen's heap

global.__memory_allocate = binaryen._malloc;
global.__memory_free = binaryen._free;
global.__memory_copy = binaryen._memmove;
global.__store = function(ptr, val) { binaryen.HEAPU8[ptr] = val; };
global.__load = function(ptr) { return binaryen.HEAPU8[ptr]; };

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./src/glue/js/float.js":
/*!******************************!*\
  !*** ./src/glue/js/float.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {const F64 = new Float64Array(1);
const F32 = new Float32Array(F64.buffer);
const I32 = new Int32Array(F64.buffer);

global.f32_as_i32 = function(value) {
  F32[0] = value;
  return I32[0];
};

global.i32_as_f32 = function(value) {
  I32[0] = value;
  return F32[0];
};

global.f64_as_i64 = function(value) {
  F64[0] = value;
  return i64_new(I32[0], I32[1]);
};

global.i64_as_f64 = function(value) {
  I32[0] = i64_low(value);
  I32[1] = i64_high(value);
  return F64[0];
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./src/glue/js/i64.js":
/*!****************************!*\
  !*** ./src/glue/js/i64.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {const Long = global.Long || __webpack_require__(/*! long */ "./node_modules/long/src/long.js");

global.i64_zero = Long.ZERO;

global.i64_one = Long.ONE;

global.i64_new = function(lo, hi) {
  return Long.fromBits(lo, hi);
};

global.i64_low = function(value) {
  return value.low;
};

global.i64_high = function(value) {
  return value.high;
};

global.i64_add = function(left, right) {
  return left.add(right);
};

global.i64_sub = function(left, right) {
  return left.sub(right);
};

global.i64_mul = function(left, right) {
  return left.mul(right);
};

global.i64_div = function(left, right) {
  return left.div(right);
};

global.i64_div_u = function(left, right) {
  return left.toUnsigned().div(right.toUnsigned()).toSigned();
};

global.i64_rem = function(left, right) {
  return left.mod(right);
};

global.i64_rem_u = function(left, right) {
  return left.toUnsigned().mod(right.toUnsigned()).toSigned();
};

global.i64_and = function(left, right) {
  return left.and(right);
};

global.i64_or = function(left, right) {
  return left.or(right);
};

global.i64_xor = function(left, right) {
  return left.xor(right);
};

global.i64_shl = function(left, right) {
  return left.shl(right);
};

global.i64_shr = function(left, right) {
  return left.shr(right);
};

global.i64_shr_u = function(left, right) {
  return left.shru(right);
};

global.i64_not = function(value) {
  return value.not();
};

global.i64_eq = function(left, right) {
  return left.eq(right);
};

global.i64_ne = function(left, right) {
  return left.ne(right);
};

global.i64_align = function(value, alignment) {
  assert(alignment && (alignment & (alignment - 1)) == 0);
  var mask = Long.fromInt(alignment - 1);
  return value.add(mask).and(mask.not());
};

global.i64_is_i8 = function(value) {
  return value.high === 0 && (value.low >= 0 && value.low <= i8.MAX_VALUE)
      || value.high === -1 && (value.low >= i8.MIN_VALUE && value.low < 0);
};

global.i64_is_i16 = function(value) {
  return value.high === 0 && (value.low >= 0 && value.low <= i16.MAX_VALUE)
      || value.high === -1 && (value.low >= i16.MIN_VALUE && value.low < 0);
};

global.i64_is_i32 = function(value) {
  return (value.high === 0 && value.low >= 0)
      || (value.high === -1 && value.low < 0);
};

global.i64_is_u8 = function(value) {
  return value.high === 0 && value.low >= 0 && value.low <= u8.MAX_VALUE;
};

global.i64_is_u16 = function(value) {
  return value.high === 0 && value.low >= 0 && value.low <= u16.MAX_VALUE;
};

global.i64_is_u32 = function(value) {
  return value.high === 0;
};

global.i64_is_bool = function(value) {
  return value.high === 0 && (value.low === 0 || value.low === 1);
};

const minSafeF32 = Long.fromNumber(f32.MIN_SAFE_INTEGER);
const maxSafeF32 = Long.fromNumber(f32.MAX_SAFE_INTEGER);

global.i64_is_f32 = function(value) {
  return value.gte(minSafeF32) && value.lte(maxSafeF32);
};

const minSafeF64 = Long.fromNumber(f64.MIN_SAFE_INTEGER);
const maxSafeF64 = Long.fromNumber(f64.MAX_SAFE_INTEGER);

global.i64_is_f64 = function(value) {
  return value.gte(minSafeF64) && value.lte(maxSafeF64);
};

global.i64_to_f32 = function(value) {
  return global.Math.fround(value.toNumber());
};

global.i64_to_f64 = function(value) {
  return value.toNumber();
};

global.i64_to_string = function(value, unsigned) {
  return (unsigned ? value.toUnsigned() : value).toString(10);
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./src/glue/js/index.ts":
/*!******************************!*\
  !*** ./src/glue/js/index.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * JavaScript glue code.
 * @module glue/js
 * @preferred
 */ /***/
Object.defineProperty(exports, "__esModule", { value: true });
__webpack_require__(/*! ./binaryen */ "./src/glue/js/binaryen.js"); // must be first so portable can pick up the memory implementation
__webpack_require__(/*! ../../../std/portable/index */ "./std/portable/index.js");
__webpack_require__(/*! ./float */ "./src/glue/js/float.js");
__webpack_require__(/*! ./i64 */ "./src/glue/js/i64.js");
const module_1 = __webpack_require__(/*! ../../module */ "./src/module.ts");
module_1.Module.prototype.toText = function () {
    // NOTE: Conversion to StackIR can yield conversion artifacts like sequences
    // of unreachable statements not actually emitted by the compiler. Optimizing
    // StackIR removes these again, but may also suppress useless code emitted by
    // the compiler that's then no longer visible in tests. Both not ideal.
    return binaryen.wrapModule(this.ref).emitStackIR(/* optimize-stack-ir */ true);
};
module_1.Module.prototype.toAsmjs = function () {
    return binaryen.wrapModule(this.ref).emitAsmjs();
};


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Low-level C-like compiler API.
 * @module index
 */ /***/
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
const compiler_1 = __webpack_require__(/*! ./compiler */ "./src/compiler.ts");
const decompiler_1 = __webpack_require__(/*! ./decompiler */ "./src/decompiler.ts");
const definitions_1 = __webpack_require__(/*! ./definitions */ "./src/definitions.ts");
const diagnostics_1 = __webpack_require__(/*! ./diagnostics */ "./src/diagnostics.ts");
exports.formatDiagnostic = diagnostics_1.formatDiagnosticMessage;
const parser_1 = __webpack_require__(/*! ./parser */ "./src/parser.ts");
/** Parses a source file. If `parser` has been omitted a new one is created. */
function parseFile(
/** Source text of the file. */
text, 
/** Normalized path of the file. */
path, 
/** Whether this is an entry file. */
isEntry = false, 
/** Parser reference. */
parser = null) {
    if (!parser)
        parser = new parser_1.Parser();
    parser.parseFile(text, path, isEntry);
    return parser;
}
exports.parseFile = parseFile;
/** Obtains the next required file's path. Returns `null` once complete. */
function nextFile(parser) {
    return parser.nextFile();
}
exports.nextFile = nextFile;
/** Obtains the path of the dependee of a given imported file. */
function getDependee(parser, file) {
    return parser.getDependee(file);
}
exports.getDependee = getDependee;
/** Obtains the next diagnostic message. Returns `null` once complete. */
function nextDiagnostic(parser) {
    var program = parser.program;
    return program.diagnosticsOffset < program.diagnostics.length
        ? program.diagnostics[program.diagnosticsOffset++]
        : null;
}
exports.nextDiagnostic = nextDiagnostic;
/** Tests whether a diagnostic is informatory. */
function isInfo(message) {
    return message.category == diagnostics_1.DiagnosticCategory.INFO;
}
exports.isInfo = isInfo;
/** Tests whether a diagnostic is a warning. */
function isWarning(message) {
    return message.category == diagnostics_1.DiagnosticCategory.WARNING;
}
exports.isWarning = isWarning;
/** Tests whether a diagnostic is an error. */
function isError(message) {
    return message.category == diagnostics_1.DiagnosticCategory.ERROR;
}
exports.isError = isError;
/** Creates a new set of compiler options. */
function createOptions() {
    return new compiler_1.Options();
}
exports.createOptions = createOptions;
/** Sets the `target` option. */
function setTarget(options, target) {
    options.target = target;
}
exports.setTarget = setTarget;
/** Sets the `noAssert` option. */
function setNoAssert(options, noAssert) {
    options.noAssert = noAssert;
}
exports.setNoAssert = setNoAssert;
/** Sets the `importMemory` option. */
function setImportMemory(options, importMemory) {
    options.importMemory = importMemory;
}
exports.setImportMemory = setImportMemory;
/** Sets the `sharedMemory` option. */
function setSharedMemory(options, sharedMemory) {
    options.sharedMemory = sharedMemory;
}
exports.setSharedMemory = setSharedMemory;
/** Sets the `importTable` option. */
function setImportTable(options, importTable) {
    options.importTable = importTable;
}
exports.setImportTable = setImportTable;
/** Sets the `sourceMap` option. */
function setSourceMap(options, sourceMap) {
    options.sourceMap = sourceMap;
}
exports.setSourceMap = setSourceMap;
/** Sets the `memoryBase` option. */
function setMemoryBase(options, memoryBase) {
    options.memoryBase = memoryBase;
}
exports.setMemoryBase = setMemoryBase;
/** Sets a 'globalAliases' value. */
function setGlobalAlias(options, alias, name) {
    var globalAliases = options.globalAliases;
    if (!globalAliases)
        options.globalAliases = globalAliases = new Map();
    globalAliases.set(alias, name);
}
exports.setGlobalAlias = setGlobalAlias;
/** Sets the `explicitStart` option. */
function setExplicitStart(options, explicitStart) {
    options.explicitStart = explicitStart;
}
exports.setExplicitStart = setExplicitStart;
/** Sets the `noUnsafe` option. */
function setNoUnsafe(options, noUnsafe) {
    options.noUnsafe = noUnsafe;
}
exports.setNoUnsafe = setNoUnsafe;
/** Sign extension operations. */
exports.FEATURE_SIGN_EXTENSION = 1 /* SIGN_EXTENSION */;
/** Mutable global imports and exports. */
exports.FEATURE_MUTABLE_GLOBALS = 2 /* MUTABLE_GLOBALS */;
/** Non-trapping float to int conversion operations. */
exports.FEATURE_NONTRAPPING_F2I = 4 /* NONTRAPPING_F2I */;
/** Bulk memory operations. */
exports.FEATURE_BULK_MEMORY = 8 /* BULK_MEMORY */;
/** SIMD types and operations. */
exports.FEATURE_SIMD = 16 /* SIMD */;
/** Threading and atomic operations. */
exports.FEATURE_THREADS = 32 /* THREADS */;
/** Exception handling operations. */
exports.FEATURE_EXCEPTION_HANDLING = 64 /* EXCEPTION_HANDLING */;
/** Tail call operations. */
exports.FEATURE_TAIL_CALLS = 128 /* TAIL_CALLS */;
/** Reference types. */
exports.FEATURE_REFERENCE_TYPES = 256 /* REFERENCE_TYPES */;
/** Enables a specific feature. */
function enableFeature(options, feature) {
    options.features |= feature;
}
exports.enableFeature = enableFeature;
/** Disables a specific feature. */
function disableFeature(options, feature) {
    options.features &= ~feature;
}
exports.disableFeature = disableFeature;
/** Gives the compiler a hint at the optimize levels that will be used later on. */
function setOptimizeLevelHints(options, optimizeLevel, shrinkLevel) {
    options.optimizeLevelHint = optimizeLevel;
    options.shrinkLevelHint = shrinkLevel;
}
exports.setOptimizeLevelHints = setOptimizeLevelHints;
/** Finishes parsing. */
function finishParsing(parser) {
    return parser.finish();
}
exports.finishParsing = finishParsing;
/** Obtains the source of the given file. */
function getSource(program, internalPath) {
    return program.getSource(internalPath);
}
exports.getSource = getSource;
/** Compiles the sources computed by the parser to a module. */
function compileProgram(program, options = null) {
    return new compiler_1.Compiler(program, options).compile();
}
exports.compileProgram = compileProgram;
/** Decompiles a module to its (low level) source. */
function decompileModule(module) {
    var decompiler = new decompiler_1.Decompiler();
    decompiler.decompile(module);
    return decompiler.finish();
}
exports.decompileModule = decompileModule;
/** Builds WebIDL definitions for the specified program. */
function buildIDL(program) {
    return definitions_1.IDLBuilder.build(program);
}
exports.buildIDL = buildIDL;
/** Builds TypeScript definitions for the specified program. */
function buildTSD(program) {
    return definitions_1.TSDBuilder.build(program);
}
exports.buildTSD = buildTSD;
/** Builds a JSON file of a program's runtime type information. */
function buildRTTI(program) {
    var sb = new Array();
    sb.push("{\n  \"names\": [\n");
    for (let cls of program.managedClasses.values()) {
        sb.push("    \"");
        sb.push(cls.internalName);
        sb.push("\",\n");
    }
    sb.push("  ],\n  \"base\": [\n");
    for (let cls of program.managedClasses.values()) {
        let base = cls.base;
        sb.push("    ");
        sb.push(base ? base.id.toString() : "0");
        sb.push(",\n");
    }
    sb.push("  ],\n  \"flags\": [\n");
    for (let cls of program.managedClasses.values()) {
        sb.push("    ");
        sb.push(cls.rttiFlags.toString());
        sb.push(",\n");
    }
    sb.push("  ]\n}\n");
    return sb.join("");
}
exports.buildRTTI = buildRTTI;
/** Prefix indicating a library file. */
var common_1 = __webpack_require__(/*! ./common */ "./src/common.ts");
exports.LIBRARY_PREFIX = common_1.LIBRARY_PREFIX;
// Full API
__export(__webpack_require__(/*! ./ast */ "./src/ast.ts"));
// export * from "./binary";
__export(__webpack_require__(/*! ./common */ "./src/common.ts"));
__export(__webpack_require__(/*! ./compiler */ "./src/compiler.ts"));
__export(__webpack_require__(/*! ./decompiler */ "./src/decompiler.ts"));
__export(__webpack_require__(/*! ./definitions */ "./src/definitions.ts"));
__export(__webpack_require__(/*! ./diagnosticMessages.generated */ "./src/diagnosticMessages.generated.ts"));
__export(__webpack_require__(/*! ./diagnostics */ "./src/diagnostics.ts"));
__export(__webpack_require__(/*! ./flow */ "./src/flow.ts"));
__export(__webpack_require__(/*! ./module */ "./src/module.ts"));
__export(__webpack_require__(/*! ./parser */ "./src/parser.ts"));
__export(__webpack_require__(/*! ./program */ "./src/program.ts"));
__export(__webpack_require__(/*! ./resolver */ "./src/resolver.ts"));
__export(__webpack_require__(/*! ./tokenizer */ "./src/tokenizer.ts"));
__export(__webpack_require__(/*! ./types */ "./src/types.ts"));
__export(__webpack_require__(/*! ./util/index */ "./src/util/index.ts"));


/***/ }),

/***/ "./src/module.ts":
/*!***********************!*\
  !*** ./src/module.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * A thin wrapper around Binaryen's C-API.
 * @module module
 */ /***/
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = __webpack_require__(/*! ./common */ "./src/common.ts");
var NativeType;
(function (NativeType) {
    NativeType[NativeType["None"] = _BinaryenTypeNone()] = "None";
    NativeType[NativeType["I32"] = _BinaryenTypeInt32()] = "I32";
    NativeType[NativeType["I64"] = _BinaryenTypeInt64()] = "I64";
    NativeType[NativeType["F32"] = _BinaryenTypeFloat32()] = "F32";
    NativeType[NativeType["F64"] = _BinaryenTypeFloat64()] = "F64";
    NativeType[NativeType["V128"] = _BinaryenTypeVec128()] = "V128";
    NativeType[NativeType["Anyref"] = _BinaryenTypeAnyref()] = "Anyref";
    NativeType[NativeType["Exnref"] = _BinaryenTypeExnref()] = "Exnref";
    NativeType[NativeType["Unreachable"] = _BinaryenTypeUnreachable()] = "Unreachable";
    NativeType[NativeType["Auto"] = _BinaryenTypeAuto()] = "Auto";
})(NativeType = exports.NativeType || (exports.NativeType = {}));
var FeatureFlags;
(function (FeatureFlags) {
    FeatureFlags[FeatureFlags["MVP"] = _BinaryenFeatureMVP()] = "MVP";
    FeatureFlags[FeatureFlags["Atomics"] = _BinaryenFeatureAtomics()] = "Atomics";
    FeatureFlags[FeatureFlags["MutableGloabls"] = _BinaryenFeatureMutableGlobals()] = "MutableGloabls";
    FeatureFlags[FeatureFlags["NontrappingFPToInt"] = _BinaryenFeatureNontrappingFPToInt()] = "NontrappingFPToInt";
    FeatureFlags[FeatureFlags["SIMD128"] = _BinaryenFeatureSIMD128()] = "SIMD128";
    FeatureFlags[FeatureFlags["BulkMemory"] = _BinaryenFeatureBulkMemory()] = "BulkMemory";
    FeatureFlags[FeatureFlags["SignExt"] = _BinaryenFeatureSignExt()] = "SignExt";
    FeatureFlags[FeatureFlags["ExceptionHandling"] = _BinaryenFeatureExceptionHandling()] = "ExceptionHandling";
    FeatureFlags[FeatureFlags["TailCall"] = _BinaryenFeatureTailCall()] = "TailCall";
    FeatureFlags[FeatureFlags["ReferenceTypes"] = _BinaryenFeatureReferenceTypes()] = "ReferenceTypes";
    FeatureFlags[FeatureFlags["All"] = _BinaryenFeatureAll()] = "All";
})(FeatureFlags = exports.FeatureFlags || (exports.FeatureFlags = {}));
var ExpressionId;
(function (ExpressionId) {
    ExpressionId[ExpressionId["Invalid"] = _BinaryenInvalidId()] = "Invalid";
    ExpressionId[ExpressionId["Block"] = _BinaryenBlockId()] = "Block";
    ExpressionId[ExpressionId["If"] = _BinaryenIfId()] = "If";
    ExpressionId[ExpressionId["Loop"] = _BinaryenLoopId()] = "Loop";
    ExpressionId[ExpressionId["Break"] = _BinaryenBreakId()] = "Break";
    ExpressionId[ExpressionId["Switch"] = _BinaryenSwitchId()] = "Switch";
    ExpressionId[ExpressionId["Call"] = _BinaryenCallId()] = "Call";
    ExpressionId[ExpressionId["CallIndirect"] = _BinaryenCallIndirectId()] = "CallIndirect";
    ExpressionId[ExpressionId["LocalGet"] = _BinaryenLocalGetId()] = "LocalGet";
    ExpressionId[ExpressionId["LocalSet"] = _BinaryenLocalSetId()] = "LocalSet";
    ExpressionId[ExpressionId["GlobalGet"] = _BinaryenGlobalGetId()] = "GlobalGet";
    ExpressionId[ExpressionId["GlobalSet"] = _BinaryenGlobalSetId()] = "GlobalSet";
    ExpressionId[ExpressionId["Load"] = _BinaryenLoadId()] = "Load";
    ExpressionId[ExpressionId["Store"] = _BinaryenStoreId()] = "Store";
    ExpressionId[ExpressionId["Const"] = _BinaryenConstId()] = "Const";
    ExpressionId[ExpressionId["Unary"] = _BinaryenUnaryId()] = "Unary";
    ExpressionId[ExpressionId["Binary"] = _BinaryenBinaryId()] = "Binary";
    ExpressionId[ExpressionId["Select"] = _BinaryenSelectId()] = "Select";
    ExpressionId[ExpressionId["Drop"] = _BinaryenDropId()] = "Drop";
    ExpressionId[ExpressionId["Return"] = _BinaryenReturnId()] = "Return";
    ExpressionId[ExpressionId["Host"] = _BinaryenHostId()] = "Host";
    ExpressionId[ExpressionId["Nop"] = _BinaryenNopId()] = "Nop";
    ExpressionId[ExpressionId["Unreachable"] = _BinaryenUnreachableId()] = "Unreachable";
    ExpressionId[ExpressionId["AtomicCmpxchg"] = _BinaryenAtomicCmpxchgId()] = "AtomicCmpxchg";
    ExpressionId[ExpressionId["AtomicRMW"] = _BinaryenAtomicRMWId()] = "AtomicRMW";
    ExpressionId[ExpressionId["AtomicWait"] = _BinaryenAtomicWaitId()] = "AtomicWait";
    ExpressionId[ExpressionId["AtomicNotify"] = _BinaryenAtomicNotifyId()] = "AtomicNotify";
    ExpressionId[ExpressionId["AtomicFence"] = _BinaryenAtomicFenceId()] = "AtomicFence";
    ExpressionId[ExpressionId["SIMDExtract"] = _BinaryenSIMDExtractId()] = "SIMDExtract";
    ExpressionId[ExpressionId["SIMDReplace"] = _BinaryenSIMDReplaceId()] = "SIMDReplace";
    ExpressionId[ExpressionId["SIMDShuffle"] = _BinaryenSIMDShuffleId()] = "SIMDShuffle";
    ExpressionId[ExpressionId["SIMDTernary"] = _BinaryenSIMDTernaryId()] = "SIMDTernary";
    ExpressionId[ExpressionId["SIMDShift"] = _BinaryenSIMDShiftId()] = "SIMDShift";
    ExpressionId[ExpressionId["SIMDLoad"] = _BinaryenSIMDLoadId()] = "SIMDLoad";
    ExpressionId[ExpressionId["MemoryInit"] = _BinaryenMemoryInitId()] = "MemoryInit";
    ExpressionId[ExpressionId["DataDrop"] = _BinaryenDataDropId()] = "DataDrop";
    ExpressionId[ExpressionId["MemoryCopy"] = _BinaryenMemoryCopyId()] = "MemoryCopy";
    ExpressionId[ExpressionId["MemoryFill"] = _BinaryenMemoryFillId()] = "MemoryFill";
    ExpressionId[ExpressionId["Try"] = _BinaryenTryId()] = "Try";
    ExpressionId[ExpressionId["Throw"] = _BinaryenThrowId()] = "Throw";
    ExpressionId[ExpressionId["Rethrow"] = _BinaryenRethrowId()] = "Rethrow";
    ExpressionId[ExpressionId["BrOnExn"] = _BinaryenBrOnExnId()] = "BrOnExn";
    ExpressionId[ExpressionId["Push"] = _BinaryenPushId()] = "Push";
    ExpressionId[ExpressionId["Pop"] = _BinaryenPopId()] = "Pop";
})(ExpressionId = exports.ExpressionId || (exports.ExpressionId = {}));
var UnaryOp;
(function (UnaryOp) {
    UnaryOp[UnaryOp["ClzI32"] = _BinaryenClzInt32()] = "ClzI32";
    UnaryOp[UnaryOp["CtzI32"] = _BinaryenCtzInt32()] = "CtzI32";
    UnaryOp[UnaryOp["PopcntI32"] = _BinaryenPopcntInt32()] = "PopcntI32";
    UnaryOp[UnaryOp["NegF32"] = _BinaryenNegFloat32()] = "NegF32";
    UnaryOp[UnaryOp["AbsF32"] = _BinaryenAbsFloat32()] = "AbsF32";
    UnaryOp[UnaryOp["CeilF32"] = _BinaryenCeilFloat32()] = "CeilF32";
    UnaryOp[UnaryOp["FloorF32"] = _BinaryenFloorFloat32()] = "FloorF32";
    UnaryOp[UnaryOp["TruncF32"] = _BinaryenTruncFloat32()] = "TruncF32";
    UnaryOp[UnaryOp["NearestF32"] = _BinaryenNearestFloat32()] = "NearestF32";
    UnaryOp[UnaryOp["SqrtF32"] = _BinaryenSqrtFloat32()] = "SqrtF32";
    UnaryOp[UnaryOp["EqzI32"] = _BinaryenEqZInt32()] = "EqzI32";
    UnaryOp[UnaryOp["ClzI64"] = _BinaryenClzInt64()] = "ClzI64";
    UnaryOp[UnaryOp["CtzI64"] = _BinaryenCtzInt64()] = "CtzI64";
    UnaryOp[UnaryOp["PopcntI64"] = _BinaryenPopcntInt64()] = "PopcntI64";
    UnaryOp[UnaryOp["NegF64"] = _BinaryenNegFloat64()] = "NegF64";
    UnaryOp[UnaryOp["AbsF64"] = _BinaryenAbsFloat64()] = "AbsF64";
    UnaryOp[UnaryOp["CeilF64"] = _BinaryenCeilFloat64()] = "CeilF64";
    UnaryOp[UnaryOp["FloorF64"] = _BinaryenFloorFloat64()] = "FloorF64";
    UnaryOp[UnaryOp["TruncF64"] = _BinaryenTruncFloat64()] = "TruncF64";
    UnaryOp[UnaryOp["NearestF64"] = _BinaryenNearestFloat64()] = "NearestF64";
    UnaryOp[UnaryOp["SqrtF64"] = _BinaryenSqrtFloat64()] = "SqrtF64";
    UnaryOp[UnaryOp["EqzI64"] = _BinaryenEqZInt64()] = "EqzI64";
    UnaryOp[UnaryOp["ExtendI32"] = _BinaryenExtendSInt32()] = "ExtendI32";
    UnaryOp[UnaryOp["ExtendU32"] = _BinaryenExtendUInt32()] = "ExtendU32";
    UnaryOp[UnaryOp["WrapI64"] = _BinaryenWrapInt64()] = "WrapI64";
    UnaryOp[UnaryOp["TruncF32ToI32"] = _BinaryenTruncSFloat32ToInt32()] = "TruncF32ToI32";
    UnaryOp[UnaryOp["TruncF32ToI64"] = _BinaryenTruncSFloat32ToInt64()] = "TruncF32ToI64";
    UnaryOp[UnaryOp["TruncF32ToU32"] = _BinaryenTruncUFloat32ToInt32()] = "TruncF32ToU32";
    UnaryOp[UnaryOp["TruncF32ToU64"] = _BinaryenTruncUFloat32ToInt64()] = "TruncF32ToU64";
    UnaryOp[UnaryOp["TruncF64ToI32"] = _BinaryenTruncSFloat64ToInt32()] = "TruncF64ToI32";
    UnaryOp[UnaryOp["TruncF64ToI64"] = _BinaryenTruncSFloat64ToInt64()] = "TruncF64ToI64";
    UnaryOp[UnaryOp["TruncF64ToU32"] = _BinaryenTruncUFloat64ToInt32()] = "TruncF64ToU32";
    UnaryOp[UnaryOp["TruncF64ToU64"] = _BinaryenTruncUFloat64ToInt64()] = "TruncF64ToU64";
    UnaryOp[UnaryOp["ReinterpretF32"] = _BinaryenReinterpretFloat32()] = "ReinterpretF32";
    UnaryOp[UnaryOp["ReinterpretF64"] = _BinaryenReinterpretFloat64()] = "ReinterpretF64";
    UnaryOp[UnaryOp["ConvertI32ToF32"] = _BinaryenConvertSInt32ToFloat32()] = "ConvertI32ToF32";
    UnaryOp[UnaryOp["ConvertI32ToF64"] = _BinaryenConvertSInt32ToFloat64()] = "ConvertI32ToF64";
    UnaryOp[UnaryOp["ConvertU32ToF32"] = _BinaryenConvertUInt32ToFloat32()] = "ConvertU32ToF32";
    UnaryOp[UnaryOp["ConvertU32ToF64"] = _BinaryenConvertUInt32ToFloat64()] = "ConvertU32ToF64";
    UnaryOp[UnaryOp["ConvertI64ToF32"] = _BinaryenConvertSInt64ToFloat32()] = "ConvertI64ToF32";
    UnaryOp[UnaryOp["ConvertI64ToF64"] = _BinaryenConvertSInt64ToFloat64()] = "ConvertI64ToF64";
    UnaryOp[UnaryOp["ConvertU64ToF32"] = _BinaryenConvertUInt64ToFloat32()] = "ConvertU64ToF32";
    UnaryOp[UnaryOp["ConvertU64ToF64"] = _BinaryenConvertUInt64ToFloat64()] = "ConvertU64ToF64";
    UnaryOp[UnaryOp["PromoteF32"] = _BinaryenPromoteFloat32()] = "PromoteF32";
    UnaryOp[UnaryOp["DemoteF64"] = _BinaryenDemoteFloat64()] = "DemoteF64";
    UnaryOp[UnaryOp["ReinterpretI32"] = _BinaryenReinterpretInt32()] = "ReinterpretI32";
    UnaryOp[UnaryOp["ReinterpretI64"] = _BinaryenReinterpretInt64()] = "ReinterpretI64";
    // see: https://github.com/WebAssembly/sign-extension-ops
    UnaryOp[UnaryOp["ExtendI8ToI32"] = _BinaryenExtendS8Int32()] = "ExtendI8ToI32";
    UnaryOp[UnaryOp["ExtendI16ToI32"] = _BinaryenExtendS16Int32()] = "ExtendI16ToI32";
    UnaryOp[UnaryOp["ExtendI8ToI64"] = _BinaryenExtendS8Int64()] = "ExtendI8ToI64";
    UnaryOp[UnaryOp["ExtendI16ToI64"] = _BinaryenExtendS16Int64()] = "ExtendI16ToI64";
    UnaryOp[UnaryOp["ExtendI32ToI64"] = _BinaryenExtendS32Int64()] = "ExtendI32ToI64";
    // see: https://github.com/WebAssembly/nontrapping-float-to-int-conversions
    UnaryOp[UnaryOp["TruncF32ToI32Sat"] = _BinaryenTruncSatSFloat32ToInt32()] = "TruncF32ToI32Sat";
    UnaryOp[UnaryOp["TruncF32ToU32Sat"] = _BinaryenTruncSatUFloat32ToInt32()] = "TruncF32ToU32Sat";
    UnaryOp[UnaryOp["TruncF64ToI32Sat"] = _BinaryenTruncSatSFloat64ToInt32()] = "TruncF64ToI32Sat";
    UnaryOp[UnaryOp["TruncF64ToU32Sat"] = _BinaryenTruncSatUFloat64ToInt32()] = "TruncF64ToU32Sat";
    UnaryOp[UnaryOp["TruncF32ToI64Sat"] = _BinaryenTruncSatSFloat32ToInt64()] = "TruncF32ToI64Sat";
    UnaryOp[UnaryOp["TruncF32ToU64Sat"] = _BinaryenTruncSatUFloat32ToInt64()] = "TruncF32ToU64Sat";
    UnaryOp[UnaryOp["TruncF64ToI64Sat"] = _BinaryenTruncSatSFloat64ToInt64()] = "TruncF64ToI64Sat";
    UnaryOp[UnaryOp["TruncF64ToU64Sat"] = _BinaryenTruncSatUFloat64ToInt64()] = "TruncF64ToU64Sat";
    // see: https://github.com/WebAssembly/simd
    UnaryOp[UnaryOp["SplatI8x16"] = _BinaryenSplatVecI8x16()] = "SplatI8x16";
    UnaryOp[UnaryOp["SplatI16x8"] = _BinaryenSplatVecI16x8()] = "SplatI16x8";
    UnaryOp[UnaryOp["SplatI32x4"] = _BinaryenSplatVecI32x4()] = "SplatI32x4";
    UnaryOp[UnaryOp["SplatI64x2"] = _BinaryenSplatVecI64x2()] = "SplatI64x2";
    UnaryOp[UnaryOp["SplatF32x4"] = _BinaryenSplatVecF32x4()] = "SplatF32x4";
    UnaryOp[UnaryOp["SplatF64x2"] = _BinaryenSplatVecF64x2()] = "SplatF64x2";
    UnaryOp[UnaryOp["NotV128"] = _BinaryenNotVec128()] = "NotV128";
    UnaryOp[UnaryOp["NegI8x16"] = _BinaryenNegVecI8x16()] = "NegI8x16";
    UnaryOp[UnaryOp["AnyTrueI8x16"] = _BinaryenAnyTrueVecI8x16()] = "AnyTrueI8x16";
    UnaryOp[UnaryOp["AllTrueI8x16"] = _BinaryenAllTrueVecI8x16()] = "AllTrueI8x16";
    UnaryOp[UnaryOp["NegI16x8"] = _BinaryenNegVecI16x8()] = "NegI16x8";
    UnaryOp[UnaryOp["AnyTrueI16x8"] = _BinaryenAnyTrueVecI16x8()] = "AnyTrueI16x8";
    UnaryOp[UnaryOp["AllTrueI16x8"] = _BinaryenAllTrueVecI16x8()] = "AllTrueI16x8";
    UnaryOp[UnaryOp["NegI32x4"] = _BinaryenNegVecI32x4()] = "NegI32x4";
    UnaryOp[UnaryOp["AnyTrueI32x4"] = _BinaryenAnyTrueVecI32x4()] = "AnyTrueI32x4";
    UnaryOp[UnaryOp["AllTrueI32x4"] = _BinaryenAllTrueVecI32x4()] = "AllTrueI32x4";
    UnaryOp[UnaryOp["NegI64x2"] = _BinaryenNegVecI64x2()] = "NegI64x2";
    UnaryOp[UnaryOp["AnyTrueI64x2"] = _BinaryenAnyTrueVecI64x2()] = "AnyTrueI64x2";
    UnaryOp[UnaryOp["AllTrueI64x2"] = _BinaryenAllTrueVecI64x2()] = "AllTrueI64x2";
    UnaryOp[UnaryOp["AbsF32x4"] = _BinaryenAbsVecF32x4()] = "AbsF32x4";
    UnaryOp[UnaryOp["NegF32x4"] = _BinaryenNegVecF32x4()] = "NegF32x4";
    UnaryOp[UnaryOp["SqrtF32x4"] = _BinaryenSqrtVecF32x4()] = "SqrtF32x4";
    UnaryOp[UnaryOp["AbsF64x2"] = _BinaryenAbsVecF64x2()] = "AbsF64x2";
    UnaryOp[UnaryOp["NegF64x2"] = _BinaryenNegVecF64x2()] = "NegF64x2";
    UnaryOp[UnaryOp["SqrtF64x2"] = _BinaryenSqrtVecF64x2()] = "SqrtF64x2";
    UnaryOp[UnaryOp["TruncSatF32x4ToI32x4"] = _BinaryenTruncSatSVecF32x4ToVecI32x4()] = "TruncSatF32x4ToI32x4";
    UnaryOp[UnaryOp["TruncSatF32x4ToU32x4"] = _BinaryenTruncSatUVecF32x4ToVecI32x4()] = "TruncSatF32x4ToU32x4";
    UnaryOp[UnaryOp["TruncSatF64x2ToI64x2"] = _BinaryenTruncSatSVecF64x2ToVecI64x2()] = "TruncSatF64x2ToI64x2";
    UnaryOp[UnaryOp["TruncSatF64x2ToU64x2"] = _BinaryenTruncSatUVecF64x2ToVecI64x2()] = "TruncSatF64x2ToU64x2";
    UnaryOp[UnaryOp["ConvertI32x4ToF32x4"] = _BinaryenConvertSVecI32x4ToVecF32x4()] = "ConvertI32x4ToF32x4";
    UnaryOp[UnaryOp["ConvertU32x4ToF32x4"] = _BinaryenConvertUVecI32x4ToVecF32x4()] = "ConvertU32x4ToF32x4";
    UnaryOp[UnaryOp["ConvertI64x2ToF64x2"] = _BinaryenConvertSVecI64x2ToVecF64x2()] = "ConvertI64x2ToF64x2";
    UnaryOp[UnaryOp["ConvertU64x2ToF64x2"] = _BinaryenConvertUVecI64x2ToVecF64x2()] = "ConvertU64x2ToF64x2";
    UnaryOp[UnaryOp["WidenLowI8x16ToI16x8"] = _BinaryenWidenLowSVecI8x16ToVecI16x8()] = "WidenLowI8x16ToI16x8";
    UnaryOp[UnaryOp["WidenLowU8x16ToU16x8"] = _BinaryenWidenLowUVecI8x16ToVecI16x8()] = "WidenLowU8x16ToU16x8";
    UnaryOp[UnaryOp["WidenHighI8x16ToI16x8"] = _BinaryenWidenHighSVecI8x16ToVecI16x8()] = "WidenHighI8x16ToI16x8";
    UnaryOp[UnaryOp["WidenHighU8x16ToU16x8"] = _BinaryenWidenHighUVecI8x16ToVecI16x8()] = "WidenHighU8x16ToU16x8";
    UnaryOp[UnaryOp["WidenLowI16x8ToI32x4"] = _BinaryenWidenLowSVecI16x8ToVecI32x4()] = "WidenLowI16x8ToI32x4";
    UnaryOp[UnaryOp["WidenLowU16x8ToU32x4"] = _BinaryenWidenLowUVecI16x8ToVecI32x4()] = "WidenLowU16x8ToU32x4";
    UnaryOp[UnaryOp["WidenHighI16x8ToI32x4"] = _BinaryenWidenHighSVecI16x8ToVecI32x4()] = "WidenHighI16x8ToI32x4";
    UnaryOp[UnaryOp["WidenHighU16x8ToU32x4"] = _BinaryenWidenHighUVecI16x8ToVecI32x4()] = "WidenHighU16x8ToU32x4";
})(UnaryOp = exports.UnaryOp || (exports.UnaryOp = {}));
var BinaryOp;
(function (BinaryOp) {
    BinaryOp[BinaryOp["AddI32"] = _BinaryenAddInt32()] = "AddI32";
    BinaryOp[BinaryOp["SubI32"] = _BinaryenSubInt32()] = "SubI32";
    BinaryOp[BinaryOp["MulI32"] = _BinaryenMulInt32()] = "MulI32";
    BinaryOp[BinaryOp["DivI32"] = _BinaryenDivSInt32()] = "DivI32";
    BinaryOp[BinaryOp["DivU32"] = _BinaryenDivUInt32()] = "DivU32";
    BinaryOp[BinaryOp["RemI32"] = _BinaryenRemSInt32()] = "RemI32";
    BinaryOp[BinaryOp["RemU32"] = _BinaryenRemUInt32()] = "RemU32";
    BinaryOp[BinaryOp["AndI32"] = _BinaryenAndInt32()] = "AndI32";
    BinaryOp[BinaryOp["OrI32"] = _BinaryenOrInt32()] = "OrI32";
    BinaryOp[BinaryOp["XorI32"] = _BinaryenXorInt32()] = "XorI32";
    BinaryOp[BinaryOp["ShlI32"] = _BinaryenShlInt32()] = "ShlI32";
    BinaryOp[BinaryOp["ShrU32"] = _BinaryenShrUInt32()] = "ShrU32";
    BinaryOp[BinaryOp["ShrI32"] = _BinaryenShrSInt32()] = "ShrI32";
    BinaryOp[BinaryOp["RotlI32"] = _BinaryenRotLInt32()] = "RotlI32";
    BinaryOp[BinaryOp["RotrI32"] = _BinaryenRotRInt32()] = "RotrI32";
    BinaryOp[BinaryOp["EqI32"] = _BinaryenEqInt32()] = "EqI32";
    BinaryOp[BinaryOp["NeI32"] = _BinaryenNeInt32()] = "NeI32";
    BinaryOp[BinaryOp["LtI32"] = _BinaryenLtSInt32()] = "LtI32";
    BinaryOp[BinaryOp["LtU32"] = _BinaryenLtUInt32()] = "LtU32";
    BinaryOp[BinaryOp["LeI32"] = _BinaryenLeSInt32()] = "LeI32";
    BinaryOp[BinaryOp["LeU32"] = _BinaryenLeUInt32()] = "LeU32";
    BinaryOp[BinaryOp["GtI32"] = _BinaryenGtSInt32()] = "GtI32";
    BinaryOp[BinaryOp["GtU32"] = _BinaryenGtUInt32()] = "GtU32";
    BinaryOp[BinaryOp["GeI32"] = _BinaryenGeSInt32()] = "GeI32";
    BinaryOp[BinaryOp["GeU32"] = _BinaryenGeUInt32()] = "GeU32";
    BinaryOp[BinaryOp["AddI64"] = _BinaryenAddInt64()] = "AddI64";
    BinaryOp[BinaryOp["SubI64"] = _BinaryenSubInt64()] = "SubI64";
    BinaryOp[BinaryOp["MulI64"] = _BinaryenMulInt64()] = "MulI64";
    BinaryOp[BinaryOp["DivI64"] = _BinaryenDivSInt64()] = "DivI64";
    BinaryOp[BinaryOp["DivU64"] = _BinaryenDivUInt64()] = "DivU64";
    BinaryOp[BinaryOp["RemI64"] = _BinaryenRemSInt64()] = "RemI64";
    BinaryOp[BinaryOp["RemU64"] = _BinaryenRemUInt64()] = "RemU64";
    BinaryOp[BinaryOp["AndI64"] = _BinaryenAndInt64()] = "AndI64";
    BinaryOp[BinaryOp["OrI64"] = _BinaryenOrInt64()] = "OrI64";
    BinaryOp[BinaryOp["XorI64"] = _BinaryenXorInt64()] = "XorI64";
    BinaryOp[BinaryOp["ShlI64"] = _BinaryenShlInt64()] = "ShlI64";
    BinaryOp[BinaryOp["ShrU64"] = _BinaryenShrUInt64()] = "ShrU64";
    BinaryOp[BinaryOp["ShrI64"] = _BinaryenShrSInt64()] = "ShrI64";
    BinaryOp[BinaryOp["RotlI64"] = _BinaryenRotLInt64()] = "RotlI64";
    BinaryOp[BinaryOp["RotrI64"] = _BinaryenRotRInt64()] = "RotrI64";
    BinaryOp[BinaryOp["EqI64"] = _BinaryenEqInt64()] = "EqI64";
    BinaryOp[BinaryOp["NeI64"] = _BinaryenNeInt64()] = "NeI64";
    BinaryOp[BinaryOp["LtI64"] = _BinaryenLtSInt64()] = "LtI64";
    BinaryOp[BinaryOp["LtU64"] = _BinaryenLtUInt64()] = "LtU64";
    BinaryOp[BinaryOp["LeI64"] = _BinaryenLeSInt64()] = "LeI64";
    BinaryOp[BinaryOp["LeU64"] = _BinaryenLeUInt64()] = "LeU64";
    BinaryOp[BinaryOp["GtI64"] = _BinaryenGtSInt64()] = "GtI64";
    BinaryOp[BinaryOp["GtU64"] = _BinaryenGtUInt64()] = "GtU64";
    BinaryOp[BinaryOp["GeI64"] = _BinaryenGeSInt64()] = "GeI64";
    BinaryOp[BinaryOp["GeU64"] = _BinaryenGeUInt64()] = "GeU64";
    BinaryOp[BinaryOp["AddF32"] = _BinaryenAddFloat32()] = "AddF32";
    BinaryOp[BinaryOp["SubF32"] = _BinaryenSubFloat32()] = "SubF32";
    BinaryOp[BinaryOp["MulF32"] = _BinaryenMulFloat32()] = "MulF32";
    BinaryOp[BinaryOp["DivF32"] = _BinaryenDivFloat32()] = "DivF32";
    BinaryOp[BinaryOp["CopysignF32"] = _BinaryenCopySignFloat32()] = "CopysignF32";
    BinaryOp[BinaryOp["MinF32"] = _BinaryenMinFloat32()] = "MinF32";
    BinaryOp[BinaryOp["MaxF32"] = _BinaryenMaxFloat32()] = "MaxF32";
    BinaryOp[BinaryOp["EqF32"] = _BinaryenEqFloat32()] = "EqF32";
    BinaryOp[BinaryOp["NeF32"] = _BinaryenNeFloat32()] = "NeF32";
    BinaryOp[BinaryOp["LtF32"] = _BinaryenLtFloat32()] = "LtF32";
    BinaryOp[BinaryOp["LeF32"] = _BinaryenLeFloat32()] = "LeF32";
    BinaryOp[BinaryOp["GtF32"] = _BinaryenGtFloat32()] = "GtF32";
    BinaryOp[BinaryOp["GeF32"] = _BinaryenGeFloat32()] = "GeF32";
    BinaryOp[BinaryOp["AddF64"] = _BinaryenAddFloat64()] = "AddF64";
    BinaryOp[BinaryOp["SubF64"] = _BinaryenSubFloat64()] = "SubF64";
    BinaryOp[BinaryOp["MulF64"] = _BinaryenMulFloat64()] = "MulF64";
    BinaryOp[BinaryOp["DivF64"] = _BinaryenDivFloat64()] = "DivF64";
    BinaryOp[BinaryOp["CopysignF64"] = _BinaryenCopySignFloat64()] = "CopysignF64";
    BinaryOp[BinaryOp["MinF64"] = _BinaryenMinFloat64()] = "MinF64";
    BinaryOp[BinaryOp["MaxF64"] = _BinaryenMaxFloat64()] = "MaxF64";
    BinaryOp[BinaryOp["EqF64"] = _BinaryenEqFloat64()] = "EqF64";
    BinaryOp[BinaryOp["NeF64"] = _BinaryenNeFloat64()] = "NeF64";
    BinaryOp[BinaryOp["LtF64"] = _BinaryenLtFloat64()] = "LtF64";
    BinaryOp[BinaryOp["LeF64"] = _BinaryenLeFloat64()] = "LeF64";
    BinaryOp[BinaryOp["GtF64"] = _BinaryenGtFloat64()] = "GtF64";
    BinaryOp[BinaryOp["GeF64"] = _BinaryenGeFloat64()] = "GeF64";
    // see: https://github.com/WebAssembly/simd
    BinaryOp[BinaryOp["EqI8x16"] = _BinaryenEqVecI8x16()] = "EqI8x16";
    BinaryOp[BinaryOp["NeI8x16"] = _BinaryenNeVecI8x16()] = "NeI8x16";
    BinaryOp[BinaryOp["LtI8x16"] = _BinaryenLtSVecI8x16()] = "LtI8x16";
    BinaryOp[BinaryOp["LtU8x16"] = _BinaryenLtUVecI8x16()] = "LtU8x16";
    BinaryOp[BinaryOp["LeI8x16"] = _BinaryenLeSVecI8x16()] = "LeI8x16";
    BinaryOp[BinaryOp["LeU8x16"] = _BinaryenLeUVecI8x16()] = "LeU8x16";
    BinaryOp[BinaryOp["GtI8x16"] = _BinaryenGtSVecI8x16()] = "GtI8x16";
    BinaryOp[BinaryOp["GtU8x16"] = _BinaryenGtUVecI8x16()] = "GtU8x16";
    BinaryOp[BinaryOp["GeI8x16"] = _BinaryenGeSVecI8x16()] = "GeI8x16";
    BinaryOp[BinaryOp["GeU8x16"] = _BinaryenGeUVecI8x16()] = "GeU8x16";
    BinaryOp[BinaryOp["EqI16x8"] = _BinaryenEqVecI16x8()] = "EqI16x8";
    BinaryOp[BinaryOp["NeI16x8"] = _BinaryenNeVecI16x8()] = "NeI16x8";
    BinaryOp[BinaryOp["LtI16x8"] = _BinaryenLtSVecI16x8()] = "LtI16x8";
    BinaryOp[BinaryOp["LtU16x8"] = _BinaryenLtUVecI16x8()] = "LtU16x8";
    BinaryOp[BinaryOp["LeI16x8"] = _BinaryenLeSVecI16x8()] = "LeI16x8";
    BinaryOp[BinaryOp["LeU16x8"] = _BinaryenLeUVecI16x8()] = "LeU16x8";
    BinaryOp[BinaryOp["GtI16x8"] = _BinaryenGtSVecI16x8()] = "GtI16x8";
    BinaryOp[BinaryOp["GtU16x8"] = _BinaryenGtUVecI16x8()] = "GtU16x8";
    BinaryOp[BinaryOp["GeI16x8"] = _BinaryenGeSVecI16x8()] = "GeI16x8";
    BinaryOp[BinaryOp["GeU16x8"] = _BinaryenGeUVecI16x8()] = "GeU16x8";
    BinaryOp[BinaryOp["EqI32x4"] = _BinaryenEqVecI32x4()] = "EqI32x4";
    BinaryOp[BinaryOp["NeI32x4"] = _BinaryenNeVecI32x4()] = "NeI32x4";
    BinaryOp[BinaryOp["LtI32x4"] = _BinaryenLtSVecI32x4()] = "LtI32x4";
    BinaryOp[BinaryOp["LtU32x4"] = _BinaryenLtUVecI32x4()] = "LtU32x4";
    BinaryOp[BinaryOp["LeI32x4"] = _BinaryenLeSVecI32x4()] = "LeI32x4";
    BinaryOp[BinaryOp["LeU32x4"] = _BinaryenLeUVecI32x4()] = "LeU32x4";
    BinaryOp[BinaryOp["GtI32x4"] = _BinaryenGtSVecI32x4()] = "GtI32x4";
    BinaryOp[BinaryOp["GtU32x4"] = _BinaryenGtUVecI32x4()] = "GtU32x4";
    BinaryOp[BinaryOp["GeI32x4"] = _BinaryenGeSVecI32x4()] = "GeI32x4";
    BinaryOp[BinaryOp["GeU32x4"] = _BinaryenGeUVecI32x4()] = "GeU32x4";
    BinaryOp[BinaryOp["EqF32x4"] = _BinaryenEqVecF32x4()] = "EqF32x4";
    BinaryOp[BinaryOp["NeF32x4"] = _BinaryenNeVecF32x4()] = "NeF32x4";
    BinaryOp[BinaryOp["LtF32x4"] = _BinaryenLtVecF32x4()] = "LtF32x4";
    BinaryOp[BinaryOp["LeF32x4"] = _BinaryenLeVecF32x4()] = "LeF32x4";
    BinaryOp[BinaryOp["GtF32x4"] = _BinaryenGtVecF32x4()] = "GtF32x4";
    BinaryOp[BinaryOp["GeF32x4"] = _BinaryenGeVecF32x4()] = "GeF32x4";
    BinaryOp[BinaryOp["EqF64x2"] = _BinaryenEqVecF64x2()] = "EqF64x2";
    BinaryOp[BinaryOp["NeF64x2"] = _BinaryenNeVecF64x2()] = "NeF64x2";
    BinaryOp[BinaryOp["LtF64x2"] = _BinaryenLtVecF64x2()] = "LtF64x2";
    BinaryOp[BinaryOp["LeF64x2"] = _BinaryenLeVecF64x2()] = "LeF64x2";
    BinaryOp[BinaryOp["GtF64x2"] = _BinaryenGtVecF64x2()] = "GtF64x2";
    BinaryOp[BinaryOp["GeF64x2"] = _BinaryenGeVecF64x2()] = "GeF64x2";
    BinaryOp[BinaryOp["AndV128"] = _BinaryenAndVec128()] = "AndV128";
    BinaryOp[BinaryOp["OrV128"] = _BinaryenOrVec128()] = "OrV128";
    BinaryOp[BinaryOp["XorV128"] = _BinaryenXorVec128()] = "XorV128";
    BinaryOp[BinaryOp["AndNotV128"] = _BinaryenAndNotVec128()] = "AndNotV128";
    BinaryOp[BinaryOp["AddI8x16"] = _BinaryenAddVecI8x16()] = "AddI8x16";
    BinaryOp[BinaryOp["AddSatI8x16"] = _BinaryenAddSatSVecI8x16()] = "AddSatI8x16";
    BinaryOp[BinaryOp["AddSatU8x16"] = _BinaryenAddSatUVecI8x16()] = "AddSatU8x16";
    BinaryOp[BinaryOp["SubI8x16"] = _BinaryenSubVecI8x16()] = "SubI8x16";
    BinaryOp[BinaryOp["SubSatI8x16"] = _BinaryenSubSatSVecI8x16()] = "SubSatI8x16";
    BinaryOp[BinaryOp["SubSatU8x16"] = _BinaryenSubSatUVecI8x16()] = "SubSatU8x16";
    BinaryOp[BinaryOp["MulI8x16"] = _BinaryenMulVecI8x16()] = "MulI8x16";
    BinaryOp[BinaryOp["MinI8x16"] = _BinaryenMinSVecI8x16()] = "MinI8x16";
    BinaryOp[BinaryOp["MinU8x16"] = _BinaryenMinUVecI8x16()] = "MinU8x16";
    BinaryOp[BinaryOp["MaxI8x16"] = _BinaryenMaxSVecI8x16()] = "MaxI8x16";
    BinaryOp[BinaryOp["MaxU8x16"] = _BinaryenMaxUVecI8x16()] = "MaxU8x16";
    BinaryOp[BinaryOp["AddI16x8"] = _BinaryenAddVecI16x8()] = "AddI16x8";
    BinaryOp[BinaryOp["AddSatI16x8"] = _BinaryenAddSatSVecI16x8()] = "AddSatI16x8";
    BinaryOp[BinaryOp["AddSatU16x8"] = _BinaryenAddSatUVecI16x8()] = "AddSatU16x8";
    BinaryOp[BinaryOp["SubI16x8"] = _BinaryenSubVecI16x8()] = "SubI16x8";
    BinaryOp[BinaryOp["SubSatI16x8"] = _BinaryenSubSatSVecI16x8()] = "SubSatI16x8";
    BinaryOp[BinaryOp["SubSatU16x8"] = _BinaryenSubSatUVecI16x8()] = "SubSatU16x8";
    BinaryOp[BinaryOp["MulI16x8"] = _BinaryenMulVecI16x8()] = "MulI16x8";
    BinaryOp[BinaryOp["MinI16x8"] = _BinaryenMinSVecI16x8()] = "MinI16x8";
    BinaryOp[BinaryOp["MinU16x8"] = _BinaryenMinUVecI16x8()] = "MinU16x8";
    BinaryOp[BinaryOp["MaxI16x8"] = _BinaryenMaxSVecI16x8()] = "MaxI16x8";
    BinaryOp[BinaryOp["MaxU16x8"] = _BinaryenMaxUVecI16x8()] = "MaxU16x8";
    BinaryOp[BinaryOp["AddI32x4"] = _BinaryenAddVecI32x4()] = "AddI32x4";
    BinaryOp[BinaryOp["SubI32x4"] = _BinaryenSubVecI32x4()] = "SubI32x4";
    BinaryOp[BinaryOp["MulI32x4"] = _BinaryenMulVecI32x4()] = "MulI32x4";
    BinaryOp[BinaryOp["MinI32x4"] = _BinaryenMinSVecI32x4()] = "MinI32x4";
    BinaryOp[BinaryOp["MinU32x4"] = _BinaryenMinUVecI32x4()] = "MinU32x4";
    BinaryOp[BinaryOp["MaxI32x4"] = _BinaryenMaxSVecI32x4()] = "MaxI32x4";
    BinaryOp[BinaryOp["MaxU32x4"] = _BinaryenMaxUVecI32x4()] = "MaxU32x4";
    BinaryOp[BinaryOp["DotI16x8"] = _BinaryenDotSVecI16x8ToVecI32x4()] = "DotI16x8";
    BinaryOp[BinaryOp["AddI64x2"] = _BinaryenAddVecI64x2()] = "AddI64x2";
    BinaryOp[BinaryOp["SubI64x2"] = _BinaryenSubVecI64x2()] = "SubI64x2";
    BinaryOp[BinaryOp["AddF32x4"] = _BinaryenAddVecF32x4()] = "AddF32x4";
    BinaryOp[BinaryOp["SubF32x4"] = _BinaryenSubVecF32x4()] = "SubF32x4";
    BinaryOp[BinaryOp["MulF32x4"] = _BinaryenMulVecF32x4()] = "MulF32x4";
    BinaryOp[BinaryOp["DivF32x4"] = _BinaryenDivVecF32x4()] = "DivF32x4";
    BinaryOp[BinaryOp["MinF32x4"] = _BinaryenMinVecF32x4()] = "MinF32x4";
    BinaryOp[BinaryOp["MaxF32x4"] = _BinaryenMaxVecF32x4()] = "MaxF32x4";
    BinaryOp[BinaryOp["AddF64x2"] = _BinaryenAddVecF64x2()] = "AddF64x2";
    BinaryOp[BinaryOp["SubF64x2"] = _BinaryenSubVecF64x2()] = "SubF64x2";
    BinaryOp[BinaryOp["MulF64x2"] = _BinaryenMulVecF64x2()] = "MulF64x2";
    BinaryOp[BinaryOp["DivF64x2"] = _BinaryenDivVecF64x2()] = "DivF64x2";
    BinaryOp[BinaryOp["MinF64x2"] = _BinaryenMinVecF64x2()] = "MinF64x2";
    BinaryOp[BinaryOp["MaxF64x2"] = _BinaryenMaxVecF64x2()] = "MaxF64x2";
    BinaryOp[BinaryOp["NarrowI16x8ToI8x16"] = _BinaryenNarrowSVecI16x8ToVecI8x16()] = "NarrowI16x8ToI8x16";
    BinaryOp[BinaryOp["NarrowU16x8ToU8x16"] = _BinaryenNarrowUVecI16x8ToVecI8x16()] = "NarrowU16x8ToU8x16";
    BinaryOp[BinaryOp["NarrowI32x4ToI16x8"] = _BinaryenNarrowSVecI32x4ToVecI16x8()] = "NarrowI32x4ToI16x8";
    BinaryOp[BinaryOp["NarrowU32x4ToU16x8"] = _BinaryenNarrowUVecI32x4ToVecI16x8()] = "NarrowU32x4ToU16x8";
    BinaryOp[BinaryOp["SwizzleV8x16"] = _BinaryenSwizzleVec8x16()] = "SwizzleV8x16";
})(BinaryOp = exports.BinaryOp || (exports.BinaryOp = {}));
var HostOp;
(function (HostOp) {
    HostOp[HostOp["MemorySize"] = _BinaryenMemorySize()] = "MemorySize";
    HostOp[HostOp["MemoryGrow"] = _BinaryenMemoryGrow()] = "MemoryGrow";
})(HostOp = exports.HostOp || (exports.HostOp = {}));
var AtomicRMWOp;
(function (AtomicRMWOp) {
    AtomicRMWOp[AtomicRMWOp["Add"] = _BinaryenAtomicRMWAdd()] = "Add";
    AtomicRMWOp[AtomicRMWOp["Sub"] = _BinaryenAtomicRMWSub()] = "Sub";
    AtomicRMWOp[AtomicRMWOp["And"] = _BinaryenAtomicRMWAnd()] = "And";
    AtomicRMWOp[AtomicRMWOp["Or"] = _BinaryenAtomicRMWOr()] = "Or";
    AtomicRMWOp[AtomicRMWOp["Xor"] = _BinaryenAtomicRMWXor()] = "Xor";
    AtomicRMWOp[AtomicRMWOp["Xchg"] = _BinaryenAtomicRMWXchg()] = "Xchg";
})(AtomicRMWOp = exports.AtomicRMWOp || (exports.AtomicRMWOp = {}));
var SIMDExtractOp;
(function (SIMDExtractOp) {
    SIMDExtractOp[SIMDExtractOp["ExtractLaneI8x16"] = _BinaryenExtractLaneSVecI8x16()] = "ExtractLaneI8x16";
    SIMDExtractOp[SIMDExtractOp["ExtractLaneU8x16"] = _BinaryenExtractLaneUVecI8x16()] = "ExtractLaneU8x16";
    SIMDExtractOp[SIMDExtractOp["ExtractLaneI16x8"] = _BinaryenExtractLaneSVecI16x8()] = "ExtractLaneI16x8";
    SIMDExtractOp[SIMDExtractOp["ExtractLaneU16x8"] = _BinaryenExtractLaneUVecI16x8()] = "ExtractLaneU16x8";
    SIMDExtractOp[SIMDExtractOp["ExtractLaneI32x4"] = _BinaryenExtractLaneVecI32x4()] = "ExtractLaneI32x4";
    SIMDExtractOp[SIMDExtractOp["ExtractLaneI64x2"] = _BinaryenExtractLaneVecI64x2()] = "ExtractLaneI64x2";
    SIMDExtractOp[SIMDExtractOp["ExtractLaneF32x4"] = _BinaryenExtractLaneVecF32x4()] = "ExtractLaneF32x4";
    SIMDExtractOp[SIMDExtractOp["ExtractLaneF64x2"] = _BinaryenExtractLaneVecF64x2()] = "ExtractLaneF64x2";
})(SIMDExtractOp = exports.SIMDExtractOp || (exports.SIMDExtractOp = {}));
var SIMDReplaceOp;
(function (SIMDReplaceOp) {
    SIMDReplaceOp[SIMDReplaceOp["ReplaceLaneI8x16"] = _BinaryenReplaceLaneVecI8x16()] = "ReplaceLaneI8x16";
    SIMDReplaceOp[SIMDReplaceOp["ReplaceLaneI16x8"] = _BinaryenReplaceLaneVecI16x8()] = "ReplaceLaneI16x8";
    SIMDReplaceOp[SIMDReplaceOp["ReplaceLaneI32x4"] = _BinaryenReplaceLaneVecI32x4()] = "ReplaceLaneI32x4";
    SIMDReplaceOp[SIMDReplaceOp["ReplaceLaneI64x2"] = _BinaryenReplaceLaneVecI64x2()] = "ReplaceLaneI64x2";
    SIMDReplaceOp[SIMDReplaceOp["ReplaceLaneF32x4"] = _BinaryenReplaceLaneVecF32x4()] = "ReplaceLaneF32x4";
    SIMDReplaceOp[SIMDReplaceOp["ReplaceLaneF64x2"] = _BinaryenReplaceLaneVecF64x2()] = "ReplaceLaneF64x2";
})(SIMDReplaceOp = exports.SIMDReplaceOp || (exports.SIMDReplaceOp = {}));
var SIMDShiftOp;
(function (SIMDShiftOp) {
    SIMDShiftOp[SIMDShiftOp["ShlI8x16"] = _BinaryenShlVecI8x16()] = "ShlI8x16";
    SIMDShiftOp[SIMDShiftOp["ShrI8x16"] = _BinaryenShrSVecI8x16()] = "ShrI8x16";
    SIMDShiftOp[SIMDShiftOp["ShrU8x16"] = _BinaryenShrUVecI8x16()] = "ShrU8x16";
    SIMDShiftOp[SIMDShiftOp["ShlI16x8"] = _BinaryenShlVecI16x8()] = "ShlI16x8";
    SIMDShiftOp[SIMDShiftOp["ShrI16x8"] = _BinaryenShrSVecI16x8()] = "ShrI16x8";
    SIMDShiftOp[SIMDShiftOp["ShrU16x8"] = _BinaryenShrUVecI16x8()] = "ShrU16x8";
    SIMDShiftOp[SIMDShiftOp["ShlI32x4"] = _BinaryenShlVecI32x4()] = "ShlI32x4";
    SIMDShiftOp[SIMDShiftOp["ShrI32x4"] = _BinaryenShrSVecI32x4()] = "ShrI32x4";
    SIMDShiftOp[SIMDShiftOp["ShrU32x4"] = _BinaryenShrUVecI32x4()] = "ShrU32x4";
    SIMDShiftOp[SIMDShiftOp["ShlI64x2"] = _BinaryenShlVecI64x2()] = "ShlI64x2";
    SIMDShiftOp[SIMDShiftOp["ShrI64x2"] = _BinaryenShrSVecI64x2()] = "ShrI64x2";
    SIMDShiftOp[SIMDShiftOp["ShrU64x2"] = _BinaryenShrUVecI64x2()] = "ShrU64x2";
})(SIMDShiftOp = exports.SIMDShiftOp || (exports.SIMDShiftOp = {}));
var SIMDTernaryOp;
(function (SIMDTernaryOp) {
    SIMDTernaryOp[SIMDTernaryOp["Bitselect"] = _BinaryenBitselectVec128()] = "Bitselect";
    SIMDTernaryOp[SIMDTernaryOp["QFMAF32x4"] = _BinaryenQFMAVecF32x4()] = "QFMAF32x4";
    SIMDTernaryOp[SIMDTernaryOp["QFMSF32x4"] = _BinaryenQFMSVecF32x4()] = "QFMSF32x4";
    SIMDTernaryOp[SIMDTernaryOp["QFMAF64x2"] = _BinaryenQFMAVecF64x2()] = "QFMAF64x2";
    SIMDTernaryOp[SIMDTernaryOp["QFMSF64x2"] = _BinaryenQFMSVecF64x2()] = "QFMSF64x2";
})(SIMDTernaryOp = exports.SIMDTernaryOp || (exports.SIMDTernaryOp = {}));
var SIMDLoadOp;
(function (SIMDLoadOp) {
    SIMDLoadOp[SIMDLoadOp["LoadSplatV8x16"] = _BinaryenLoadSplatVec8x16()] = "LoadSplatV8x16";
    SIMDLoadOp[SIMDLoadOp["LoadSplatV16x8"] = _BinaryenLoadSplatVec16x8()] = "LoadSplatV16x8";
    SIMDLoadOp[SIMDLoadOp["LoadSplatV32x4"] = _BinaryenLoadSplatVec32x4()] = "LoadSplatV32x4";
    SIMDLoadOp[SIMDLoadOp["LoadSplatV64x2"] = _BinaryenLoadSplatVec64x2()] = "LoadSplatV64x2";
    SIMDLoadOp[SIMDLoadOp["LoadI8ToI16x8"] = _BinaryenLoadExtSVec8x8ToVecI16x8()] = "LoadI8ToI16x8";
    SIMDLoadOp[SIMDLoadOp["LoadU8ToU16x8"] = _BinaryenLoadExtUVec8x8ToVecI16x8()] = "LoadU8ToU16x8";
    SIMDLoadOp[SIMDLoadOp["LoadI16ToI32x4"] = _BinaryenLoadExtSVec16x4ToVecI32x4()] = "LoadI16ToI32x4";
    SIMDLoadOp[SIMDLoadOp["LoadU16ToU32x4"] = _BinaryenLoadExtUVec16x4ToVecI32x4()] = "LoadU16ToU32x4";
    SIMDLoadOp[SIMDLoadOp["LoadI32ToI64x2"] = _BinaryenLoadExtSVec32x2ToVecI64x2()] = "LoadI32ToI64x2";
    SIMDLoadOp[SIMDLoadOp["LoadU32ToU64x2"] = _BinaryenLoadExtUVec32x2ToVecI64x2()] = "LoadU32ToU64x2";
})(SIMDLoadOp = exports.SIMDLoadOp || (exports.SIMDLoadOp = {}));
class MemorySegment {
    static create(buffer, offset) {
        var segment = new MemorySegment();
        segment.buffer = buffer;
        segment.offset = offset;
        return segment;
    }
}
exports.MemorySegment = MemorySegment;
class Module {
    constructor() {
        this.hasTemporaryFunction = false;
        this.cachedPrecomputeNames = 0;
        this.cachedStrings = new Map();
    }
    static create() {
        var module = new Module();
        module.ref = _BinaryenModuleCreate();
        module.lit = memory.allocate(_BinaryenSizeofLiteral());
        return module;
    }
    static createFrom(buffer) {
        var cArr = allocU8Array(buffer);
        try {
            let module = new Module();
            module.ref = _BinaryenModuleRead(cArr, buffer.length);
            module.lit = memory.allocate(_BinaryenSizeofLiteral());
            return module;
        }
        finally {
            memory.free(changetype(cArr));
        }
    }
    // types
    addFunctionType(name, result, paramTypes) {
        var cStr = this.allocStringCached(name);
        var cArr = allocI32Array(paramTypes);
        try {
            return _BinaryenAddFunctionType(this.ref, cStr, result, cArr, paramTypes ? paramTypes.length : 0);
        }
        finally {
            memory.free(cArr);
        }
    }
    getFunctionTypeBySignature(result, paramTypes) {
        var cArr = allocI32Array(paramTypes);
        try {
            return _BinaryenGetFunctionTypeBySignature(this.ref, result, cArr, paramTypes ? paramTypes.length : 0);
        }
        finally {
            memory.free(cArr);
        }
    }
    removeFunctionType(name) {
        var cStr = this.allocStringCached(name);
        _BinaryenRemoveFunctionType(this.ref, cStr);
    }
    // constants
    i32(value) {
        var out = this.lit;
        _BinaryenLiteralInt32(out, value);
        return _BinaryenConst(this.ref, out);
    }
    i64(valueLow, valueHigh = 0) {
        var out = this.lit;
        _BinaryenLiteralInt64(out, valueLow, valueHigh);
        return _BinaryenConst(this.ref, out);
    }
    f32(value) {
        var out = this.lit;
        _BinaryenLiteralFloat32(out, value);
        return _BinaryenConst(this.ref, out);
    }
    f64(value) {
        var out = this.lit;
        _BinaryenLiteralFloat64(out, value);
        return _BinaryenConst(this.ref, out);
    }
    v128(bytes) {
        assert(bytes.length == 16);
        var out = this.lit;
        for (let i = 0; i < 16; ++i)
            store(out + i, bytes[i]);
        _BinaryenLiteralVec128(out, out);
        return _BinaryenConst(this.ref, out);
    }
    // expressions
    unary(op, expr) {
        return _BinaryenUnary(this.ref, op, expr);
    }
    binary(op, left, right) {
        return _BinaryenBinary(this.ref, op, left, right);
    }
    host(op, name = null, operands = null) {
        var cStr = this.allocStringCached(name);
        var cArr = allocPtrArray(operands);
        try {
            return _BinaryenHost(this.ref, op, cStr, cArr, operands ? operands.length : 0);
        }
        finally {
            memory.free(cArr);
        }
    }
    local_get(index, type) {
        return _BinaryenLocalGet(this.ref, index, type);
    }
    local_tee(index, value) {
        return _BinaryenLocalTee(this.ref, index, value);
    }
    global_get(name, type) {
        var cStr = this.allocStringCached(name);
        return _BinaryenGlobalGet(this.ref, cStr, type);
    }
    load(bytes, signed, ptr, type, offset = 0, align = bytes // naturally aligned by default
    ) {
        return _BinaryenLoad(this.ref, bytes, signed ? 1 : 0, offset, align, type, ptr);
    }
    store(bytes, ptr, value, type, offset = 0, align = bytes // naturally aligned by default
    ) {
        if (type < NativeType.None || type > NativeType.V128)
            throw new Error("here: " + type);
        return _BinaryenStore(this.ref, bytes, offset, align, ptr, value, type);
    }
    atomic_load(bytes, ptr, type, offset = 0) {
        return _BinaryenAtomicLoad(this.ref, bytes, offset, type, ptr);
    }
    atomic_store(bytes, ptr, value, type, offset = 0) {
        return _BinaryenAtomicStore(this.ref, bytes, offset, ptr, value, type);
    }
    atomic_rmw(op, bytes, offset, ptr, value, type) {
        return _BinaryenAtomicRMW(this.ref, op, bytes, offset, ptr, value, type);
    }
    atomic_cmpxchg(bytes, offset, ptr, expected, replacement, type) {
        return _BinaryenAtomicCmpxchg(this.ref, bytes, offset, ptr, expected, replacement, type);
    }
    atomic_wait(ptr, expected, timeout, expectedType) {
        return _BinaryenAtomicWait(this.ref, ptr, expected, timeout, expectedType);
    }
    atomic_notify(ptr, notifyCount) {
        return _BinaryenAtomicNotify(this.ref, ptr, notifyCount);
    }
    atomic_fence() {
        return _BinaryenAtomicFence(this.ref);
    }
    // statements
    local_set(index, value) {
        return _BinaryenLocalSet(this.ref, index, value);
    }
    global_set(name, value) {
        var cStr = this.allocStringCached(name);
        return _BinaryenGlobalSet(this.ref, cStr, value);
    }
    block(label, children, type = NativeType.None) {
        var cStr = this.allocStringCached(label);
        var cArr = allocPtrArray(children);
        try {
            return _BinaryenBlock(this.ref, cStr, cArr, children.length, type);
        }
        finally {
            memory.free(cArr);
        }
    }
    br(label, condition = 0, value = 0) {
        var cStr = this.allocStringCached(label);
        return _BinaryenBreak(this.ref, cStr, condition, value);
    }
    drop(expression) {
        return _BinaryenDrop(this.ref, expression);
    }
    loop(label, body) {
        var cStr = this.allocStringCached(label);
        return _BinaryenLoop(this.ref, cStr, body);
    }
    if(condition, ifTrue, ifFalse = 0) {
        return _BinaryenIf(this.ref, condition, ifTrue, ifFalse);
    }
    nop() {
        return _BinaryenNop(this.ref);
    }
    return(expression = 0) {
        return _BinaryenReturn(this.ref, expression);
    }
    select(ifTrue, ifFalse, condition) {
        return _BinaryenSelect(this.ref, condition, ifTrue, ifFalse);
    }
    switch(names, defaultName, condition, value = 0) {
        var numNames = names.length;
        var strs = new Array(numNames);
        for (let i = 0; i < numNames; ++i) {
            strs[i] = this.allocStringCached(names[i]);
        }
        var cArr = allocI32Array(strs);
        var cStr = this.allocStringCached(defaultName);
        try {
            return _BinaryenSwitch(this.ref, cArr, numNames, cStr, condition, value);
        }
        finally {
            memory.free(cArr);
        }
    }
    call(target, operands, returnType, isReturn = false) {
        var cStr = this.allocStringCached(target);
        var cArr = allocPtrArray(operands);
        try {
            return isReturn
                ? _BinaryenReturnCall(this.ref, cStr, cArr, operands && operands.length || 0, returnType)
                : _BinaryenCall(this.ref, cStr, cArr, operands && operands.length || 0, returnType);
        }
        finally {
            memory.free(cArr);
        }
    }
    return_call(target, operands, returnType) {
        return this.call(target, operands, returnType, true);
    }
    call_indirect(index, operands, typeName, isReturn = false) {
        var cStr = this.allocStringCached(typeName);
        var cArr = allocPtrArray(operands);
        try {
            return isReturn
                ? _BinaryenReturnCallIndirect(this.ref, index, cArr, operands && operands.length || 0, cStr)
                : _BinaryenCallIndirect(this.ref, index, cArr, operands && operands.length || 0, cStr);
        }
        finally {
            memory.free(cArr);
        }
    }
    return_call_indirect(index, operands, typeName) {
        return this.call_indirect(index, operands, typeName, true);
    }
    unreachable() {
        return _BinaryenUnreachable(this.ref);
    }
    // bulk memory
    memory_copy(dest, source, size) {
        return _BinaryenMemoryCopy(this.ref, dest, source, size);
    }
    memory_fill(dest, value, size) {
        return _BinaryenMemoryFill(this.ref, dest, value, size);
    }
    // exception handling
    try(body, catchBody) {
        return _BinaryenTry(this.ref, body, catchBody);
    }
    throw(eventName, operands) {
        var cStr = this.allocStringCached(eventName);
        var cArr = allocPtrArray(operands);
        try {
            return _BinaryenThrow(this.ref, cStr, cArr, operands.length);
        }
        finally {
            memory.free(cArr);
        }
    }
    rethrow(exnref) {
        return _BinaryenRethrow(this.ref, exnref);
    }
    br_on_exn(name, eventName, exnref) {
        var cStr1 = this.allocStringCached(name);
        var cStr2 = this.allocStringCached(eventName);
        return _BinaryenBrOnExn(this.ref, cStr1, cStr2, exnref);
    }
    // push / pop (multi value?)
    push(value) {
        return _BinaryenPush(this.ref, value);
    }
    pop(type) {
        return _BinaryenPop(this.ref, type);
    }
    // simd
    simd_extract(op, vec, idx) {
        return _BinaryenSIMDExtract(this.ref, op, vec, idx);
    }
    simd_replace(op, vec, idx, value) {
        return _BinaryenSIMDReplace(this.ref, op, vec, idx, value);
    }
    simd_shuffle(vec1, vec2, mask) {
        assert(mask.length == 16);
        var cArr = allocU8Array(mask);
        try {
            return _BinaryenSIMDShuffle(this.ref, vec1, vec2, cArr);
        }
        finally {
            memory.free(cArr);
        }
    }
    simd_ternary(op, a, b, c) {
        return _BinaryenSIMDTernary(this.ref, op, a, b, c);
    }
    simd_shift(op, vec, shift) {
        return _BinaryenSIMDShift(this.ref, op, vec, shift);
    }
    simd_load(op, ptr, offset, align) {
        return _BinaryenSIMDLoad(this.ref, op, offset, align, ptr);
    }
    // meta
    addGlobal(name, type, mutable, initializer) {
        var cStr = this.allocStringCached(name);
        return _BinaryenAddGlobal(this.ref, cStr, type, mutable, initializer);
    }
    removeGlobal(name) {
        var cStr = this.allocStringCached(name);
        _BinaryenRemoveGlobal(this.ref, cStr);
    }
    addEvent(name, attribute, type) {
        var cStr = this.allocStringCached(name);
        return _BinaryenAddEvent(this.ref, cStr, attribute, type);
    }
    addFunction(name, type, varTypes, body) {
        var cStr = this.allocStringCached(name);
        var cArr = allocI32Array(varTypes);
        try {
            return _BinaryenAddFunction(this.ref, cStr, type, cArr, varTypes ? varTypes.length : 0, body);
        }
        finally {
            memory.free(cArr);
        }
    }
    getFunction(name) {
        var cStr = this.allocStringCached(name);
        return _BinaryenGetFunction(this.ref, cStr);
    }
    removeFunction(name) {
        var cStr = this.allocStringCached(name);
        _BinaryenRemoveFunction(this.ref, cStr);
    }
    addTemporaryFunction(result, paramTypes, body) {
        this.hasTemporaryFunction = assert(!this.hasTemporaryFunction);
        var tempName = this.allocStringCached("");
        var cArr = allocI32Array(paramTypes);
        try {
            let typeRef = _BinaryenAddFunctionType(this.ref, tempName, result, cArr, paramTypes ? paramTypes.length : 0);
            return _BinaryenAddFunction(this.ref, tempName, typeRef, 0, 0, body);
        }
        finally {
            memory.free(cArr);
        }
    }
    removeTemporaryFunction() {
        this.hasTemporaryFunction = !assert(this.hasTemporaryFunction);
        var tempName = this.allocStringCached("");
        _BinaryenRemoveFunction(this.ref, tempName);
        _BinaryenRemoveFunctionType(this.ref, tempName);
    }
    addFunctionExport(internalName, externalName) {
        var cStr1 = this.allocStringCached(internalName);
        var cStr2 = this.allocStringCached(externalName);
        return _BinaryenAddFunctionExport(this.ref, cStr1, cStr2);
    }
    addTableExport(internalName, externalName) {
        var cStr1 = this.allocStringCached(internalName);
        var cStr2 = this.allocStringCached(externalName);
        return _BinaryenAddTableExport(this.ref, cStr1, cStr2);
    }
    addMemoryExport(internalName, externalName) {
        var cStr1 = this.allocStringCached(internalName);
        var cStr2 = this.allocStringCached(externalName);
        return _BinaryenAddMemoryExport(this.ref, cStr1, cStr2);
    }
    addGlobalExport(internalName, externalName) {
        var cStr1 = this.allocStringCached(internalName);
        var cStr2 = this.allocStringCached(externalName);
        return _BinaryenAddGlobalExport(this.ref, cStr1, cStr2);
    }
    addEventExport(internalName, externalName) {
        var cStr1 = this.allocStringCached(internalName);
        var cStr2 = this.allocStringCached(externalName);
        return _BinaryenAddEventExport(this.ref, cStr1, cStr2);
    }
    removeExport(externalName) {
        var cStr = this.allocStringCached(externalName);
        _BinaryenRemoveExport(this.ref, cStr);
    }
    addFunctionImport(internalName, externalModuleName, externalBaseName, functionType) {
        var cStr1 = this.allocStringCached(internalName);
        var cStr2 = this.allocStringCached(externalModuleName);
        var cStr3 = this.allocStringCached(externalBaseName);
        _BinaryenAddFunctionImport(this.ref, cStr1, cStr2, cStr3, functionType);
    }
    addTableImport(internalName, externalModuleName, externalBaseName) {
        var cStr1 = this.allocStringCached(internalName);
        var cStr2 = this.allocStringCached(externalModuleName);
        var cStr3 = this.allocStringCached(externalBaseName);
        _BinaryenAddTableImport(this.ref, cStr1, cStr2, cStr3);
    }
    addMemoryImport(internalName, externalModuleName, externalBaseName, shared = false) {
        var cStr1 = this.allocStringCached(internalName);
        var cStr2 = this.allocStringCached(externalModuleName);
        var cStr3 = this.allocStringCached(externalBaseName);
        _BinaryenAddMemoryImport(this.ref, cStr1, cStr2, cStr3, shared);
    }
    addGlobalImport(internalName, externalModuleName, externalBaseName, globalType, mutable = false) {
        var cStr1 = this.allocStringCached(internalName);
        var cStr2 = this.allocStringCached(externalModuleName);
        var cStr3 = this.allocStringCached(externalBaseName);
        _BinaryenAddGlobalImport(this.ref, cStr1, cStr2, cStr3, globalType, mutable);
    }
    addEventImport(internalName, externalModuleName, externalBaseName, attribute, eventType) {
        var cStr1 = this.allocStringCached(internalName);
        var cStr2 = this.allocStringCached(externalModuleName);
        var cStr3 = this.allocStringCached(externalBaseName);
        _BinaryenAddEventImport(this.ref, cStr1, cStr2, cStr3, attribute, eventType);
    }
    setMemory(initial, maximum, segments, target, exportName = null, shared = false) {
        var cStr = this.allocStringCached(exportName);
        var k = segments.length;
        var segs = new Array(k);
        var psvs = new Uint8Array(k);
        var offs = new Array(k);
        var sizs = new Array(k);
        for (let i = 0; i < k; ++i) {
            let buffer = segments[i].buffer;
            let offset = segments[i].offset;
            segs[i] = allocU8Array(buffer);
            psvs[i] = 0; // no passive segments currently
            offs[i] = target == common_1.Target.WASM64
                ? this.i64(i64_low(offset), i64_high(offset))
                : this.i32(i64_low(offset));
            sizs[i] = buffer.length;
        }
        var cArr1 = allocI32Array(segs);
        var cArr2 = allocU8Array(psvs);
        var cArr3 = allocI32Array(offs);
        var cArr4 = allocI32Array(sizs);
        try {
            _BinaryenSetMemory(this.ref, initial, maximum, cStr, cArr1, cArr2, cArr3, cArr4, k, shared);
        }
        finally {
            memory.free(cArr4);
            memory.free(cArr3);
            memory.free(cArr2);
            memory.free(cArr1);
            for (let i = k - 1; i >= 0; --i)
                memory.free(segs[i]);
        }
    }
    setFunctionTable(initial, maximum, funcs, offset) {
        var numNames = funcs.length;
        var names = new Array(numNames);
        for (let i = 0; i < numNames; ++i) {
            names[i] = this.allocStringCached(funcs[i]);
        }
        var cArr = allocI32Array(names);
        try {
            _BinaryenSetFunctionTable(this.ref, initial, maximum, cArr, numNames, offset);
        }
        finally {
            memory.free(cArr);
        }
    }
    setStart(func) {
        _BinaryenSetStart(this.ref, func);
    }
    addCustomSection(name, contents) {
        var cStr = this.allocStringCached(name);
        var cArr = allocU8Array(contents);
        try {
            _BinaryenAddCustomSection(this.ref, cStr, cArr, contents.length);
        }
        finally {
            memory.free(cArr);
        }
    }
    getOptimizeLevel() {
        return _BinaryenGetOptimizeLevel();
    }
    setOptimizeLevel(level = 2) {
        _BinaryenSetOptimizeLevel(level);
    }
    getShrinkLevel() {
        return _BinaryenGetShrinkLevel();
    }
    setShrinkLevel(level = 1) {
        _BinaryenSetShrinkLevel(level);
    }
    setDebugInfo(on = false) {
        _BinaryenSetDebugInfo(on);
    }
    getFeatures() {
        return _BinaryenModuleGetFeatures(this.ref);
    }
    setFeatures(featureFlags) {
        _BinaryenModuleSetFeatures(this.ref, featureFlags);
    }
    optimize(func = 0) {
        if (func) {
            _BinaryenFunctionOptimize(func, this.ref);
        }
        else {
            _BinaryenModuleOptimize(this.ref);
        }
    }
    runPasses(passes, func = 0) {
        var numNames = passes.length;
        var names = new Array(numNames);
        for (let i = 0; i < numNames; ++i) {
            names[i] = allocString(passes[i]);
        }
        var cArr = allocI32Array(names);
        try {
            if (func) {
                _BinaryenFunctionRunPasses(func, this.ref, cArr, numNames);
            }
            else {
                _BinaryenModuleRunPasses(this.ref, cArr, numNames);
            }
        }
        finally {
            memory.free(cArr);
            for (let i = numNames; i >= 0; --i)
                memory.free(names[i]);
        }
    }
    precomputeExpression(expr) {
        // remember the previous optimize levels and set to max instead, to be sure
        var previousOptimizeLevel = _BinaryenGetOptimizeLevel();
        var previousShrinkLevel = _BinaryenGetShrinkLevel();
        var previousDebugInfo = _BinaryenGetDebugInfo();
        _BinaryenSetOptimizeLevel(4);
        _BinaryenSetShrinkLevel(0);
        _BinaryenSetDebugInfo(false);
        // wrap the expression in a temp. function and run the precompute pass on it
        var type = _BinaryenExpressionGetType(expr);
        var func = this.addTemporaryFunction(type, null, expr);
        var names = this.cachedPrecomputeNames;
        if (!names) {
            this.cachedPrecomputeNames = names = allocI32Array([
                this.allocStringCached("vacuum"),
                this.allocStringCached("precompute")
            ]);
        }
        _BinaryenFunctionRunPasses(func, this.ref, names, 2);
        expr = _BinaryenFunctionGetBody(func);
        if (_BinaryenExpressionGetId(expr) == ExpressionId.Return) {
            expr = _BinaryenReturnGetValue(expr);
        }
        this.removeTemporaryFunction();
        // reset optimize levels to previous
        _BinaryenSetOptimizeLevel(previousOptimizeLevel);
        _BinaryenSetShrinkLevel(previousShrinkLevel);
        _BinaryenSetDebugInfo(previousDebugInfo);
        return expr;
    }
    validate() {
        return _BinaryenModuleValidate(this.ref) == 1;
    }
    interpret() {
        _BinaryenModuleInterpret(this.ref);
    }
    toBinary(sourceMapUrl) {
        var out = this.lit; // safe to reuse as long as..
        assert(_BinaryenSizeofLiteral() >= 12);
        var cStr = allocString(sourceMapUrl);
        var binaryPtr = 0;
        var sourceMapPtr = 0;
        try {
            _BinaryenModuleAllocateAndWrite(out, this.ref, cStr);
            binaryPtr = readInt(out);
            let binaryBytes = readInt(out + 4);
            sourceMapPtr = readInt(out + 4 * 2);
            let ret = new BinaryModule();
            ret.output = readBuffer(binaryPtr, binaryBytes);
            ret.sourceMap = readString(sourceMapPtr);
            return ret;
        }
        finally {
            if (cStr)
                memory.free(cStr);
            if (binaryPtr)
                memory.free(binaryPtr);
            if (sourceMapPtr)
                memory.free(sourceMapPtr);
        }
    }
    toText() {
        throw new Error("not implemented"); // JS glue overrides this
    }
    toAsmjs() {
        throw new Error("not implemented"); // JS glue overrides this
    }
    allocStringCached(str) {
        if (str == null)
            return 0;
        var cachedStrings = this.cachedStrings;
        if (cachedStrings.has(str))
            return cachedStrings.get(str);
        var ptr = allocString(str);
        cachedStrings.set(str, ptr);
        return ptr;
    }
    dispose() {
        assert(this.ref);
        for (let ptr of this.cachedStrings.values())
            memory.free(ptr);
        this.cachedStrings = new Map();
        memory.free(this.lit);
        memory.free(this.cachedPrecomputeNames);
        this.cachedPrecomputeNames = 0;
        _BinaryenModuleDispose(this.ref);
        this.ref = 0;
    }
    createRelooper() {
        return Relooper.create(this);
    }
    cloneExpression(expr, noSideEffects = false, maxDepth = i32.MAX_VALUE) {
        if (maxDepth < 0)
            return 0;
        maxDepth -= 1;
        var nested1, nested2;
        switch (_BinaryenExpressionGetId(expr)) {
            case ExpressionId.Const: {
                switch (_BinaryenExpressionGetType(expr)) {
                    case NativeType.I32: {
                        return this.i32(_BinaryenConstGetValueI32(expr));
                    }
                    case NativeType.I64: {
                        return this.i64(_BinaryenConstGetValueI64Low(expr), _BinaryenConstGetValueI64High(expr));
                    }
                    case NativeType.F32: {
                        return this.f32(_BinaryenConstGetValueF32(expr));
                    }
                    case NativeType.F64: {
                        return this.f64(_BinaryenConstGetValueF64(expr));
                    }
                    case NativeType.V128: {
                        // TODO
                        return 0;
                    }
                    // Not possible to clone an anyref as it is opaque
                    case NativeType.Anyref: {
                        return 0;
                    }
                    default: {
                        throw new Error("concrete type expected");
                    }
                }
            }
            case ExpressionId.LocalGet: {
                return _BinaryenLocalGet(this.ref, _BinaryenLocalGetGetIndex(expr), _BinaryenExpressionGetType(expr));
            }
            case ExpressionId.GlobalGet: {
                let globalName = _BinaryenGlobalGetGetName(expr);
                if (!globalName)
                    break;
                return _BinaryenGlobalGet(this.ref, globalName, _BinaryenExpressionGetType(expr));
            }
            case ExpressionId.Load: {
                if (!(nested1 = this.cloneExpression(_BinaryenLoadGetPtr(expr), noSideEffects, maxDepth))) {
                    break;
                }
                return (_BinaryenLoadIsAtomic(expr)
                    ? _BinaryenAtomicLoad(this.ref, _BinaryenLoadGetBytes(expr), _BinaryenLoadGetOffset(expr), _BinaryenExpressionGetType(expr), nested1)
                    : _BinaryenLoad(this.ref, _BinaryenLoadGetBytes(expr), _BinaryenLoadIsSigned(expr) ? 1 : 0, _BinaryenLoadGetOffset(expr), _BinaryenLoadGetAlign(expr), _BinaryenExpressionGetType(expr), nested1));
            }
            case ExpressionId.Unary: {
                if (!(nested1 = this.cloneExpression(_BinaryenUnaryGetValue(expr), noSideEffects, maxDepth))) {
                    break;
                }
                return _BinaryenUnary(this.ref, _BinaryenUnaryGetOp(expr), nested1);
            }
            case ExpressionId.Binary: {
                if (!(nested1 = this.cloneExpression(_BinaryenBinaryGetLeft(expr), noSideEffects, maxDepth))) {
                    break;
                }
                if (!(nested2 = this.cloneExpression(_BinaryenBinaryGetRight(expr), noSideEffects, maxDepth))) {
                    break;
                }
                return _BinaryenBinary(this.ref, _BinaryenBinaryGetOp(expr), nested1, nested2);
            }
        }
        return 0;
    }
    // source map generation
    addDebugInfoFile(name) {
        var cStr = allocString(name);
        try {
            return _BinaryenModuleAddDebugInfoFileName(this.ref, cStr);
        }
        finally {
            memory.free(cStr);
        }
    }
    getDebugInfoFile(index) {
        return readString(_BinaryenModuleGetDebugInfoFileName(this.ref, index));
    }
    setDebugLocation(func, expr, fileIndex, lineNumber, columnNumber) {
        _BinaryenFunctionSetDebugLocation(func, expr, fileIndex, lineNumber, columnNumber);
    }
}
exports.Module = Module;
/** Unlimited memory constant. */
Module.UNLIMITED_MEMORY = -1;
// expressions
function getExpressionId(expr) {
    return _BinaryenExpressionGetId(expr);
}
exports.getExpressionId = getExpressionId;
function getExpressionType(expr) {
    return _BinaryenExpressionGetType(expr);
}
exports.getExpressionType = getExpressionType;
function getConstValueI32(expr) {
    return _BinaryenConstGetValueI32(expr);
}
exports.getConstValueI32 = getConstValueI32;
function getConstValueI64Low(expr) {
    return _BinaryenConstGetValueI64Low(expr);
}
exports.getConstValueI64Low = getConstValueI64Low;
function getConstValueI64High(expr) {
    return _BinaryenConstGetValueI64High(expr);
}
exports.getConstValueI64High = getConstValueI64High;
function getConstValueF32(expr) {
    return _BinaryenConstGetValueF32(expr);
}
exports.getConstValueF32 = getConstValueF32;
function getConstValueF64(expr) {
    return _BinaryenConstGetValueF64(expr);
}
exports.getConstValueF64 = getConstValueF64;
function getLocalGetIndex(expr) {
    return _BinaryenLocalGetGetIndex(expr);
}
exports.getLocalGetIndex = getLocalGetIndex;
function getLocalSetIndex(expr) {
    return _BinaryenLocalSetGetIndex(expr);
}
exports.getLocalSetIndex = getLocalSetIndex;
function getLocalSetValue(expr) {
    return _BinaryenLocalSetGetValue(expr);
}
exports.getLocalSetValue = getLocalSetValue;
function isLocalTee(expr) {
    return _BinaryenLocalSetIsTee(expr);
}
exports.isLocalTee = isLocalTee;
function getGlobalGetName(expr) {
    return readString(_BinaryenGlobalGetGetName(expr));
}
exports.getGlobalGetName = getGlobalGetName;
function getBinaryOp(expr) {
    return _BinaryenBinaryGetOp(expr);
}
exports.getBinaryOp = getBinaryOp;
function getBinaryLeft(expr) {
    return _BinaryenBinaryGetLeft(expr);
}
exports.getBinaryLeft = getBinaryLeft;
function getBinaryRight(expr) {
    return _BinaryenBinaryGetRight(expr);
}
exports.getBinaryRight = getBinaryRight;
function getUnaryOp(expr) {
    return _BinaryenUnaryGetOp(expr);
}
exports.getUnaryOp = getUnaryOp;
function getUnaryValue(expr) {
    return _BinaryenUnaryGetValue(expr);
}
exports.getUnaryValue = getUnaryValue;
function getLoadBytes(expr) {
    return _BinaryenLoadGetBytes(expr);
}
exports.getLoadBytes = getLoadBytes;
function getLoadOffset(expr) {
    return _BinaryenLoadGetOffset(expr);
}
exports.getLoadOffset = getLoadOffset;
function getLoadPtr(expr) {
    return _BinaryenLoadGetPtr(expr);
}
exports.getLoadPtr = getLoadPtr;
function isLoadSigned(expr) {
    return _BinaryenLoadIsSigned(expr);
}
exports.isLoadSigned = isLoadSigned;
function getStoreBytes(expr) {
    return _BinaryenStoreGetBytes(expr);
}
exports.getStoreBytes = getStoreBytes;
function getStoreOffset(expr) {
    return _BinaryenStoreGetOffset(expr);
}
exports.getStoreOffset = getStoreOffset;
function getStorePtr(expr) {
    return _BinaryenStoreGetPtr(expr);
}
exports.getStorePtr = getStorePtr;
function getStoreValue(expr) {
    return _BinaryenStoreGetValue(expr);
}
exports.getStoreValue = getStoreValue;
function getBlockName(expr) {
    return readString(_BinaryenBlockGetName(expr));
}
exports.getBlockName = getBlockName;
function getBlockChildCount(expr) {
    return _BinaryenBlockGetNumChildren(expr);
}
exports.getBlockChildCount = getBlockChildCount;
function getBlockChild(expr, index) {
    return _BinaryenBlockGetChild(expr, index);
}
exports.getBlockChild = getBlockChild;
function getIfCondition(expr) {
    return _BinaryenIfGetCondition(expr);
}
exports.getIfCondition = getIfCondition;
function getIfTrue(expr) {
    return _BinaryenIfGetIfTrue(expr);
}
exports.getIfTrue = getIfTrue;
function getIfFalse(expr) {
    return _BinaryenIfGetIfFalse(expr);
}
exports.getIfFalse = getIfFalse;
function getLoopName(expr) {
    return readString(_BinaryenLoopGetName(expr));
}
exports.getLoopName = getLoopName;
function getLoopBody(expr) {
    return _BinaryenLoopGetBody(expr);
}
exports.getLoopBody = getLoopBody;
function getBreakName(expr) {
    return readString(_BinaryenBreakGetName(expr));
}
exports.getBreakName = getBreakName;
function getBreakCondition(expr) {
    return _BinaryenBreakGetCondition(expr);
}
exports.getBreakCondition = getBreakCondition;
function getSelectThen(expr) {
    return _BinaryenSelectGetIfTrue(expr);
}
exports.getSelectThen = getSelectThen;
function getSelectElse(expr) {
    return _BinaryenSelectGetIfFalse(expr);
}
exports.getSelectElse = getSelectElse;
function getSelectCondition(expr) {
    return _BinaryenSelectGetCondition(expr);
}
exports.getSelectCondition = getSelectCondition;
function getDropValue(expr) {
    return _BinaryenDropGetValue(expr);
}
exports.getDropValue = getDropValue;
function getReturnValue(expr) {
    return _BinaryenReturnGetValue(expr);
}
exports.getReturnValue = getReturnValue;
function getCallTarget(expr) {
    return readString(_BinaryenCallGetTarget(expr));
}
exports.getCallTarget = getCallTarget;
function getCallOperandCount(expr) {
    return _BinaryenCallGetNumOperands(expr);
}
exports.getCallOperandCount = getCallOperandCount;
function getCallOperand(expr, index) {
    return _BinaryenCallGetOperand(expr, index);
}
exports.getCallOperand = getCallOperand;
function getHostOp(expr) {
    return _BinaryenHostGetOp(expr);
}
exports.getHostOp = getHostOp;
function getHostOperandCount(expr) {
    return _BinaryenHostGetNumOperands(expr);
}
exports.getHostOperandCount = getHostOperandCount;
function getHostOperand(expr, index) {
    return _BinaryenHostGetOperand(expr, index);
}
exports.getHostOperand = getHostOperand;
function getHostName(expr) {
    return readString(_BinaryenHostGetNameOperand(expr));
}
exports.getHostName = getHostName;
// functions
function getFunctionBody(func) {
    return _BinaryenFunctionGetBody(func);
}
exports.getFunctionBody = getFunctionBody;
function getFunctionName(func) {
    return readString(_BinaryenFunctionGetName(func));
}
exports.getFunctionName = getFunctionName;
function getFunctionParamCount(func) {
    return _BinaryenFunctionGetNumParams(func);
}
exports.getFunctionParamCount = getFunctionParamCount;
function getFunctionParamType(func, index) {
    return _BinaryenFunctionGetParam(func, index);
}
exports.getFunctionParamType = getFunctionParamType;
function getFunctionResultType(func) {
    return _BinaryenFunctionGetResult(func);
}
exports.getFunctionResultType = getFunctionResultType;
class Relooper {
    constructor() { }
    static create(module) {
        var relooper = new Relooper();
        relooper.module = module;
        relooper.ref = _RelooperCreate(module.ref);
        return relooper;
    }
    addBlock(code) {
        return _RelooperAddBlock(this.ref, code);
    }
    addBranch(from, to, condition = 0, code = 0) {
        _RelooperAddBranch(from, to, condition, code);
    }
    addBlockWithSwitch(code, condition) {
        return _RelooperAddBlockWithSwitch(this.ref, code, condition);
    }
    addBranchForSwitch(from, to, indexes, code = 0) {
        var cArr = allocI32Array(indexes);
        try {
            _RelooperAddBranchForSwitch(from, to, cArr, indexes.length, code);
        }
        finally {
            memory.free(cArr);
        }
    }
    renderAndDispose(entry, labelHelper) {
        return _RelooperRenderAndDispose(this.ref, entry, labelHelper);
    }
}
exports.Relooper = Relooper;
function hasSideEffects(expr) {
    // TODO: there's more
    switch (_BinaryenExpressionGetId(expr)) {
        case ExpressionId.LocalGet:
        case ExpressionId.GlobalGet:
        case ExpressionId.Const:
        case ExpressionId.Nop: {
            return false;
        }
        case ExpressionId.Block: {
            for (let i = 0, k = _BinaryenBlockGetNumChildren(expr); i < k; ++i) {
                if (hasSideEffects(_BinaryenBlockGetChild(expr, i)))
                    return true;
            }
            return false;
        }
        case ExpressionId.If: {
            return hasSideEffects(_BinaryenIfGetCondition(expr))
                || hasSideEffects(_BinaryenIfGetIfTrue(expr))
                || hasSideEffects(_BinaryenIfGetIfFalse(expr));
        }
        case ExpressionId.Unary: {
            return hasSideEffects(_BinaryenUnaryGetValue(expr));
        }
        case ExpressionId.Binary: {
            return hasSideEffects(_BinaryenBinaryGetLeft(expr))
                || hasSideEffects(_BinaryenBinaryGetRight(expr));
        }
        case ExpressionId.Drop: {
            return hasSideEffects(_BinaryenDropGetValue(expr));
        }
        case ExpressionId.Select: {
            return hasSideEffects(_BinaryenSelectGetIfTrue(expr))
                || hasSideEffects(_BinaryenSelectGetIfFalse(expr))
                || hasSideEffects(_BinaryenSelectGetCondition(expr));
        }
    }
    return true;
}
exports.hasSideEffects = hasSideEffects;
// helpers
// can't do stack allocation here: STACKTOP is a global in WASM but a hidden variable in asm.js
function allocU8Array(u8s) {
    if (!u8s)
        return 0;
    var numValues = u8s.length;
    var ptr = memory.allocate(numValues);
    var idx = ptr;
    for (let i = 0; i < numValues; ++i) {
        store(idx++, u8s[i]);
    }
    return ptr;
}
function allocI32Array(i32s) {
    if (!i32s)
        return 0;
    var ptr = memory.allocate(i32s.length << 2);
    var idx = ptr;
    for (let i = 0, k = i32s.length; i < k; ++i) {
        let val = i32s[i];
        // store<i32>(idx, val) is not portable
        store(idx, (val & 0xff));
        store(idx + 1, ((val >> 8) & 0xff));
        store(idx + 2, ((val >> 16) & 0xff));
        store(idx + 3, (val >>> 24));
        idx += 4;
    }
    return ptr;
}
function allocPtrArray(ptrs) {
    return allocI32Array(ptrs); // TODO: WASM64 one day
}
function stringLengthUTF8(str) {
    var len = 0;
    for (let i = 0, k = str.length; i < k; ++i) {
        let u = str.charCodeAt(i);
        if (u >= 0xD800 && u <= 0xDFFF && i + 1 < k) {
            u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);
        }
        if (u <= 0x7F) {
            ++len;
        }
        else if (u <= 0x7FF) {
            len += 2;
        }
        else if (u <= 0xFFFF) {
            len += 3;
        }
        else if (u <= 0x1FFFFF) {
            len += 4;
        }
        else if (u <= 0x3FFFFFF) {
            len += 5;
        }
        else {
            len += 6;
        }
    }
    return len;
}
function allocString(str) {
    if (str == null)
        return 0;
    var ptr = memory.allocate(stringLengthUTF8(str) + 1);
    // the following is based on Emscripten's stringToUTF8Array
    var idx = ptr;
    for (let i = 0, k = str.length; i < k; ++i) {
        let u = str.charCodeAt(i);
        if (u >= 0xD800 && u <= 0xDFFF && i + 1 < k) {
            u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);
        }
        if (u <= 0x7F) {
            store(idx++, u);
        }
        else if (u <= 0x7FF) {
            store(idx++, (0xC0 | (u >>> 6)));
            store(idx++, (0x80 | (u & 63)));
        }
        else if (u <= 0xFFFF) {
            store(idx++, (0xE0 | (u >>> 12)));
            store(idx++, (0x80 | ((u >>> 6) & 63)));
            store(idx++, (0x80 | (u & 63)));
        }
        else if (u <= 0x1FFFFF) {
            store(idx++, (0xF0 | (u >>> 18)));
            store(idx++, (0x80 | ((u >>> 12) & 63)));
            store(idx++, (0x80 | ((u >>> 6) & 63)));
            store(idx++, (0x80 | (u & 63)));
        }
        else if (u <= 0x3FFFFFF) {
            store(idx++, (0xF8 | (u >>> 24)));
            store(idx++, (0x80 | ((u >>> 18) & 63)));
            store(idx++, (0x80 | ((u >>> 12) & 63)));
            store(idx++, (0x80 | ((u >>> 6) & 63)));
            store(idx++, (0x80 | (u & 63)));
        }
        else {
            store(idx++, (0xFC | (u >>> 30)));
            store(idx++, (0x80 | ((u >>> 24) & 63)));
            store(idx++, (0x80 | ((u >>> 18) & 63)));
            store(idx++, (0x80 | ((u >>> 12) & 63)));
            store(idx++, (0x80 | ((u >>> 6) & 63)));
            store(idx++, (0x80 | (u & 63)));
        }
    }
    store(idx, 0);
    return ptr;
}
function readInt(ptr) {
    return (load(ptr) |
        (load(ptr + 1) << 8) |
        (load(ptr + 2) << 16) |
        (load(ptr + 3) << 24));
}
function readBuffer(ptr, length) {
    var ret = new Uint8Array(length);
    for (let i = 0; i < length; ++i) {
        ret[i] = load(ptr + i);
    }
    return ret;
}
function readString(ptr) {
    if (!ptr)
        return null;
    var arr = new Array();
    // the following is based on Emscripten's UTF8ArrayToString
    var cp;
    var u1, u2, u3, u4, u5;
    while (cp = load(ptr++)) {
        if (!(cp & 0x80)) {
            arr.push(cp);
            continue;
        }
        u1 = load(ptr++) & 63;
        if ((cp & 0xE0) == 0xC0) {
            arr.push(((cp & 31) << 6) | u1);
            continue;
        }
        u2 = load(ptr++) & 63;
        if ((cp & 0xF0) == 0xE0) {
            cp = ((cp & 15) << 12) | (u1 << 6) | u2;
        }
        else {
            u3 = load(ptr++) & 63;
            if ((cp & 0xF8) == 0xF0) {
                cp = ((cp & 7) << 18) | (u1 << 12) | (u2 << 6) | u3;
            }
            else {
                u4 = load(ptr++) & 63;
                if ((cp & 0xFC) == 0xF8) {
                    cp = ((cp & 3) << 24) | (u1 << 18) | (u2 << 12) | (u3 << 6) | u4;
                }
                else {
                    u5 = load(ptr++) & 63;
                    cp = ((cp & 1) << 30) | (u1 << 24) | (u2 << 18) | (u3 << 12) | (u4 << 6) | u5;
                }
            }
        }
        arr.push(cp);
        // if (cp < 0x10000) {
        //   arr.push(cp);
        // } else {
        //   var ch = cp - 0x10000;
        //   arr.push(0xD800 | (ch >> 10));
        //   arr.push(0xDC00 | (ch & 0x3FF));
        // }
    }
    // return String.fromCharCodes(arr);
    return String.fromCodePoints(arr);
}
exports.readString = readString;
/** Result structure of {@link Module#toBinary}. */
class BinaryModule {
}
exports.BinaryModule = BinaryModule;
/** Tests if an expression needs an explicit 'unreachable' when it is the terminating statement. */
function needsExplicitUnreachable(expr) {
    // not applicable if pushing a value to the stack
    if (_BinaryenExpressionGetType(expr) != NativeType.Unreachable)
        return false;
    switch (_BinaryenExpressionGetId(expr)) {
        case ExpressionId.Unreachable:
        case ExpressionId.Return: return false;
        case ExpressionId.Break: return _BinaryenBreakGetCondition(expr) != 0;
        case ExpressionId.Block: {
            if (!_BinaryenBlockGetName(expr)) { // can't break out of it
                let numChildren = _BinaryenBlockGetNumChildren(expr); // last child needs unreachable
                return numChildren > 0 && needsExplicitUnreachable(_BinaryenBlockGetChild(expr, numChildren - 1));
            }
        }
    }
    return true;
}
exports.needsExplicitUnreachable = needsExplicitUnreachable;
/** Traverses all expression members of an expression, calling the given visitor. */
function traverse(expr, data, visit) {
    switch (getExpressionId(expr)) {
        case ExpressionId.Block: {
            for (let i = 0, n = _BinaryenBlockGetNumChildren(expr); i < n; ++i) {
                visit(_BinaryenBlockGetChild(expr, i), data);
            }
            break;
        }
        case ExpressionId.If: {
            visit(_BinaryenIfGetCondition(expr), data);
            visit(_BinaryenIfGetIfTrue(expr), data);
            let ifFalse = _BinaryenIfGetIfFalse(expr);
            if (ifFalse)
                visit(ifFalse, data);
            break;
        }
        case ExpressionId.Loop: {
            visit(_BinaryenLoopGetBody(expr), data);
            break;
        }
        case ExpressionId.Break: {
            let condition = _BinaryenBreakGetCondition(expr);
            if (condition)
                visit(condition, data);
            break;
        }
        case ExpressionId.Switch: {
            visit(_BinaryenSwitchGetCondition(expr), data);
            break;
        }
        case ExpressionId.Call: {
            for (let i = 0, n = _BinaryenCallGetNumOperands(expr); i < n; ++i) {
                visit(_BinaryenCallGetOperand(expr, i), data);
            }
            break;
        }
        case ExpressionId.CallIndirect: {
            for (let i = 0, n = _BinaryenCallIndirectGetNumOperands(expr); i < n; ++i) {
                visit(_BinaryenCallIndirectGetOperand(expr, i), data);
            }
            break;
        }
        case ExpressionId.LocalGet: {
            break;
        }
        case ExpressionId.LocalSet: {
            visit(_BinaryenLocalSetGetValue(expr), data);
            break;
        }
        case ExpressionId.GlobalGet: {
            break;
        }
        case ExpressionId.GlobalSet: {
            visit(_BinaryenGlobalSetGetValue(expr), data);
            break;
        }
        case ExpressionId.Load: {
            visit(_BinaryenLoadGetPtr(expr), data);
            break;
        }
        case ExpressionId.Store: {
            visit(_BinaryenStoreGetPtr(expr), data);
            visit(_BinaryenStoreGetValue(expr), data);
            break;
        }
        case ExpressionId.AtomicRMW: {
            visit(_BinaryenAtomicRMWGetPtr(expr), data);
            visit(_BinaryenAtomicRMWGetValue(expr), data);
            break;
        }
        case ExpressionId.AtomicCmpxchg: {
            visit(_BinaryenAtomicCmpxchgGetPtr(expr), data);
            visit(_BinaryenAtomicCmpxchgGetExpected(expr), data);
            visit(_BinaryenAtomicCmpxchgGetReplacement(expr), data);
            break;
        }
        case ExpressionId.AtomicWait: {
            visit(_BinaryenAtomicWaitGetPtr(expr), data);
            visit(_BinaryenAtomicWaitGetExpected(expr), data);
            visit(_BinaryenAtomicWaitGetTimeout(expr), data);
            break;
        }
        case ExpressionId.AtomicNotify: {
            visit(_BinaryenAtomicNotifyGetPtr(expr), data);
            break;
        }
        case ExpressionId.AtomicFence: {
            break;
        }
        case ExpressionId.SIMDExtract: {
            visit(_BinaryenSIMDExtractGetVec(expr), data);
            break;
        }
        case ExpressionId.SIMDReplace: {
            visit(_BinaryenSIMDReplaceGetVec(expr), data);
            visit(_BinaryenSIMDReplaceGetValue(expr), data);
            break;
        }
        case ExpressionId.SIMDShuffle: {
            visit(_BinaryenSIMDShuffleGetLeft(expr), data);
            visit(_BinaryenSIMDShuffleGetRight(expr), data);
            break;
        }
        case ExpressionId.SIMDTernary: {
            visit(_BinaryenSIMDTernaryGetA(expr), data);
            visit(_BinaryenSIMDTernaryGetB(expr), data);
            visit(_BinaryenSIMDTernaryGetC(expr), data);
            break;
        }
        case ExpressionId.SIMDShift: {
            visit(_BinaryenSIMDShiftGetVec(expr), data);
            visit(_BinaryenSIMDShiftGetShift(expr), data);
            break;
        }
        case ExpressionId.SIMDLoad: {
            visit(_BinaryenSIMDLoadGetPtr(expr), data);
            break;
        }
        case ExpressionId.MemoryInit: {
            visit(_BinaryenMemoryInitGetDest(expr), data);
            visit(_BinaryenMemoryInitGetOffset(expr), data);
            visit(_BinaryenMemoryInitGetSize(expr), data);
            break;
        }
        case ExpressionId.DataDrop: {
            break;
        }
        case ExpressionId.MemoryCopy: {
            visit(_BinaryenMemoryCopyGetDest(expr), data);
            visit(_BinaryenMemoryCopyGetSource(expr), data);
            visit(_BinaryenMemoryCopyGetSize(expr), data);
            break;
        }
        case ExpressionId.MemoryFill: {
            visit(_BinaryenMemoryFillGetDest(expr), data);
            visit(_BinaryenMemoryFillGetValue(expr), data);
            visit(_BinaryenMemoryFillGetSize(expr), data);
            break;
        }
        case ExpressionId.Try: {
            visit(_BinaryenTryGetBody(expr), data);
            visit(_BinaryenTryGetCatchBody(expr), data);
            break;
        }
        case ExpressionId.Throw: {
            for (let i = 0, n = _BinaryenThrowGetNumOperands(expr); i < n; ++i) {
                visit(_BinaryenThrowGetOperand(expr, i), data);
            }
            break;
        }
        case ExpressionId.Rethrow: {
            visit(_BinaryenRethrowGetExnref(expr), data);
            break;
        }
        case ExpressionId.BrOnExn: {
            visit(_BinaryenBrOnExnGetExnref(expr), data);
            break;
        }
        case ExpressionId.Push: {
            visit(_BinaryenPushGetValue(expr), data);
            break;
        }
        case ExpressionId.Pop: {
            break;
        }
        case ExpressionId.Const: {
            break;
        }
        case ExpressionId.Unary: {
            visit(_BinaryenUnaryGetValue(expr), data);
            break;
        }
        case ExpressionId.Binary: {
            visit(_BinaryenBinaryGetLeft(expr), data);
            visit(_BinaryenBinaryGetRight(expr), data);
            break;
        }
        case ExpressionId.Select: {
            visit(_BinaryenSelectGetIfTrue(expr), data);
            visit(_BinaryenSelectGetIfFalse(expr), data);
            visit(_BinaryenSelectGetCondition(expr), data);
            break;
        }
        case ExpressionId.Drop: {
            visit(_BinaryenDropGetValue(expr), data);
            break;
        }
        case ExpressionId.Return: {
            visit(_BinaryenReturnGetValue(expr), data);
            break;
        }
        case ExpressionId.Host: {
            for (let i = 0, n = _BinaryenHostGetNumOperands(expr); i < n; ++i) {
                visit(_BinaryenHostGetOperand(expr, i), data);
            }
            break;
        }
        case ExpressionId.Nop: {
            break;
        }
        case ExpressionId.Unreachable: {
            break;
        }
        default: assert(false);
    }
    return true;
}
exports.traverse = traverse;


/***/ }),

/***/ "./src/parser.ts":
/*!***********************!*\
  !*** ./src/parser.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * A TypeScript parser for the AssemblyScript subset.
 * @module parser
 */ /***/
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = __webpack_require__(/*! ./common */ "./src/common.ts");
const program_1 = __webpack_require__(/*! ./program */ "./src/program.ts");
const tokenizer_1 = __webpack_require__(/*! ./tokenizer */ "./src/tokenizer.ts");
const diagnostics_1 = __webpack_require__(/*! ./diagnostics */ "./src/diagnostics.ts");
const util_1 = __webpack_require__(/*! ./util */ "./src/util/index.ts");
const ast_1 = __webpack_require__(/*! ./ast */ "./src/ast.ts");
/** Parser interface. */
class Parser extends diagnostics_1.DiagnosticEmitter {
    /** Constructs a new parser. */
    constructor() {
        super();
        /** Source file names to be requested next. */
        this.backlog = new Array();
        /** Source file names already seen, that is processed or backlogged. */
        this.seenlog = new Set();
        /** Source file names already completely processed. */
        this.donelog = new Set();
        /** Optional handler to intercept comments while tokenizing. */
        this.onComment = null;
        /** Dependency map **/
        this.dependees = new Map();
        // Indicates whether tryParseSignature determined that it is handling a Signature
        this.tryParseSignatureIsSignature = false;
        this.parseParametersThis = null;
        this.program = new program_1.Program(this.diagnostics);
    }
    /** Parses a file and adds its definitions to the program. */
    parseFile(
    /** Source text of the file. */
    text, 
    /** Normalized path of the file. */
    path, 
    /** Whether this is an entry file. */
    isEntry) {
        // the frontend gives us paths with .ts endings
        var normalizedPath = util_1.normalizePath(path);
        var internalPath = ast_1.mangleInternalPath(normalizedPath);
        // check if already processed
        if (this.donelog.has(internalPath))
            return;
        this.donelog.add(internalPath); // do not parse again
        this.seenlog.add(internalPath); // do not request again
        // create the source element
        var source = new ast_1.Source(normalizedPath, text, isEntry
            ? ast_1.SourceKind.USER_ENTRY
            : path.startsWith(common_1.LIBRARY_PREFIX)
                ? path.indexOf(common_1.PATH_DELIMITER, common_1.LIBRARY_PREFIX.length) < 0
                    ? ast_1.SourceKind.LIBRARY_ENTRY
                    : ast_1.SourceKind.LIBRARY
                : ast_1.SourceKind.USER);
        var program = this.program;
        program.sources.push(source);
        this.currentSource = source;
        // tokenize and parse
        var tn = new tokenizer_1.Tokenizer(source, program.diagnostics);
        tn.onComment = this.onComment;
        source.tokenizer = tn;
        var statements = source.statements;
        while (!tn.skip(tokenizer_1.Token.ENDOFFILE)) {
            let statement = this.parseTopLevelStatement(tn, null);
            if (statement)
                statements.push(statement);
        }
        tn.finish();
    }
    /** Parses a top-level statement. */
    parseTopLevelStatement(tn, namespace = null) {
        var flags = common_1.CommonFlags.NONE;
        var startPos = -1;
        // check decorators
        var decorators = null;
        while (tn.skip(tokenizer_1.Token.AT)) {
            if (startPos < 0)
                startPos = tn.tokenPos;
            let decorator = this.parseDecorator(tn);
            if (!decorator) {
                this.skipStatement(tn);
                continue;
            }
            if (!decorators)
                decorators = [decorator];
            else
                decorators.push(decorator);
        }
        // check modifiers
        var exportStart = 0;
        var exportEnd = 0;
        var defaultStart = 0;
        var defaultEnd = 0;
        if (tn.skip(tokenizer_1.Token.EXPORT)) {
            if (startPos < 0)
                startPos = tn.tokenPos;
            flags |= common_1.CommonFlags.EXPORT;
            exportStart = tn.tokenPos;
            exportEnd = tn.pos;
            if (tn.skip(tokenizer_1.Token.DEFAULT)) {
                defaultStart = tn.tokenPos;
                defaultEnd = tn.pos;
            }
        }
        var declareStart = 0;
        var declareEnd = 0;
        var contextIsAmbient = namespace != null && namespace.is(common_1.CommonFlags.AMBIENT);
        if (tn.skip(tokenizer_1.Token.DECLARE)) {
            if (contextIsAmbient) {
                this.error(diagnostics_1.DiagnosticCode.A_declare_modifier_cannot_be_used_in_an_already_ambient_context, tn.range()); // recoverable
            }
            else {
                if (startPos < 0)
                    startPos = tn.tokenPos;
                declareStart = startPos;
                declareEnd = tn.pos;
                flags |= common_1.CommonFlags.DECLARE | common_1.CommonFlags.AMBIENT;
            }
        }
        else if (contextIsAmbient) {
            flags |= common_1.CommonFlags.AMBIENT;
        }
        // parse the statement
        var statement = null;
        // handle declarations
        var first = tn.peek();
        if (startPos < 0)
            startPos = tn.nextTokenPos;
        switch (first) {
            case tokenizer_1.Token.CONST: {
                tn.next();
                flags |= common_1.CommonFlags.CONST;
                if (tn.skip(tokenizer_1.Token.ENUM)) {
                    statement = this.parseEnum(tn, flags, decorators, startPos);
                }
                else {
                    statement = this.parseVariable(tn, flags, decorators, startPos);
                }
                decorators = null;
                break;
            }
            case tokenizer_1.Token.LET: flags |= common_1.CommonFlags.LET;
            case tokenizer_1.Token.VAR: {
                tn.next();
                statement = this.parseVariable(tn, flags, decorators, startPos);
                decorators = null;
                break;
            }
            case tokenizer_1.Token.ENUM: {
                tn.next();
                statement = this.parseEnum(tn, flags, decorators, startPos);
                decorators = null;
                break;
            }
            case tokenizer_1.Token.FUNCTION: {
                tn.next();
                statement = this.parseFunction(tn, flags, decorators, startPos);
                decorators = null;
                break;
            }
            case tokenizer_1.Token.ABSTRACT: {
                let state = tn.mark();
                tn.next();
                if (!tn.skip(tokenizer_1.Token.CLASS)) {
                    tn.reset(state);
                    statement = this.parseStatement(tn, true);
                    break;
                }
                else {
                    tn.discard(state);
                }
                flags |= common_1.CommonFlags.ABSTRACT;
                // fall through
            }
            case tokenizer_1.Token.CLASS:
            case tokenizer_1.Token.INTERFACE: {
                tn.next();
                statement = this.parseClassOrInterface(tn, flags, decorators, startPos);
                decorators = null;
                break;
            }
            case tokenizer_1.Token.NAMESPACE: {
                let state = tn.mark();
                tn.next();
                if (tn.peek(false, tokenizer_1.IdentifierHandling.PREFER) == tokenizer_1.Token.IDENTIFIER) {
                    tn.discard(state);
                    statement = this.parseNamespace(tn, flags, decorators, startPos);
                    decorators = null;
                }
                else {
                    tn.reset(state);
                    statement = this.parseStatement(tn, true);
                }
                break;
            }
            case tokenizer_1.Token.IMPORT: {
                tn.next();
                flags |= common_1.CommonFlags.IMPORT;
                if (flags & common_1.CommonFlags.EXPORT) {
                    statement = this.parseExportImport(tn, startPos);
                }
                else {
                    statement = this.parseImport(tn);
                }
                break;
            }
            case tokenizer_1.Token.TYPE: { // also identifier
                let state = tn.mark();
                tn.next();
                if (tn.peek(false, tokenizer_1.IdentifierHandling.PREFER) == tokenizer_1.Token.IDENTIFIER) {
                    tn.discard(state);
                    statement = this.parseTypeDeclaration(tn, flags, decorators, startPos);
                    decorators = null;
                }
                else {
                    tn.reset(state);
                    statement = this.parseStatement(tn, true);
                }
                break;
            }
            default: {
                // handle plain exports
                if (flags & common_1.CommonFlags.EXPORT) {
                    if (defaultEnd && tn.skipIdentifier(tokenizer_1.IdentifierHandling.PREFER)) {
                        if (declareEnd) {
                            this.error(diagnostics_1.DiagnosticCode.An_export_assignment_cannot_have_modifiers, tn.range(declareStart, declareEnd));
                        }
                        statement = this.parseExportDefaultAlias(tn, startPos, defaultStart, defaultEnd);
                        defaultStart = defaultEnd = 0; // consume
                    }
                    else {
                        statement = this.parseExport(tn, startPos, (flags & common_1.CommonFlags.DECLARE) != 0);
                    }
                    // handle non-declaration statements
                }
                else {
                    if (exportEnd) {
                        this.error(diagnostics_1.DiagnosticCode._0_modifier_cannot_be_used_here, tn.range(exportStart, exportEnd), "export"); // recoverable
                    }
                    if (declareEnd) {
                        this.error(diagnostics_1.DiagnosticCode._0_modifier_cannot_be_used_here, tn.range(declareStart, declareEnd), "declare"); // recoverable
                    }
                    if (!namespace) {
                        statement = this.parseStatement(tn, true);
                    } // TODO: else?
                }
                break;
            }
        }
        // check for decorators that weren't consumed
        if (decorators) {
            for (let i = 0, k = decorators.length; i < k; ++i) {
                this.error(diagnostics_1.DiagnosticCode.Decorators_are_not_valid_here, decorators[i].range);
            }
        }
        // check if this an `export default` declaration
        if (defaultEnd && statement !== null) {
            switch (statement.kind) {
                case ast_1.NodeKind.ENUMDECLARATION:
                case ast_1.NodeKind.FUNCTIONDECLARATION:
                case ast_1.NodeKind.CLASSDECLARATION:
                case ast_1.NodeKind.INTERFACEDECLARATION:
                case ast_1.NodeKind.NAMESPACEDECLARATION: {
                    return ast_1.Node.createExportDefaultStatement(statement, tn.range(startPos, tn.pos));
                }
                default: {
                    this.error(diagnostics_1.DiagnosticCode._0_modifier_cannot_be_used_here, tn.range(defaultStart, defaultEnd), "default");
                }
            }
        }
        return statement;
    }
    /** Obtains the next file to parse. */
    nextFile() {
        var backlog = this.backlog;
        return backlog.length ? backlog.shift() : null;
    }
    /** Obtains the dependee of the given imported file. */
    getDependee(dependent) {
        var source = this.dependees.get(dependent);
        if (source)
            return source.internalPath;
        return null;
    }
    /** Finishes parsing and returns the program. */
    finish() {
        if (this.backlog.length)
            throw new Error("backlog is not empty");
        this.backlog = [];
        this.seenlog.clear();
        this.donelog.clear();
        this.dependees.clear();
        return this.program;
    }
    /** Parses a type. */
    parseType(tn, acceptParenthesized = true, suppressErrors = false) {
        // NOTE: this parses our limited subset
        var token = tn.next();
        var startPos = tn.tokenPos;
        var type;
        // '(' ...
        if (token == tokenizer_1.Token.OPENPAREN) {
            // '(' FunctionSignature ')' '|' 'null'?
            let isNullableSignature = tn.skip(tokenizer_1.Token.OPENPAREN);
            // FunctionSignature?
            let signature = this.tryParseFunctionType(tn);
            if (signature) {
                if (isNullableSignature) {
                    if (!tn.skip(tokenizer_1.Token.CLOSEPAREN)) {
                        this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), ")");
                        return null;
                    }
                    if (!tn.skip(tokenizer_1.Token.BAR)) {
                        this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), "|");
                        return null;
                    }
                    if (!tn.skip(tokenizer_1.Token.NULL)) {
                        this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), "null");
                    }
                    signature.isNullable = true;
                }
                return signature;
            }
            else if (isNullableSignature || this.tryParseSignatureIsSignature) {
                this.error(diagnostics_1.DiagnosticCode.Unexpected_token, tn.range());
                return null;
            }
            // Type (',' Type)* ')'
            if (acceptParenthesized) {
                let innerType = this.parseType(tn, false, suppressErrors);
                if (!innerType)
                    return null;
                if (!tn.skip(tokenizer_1.Token.CLOSEPAREN)) {
                    if (!suppressErrors) {
                        this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(tn.pos), ")");
                    }
                    return null;
                }
                type = innerType;
                type.range.start = startPos;
                type.range.end = tn.pos;
            }
            else {
                this.error(diagnostics_1.DiagnosticCode.Unexpected_token, tn.range());
                return null;
            }
            // 'void'
        }
        else if (token == tokenizer_1.Token.VOID) {
            type = ast_1.Node.createNamedType(ast_1.Node.createSimpleTypeName("void", tn.range()), [], false, tn.range(startPos, tn.pos));
            // 'this'
        }
        else if (token == tokenizer_1.Token.THIS) {
            type = ast_1.Node.createNamedType(ast_1.Node.createSimpleTypeName("this", tn.range()), [], false, tn.range(startPos, tn.pos));
            // 'true'
        }
        else if (token == tokenizer_1.Token.TRUE || token == tokenizer_1.Token.FALSE) {
            type = ast_1.Node.createNamedType(ast_1.Node.createSimpleTypeName("bool", tn.range()), [], false, tn.range(startPos, tn.pos));
            // StringLiteral
        }
        else if (token == tokenizer_1.Token.STRINGLITERAL) {
            tn.readString();
            type = ast_1.Node.createNamedType(ast_1.Node.createSimpleTypeName("string", tn.range()), [], false, tn.range(startPos, tn.pos));
            // Identifier
        }
        else if (token == tokenizer_1.Token.IDENTIFIER) {
            let first = ast_1.Node.createSimpleTypeName(tn.readIdentifier(), tn.range());
            let current = first;
            let parameters = null;
            let nullable = false;
            // Identifier ('.' Identifier)+
            while (tn.skip(tokenizer_1.Token.DOT)) {
                if (tn.skip(tokenizer_1.Token.IDENTIFIER)) {
                    let next = ast_1.Node.createSimpleTypeName(tn.readIdentifier(), tn.range());
                    current.next = next;
                    current = next;
                }
                else {
                    this.error(diagnostics_1.DiagnosticCode.Identifier_expected, tn.range(tn.pos));
                    return null;
                }
            }
            // Name<T>
            if (tn.skip(tokenizer_1.Token.LESSTHAN)) {
                do {
                    let parameter = this.parseType(tn, true, suppressErrors);
                    if (!parameter)
                        return null;
                    if (!parameters)
                        parameters = [parameter];
                    else
                        parameters.push(parameter);
                } while (tn.skip(tokenizer_1.Token.COMMA));
                if (!tn.skip(tokenizer_1.Token.GREATERTHAN)) {
                    if (!suppressErrors) {
                        this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(tn.pos), ">");
                    }
                    return null;
                }
            }
            // ... | null
            while (tn.skip(tokenizer_1.Token.BAR)) {
                if (tn.skip(tokenizer_1.Token.NULL)) {
                    nullable = true;
                }
                else {
                    if (!suppressErrors) {
                        this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(tn.pos), "null");
                    }
                    return null;
                }
            }
            type = ast_1.Node.createNamedType(first, parameters || [], nullable, tn.range(startPos, tn.pos));
        }
        else {
            if (!suppressErrors) {
                this.error(diagnostics_1.DiagnosticCode.Identifier_expected, tn.range());
            }
            return null;
        }
        // ... [][]
        while (tn.skip(tokenizer_1.Token.OPENBRACKET)) {
            let bracketStart = tn.tokenPos;
            if (!tn.skip(tokenizer_1.Token.CLOSEBRACKET)) {
                if (!suppressErrors) {
                    this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), "]");
                }
                return null;
            }
            let bracketRange = tn.range(bracketStart, tn.pos);
            // ...[] | null
            let nullable = false;
            if (tn.skip(tokenizer_1.Token.BAR)) {
                if (tn.skip(tokenizer_1.Token.NULL)) {
                    nullable = true;
                }
                else {
                    if (!suppressErrors) {
                        this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), "null");
                    }
                    return null;
                }
            }
            type = ast_1.Node.createNamedType(ast_1.Node.createSimpleTypeName("Array", bracketRange), [type], nullable, tn.range(startPos, tn.pos));
            if (nullable)
                break;
        }
        return type;
    }
    /** Parses a function type, as used in type declarations. */
    tryParseFunctionType(tn) {
        // at '(': ('...'? Identifier '?'? ':' Type (','  '...'? Identifier '?'? ':' Type)* )? ')' '=>' Type
        var state = tn.mark();
        var startPos = tn.tokenPos;
        var parameters = null;
        var thisType = null;
        var isSignature = false;
        var firstParamNameNoType = null;
        var firstParamKind = ast_1.ParameterKind.DEFAULT;
        if (tn.skip(tokenizer_1.Token.CLOSEPAREN)) {
            isSignature = true;
            tn.discard(state);
            parameters = [];
        }
        else {
            isSignature = false; // not yet known
            do {
                let kind = ast_1.ParameterKind.DEFAULT;
                if (tn.skip(tokenizer_1.Token.DOT_DOT_DOT)) {
                    isSignature = true;
                    tn.discard(state);
                    kind = ast_1.ParameterKind.REST;
                }
                if (tn.skip(tokenizer_1.Token.THIS)) {
                    if (tn.skip(tokenizer_1.Token.COLON)) {
                        isSignature = true;
                        tn.discard(state);
                        let t = this.parseType(tn, false);
                        if (!t)
                            return null;
                        if (t.kind != ast_1.NodeKind.NAMEDTYPE) {
                            this.error(diagnostics_1.DiagnosticCode.Identifier_expected, t.range);
                            this.tryParseSignatureIsSignature = true;
                            return null;
                        }
                        thisType = t;
                    }
                    else {
                        tn.reset(state);
                        this.tryParseSignatureIsSignature = false;
                        return null;
                    }
                }
                else if (tn.skipIdentifier()) {
                    let name = ast_1.Node.createIdentifierExpression(tn.readIdentifier(), tn.range(tn.tokenPos, tn.pos));
                    if (tn.skip(tokenizer_1.Token.QUESTION)) {
                        isSignature = true;
                        tn.discard(state);
                        if (kind == ast_1.ParameterKind.REST) {
                            this.error(diagnostics_1.DiagnosticCode.A_rest_parameter_cannot_be_optional, tn.range()); // recoverable
                        }
                        else {
                            kind = ast_1.ParameterKind.OPTIONAL;
                        }
                    }
                    if (tn.skip(tokenizer_1.Token.COLON)) {
                        isSignature = true;
                        tn.discard(state);
                        let type = this.parseType(tn); // not suppressing errors because known
                        if (!type) {
                            this.tryParseSignatureIsSignature = isSignature;
                            return null;
                        }
                        let param = new ast_1.ParameterNode();
                        param.parameterKind = kind;
                        param.name = name;
                        param.type = type;
                        if (!parameters)
                            parameters = [param];
                        else
                            parameters.push(param);
                    }
                    else {
                        if (!isSignature) {
                            if (tn.peek() == tokenizer_1.Token.COMMA) {
                                isSignature = true;
                                tn.discard(state);
                            }
                        }
                        if (isSignature) {
                            let param = new ast_1.ParameterNode();
                            param.parameterKind = kind;
                            param.name = name;
                            param.type = ast_1.Node.createOmittedType(tn.range().atEnd);
                            if (!parameters)
                                parameters = [param];
                            else
                                parameters.push(param);
                            this.error(diagnostics_1.DiagnosticCode.Type_expected, param.type.range); // recoverable
                        }
                        else if (!parameters) {
                            // on '(' Identifier ^',' we don't yet know whether this is a
                            // parenthesized or a function type, hence we have to delay the
                            // respective diagnostic until we know for sure.
                            firstParamNameNoType = name;
                            firstParamKind = kind;
                        }
                    }
                }
                else {
                    if (isSignature) {
                        this.error(diagnostics_1.DiagnosticCode.Identifier_expected, tn.range());
                    }
                    else {
                        tn.reset(state);
                    }
                    this.tryParseSignatureIsSignature = isSignature;
                    return null;
                }
            } while (tn.skip(tokenizer_1.Token.COMMA));
            if (!tn.skip(tokenizer_1.Token.CLOSEPAREN)) {
                if (isSignature) {
                    this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), ")");
                }
                else {
                    tn.reset(state);
                }
                this.tryParseSignatureIsSignature = isSignature;
                return null;
            }
        }
        var returnType;
        if (tn.skip(tokenizer_1.Token.EQUALS_GREATERTHAN)) {
            if (!isSignature) {
                isSignature = true;
                tn.discard(state);
                if (firstParamNameNoType) { // now we know
                    let param = new ast_1.ParameterNode();
                    param.parameterKind = firstParamKind;
                    param.name = firstParamNameNoType;
                    param.type = ast_1.Node.createOmittedType(firstParamNameNoType.range.atEnd);
                    if (!parameters)
                        parameters = [param];
                    else
                        parameters.push(param);
                    this.error(diagnostics_1.DiagnosticCode.Type_expected, param.type.range); // recoverable
                }
            }
            returnType = this.parseType(tn);
            if (!returnType) {
                this.tryParseSignatureIsSignature = isSignature;
                return null;
            }
        }
        else {
            if (isSignature) {
                this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), "=>");
            }
            else {
                tn.reset(state);
            }
            this.tryParseSignatureIsSignature = isSignature;
            return null;
        }
        this.tryParseSignatureIsSignature = true;
        return ast_1.Node.createFunctionType(parameters || [], returnType, thisType, false, tn.range(startPos, tn.pos));
    }
    // statements
    parseDecorator(tn) {
        // at '@': Identifier ('.' Identifier)* '(' Arguments
        var startPos = tn.tokenPos;
        if (tn.skipIdentifier()) {
            let name = tn.readIdentifier();
            let expression = ast_1.Node.createIdentifierExpression(name, tn.range(startPos, tn.pos));
            while (tn.skip(tokenizer_1.Token.DOT)) {
                if (tn.skipIdentifier()) {
                    name = tn.readIdentifier();
                    expression = ast_1.Node.createPropertyAccessExpression(expression, ast_1.Node.createIdentifierExpression(name, tn.range()), tn.range(startPos, tn.pos));
                }
                else {
                    this.error(diagnostics_1.DiagnosticCode.Identifier_expected, tn.range());
                    return null;
                }
            }
            let args;
            if (tn.skip(tokenizer_1.Token.OPENPAREN)) {
                args = this.parseArguments(tn);
                if (args) {
                    return ast_1.Node.createDecorator(expression, args, tn.range(startPos, tn.pos));
                }
            }
            else {
                return ast_1.Node.createDecorator(expression, null, tn.range(startPos, tn.pos));
            }
        }
        else {
            this.error(diagnostics_1.DiagnosticCode.Identifier_expected, tn.range());
        }
        return null;
    }
    parseVariable(tn, flags, decorators, startPos) {
        // at ('const' | 'let' | 'var'): VariableDeclaration (',' VariableDeclaration)* ';'?
        var members = new Array();
        do {
            let member = this.parseVariableDeclaration(tn, flags, decorators);
            if (!member)
                return null;
            members.push(member);
        } while (tn.skip(tokenizer_1.Token.COMMA));
        var ret = ast_1.Node.createVariableStatement(members, decorators, tn.range(startPos, tn.pos));
        tn.skip(tokenizer_1.Token.SEMICOLON);
        return ret;
    }
    parseVariableDeclaration(tn, parentFlags, parentDecorators) {
        // before: Identifier (':' Type)? ('=' Expression)?
        if (!tn.skipIdentifier()) {
            this.error(diagnostics_1.DiagnosticCode.Identifier_expected, tn.range());
            return null;
        }
        var identifier = ast_1.Node.createIdentifierExpression(tn.readIdentifier(), tn.range());
        if (tokenizer_1.isIllegalVariableIdentifier(identifier.text)) {
            this.error(diagnostics_1.DiagnosticCode.Identifier_expected, identifier.range);
        }
        var flags = parentFlags;
        if (tn.skip(tokenizer_1.Token.EXCLAMATION)) {
            flags |= common_1.CommonFlags.DEFINITE_ASSIGNMENT;
        }
        var type = null;
        if (tn.skip(tokenizer_1.Token.COLON)) {
            type = this.parseType(tn);
        }
        var initializer = null;
        if (tn.skip(tokenizer_1.Token.EQUALS)) {
            if (flags & common_1.CommonFlags.AMBIENT) {
                this.error(diagnostics_1.DiagnosticCode.Initializers_are_not_allowed_in_ambient_contexts, tn.range()); // recoverable
            }
            initializer = this.parseExpression(tn, 1 /* COMMA */ + 1);
            if (!initializer)
                return null;
        }
        else {
            if (flags & common_1.CommonFlags.CONST) {
                if (!(flags & common_1.CommonFlags.AMBIENT)) {
                    this.error(diagnostics_1.DiagnosticCode._const_declarations_must_be_initialized, identifier.range); // recoverable
                }
            }
            else if (!type) { // neither type nor initializer
                this.error(diagnostics_1.DiagnosticCode.Type_expected, tn.range(tn.pos)); // recoverable
            }
        }
        var range = tokenizer_1.Range.join(identifier.range, tn.range());
        if ((flags & common_1.CommonFlags.DEFINITE_ASSIGNMENT) && initializer) {
            this.error(diagnostics_1.DiagnosticCode.A_definite_assignment_assertion_is_not_permitted_in_this_context, range);
        }
        return ast_1.Node.createVariableDeclaration(identifier, type, initializer, parentDecorators, flags, range);
    }
    parseEnum(tn, flags, decorators, startPos) {
        // at 'enum': Identifier '{' (EnumValueDeclaration (',' EnumValueDeclaration )*)? '}' ';'?
        if (tn.next() != tokenizer_1.Token.IDENTIFIER) {
            this.error(diagnostics_1.DiagnosticCode.Identifier_expected, tn.range());
            return null;
        }
        var identifier = ast_1.Node.createIdentifierExpression(tn.readIdentifier(), tn.range());
        if (tn.next() != tokenizer_1.Token.OPENBRACE) {
            this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), "{");
            return null;
        }
        var members = new Array();
        while (!tn.skip(tokenizer_1.Token.CLOSEBRACE)) {
            let member = this.parseEnumValue(tn, common_1.CommonFlags.NONE);
            if (!member)
                return null;
            members.push(member);
            if (!tn.skip(tokenizer_1.Token.COMMA)) {
                if (tn.skip(tokenizer_1.Token.CLOSEBRACE)) {
                    break;
                }
                else {
                    this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), "}");
                    return null;
                }
            }
        }
        var ret = ast_1.Node.createEnumDeclaration(identifier, members, decorators, flags, tn.range(startPos, tn.pos));
        tn.skip(tokenizer_1.Token.SEMICOLON);
        return ret;
    }
    parseEnumValue(tn, parentFlags) {
        // before: Identifier ('=' Expression)?
        if (!tn.skipIdentifier()) {
            this.error(diagnostics_1.DiagnosticCode.Identifier_expected, tn.range());
            return null;
        }
        var identifier = ast_1.Node.createIdentifierExpression(tn.readIdentifier(), tn.range());
        var value = null;
        if (tn.skip(tokenizer_1.Token.EQUALS)) {
            value = this.parseExpression(tn, 1 /* COMMA */ + 1);
            if (!value)
                return null;
        }
        return ast_1.Node.createEnumValueDeclaration(identifier, value, parentFlags, tokenizer_1.Range.join(identifier.range, tn.range()));
    }
    parseReturn(tn) {
        // at 'return': Expression | (';' | '}' | ...'\n')
        var startPos = tn.tokenPos;
        var expr = null;
        if (tn.peek(true) != tokenizer_1.Token.SEMICOLON &&
            tn.nextToken != tokenizer_1.Token.CLOSEBRACE &&
            !tn.nextTokenOnNewLine) {
            if (!(expr = this.parseExpression(tn)))
                return null;
        }
        var ret = ast_1.Node.createReturnStatement(expr, tn.range(startPos, tn.pos));
        tn.skip(tokenizer_1.Token.SEMICOLON);
        return ret;
    }
    parseTypeParameters(tn) {
        // at '<': TypeParameter (',' TypeParameter)* '>'
        var typeParameters = null;
        var seenOptional = false;
        while (!tn.skip(tokenizer_1.Token.GREATERTHAN)) {
            let typeParameter = this.parseTypeParameter(tn);
            if (!typeParameter)
                return null;
            if (typeParameter.defaultType !== null) {
                seenOptional = true;
            }
            else if (seenOptional) {
                this.error(diagnostics_1.DiagnosticCode.Required_type_parameters_may_not_follow_optional_type_parameters, typeParameter.range);
                typeParameter.defaultType = null;
            }
            if (!typeParameters)
                typeParameters = [typeParameter];
            else
                typeParameters.push(typeParameter);
            if (!tn.skip(tokenizer_1.Token.COMMA)) {
                if (tn.skip(tokenizer_1.Token.GREATERTHAN)) {
                    break;
                }
                else {
                    this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), ">");
                    return null;
                }
            }
        }
        if (!(typeParameters && typeParameters.length)) {
            this.error(diagnostics_1.DiagnosticCode.Type_parameter_list_cannot_be_empty, tn.range()); // recoverable
        }
        return typeParameters;
    }
    parseTypeParameter(tn) {
        // before: Identifier ('extends' Type)? ('=' Type)?
        if (tn.next() == tokenizer_1.Token.IDENTIFIER) {
            let identifier = ast_1.Node.createIdentifierExpression(tn.readIdentifier(), tn.range());
            let extendsType = null;
            if (tn.skip(tokenizer_1.Token.EXTENDS)) {
                let t = this.parseType(tn);
                if (!t)
                    return null;
                if (t.kind != ast_1.NodeKind.NAMEDTYPE) {
                    this.error(diagnostics_1.DiagnosticCode.Identifier_expected, t.range);
                    return null;
                }
                extendsType = t;
            }
            let defaultType = null;
            if (tn.skip(tokenizer_1.Token.EQUALS)) {
                let t = this.parseType(tn);
                if (!t)
                    return null;
                if (t.kind != ast_1.NodeKind.NAMEDTYPE) {
                    this.error(diagnostics_1.DiagnosticCode.Identifier_expected, t.range);
                    return null;
                }
                defaultType = t;
            }
            return ast_1.Node.createTypeParameter(identifier, extendsType, defaultType, tokenizer_1.Range.join(identifier.range, tn.range()));
        }
        else {
            this.error(diagnostics_1.DiagnosticCode.Identifier_expected, tn.range());
        }
        return null;
    }
    parseParameters(tn, isConstructor = false) {
        // at '(': (Parameter (',' Parameter)*)? ')'
        var parameters = new Array();
        var seenRest = null;
        var seenOptional = false;
        var reportedRest = false;
        var thisType = null;
        // check if there is a leading `this` parameter
        this.parseParametersThis = null;
        if (tn.skip(tokenizer_1.Token.THIS)) {
            if (tn.skip(tokenizer_1.Token.COLON)) {
                thisType = this.parseType(tn); // reports
                if (!thisType)
                    return null;
                if (thisType.kind == ast_1.NodeKind.NAMEDTYPE) {
                    this.parseParametersThis = thisType;
                }
                else {
                    this.error(diagnostics_1.DiagnosticCode.Identifier_expected, thisType.range);
                }
            }
            else {
                this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), ":");
                return null;
            }
            if (!tn.skip(tokenizer_1.Token.COMMA)) {
                if (tn.skip(tokenizer_1.Token.CLOSEPAREN)) {
                    return parameters;
                }
                else {
                    this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), ")");
                    return null;
                }
            }
        }
        while (!tn.skip(tokenizer_1.Token.CLOSEPAREN)) {
            let param = this.parseParameter(tn, isConstructor); // reports
            if (!param)
                return null;
            if (seenRest && !reportedRest) {
                this.error(diagnostics_1.DiagnosticCode.A_rest_parameter_must_be_last_in_a_parameter_list, seenRest.name.range);
                reportedRest = true;
            }
            switch (param.parameterKind) {
                default: {
                    if (seenOptional) {
                        this.error(diagnostics_1.DiagnosticCode.A_required_parameter_cannot_follow_an_optional_parameter, param.name.range);
                    }
                    break;
                }
                case ast_1.ParameterKind.OPTIONAL: {
                    seenOptional = true;
                    break;
                }
                case ast_1.ParameterKind.REST: {
                    seenRest = param;
                    break;
                }
            }
            parameters.push(param);
            if (!tn.skip(tokenizer_1.Token.COMMA)) {
                if (tn.skip(tokenizer_1.Token.CLOSEPAREN)) {
                    break;
                }
                else {
                    this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), ")");
                    return null;
                }
            }
        }
        return parameters;
    }
    parseParameter(tn, isConstructor = false) {
        // before: ('public' | 'private' | 'protected' | '...')? Identifier '?'? (':' Type)? ('=' Expression)?
        var isRest = false;
        var isOptional = false;
        var startRange = null;
        var accessFlags = common_1.CommonFlags.NONE;
        if (isConstructor) {
            if (tn.skip(tokenizer_1.Token.PUBLIC)) {
                startRange = tn.range();
                accessFlags |= common_1.CommonFlags.PUBLIC;
            }
            else if (tn.skip(tokenizer_1.Token.PROTECTED)) {
                startRange = tn.range();
                accessFlags |= common_1.CommonFlags.PROTECTED;
            }
            else if (tn.skip(tokenizer_1.Token.PRIVATE)) {
                startRange = tn.range();
                accessFlags |= common_1.CommonFlags.PRIVATE;
            }
            if (tn.peek() == tokenizer_1.Token.READONLY) {
                let state = tn.mark();
                tn.next();
                if (tn.peek() != tokenizer_1.Token.COLON) { // modifier
                    tn.discard(state);
                    if (!startRange)
                        startRange = tn.range();
                    accessFlags |= common_1.CommonFlags.READONLY;
                }
                else { // identifier
                    tn.reset(state);
                }
            }
        }
        if (tn.skip(tokenizer_1.Token.DOT_DOT_DOT)) {
            if (accessFlags) {
                this.error(diagnostics_1.DiagnosticCode.A_parameter_property_cannot_be_declared_using_a_rest_parameter, tn.range());
            }
            else {
                startRange = tn.range();
            }
            isRest = true;
        }
        if (tn.skipIdentifier()) {
            if (!isRest)
                startRange = tn.range();
            let identifier = ast_1.Node.createIdentifierExpression(tn.readIdentifier(), tn.range());
            let type = null;
            if (isOptional = tn.skip(tokenizer_1.Token.QUESTION)) {
                if (isRest) {
                    this.error(diagnostics_1.DiagnosticCode.A_rest_parameter_cannot_be_optional, identifier.range);
                }
            }
            if (tn.skip(tokenizer_1.Token.COLON)) {
                type = this.parseType(tn);
                if (!type)
                    return null;
            }
            else {
                type = ast_1.Node.createOmittedType(tn.range(tn.pos));
            }
            let initializer = null;
            if (tn.skip(tokenizer_1.Token.EQUALS)) {
                if (isRest) {
                    this.error(diagnostics_1.DiagnosticCode.A_rest_parameter_cannot_have_an_initializer, identifier.range);
                }
                if (isOptional) {
                    this.error(diagnostics_1.DiagnosticCode.Parameter_cannot_have_question_mark_and_initializer, identifier.range);
                }
                else {
                    isOptional = true;
                }
                initializer = this.parseExpression(tn, 1 /* COMMA */ + 1);
                if (!initializer)
                    return null;
            }
            let param = ast_1.Node.createParameter(identifier, type, initializer, isRest
                ? ast_1.ParameterKind.REST
                : isOptional
                    ? ast_1.ParameterKind.OPTIONAL
                    : ast_1.ParameterKind.DEFAULT, tokenizer_1.Range.join(startRange, tn.range()));
            param.flags |= accessFlags;
            return param;
        }
        else {
            this.error(diagnostics_1.DiagnosticCode.Identifier_expected, tn.range());
        }
        return null;
    }
    parseFunction(tn, flags, decorators, startPos) {
        // at 'function':
        //  Identifier
        //  ('<' TypeParameters)?
        //  '(' Parameters (':' Type)?
        //  '{' Statement* '}'
        //  ';'?
        if (!tn.skipIdentifier()) {
            this.error(diagnostics_1.DiagnosticCode.Identifier_expected, tn.range(tn.pos));
            return null;
        }
        var name = ast_1.Node.createIdentifierExpression(tn.readIdentifier(), tn.range());
        var signatureStart = -1;
        var typeParameters = null;
        if (tn.skip(tokenizer_1.Token.LESSTHAN)) {
            signatureStart = tn.tokenPos;
            typeParameters = this.parseTypeParameters(tn);
            if (!typeParameters)
                return null;
            flags |= common_1.CommonFlags.GENERIC;
        }
        if (!tn.skip(tokenizer_1.Token.OPENPAREN)) {
            this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(tn.pos), "(");
            return null;
        }
        if (signatureStart < 0) {
            signatureStart = tn.tokenPos;
        }
        var parameters = this.parseParameters(tn);
        if (!parameters)
            return null;
        var thisType = this.parseParametersThis;
        var isSetter = (flags & common_1.CommonFlags.SET) != 0;
        if (isSetter) {
            if (parameters.length != 1) {
                this.error(diagnostics_1.DiagnosticCode.A_set_accessor_must_have_exactly_one_parameter, name.range); // recoverable
            }
            if (parameters.length && parameters[0].initializer) {
                this.error(diagnostics_1.DiagnosticCode.A_set_accessor_parameter_cannot_have_an_initializer, name.range); // recoverable
            }
        }
        if (flags & common_1.CommonFlags.GET) {
            if (parameters.length) {
                this.error(diagnostics_1.DiagnosticCode.A_get_accessor_cannot_have_parameters, name.range); // recoverable
            }
        }
        var returnType = null;
        if (tn.skip(tokenizer_1.Token.COLON)) {
            returnType = this.parseType(tn, true, isSetter);
            if (!returnType)
                return null;
        }
        if (!returnType) {
            returnType = ast_1.Node.createOmittedType(tn.range(tn.pos));
            if (!isSetter) {
                this.error(diagnostics_1.DiagnosticCode.Type_expected, returnType.range); // recoverable
            }
        }
        var signature = ast_1.Node.createFunctionType(parameters, returnType, thisType, false, tn.range(signatureStart, tn.pos));
        var body = null;
        if (tn.skip(tokenizer_1.Token.OPENBRACE)) {
            if (flags & common_1.CommonFlags.AMBIENT) {
                this.error(diagnostics_1.DiagnosticCode.An_implementation_cannot_be_declared_in_ambient_contexts, tn.range()); // recoverable
            }
            body = this.parseBlockStatement(tn, false);
            if (!body)
                return null;
        }
        else if (!(flags & common_1.CommonFlags.AMBIENT)) {
            this.error(diagnostics_1.DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration, tn.range(tn.pos));
        }
        var ret = ast_1.Node.createFunctionDeclaration(name, typeParameters, signature, body, decorators, flags, 0 /* NONE */, tn.range(startPos, tn.pos));
        tn.skip(tokenizer_1.Token.SEMICOLON);
        return ret;
    }
    parseFunctionExpression(tn) {
        var startPos = tn.tokenPos;
        var name;
        var arrowKind = 0 /* NONE */;
        // either at 'function':
        //  Identifier?
        //  '(' Parameters (':' Type)?
        //  Statement
        if (tn.token == tokenizer_1.Token.FUNCTION) {
            if (tn.skipIdentifier()) {
                name = ast_1.Node.createIdentifierExpression(tn.readIdentifier(), tn.range());
            }
            else { // empty name
                name = ast_1.Node.createEmptyIdentifierExpression(tn.range(tn.pos));
            }
            if (!tn.skip(tokenizer_1.Token.OPENPAREN)) {
                this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(tn.pos), "(");
                return null;
            }
            // or at '(' of arrow function:
            //  Parameters (':' Type)?
            //  Statement
        }
        else {
            arrowKind = 1 /* ARROW_PARENTHESIZED */;
            assert(tn.token == tokenizer_1.Token.OPENPAREN);
            name = ast_1.Node.createEmptyIdentifierExpression(tn.range(tn.tokenPos));
        }
        // TODO: type parameters? doesn't seem worth it.
        var signatureStart = tn.pos;
        var parameters = this.parseParameters(tn);
        if (!parameters)
            return null;
        return this.parseFunctionExpressionCommon(tn, name, parameters, arrowKind, startPos, signatureStart);
    }
    parseFunctionExpressionCommon(tn, name, parameters, arrowKind, startPos = -1, signatureStart = -1) {
        if (startPos < 0)
            startPos = name.range.start;
        if (signatureStart < 0)
            signatureStart = startPos;
        var returnType = null;
        if (arrowKind != 2 /* ARROW_SINGLE */ && tn.skip(tokenizer_1.Token.COLON)) {
            returnType = this.parseType(tn);
            if (!returnType)
                return null;
        }
        else {
            returnType = ast_1.Node.createOmittedType(tn.range(tn.pos));
        }
        if (arrowKind) {
            if (!tn.skip(tokenizer_1.Token.EQUALS_GREATERTHAN)) {
                this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(tn.pos), "=>");
                return null;
            }
        }
        var signature = ast_1.Node.createFunctionType(parameters, returnType, null, // TODO?
        false, tn.range(signatureStart, tn.pos));
        var body = null;
        if (arrowKind) {
            if (tn.skip(tokenizer_1.Token.OPENBRACE)) {
                body = this.parseBlockStatement(tn, false);
            }
            else {
                let bodyExpression = this.parseExpression(tn, 1 /* COMMA */ + 1);
                if (bodyExpression)
                    body = ast_1.Node.createExpressionStatement(bodyExpression);
            }
        }
        else {
            if (!tn.skip(tokenizer_1.Token.OPENBRACE)) {
                this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(tn.pos), "{");
                return null;
            }
            body = this.parseBlockStatement(tn, false);
        }
        if (!body)
            return null;
        var declaration = ast_1.Node.createFunctionDeclaration(name, null, signature, body, null, common_1.CommonFlags.NONE, arrowKind, tn.range(startPos, tn.pos));
        return ast_1.Node.createFunctionExpression(declaration);
    }
    parseClassOrInterface(tn, flags, decorators, startPos) {
        // at ('class' | 'interface'):
        //   Identifier
        //   ('<' TypeParameters)?
        //   ('extends' Type)?
        //   ('implements' Type (',' Type)*)?
        //   '{' ClassMember* '}'
        var isInterface = tn.token == tokenizer_1.Token.INTERFACE;
        if (!tn.skipIdentifier()) {
            this.error(diagnostics_1.DiagnosticCode.Identifier_expected, tn.range());
            return null;
        }
        var identifier = ast_1.Node.createIdentifierExpression(tn.readIdentifier(), tn.range());
        var typeParameters = null;
        if (tn.skip(tokenizer_1.Token.LESSTHAN)) {
            typeParameters = this.parseTypeParameters(tn);
            if (!typeParameters)
                return null;
            flags |= common_1.CommonFlags.GENERIC;
        }
        var extendsType = null;
        if (tn.skip(tokenizer_1.Token.EXTENDS)) {
            let t = this.parseType(tn);
            if (!t)
                return null;
            if (t.kind != ast_1.NodeKind.NAMEDTYPE) {
                this.error(diagnostics_1.DiagnosticCode.Identifier_expected, t.range);
                return null;
            }
            extendsType = t;
        }
        var implementsTypes = null;
        if (tn.skip(tokenizer_1.Token.IMPLEMENTS)) {
            if (isInterface) {
                this.error(diagnostics_1.DiagnosticCode.Interface_declaration_cannot_have_implements_clause, tn.range()); // recoverable
            }
            do {
                let type = this.parseType(tn);
                if (!type)
                    return null;
                if (!isInterface) {
                    if (!implementsTypes)
                        implementsTypes = [type];
                    else
                        implementsTypes.push(type);
                }
            } while (tn.skip(tokenizer_1.Token.COMMA));
        }
        if (!tn.skip(tokenizer_1.Token.OPENBRACE)) {
            this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), "{");
            return null;
        }
        var members = new Array();
        var declaration;
        if (isInterface) {
            assert(!implementsTypes);
            declaration = ast_1.Node.createInterfaceDeclaration(identifier, typeParameters, extendsType, members, decorators, flags, tn.range(startPos, tn.pos));
        }
        else {
            declaration = ast_1.Node.createClassDeclaration(identifier, typeParameters, extendsType, implementsTypes, members, decorators, flags, tn.range(startPos, tn.pos));
        }
        if (!tn.skip(tokenizer_1.Token.CLOSEBRACE)) {
            do {
                let member = this.parseClassMember(tn, declaration);
                if (member)
                    members.push(member);
                else {
                    this.skipStatement(tn);
                    if (tn.skip(tokenizer_1.Token.ENDOFFILE)) {
                        this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), "}");
                        return null;
                    }
                }
            } while (!tn.skip(tokenizer_1.Token.CLOSEBRACE));
        }
        declaration.range.end = tn.pos;
        return declaration;
    }
    parseClassExpression(tn) {
        // at 'class': Identifier? '{' ... '}'
        var startPos = tn.tokenPos;
        var name;
        if (tn.skipIdentifier()) {
            name = ast_1.Node.createIdentifierExpression(tn.readIdentifier(), tn.range());
        }
        else {
            name = ast_1.Node.createEmptyIdentifierExpression(tn.range(tn.pos));
        }
        if (!tn.skip(tokenizer_1.Token.OPENBRACE)) {
            this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(tn.pos), "{");
            return null;
        }
        var members = new Array();
        var declaration = ast_1.Node.createClassDeclaration(name, [], null, null, members, null, common_1.CommonFlags.NONE, tn.range(startPos, tn.pos));
        if (!tn.skip(tokenizer_1.Token.CLOSEBRACE)) {
            do {
                let member = this.parseClassMember(tn, declaration);
                if (member)
                    members.push(member);
                else {
                    this.skipStatement(tn);
                    if (tn.skip(tokenizer_1.Token.ENDOFFILE)) {
                        this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), "}");
                        return null;
                    }
                }
            } while (!tn.skip(tokenizer_1.Token.CLOSEBRACE));
        }
        declaration.range.end = tn.pos;
        return ast_1.Node.createClassExpression(declaration);
    }
    parseClassMember(tn, parent) {
        // before:
        //   ('public' | 'private' | 'protected')?
        //   ('static' | 'abstract')?
        //   'readonly'?
        //   ('get' | 'set')?
        //   Identifier ...
        var startPos = tn.pos;
        var isInterface = parent.kind == ast_1.NodeKind.INTERFACEDECLARATION;
        var decorators = null;
        if (tn.skip(tokenizer_1.Token.AT)) {
            do {
                let decorator = this.parseDecorator(tn);
                if (!decorator)
                    break;
                if (!decorators)
                    decorators = [decorator];
                else
                    decorators.push(decorator);
            } while (tn.skip(tokenizer_1.Token.AT));
            if (decorators && isInterface) {
                this.error(diagnostics_1.DiagnosticCode.Decorators_are_not_valid_here, tokenizer_1.Range.join(decorators[0].range, decorators[decorators.length - 1].range));
            }
        }
        // inherit ambient status
        var flags = parent.flags & common_1.CommonFlags.AMBIENT;
        // implemented methods are virtual
        if (isInterface)
            flags |= common_1.CommonFlags.VIRTUAL;
        var accessStart = 0;
        var accessEnd = 0;
        if (tn.skip(tokenizer_1.Token.PUBLIC)) {
            if (isInterface) {
                this.error(diagnostics_1.DiagnosticCode._0_modifier_cannot_be_used_here, tn.range(), "public");
            }
            flags |= common_1.CommonFlags.PUBLIC;
            accessStart = tn.tokenPos;
            accessEnd = tn.pos;
        }
        else if (tn.skip(tokenizer_1.Token.PRIVATE)) {
            if (isInterface) {
                this.error(diagnostics_1.DiagnosticCode._0_modifier_cannot_be_used_here, tn.range(), "private");
            }
            flags |= common_1.CommonFlags.PRIVATE;
            accessStart = tn.tokenPos;
            accessEnd = tn.pos;
        }
        else if (tn.skip(tokenizer_1.Token.PROTECTED)) {
            if (isInterface) {
                this.error(diagnostics_1.DiagnosticCode._0_modifier_cannot_be_used_here, tn.range(), "protected");
            }
            flags |= common_1.CommonFlags.PROTECTED;
            accessStart = tn.tokenPos;
            accessEnd = tn.pos;
        }
        var staticStart = 0;
        var staticEnd = 0;
        var abstractStart = 0;
        var abstractEnd = 0;
        if (tn.skip(tokenizer_1.Token.STATIC)) {
            if (isInterface) {
                this.error(diagnostics_1.DiagnosticCode._0_modifier_cannot_be_used_here, tn.range(), "static");
            }
            flags |= common_1.CommonFlags.STATIC;
            staticStart = tn.tokenPos;
            staticEnd = tn.pos;
        }
        else {
            flags |= common_1.CommonFlags.INSTANCE;
            if (tn.skip(tokenizer_1.Token.ABSTRACT)) {
                if (isInterface) {
                    this.error(diagnostics_1.DiagnosticCode._0_modifier_cannot_be_used_here, tn.range(), "abstract");
                }
                flags |= common_1.CommonFlags.ABSTRACT;
                abstractStart = tn.tokenPos;
                abstractEnd = tn.pos;
            }
            if (parent.flags & common_1.CommonFlags.GENERIC)
                flags |= common_1.CommonFlags.GENERIC_CONTEXT;
        }
        var readonlyStart = 0;
        var readonlyEnd = 0;
        if (tn.peek() == tokenizer_1.Token.READONLY) {
            let state = tn.mark();
            tn.next();
            if (tn.peek() != tokenizer_1.Token.COLON) { // modifier
                tn.discard(state);
                flags |= common_1.CommonFlags.READONLY;
                readonlyStart = tn.tokenPos;
                readonlyEnd = tn.pos;
            }
            else { // identifier
                tn.reset(state);
            }
        }
        // check if accessor: ('get' | 'set') ^\n Identifier
        var state = tn.mark();
        var isConstructor = false;
        var isGetter = false;
        var getStart = 0;
        var getEnd = 0;
        var isSetter = false;
        var setStart = 0;
        var setEnd = 0;
        if (!isInterface) {
            if (tn.skip(tokenizer_1.Token.GET)) {
                if (tn.peek(true, tokenizer_1.IdentifierHandling.PREFER) == tokenizer_1.Token.IDENTIFIER && !tn.nextTokenOnNewLine) {
                    flags |= common_1.CommonFlags.GET;
                    isGetter = true;
                    setStart = tn.tokenPos;
                    setEnd = tn.pos;
                    if (flags & common_1.CommonFlags.READONLY) {
                        this.error(diagnostics_1.DiagnosticCode._0_modifier_cannot_be_used_here, tn.range(readonlyStart, readonlyEnd), "readonly"); // recoverable
                    }
                }
                else {
                    tn.reset(state);
                }
            }
            else if (tn.skip(tokenizer_1.Token.SET)) {
                if (tn.peek(true, tokenizer_1.IdentifierHandling.PREFER) == tokenizer_1.Token.IDENTIFIER && !tn.nextTokenOnNewLine) {
                    flags |= common_1.CommonFlags.SET;
                    isSetter = true;
                    setStart = tn.tokenPos;
                    setEnd = tn.pos;
                    if (flags & common_1.CommonFlags.READONLY) {
                        this.error(diagnostics_1.DiagnosticCode._0_modifier_cannot_be_used_here, tn.range(readonlyStart, readonlyEnd), "readonly"); // recoverable
                    }
                }
                else {
                    tn.reset(state);
                }
            }
            else if (tn.skip(tokenizer_1.Token.CONSTRUCTOR)) {
                flags |= common_1.CommonFlags.CONSTRUCTOR;
                isConstructor = true;
                if (flags & common_1.CommonFlags.STATIC) {
                    this.error(diagnostics_1.DiagnosticCode._0_modifier_cannot_be_used_here, tn.range(staticStart, staticEnd), "static"); // recoverable
                }
                if (flags & common_1.CommonFlags.ABSTRACT) {
                    this.error(diagnostics_1.DiagnosticCode._0_modifier_cannot_be_used_here, tn.range(abstractStart, abstractEnd), "abstract"); // recoverable
                }
                if (flags & common_1.CommonFlags.READONLY) {
                    this.error(diagnostics_1.DiagnosticCode._0_modifier_cannot_be_used_here, tn.range(readonlyStart, readonlyEnd), "readonly"); // recoverable
                }
            }
        }
        var name;
        if (isConstructor) {
            name = ast_1.Node.createConstructorExpression(tn.range());
        }
        else {
            if (!(isGetter || isSetter) && tn.skip(tokenizer_1.Token.OPENBRACKET)) {
                // TODO: also handle symbols, which might have some of these modifiers
                if (flags & common_1.CommonFlags.PUBLIC) {
                    this.error(diagnostics_1.DiagnosticCode._0_modifier_cannot_be_used_here, tn.range(accessStart, accessEnd), "public"); // recoverable
                }
                else if (flags & common_1.CommonFlags.PROTECTED) {
                    this.error(diagnostics_1.DiagnosticCode._0_modifier_cannot_be_used_here, tn.range(accessStart, accessEnd), "protected"); // recoverable
                }
                else if (flags & common_1.CommonFlags.PRIVATE) {
                    this.error(diagnostics_1.DiagnosticCode._0_modifier_cannot_be_used_here, tn.range(accessStart, accessEnd), "protected"); // recoverable
                }
                if (flags & common_1.CommonFlags.STATIC) {
                    this.error(diagnostics_1.DiagnosticCode._0_modifier_cannot_be_used_here, tn.range(staticStart, staticEnd), "static"); // recoverable
                }
                if (flags & common_1.CommonFlags.ABSTRACT) {
                    this.error(diagnostics_1.DiagnosticCode._0_modifier_cannot_be_used_here, tn.range(abstractStart, abstractEnd), "abstract"); // recoverable
                }
                if (flags & common_1.CommonFlags.READONLY) {
                    this.error(diagnostics_1.DiagnosticCode._0_modifier_cannot_be_used_here, tn.range(readonlyStart, readonlyEnd), "readonly"); // recoverable
                }
                let retIndex = this.parseIndexSignatureDeclaration(tn, decorators);
                if (!retIndex)
                    return null;
                tn.skip(tokenizer_1.Token.SEMICOLON);
                return retIndex;
            }
            if (!tn.skipIdentifier()) {
                this.error(diagnostics_1.DiagnosticCode.Identifier_expected, tn.range());
                return null;
            }
            name = ast_1.Node.createIdentifierExpression(tn.readIdentifier(), tn.range());
        }
        var typeParameters = null;
        if (tn.skip(tokenizer_1.Token.LESSTHAN)) {
            let typeParametersStart = tn.tokenPos;
            typeParameters = this.parseTypeParameters(tn);
            if (!typeParameters)
                return null;
            if (isConstructor) {
                this.error(diagnostics_1.DiagnosticCode.Type_parameters_cannot_appear_on_a_constructor_declaration, tn.range(typeParametersStart, tn.pos)); // recoverable
            }
            else if (isGetter || isSetter) {
                this.error(diagnostics_1.DiagnosticCode.An_accessor_cannot_have_type_parameters, tn.range(typeParametersStart, tn.pos)); // recoverable
            }
            else {
                flags |= common_1.CommonFlags.GENERIC;
            }
        }
        // method: '(' Parameters (':' Type)? '{' Statement* '}' ';'?
        if (tn.skip(tokenizer_1.Token.OPENPAREN)) {
            let signatureStart = tn.tokenPos;
            let parameters = this.parseParameters(tn, isConstructor);
            if (!parameters)
                return null;
            let thisType = this.parseParametersThis;
            if (isConstructor) {
                for (let i = 0, k = parameters.length; i < k; ++i) {
                    let parameter = parameters[i];
                    if (parameter.isAny(common_1.CommonFlags.PUBLIC |
                        common_1.CommonFlags.PROTECTED |
                        common_1.CommonFlags.PRIVATE |
                        common_1.CommonFlags.READONLY)) {
                        let implicitFieldDeclaration = ast_1.Node.createFieldDeclaration(parameter.name, parameter.type, null, // initialized via parameter
                        null, parameter.flags | common_1.CommonFlags.INSTANCE, parameter.range);
                        implicitFieldDeclaration.parameterIndex = i;
                        parameter.implicitFieldDeclaration = implicitFieldDeclaration;
                        parent.members.push(implicitFieldDeclaration);
                    }
                }
            }
            else if (isGetter) {
                if (parameters.length) {
                    this.error(diagnostics_1.DiagnosticCode.A_get_accessor_cannot_have_parameters, name.range);
                }
            }
            else if (isSetter) {
                if (parameters.length != 1) {
                    this.error(diagnostics_1.DiagnosticCode.A_set_accessor_must_have_exactly_one_parameter, name.range);
                }
                if (parameters.length && parameters[0].initializer) {
                    this.error(diagnostics_1.DiagnosticCode.A_set_accessor_parameter_cannot_have_an_initializer, name.range);
                }
            }
            let returnType = null;
            if (tn.skip(tokenizer_1.Token.COLON)) {
                if (name.kind == ast_1.NodeKind.CONSTRUCTOR) {
                    this.error(diagnostics_1.DiagnosticCode.Type_annotation_cannot_appear_on_a_constructor_declaration, tn.range());
                }
                else if (isSetter) {
                    this.error(diagnostics_1.DiagnosticCode.A_set_accessor_cannot_have_a_return_type_annotation, tn.range());
                }
                returnType = this.parseType(tn, name.kind == ast_1.NodeKind.CONSTRUCTOR || isSetter);
                if (!returnType)
                    return null;
            }
            else {
                returnType = ast_1.Node.createOmittedType(tn.range(tn.pos));
                if (!isSetter && name.kind != ast_1.NodeKind.CONSTRUCTOR) {
                    this.error(diagnostics_1.DiagnosticCode.Type_expected, returnType.range); // recoverable
                }
            }
            let signature = ast_1.Node.createFunctionType(parameters, returnType, thisType, false, tn.range(signatureStart, tn.pos));
            let body = null;
            if (tn.skip(tokenizer_1.Token.OPENBRACE)) {
                if (flags & common_1.CommonFlags.AMBIENT) {
                    this.error(diagnostics_1.DiagnosticCode.An_implementation_cannot_be_declared_in_ambient_contexts, tn.range()); // recoverable
                }
                else if (flags & common_1.CommonFlags.ABSTRACT) {
                    this.error(diagnostics_1.DiagnosticCode.Method_0_cannot_have_an_implementation_because_it_is_marked_abstract, tn.range(), name.text); // recoverable
                }
                body = this.parseBlockStatement(tn, false);
                if (!body)
                    return null;
            }
            else if (!(flags & common_1.CommonFlags.AMBIENT) && !isInterface) {
                this.error(diagnostics_1.DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration, tn.range()); // recoverable
            }
            let retMethod = ast_1.Node.createMethodDeclaration(name, typeParameters, signature, body, decorators, flags, tn.range(startPos, tn.pos));
            tn.skip(tokenizer_1.Token.SEMICOLON);
            return retMethod;
        }
        else if (isConstructor) {
            this.error(diagnostics_1.DiagnosticCode.Constructor_implementation_is_missing, name.range);
        }
        else if (isGetter || isSetter) {
            this.error(diagnostics_1.DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration, name.range);
            // field: (':' Type)? ('=' Expression)? ';'?
        }
        else {
            if (flags & common_1.CommonFlags.ABSTRACT) {
                this.error(diagnostics_1.DiagnosticCode._0_modifier_cannot_be_used_here, tn.range(abstractStart, abstractEnd), "abstract"); // recoverable
            }
            if (flags & common_1.CommonFlags.GET) {
                this.error(diagnostics_1.DiagnosticCode._0_modifier_cannot_be_used_here, tn.range(getStart, getEnd), "get"); // recoverable
            }
            if (flags & common_1.CommonFlags.SET) {
                this.error(diagnostics_1.DiagnosticCode._0_modifier_cannot_be_used_here, tn.range(setStart, setEnd), "set"); // recoverable
            }
            let type = null;
            if (tn.skip(tokenizer_1.Token.QUESTION)) {
                this.error(diagnostics_1.DiagnosticCode.Optional_properties_are_not_supported, tn.range(startPos, tn.pos));
            }
            if (tn.skip(tokenizer_1.Token.EXCLAMATION)) {
                flags |= common_1.CommonFlags.DEFINITE_ASSIGNMENT;
            }
            if (tn.skip(tokenizer_1.Token.COLON)) {
                type = this.parseType(tn);
                if (!type)
                    return null;
            }
            else {
                this.error(diagnostics_1.DiagnosticCode.Type_expected, tn.range()); // recoverable
            }
            let initializer = null;
            if (tn.skip(tokenizer_1.Token.EQUALS)) {
                initializer = this.parseExpression(tn);
                if (!initializer)
                    return null;
            }
            let range = tn.range(startPos, tn.pos);
            if ((flags & common_1.CommonFlags.DEFINITE_ASSIGNMENT) && ((flags & common_1.CommonFlags.STATIC) || isInterface || initializer)) {
                this.error(diagnostics_1.DiagnosticCode.A_definite_assignment_assertion_is_not_permitted_in_this_context, range);
            }
            let retField = ast_1.Node.createFieldDeclaration(name, type, initializer, decorators, flags, range);
            tn.skip(tokenizer_1.Token.SEMICOLON);
            return retField;
        }
        return null;
    }
    parseIndexSignatureDeclaration(tn, decorators) {
        // at: '[': 'key' ':' Type ']' ':' Type
        if (decorators && decorators.length) {
            this.error(diagnostics_1.DiagnosticCode.Decorators_are_not_valid_here, tokenizer_1.Range.join(decorators[0].range, decorators[decorators.length - 1].range)); // recoverable
        }
        var start = tn.tokenPos;
        if (tn.skipIdentifier()) {
            let id = tn.readIdentifier();
            if (id == "key") {
                if (tn.skip(tokenizer_1.Token.COLON)) {
                    let keyType = this.parseType(tn);
                    if (!keyType)
                        return null;
                    if (keyType.kind != ast_1.NodeKind.NAMEDTYPE) {
                        this.error(diagnostics_1.DiagnosticCode.Type_expected, tn.range());
                        return null;
                    }
                    if (tn.skip(tokenizer_1.Token.CLOSEBRACKET)) {
                        if (tn.skip(tokenizer_1.Token.COLON)) {
                            let valueType = this.parseType(tn);
                            if (!valueType)
                                return null;
                            return ast_1.Node.createIndexSignatureDeclaration(keyType, valueType, tn.range(start, tn.pos));
                        }
                        else {
                            this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), ":");
                        }
                    }
                    else {
                        this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), "]");
                    }
                }
                else {
                    this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), ":");
                }
            }
            else {
                this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), "key");
            }
        }
        else {
            this.error(diagnostics_1.DiagnosticCode.Identifier_expected, tn.range());
        }
        return null;
    }
    parseNamespace(tn, flags, decorators, startPos) {
        // at 'namespace': Identifier '{' (Variable | Function)* '}'
        if (tn.skipIdentifier()) {
            let identifier = ast_1.Node.createIdentifierExpression(tn.readIdentifier(), tn.range());
            if (tn.skip(tokenizer_1.Token.OPENBRACE)) {
                let members = new Array();
                let declaration = ast_1.Node.createNamespaceDeclaration(identifier, members, decorators, flags, tn.range(startPos, tn.pos));
                while (!tn.skip(tokenizer_1.Token.CLOSEBRACE)) {
                    let member = this.parseTopLevelStatement(tn, declaration);
                    if (member)
                        members.push(member);
                    else {
                        this.skipStatement(tn);
                        if (tn.skip(tokenizer_1.Token.ENDOFFILE)) {
                            this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), "}");
                            return null;
                        }
                    }
                }
                declaration.range.end = tn.pos;
                tn.skip(tokenizer_1.Token.SEMICOLON);
                return declaration;
            }
            else {
                this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), "{");
            }
        }
        else {
            this.error(diagnostics_1.DiagnosticCode.Identifier_expected, tn.range());
        }
        return null;
    }
    parseExport(tn, startPos, isDeclare) {
        // at 'export': '{' ExportMember (',' ExportMember)* }' ('from' StringLiteral)? ';'?
        var path = null;
        if (tn.skip(tokenizer_1.Token.OPENBRACE)) {
            let members = new Array();
            while (!tn.skip(tokenizer_1.Token.CLOSEBRACE)) {
                let member = this.parseExportMember(tn);
                if (!member)
                    return null;
                members.push(member);
                if (!tn.skip(tokenizer_1.Token.COMMA)) {
                    if (tn.skip(tokenizer_1.Token.CLOSEBRACE)) {
                        break;
                    }
                    else {
                        this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), "}");
                        return null;
                    }
                }
            }
            if (tn.skip(tokenizer_1.Token.FROM)) {
                if (tn.skip(tokenizer_1.Token.STRINGLITERAL)) {
                    path = ast_1.Node.createStringLiteralExpression(tn.readString(), tn.range());
                }
                else {
                    this.error(diagnostics_1.DiagnosticCode.String_literal_expected, tn.range());
                    return null;
                }
            }
            let ret = ast_1.Node.createExportStatement(members, path, isDeclare, tn.range(startPos, tn.pos));
            let internalPath = ret.internalPath;
            if (internalPath !== null && !this.seenlog.has(internalPath)) {
                this.dependees.set(internalPath, this.currentSource);
                this.backlog.push(internalPath);
                this.seenlog.add(internalPath);
            }
            tn.skip(tokenizer_1.Token.SEMICOLON);
            return ret;
        }
        else if (tn.skip(tokenizer_1.Token.ASTERISK)) {
            if (tn.skip(tokenizer_1.Token.FROM)) {
                if (tn.skip(tokenizer_1.Token.STRINGLITERAL)) {
                    path = ast_1.Node.createStringLiteralExpression(tn.readString(), tn.range());
                    let ret = ast_1.Node.createExportStatement(null, path, isDeclare, tn.range(startPos, tn.pos));
                    let internalPath = assert(ret.internalPath);
                    let source = tn.source;
                    if (!source.exportPaths)
                        source.exportPaths = new Set();
                    source.exportPaths.add(internalPath);
                    if (!this.seenlog.has(internalPath)) {
                        this.dependees.set(internalPath, this.currentSource);
                        this.backlog.push(internalPath);
                    }
                    tn.skip(tokenizer_1.Token.SEMICOLON);
                    return ret;
                }
                else {
                    this.error(diagnostics_1.DiagnosticCode.String_literal_expected, tn.range());
                }
            }
            else {
                this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), "from");
            }
        }
        else {
            this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), "{");
        }
        return null;
    }
    parseExportMember(tn) {
        // before: Identifier ('as' Identifier)?
        if (tn.skipIdentifier()) {
            let identifier = ast_1.Node.createIdentifierExpression(tn.readIdentifier(), tn.range());
            let asIdentifier = null;
            if (tn.skip(tokenizer_1.Token.AS)) {
                if (tn.skipIdentifier(tokenizer_1.IdentifierHandling.ALWAYS)) {
                    asIdentifier = ast_1.Node.createIdentifierExpression(tn.readIdentifier(), tn.range());
                }
                else {
                    this.error(diagnostics_1.DiagnosticCode.Identifier_expected, tn.range());
                    return null;
                }
            }
            return ast_1.Node.createExportMember(identifier, asIdentifier, asIdentifier
                ? tokenizer_1.Range.join(identifier.range, asIdentifier.range)
                : identifier.range);
        }
        else {
            this.error(diagnostics_1.DiagnosticCode.Identifier_expected, tn.range());
        }
        return null;
    }
    parseExportDefaultAlias(tn, startPos, defaultStart, defaultEnd) {
        // at 'export' 'default': [Known-To-Be-]Identifier
        var name = tn.readIdentifier();
        var range = tn.range();
        var ret = ast_1.Node.createExportStatement([
            ast_1.Node.createExportMember(ast_1.Node.createIdentifierExpression(name, range), ast_1.Node.createIdentifierExpression("default", tn.range(defaultStart, defaultEnd)), range)
        ], null, false, tn.range(startPos, tn.pos));
        tn.skip(tokenizer_1.Token.SEMICOLON);
        return ret;
    }
    parseImport(tn) {
        // at 'import':
        //  ('{' (ImportMember (',' ImportMember)* '}') | ('*' 'as' Identifier)?
        //  'from' StringLiteral ';'?
        var startPos = tn.tokenPos;
        var members = null;
        var namespaceName = null;
        var skipFrom = false;
        if (tn.skip(tokenizer_1.Token.OPENBRACE)) { // import { ... } from "file"
            members = new Array();
            while (!tn.skip(tokenizer_1.Token.CLOSEBRACE)) {
                let member = this.parseImportDeclaration(tn);
                if (!member)
                    return null;
                members.push(member);
                if (!tn.skip(tokenizer_1.Token.COMMA)) {
                    if (tn.skip(tokenizer_1.Token.CLOSEBRACE)) {
                        break;
                    }
                    else {
                        this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), "}");
                        return null;
                    }
                }
            }
        }
        else if (tn.skip(tokenizer_1.Token.ASTERISK)) { // import * from "file"
            if (tn.skip(tokenizer_1.Token.AS)) {
                if (tn.skipIdentifier()) {
                    namespaceName = ast_1.Node.createIdentifierExpression(tn.readIdentifier(), tn.range());
                }
                else {
                    this.error(diagnostics_1.DiagnosticCode.Identifier_expected, tn.range());
                    return null;
                }
            }
            else {
                this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), "as");
                return null;
            }
        }
        else if (tn.skip(tokenizer_1.Token.IDENTIFIER, tokenizer_1.IdentifierHandling.PREFER)) { // import Name from "file"
            let name = tn.readIdentifier();
            let range = tn.range();
            members = [
                ast_1.Node.createImportDeclaration(ast_1.Node.createIdentifierExpression("default", range), ast_1.Node.createIdentifierExpression(name, range), range)
            ];
            if (tn.skip(tokenizer_1.Token.COMMA)) {
                // TODO: default + star, default + members
                this.error(diagnostics_1.DiagnosticCode.Not_implemented, tn.range());
                return null;
            }
        }
        else { // import "file"
            skipFrom = true;
        }
        if (skipFrom || tn.skip(tokenizer_1.Token.FROM)) {
            if (tn.skip(tokenizer_1.Token.STRINGLITERAL)) {
                let path = ast_1.Node.createStringLiteralExpression(tn.readString(), tn.range());
                let ret;
                if (namespaceName) {
                    assert(!members);
                    ret = ast_1.Node.createImportStatementWithWildcard(namespaceName, path, tn.range(startPos, tn.pos));
                }
                else {
                    ret = ast_1.Node.createImportStatement(members, path, tn.range(startPos, tn.pos));
                }
                let internalPath = ret.internalPath;
                if (!this.seenlog.has(internalPath)) {
                    this.dependees.set(internalPath, this.currentSource);
                    this.backlog.push(internalPath);
                }
                tn.skip(tokenizer_1.Token.SEMICOLON);
                return ret;
            }
            else {
                this.error(diagnostics_1.DiagnosticCode.String_literal_expected, tn.range());
            }
        }
        else {
            this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), "from");
        }
        return null;
    }
    parseImportDeclaration(tn) {
        // before: Identifier ('as' Identifier)?
        if (tn.skipIdentifier(tokenizer_1.IdentifierHandling.ALWAYS)) {
            let identifier = ast_1.Node.createIdentifierExpression(tn.readIdentifier(), tn.range());
            let asIdentifier = null;
            if (tn.skip(tokenizer_1.Token.AS)) {
                if (tn.skipIdentifier()) {
                    asIdentifier = ast_1.Node.createIdentifierExpression(tn.readIdentifier(), tn.range());
                }
                else {
                    this.error(diagnostics_1.DiagnosticCode.Identifier_expected, tn.range());
                    return null;
                }
            }
            return ast_1.Node.createImportDeclaration(identifier, asIdentifier, asIdentifier
                ? tokenizer_1.Range.join(identifier.range, asIdentifier.range)
                : identifier.range);
        }
        else {
            this.error(diagnostics_1.DiagnosticCode.Identifier_expected, tn.range());
        }
        return null;
    }
    parseExportImport(tn, startPos) {
        // at 'export' 'import': Identifier ('=' Identifier)? ';'?
        if (tn.skipIdentifier()) {
            let asIdentifier = ast_1.Node.createIdentifierExpression(tn.readIdentifier(), tn.range());
            if (tn.skip(tokenizer_1.Token.EQUALS)) {
                if (tn.skipIdentifier()) {
                    let identifier = ast_1.Node.createIdentifierExpression(tn.readIdentifier(), tn.range());
                    let ret = ast_1.Node.createExportImportStatement(identifier, asIdentifier, tn.range(startPos, tn.pos));
                    tn.skip(tokenizer_1.Token.SEMICOLON);
                    return ret;
                }
                else {
                    this.error(diagnostics_1.DiagnosticCode.Identifier_expected, tn.range());
                }
            }
            else {
                this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), "=");
            }
        }
        else {
            this.error(diagnostics_1.DiagnosticCode.Identifier_expected, tn.range());
        }
        return null;
    }
    parseStatement(tn, topLevel = false) {
        // at previous token
        var state = tn.mark();
        var token = tn.next();
        var statement = null;
        switch (token) {
            case tokenizer_1.Token.BREAK: {
                statement = this.parseBreak(tn);
                break;
            }
            case tokenizer_1.Token.CONST: {
                statement = this.parseVariable(tn, common_1.CommonFlags.CONST, null, tn.tokenPos);
                break;
            }
            case tokenizer_1.Token.CONTINUE: {
                statement = this.parseContinue(tn);
                break;
            }
            case tokenizer_1.Token.DO: {
                statement = this.parseDoStatement(tn);
                break;
            }
            case tokenizer_1.Token.FOR: {
                statement = this.parseForStatement(tn);
                break;
            }
            case tokenizer_1.Token.IF: {
                statement = this.parseIfStatement(tn);
                break;
            }
            case tokenizer_1.Token.LET: {
                statement = this.parseVariable(tn, common_1.CommonFlags.LET, null, tn.tokenPos);
                break;
            }
            case tokenizer_1.Token.VAR: {
                statement = this.parseVariable(tn, common_1.CommonFlags.NONE, null, tn.tokenPos);
                break;
            }
            case tokenizer_1.Token.OPENBRACE: {
                statement = this.parseBlockStatement(tn, topLevel);
                break;
            }
            case tokenizer_1.Token.RETURN: {
                if (topLevel) {
                    this.error(diagnostics_1.DiagnosticCode.A_return_statement_can_only_be_used_within_a_function_body, tn.range()); // recoverable
                }
                statement = this.parseReturn(tn);
                break;
            }
            case tokenizer_1.Token.SEMICOLON: {
                return ast_1.Node.createEmptyStatement(tn.range(tn.tokenPos));
            }
            case tokenizer_1.Token.SWITCH: {
                statement = this.parseSwitchStatement(tn);
                break;
            }
            case tokenizer_1.Token.THROW: {
                statement = this.parseThrowStatement(tn);
                break;
            }
            case tokenizer_1.Token.TRY: {
                statement = this.parseTryStatement(tn);
                break;
            }
            case tokenizer_1.Token.VOID: {
                statement = this.parseVoidStatement(tn);
                break;
            }
            case tokenizer_1.Token.WHILE: {
                statement = this.parseWhileStatement(tn);
                break;
            }
            case tokenizer_1.Token.TYPE: { // also identifier
                if (tn.peek(false, tokenizer_1.IdentifierHandling.PREFER) == tokenizer_1.Token.IDENTIFIER) {
                    statement = this.parseTypeDeclaration(tn, common_1.CommonFlags.NONE, null, tn.tokenPos);
                    break;
                }
                // fall-through
            }
            default: {
                tn.reset(state);
                statement = this.parseExpressionStatement(tn);
                break;
            }
        }
        if (!statement) { // has been reported
            tn.reset(state);
            this.skipStatement(tn);
        }
        else {
            tn.discard(state);
        }
        return statement;
    }
    parseBlockStatement(tn, topLevel) {
        // at '{': Statement* '}' ';'?
        var startPos = tn.tokenPos;
        var statements = new Array();
        while (!tn.skip(tokenizer_1.Token.CLOSEBRACE)) {
            let state = tn.mark();
            let statement = this.parseStatement(tn, topLevel);
            if (!statement) {
                if (tn.token == tokenizer_1.Token.ENDOFFILE)
                    return null;
                tn.reset(state);
                this.skipStatement(tn);
            }
            else {
                tn.discard(state);
                statements.push(statement);
            }
        }
        var ret = ast_1.Node.createBlockStatement(statements, tn.range(startPos, tn.pos));
        tn.skip(tokenizer_1.Token.SEMICOLON);
        return ret;
    }
    parseBreak(tn) {
        // at 'break': Identifier? ';'?
        var identifier = null;
        if (tn.peek(true) == tokenizer_1.Token.IDENTIFIER && !tn.nextTokenOnNewLine) {
            tn.next(tokenizer_1.IdentifierHandling.PREFER);
            identifier = ast_1.Node.createIdentifierExpression(tn.readIdentifier(), tn.range());
        }
        var ret = ast_1.Node.createBreakStatement(identifier, tn.range());
        tn.skip(tokenizer_1.Token.SEMICOLON);
        return ret;
    }
    parseContinue(tn) {
        // at 'continue': Identifier? ';'?
        var identifier = null;
        if (tn.peek(true) == tokenizer_1.Token.IDENTIFIER && !tn.nextTokenOnNewLine) {
            tn.next(tokenizer_1.IdentifierHandling.PREFER);
            identifier = ast_1.Node.createIdentifierExpression(tn.readIdentifier(), tn.range());
        }
        var ret = ast_1.Node.createContinueStatement(identifier, tn.range());
        tn.skip(tokenizer_1.Token.SEMICOLON);
        return ret;
    }
    parseDoStatement(tn) {
        // at 'do': Statement 'while' '(' Expression ')' ';'?
        var startPos = tn.tokenPos;
        var statement = this.parseStatement(tn);
        if (!statement)
            return null;
        if (tn.skip(tokenizer_1.Token.WHILE)) {
            if (tn.skip(tokenizer_1.Token.OPENPAREN)) {
                let condition = this.parseExpression(tn);
                if (!condition)
                    return null;
                if (tn.skip(tokenizer_1.Token.CLOSEPAREN)) {
                    let ret = ast_1.Node.createDoStatement(statement, condition, tn.range(startPos, tn.pos));
                    tn.skip(tokenizer_1.Token.SEMICOLON);
                    return ret;
                }
                else {
                    this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), ")");
                }
            }
            else {
                this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), "(");
            }
        }
        else {
            this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), "while");
        }
        return null;
    }
    parseExpressionStatement(tn) {
        // at previous token
        var expr = this.parseExpression(tn);
        if (!expr)
            return null;
        var ret = ast_1.Node.createExpressionStatement(expr);
        tn.skip(tokenizer_1.Token.SEMICOLON);
        return ret;
    }
    parseForStatement(tn) {
        // at 'for': '(' Statement? Expression? ';' Expression? ')' Statement
        var startPos = tn.tokenPos;
        if (tn.skip(tokenizer_1.Token.OPENPAREN)) {
            let initializer = null;
            if (tn.skip(tokenizer_1.Token.CONST)) {
                initializer = this.parseVariable(tn, common_1.CommonFlags.CONST, null, tn.tokenPos);
            }
            else if (tn.skip(tokenizer_1.Token.LET)) {
                initializer = this.parseVariable(tn, common_1.CommonFlags.LET, null, tn.tokenPos);
            }
            else if (tn.skip(tokenizer_1.Token.VAR)) {
                initializer = this.parseVariable(tn, common_1.CommonFlags.NONE, null, tn.tokenPos);
            }
            else if (!tn.skip(tokenizer_1.Token.SEMICOLON)) {
                initializer = this.parseExpressionStatement(tn);
                if (!initializer)
                    return null;
            }
            if (tn.token == tokenizer_1.Token.SEMICOLON) {
                let condition = null;
                if (!tn.skip(tokenizer_1.Token.SEMICOLON)) {
                    condition = this.parseExpressionStatement(tn);
                    if (!condition)
                        return null;
                }
                if (tn.token == tokenizer_1.Token.SEMICOLON) {
                    let incrementor = null;
                    if (!tn.skip(tokenizer_1.Token.CLOSEPAREN)) {
                        incrementor = this.parseExpression(tn);
                        if (!incrementor)
                            return null;
                        if (!tn.skip(tokenizer_1.Token.CLOSEPAREN)) {
                            this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), ")");
                            return null;
                        }
                    }
                    let statement = this.parseStatement(tn);
                    if (!statement)
                        return null;
                    return ast_1.Node.createForStatement(initializer, condition
                        ? condition.expression
                        : null, incrementor, statement, tn.range(startPos, tn.pos));
                }
                else {
                    this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), ";");
                }
            }
            else {
                this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), ";");
            }
        }
        else {
            this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), "(");
        }
        return null;
    }
    parseIfStatement(tn) {
        // at 'if': '(' Expression ')' Statement ('else' Statement)?
        var startPos = tn.tokenPos;
        if (tn.skip(tokenizer_1.Token.OPENPAREN)) {
            let condition = this.parseExpression(tn);
            if (!condition)
                return null;
            if (tn.skip(tokenizer_1.Token.CLOSEPAREN)) {
                let statement = this.parseStatement(tn);
                if (!statement)
                    return null;
                let elseStatement = null;
                if (tn.skip(tokenizer_1.Token.ELSE)) {
                    elseStatement = this.parseStatement(tn);
                    if (!elseStatement)
                        return null;
                }
                return ast_1.Node.createIfStatement(condition, statement, elseStatement, tn.range(startPos, tn.pos));
            }
            else {
                this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), ")");
            }
        }
        else {
            this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), "(");
        }
        return null;
    }
    parseSwitchStatement(tn) {
        // at 'switch': '(' Expression ')' '{' SwitchCase* '}' ';'?
        var startPos = tn.tokenPos;
        if (tn.skip(tokenizer_1.Token.OPENPAREN)) {
            let condition = this.parseExpression(tn);
            if (!condition)
                return null;
            if (tn.skip(tokenizer_1.Token.CLOSEPAREN)) {
                if (tn.skip(tokenizer_1.Token.OPENBRACE)) {
                    let cases = new Array();
                    while (!tn.skip(tokenizer_1.Token.CLOSEBRACE)) {
                        let case_ = this.parseSwitchCase(tn);
                        if (!case_)
                            return null;
                        cases.push(case_);
                    }
                    let ret = ast_1.Node.createSwitchStatement(condition, cases, tn.range(startPos, tn.pos));
                    tn.skip(tokenizer_1.Token.SEMICOLON);
                    return ret;
                }
                else {
                    this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), "{");
                }
            }
            else {
                this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), ")");
            }
        }
        else {
            this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), "(");
        }
        return null;
    }
    parseSwitchCase(tn) {
        var startPos = tn.tokenPos;
        var statements, statement;
        // 'case' Expression ':' Statement*
        if (tn.skip(tokenizer_1.Token.CASE)) {
            let label = this.parseExpression(tn);
            if (!label)
                return null;
            if (tn.skip(tokenizer_1.Token.COLON)) {
                statements = new Array();
                while (tn.peek() != tokenizer_1.Token.CASE && tn.nextToken != tokenizer_1.Token.DEFAULT && tn.nextToken != tokenizer_1.Token.CLOSEBRACE) {
                    statement = this.parseStatement(tn);
                    if (!statement)
                        return null;
                    statements.push(statement);
                }
                return ast_1.Node.createSwitchCase(label, statements, tn.range(startPos, tn.pos));
            }
            else {
                this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), ":");
            }
            // 'default' ':' Statement*
        }
        else if (tn.skip(tokenizer_1.Token.DEFAULT)) {
            if (tn.skip(tokenizer_1.Token.COLON)) {
                statements = new Array();
                while (tn.peek() != tokenizer_1.Token.CASE && tn.nextToken != tokenizer_1.Token.DEFAULT && tn.nextToken != tokenizer_1.Token.CLOSEBRACE) {
                    statement = this.parseStatement(tn);
                    if (!statement)
                        return null;
                    statements.push(statement);
                }
                return ast_1.Node.createSwitchCase(null, statements, tn.range(startPos, tn.pos));
            }
            else {
                this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), ":");
            }
        }
        else {
            this.error(diagnostics_1.DiagnosticCode._case_or_default_expected, tn.range());
        }
        return null;
    }
    parseThrowStatement(tn) {
        // at 'throw': Expression ';'?
        var startPos = tn.tokenPos;
        var expression = this.parseExpression(tn);
        if (!expression)
            return null;
        var ret = ast_1.Node.createThrowStatement(expression, tn.range(startPos, tn.pos));
        tn.skip(tokenizer_1.Token.SEMICOLON);
        return ret;
    }
    parseTryStatement(tn) {
        // at 'try':
        //   '{' Statement* '}'
        //   ('catch' '(' VariableMember ')' '{' Statement* '}')?
        //   ('finally' '{' Statement* '}'? ';'?
        var startPos = tn.tokenPos;
        var stmt;
        if (tn.skip(tokenizer_1.Token.OPENBRACE)) {
            let statements = new Array();
            while (!tn.skip(tokenizer_1.Token.CLOSEBRACE)) {
                stmt = this.parseStatement(tn);
                if (!stmt)
                    return null;
                statements.push(stmt);
            }
            let catchVariable = null;
            let catchStatements = null;
            let finallyStatements = null;
            if (tn.skip(tokenizer_1.Token.CATCH)) {
                if (!tn.skip(tokenizer_1.Token.OPENPAREN)) {
                    this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), "(");
                    return null;
                }
                if (!tn.skipIdentifier()) {
                    this.error(diagnostics_1.DiagnosticCode.Identifier_expected, tn.range());
                    return null;
                }
                catchVariable = ast_1.Node.createIdentifierExpression(tn.readIdentifier(), tn.range());
                if (!tn.skip(tokenizer_1.Token.CLOSEPAREN)) {
                    this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), ")");
                    return null;
                }
                if (!tn.skip(tokenizer_1.Token.OPENBRACE)) {
                    this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), "{");
                    return null;
                }
                catchStatements = [];
                while (!tn.skip(tokenizer_1.Token.CLOSEBRACE)) {
                    stmt = this.parseStatement(tn);
                    if (!stmt)
                        return null;
                    catchStatements.push(stmt);
                }
            }
            if (tn.skip(tokenizer_1.Token.FINALLY)) {
                if (!tn.skip(tokenizer_1.Token.OPENBRACE)) {
                    this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), "{");
                    return null;
                }
                finallyStatements = [];
                while (!tn.skip(tokenizer_1.Token.CLOSEBRACE)) {
                    stmt = this.parseStatement(tn);
                    if (!stmt)
                        return null;
                    finallyStatements.push(stmt);
                }
            }
            if (!(catchStatements || finallyStatements)) {
                this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), "catch");
                return null;
            }
            let ret = ast_1.Node.createTryStatement(statements, catchVariable, catchStatements, finallyStatements, tn.range(startPos, tn.pos));
            tn.skip(tokenizer_1.Token.SEMICOLON);
            return ret;
        }
        else {
            this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), "{");
        }
        return null;
    }
    parseTypeDeclaration(tn, flags, decorators, startPos) {
        // at 'type': Identifier ('<' TypeParameters '>')? '=' Type ';'?
        if (tn.skipIdentifier()) {
            let name = ast_1.Node.createIdentifierExpression(tn.readIdentifier(), tn.range());
            let typeParameters = null;
            if (tn.skip(tokenizer_1.Token.LESSTHAN)) {
                typeParameters = this.parseTypeParameters(tn);
                if (!typeParameters)
                    return null;
                flags |= common_1.CommonFlags.GENERIC;
            }
            if (tn.skip(tokenizer_1.Token.EQUALS)) {
                let type = this.parseType(tn);
                if (!type)
                    return null;
                let ret = ast_1.Node.createTypeDeclaration(name, typeParameters, type, decorators, flags, tn.range(startPos, tn.pos));
                tn.skip(tokenizer_1.Token.SEMICOLON);
                return ret;
            }
            else {
                this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), "=");
            }
        }
        else {
            this.error(diagnostics_1.DiagnosticCode.Identifier_expected, tn.range());
        }
        return null;
    }
    parseVoidStatement(tn) {
        // at 'void': Expression ';'?
        var startPos = tn.tokenPos;
        var expression = this.parseExpression(tn, 21 /* GROUPING */);
        if (!expression)
            return null;
        var ret = ast_1.Node.createVoidStatement(expression, tn.range(startPos, tn.pos));
        tn.skip(tokenizer_1.Token.SEMICOLON);
        return ret;
    }
    parseWhileStatement(tn) {
        // at 'while': '(' Expression ')' Statement ';'?
        var startPos = tn.tokenPos;
        if (tn.skip(tokenizer_1.Token.OPENPAREN)) {
            let expression = this.parseExpression(tn);
            if (!expression)
                return null;
            if (tn.skip(tokenizer_1.Token.CLOSEPAREN)) {
                let statement = this.parseStatement(tn);
                if (!statement)
                    return null;
                let ret = ast_1.Node.createWhileStatement(expression, statement, tn.range(startPos, tn.pos));
                tn.skip(tokenizer_1.Token.SEMICOLON);
                return ret;
            }
            else {
                this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), ")");
            }
        }
        else {
            this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), "(");
        }
        return null;
    }
    // expressions
    // see: http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm#climbing
    parseExpressionStart(tn) {
        var token = tn.next(tokenizer_1.IdentifierHandling.PREFER);
        var startPos = tn.tokenPos;
        var precedence = determinePrecedenceStart(token);
        if (precedence != 0 /* NONE */) {
            let operand;
            // TODO: SpreadExpression, YieldExpression (currently become unsupported UnaryPrefixExpressions)
            // NewExpression
            if (token == tokenizer_1.Token.NEW) {
                operand = this.parseExpression(tn, 19 /* CALL */);
                if (!operand)
                    return null;
                if (operand.kind == ast_1.NodeKind.CALL) {
                    return ast_1.Node.createNewExpression(operand.expression, operand.typeArguments, operand.arguments, tn.range(startPos, tn.pos));
                }
                else {
                    this.error(diagnostics_1.DiagnosticCode.This_expression_is_not_constructable, operand.range);
                }
                return null;
            }
            else {
                operand = this.parseExpression(tn, precedence);
                if (!operand)
                    return null;
            }
            // UnaryPrefixExpression
            if (token == tokenizer_1.Token.PLUS_PLUS || token == tokenizer_1.Token.MINUS_MINUS) {
                if (operand.kind != ast_1.NodeKind.IDENTIFIER &&
                    operand.kind != ast_1.NodeKind.ELEMENTACCESS &&
                    operand.kind != ast_1.NodeKind.PROPERTYACCESS) {
                    this.error(diagnostics_1.DiagnosticCode.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access, operand.range);
                }
            }
            return ast_1.Node.createUnaryPrefixExpression(token, operand, tn.range(startPos, tn.pos));
        }
        var expr = null;
        switch (token) {
            case tokenizer_1.Token.NULL: return ast_1.Node.createNullExpression(tn.range());
            case tokenizer_1.Token.TRUE: return ast_1.Node.createTrueExpression(tn.range());
            case tokenizer_1.Token.FALSE: return ast_1.Node.createFalseExpression(tn.range());
            // ParenthesizedExpression
            // FunctionExpression
            case tokenizer_1.Token.OPENPAREN: {
                // determine whether this is a function expression
                if (tn.skip(tokenizer_1.Token.CLOSEPAREN)) { // must be a function expression (fast route)
                    return this.parseFunctionExpressionCommon(tn, ast_1.Node.createEmptyIdentifierExpression(tn.range(startPos)), [], 1 /* ARROW_PARENTHESIZED */);
                }
                let state = tn.mark();
                let again = true;
                do {
                    switch (tn.next(tokenizer_1.IdentifierHandling.PREFER)) {
                        // function expression
                        case tokenizer_1.Token.DOT_DOT_DOT: {
                            tn.reset(state);
                            return this.parseFunctionExpression(tn);
                        }
                        // can be both
                        case tokenizer_1.Token.IDENTIFIER: {
                            tn.readIdentifier();
                            switch (tn.next()) {
                                // if we got here, check for arrow
                                case tokenizer_1.Token.CLOSEPAREN: {
                                    if (!tn.skip(tokenizer_1.Token.COLON) &&
                                        !tn.skip(tokenizer_1.Token.EQUALS_GREATERTHAN)) {
                                        again = false;
                                        break;
                                    }
                                    // fall-through
                                }
                                // function expression
                                case tokenizer_1.Token.COLON: { // type annotation
                                    tn.reset(state);
                                    return this.parseFunctionExpression(tn);
                                }
                                // optional parameter or parenthesized
                                case tokenizer_1.Token.QUESTION: {
                                    if (tn.skip(tokenizer_1.Token.COLON) || // optional parameter with type
                                        tn.skip(tokenizer_1.Token.COMMA) || // optional parameter without type
                                        tn.skip(tokenizer_1.Token.CLOSEPAREN) // last optional parameter without type
                                    ) {
                                        tn.reset(state);
                                        return this.parseFunctionExpression(tn);
                                    }
                                    again = false; // parenthesized
                                    break;
                                }
                                case tokenizer_1.Token.COMMA: {
                                    break; // continue
                                }
                                // parenthesized expression
                                // case Token.EQUALS:  // missing type annotation for simplicity
                                default: {
                                    again = false;
                                    break;
                                }
                            }
                            break;
                        }
                        // parenthesized expression
                        default: {
                            again = false;
                            break;
                        }
                    }
                } while (again);
                tn.reset(state);
                // parse parenthesized
                expr = this.parseExpression(tn);
                if (!expr)
                    return null;
                if (!tn.skip(tokenizer_1.Token.CLOSEPAREN)) {
                    this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), ")");
                    return null;
                }
                return ast_1.Node.createParenthesizedExpression(expr, tn.range(startPos, tn.pos));
            }
            // ArrayLiteralExpression
            case tokenizer_1.Token.OPENBRACKET: {
                let elementExpressions = new Array();
                while (!tn.skip(tokenizer_1.Token.CLOSEBRACKET)) {
                    if (tn.peek() == tokenizer_1.Token.COMMA) {
                        expr = null; // omitted
                    }
                    else {
                        expr = this.parseExpression(tn, 1 /* COMMA */ + 1);
                        if (!expr)
                            return null;
                    }
                    elementExpressions.push(expr);
                    if (!tn.skip(tokenizer_1.Token.COMMA)) {
                        if (tn.skip(tokenizer_1.Token.CLOSEBRACKET)) {
                            break;
                        }
                        else {
                            this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), "]");
                            return null;
                        }
                    }
                }
                return ast_1.Node.createArrayLiteralExpression(elementExpressions, tn.range(startPos, tn.pos));
            }
            // ObjectLiteralExpression
            case tokenizer_1.Token.OPENBRACE: {
                let startPos = tn.tokenPos;
                let names = new Array();
                let values = new Array();
                let name;
                while (!tn.skip(tokenizer_1.Token.CLOSEBRACE)) {
                    if (!tn.skipIdentifier()) {
                        if (!tn.skip(tokenizer_1.Token.STRINGLITERAL)) {
                            this.error(diagnostics_1.DiagnosticCode.Identifier_expected, tn.range());
                            return null;
                        }
                        name = ast_1.Node.createIdentifierExpression(tn.readString(), tn.range());
                        name.isQuoted = true;
                    }
                    else {
                        name = ast_1.Node.createIdentifierExpression(tn.readIdentifier(), tn.range());
                    }
                    names.push(name);
                    if (tn.skip(tokenizer_1.Token.COLON)) {
                        let value = this.parseExpression(tn, 1 /* COMMA */ + 1);
                        if (!value)
                            return null;
                        values.push(value);
                    }
                    else if (!name.isQuoted) {
                        values.push(name);
                    }
                    else {
                        this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), ":");
                        return null;
                    }
                    if (!tn.skip(tokenizer_1.Token.COMMA)) {
                        if (tn.skip(tokenizer_1.Token.CLOSEBRACE)) {
                            break;
                        }
                        else {
                            this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), "}");
                            return null;
                        }
                    }
                }
                return ast_1.Node.createObjectLiteralExpression(names, values, tn.range(startPos, tn.pos));
            }
            // AssertionExpression (unary prefix)
            case tokenizer_1.Token.LESSTHAN: {
                let toType = this.parseType(tn);
                if (!toType)
                    return null;
                if (!tn.skip(tokenizer_1.Token.GREATERTHAN)) {
                    this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), ">");
                    return null;
                }
                expr = this.parseExpression(tn, 19 /* CALL */);
                if (!expr)
                    return null;
                return ast_1.Node.createAssertionExpression(ast_1.AssertionKind.PREFIX, expr, toType, tn.range(startPos, tn.pos));
            }
            case tokenizer_1.Token.IDENTIFIER: {
                let identifierText = tn.readIdentifier();
                if (identifierText == "null")
                    return ast_1.Node.createNullExpression(tn.range()); // special
                let identifier = ast_1.Node.createIdentifierExpression(identifierText, tn.range(startPos, tn.pos));
                if (tn.peek(true) == tokenizer_1.Token.EQUALS_GREATERTHAN && !tn.nextTokenOnNewLine) {
                    return this.parseFunctionExpressionCommon(tn, ast_1.Node.createEmptyIdentifierExpression(tn.range(startPos)), [
                        ast_1.Node.createParameter(identifier, ast_1.Node.createOmittedType(identifier.range.atEnd), null, ast_1.ParameterKind.DEFAULT, identifier.range)
                    ], 2 /* ARROW_SINGLE */, startPos);
                }
                return identifier;
            }
            case tokenizer_1.Token.THIS: {
                return ast_1.Node.createThisExpression(tn.range(startPos, tn.pos));
            }
            case tokenizer_1.Token.CONSTRUCTOR: {
                return ast_1.Node.createConstructorExpression(tn.range(startPos, tn.pos));
            }
            case tokenizer_1.Token.SUPER: {
                if (tn.peek() != tokenizer_1.Token.DOT && tn.nextToken != tokenizer_1.Token.OPENPAREN) {
                    this.error(diagnostics_1.DiagnosticCode._super_must_be_followed_by_an_argument_list_or_member_access, tn.range());
                }
                return ast_1.Node.createSuperExpression(tn.range(startPos, tn.pos));
            }
            case tokenizer_1.Token.STRINGLITERAL: {
                return ast_1.Node.createStringLiteralExpression(tn.readString(), tn.range(startPos, tn.pos));
            }
            case tokenizer_1.Token.INTEGERLITERAL: {
                return ast_1.Node.createIntegerLiteralExpression(tn.readInteger(), tn.range(startPos, tn.pos));
            }
            case tokenizer_1.Token.FLOATLITERAL: {
                return ast_1.Node.createFloatLiteralExpression(tn.readFloat(), tn.range(startPos, tn.pos));
            }
            // RegexpLiteralExpression
            // note that this also continues on invalid ones so the surrounding AST remains intact
            case tokenizer_1.Token.SLASH: {
                let regexpPattern = tn.readRegexpPattern(); // also reports
                if (!tn.skip(tokenizer_1.Token.SLASH)) {
                    this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), "/");
                    return null;
                }
                return ast_1.Node.createRegexpLiteralExpression(regexpPattern, tn.readRegexpFlags(), // also reports
                tn.range(startPos, tn.pos));
            }
            case tokenizer_1.Token.FUNCTION: {
                return this.parseFunctionExpression(tn);
            }
            case tokenizer_1.Token.CLASS: {
                return this.parseClassExpression(tn);
            }
            default: {
                if (token == tokenizer_1.Token.ENDOFFILE) {
                    this.error(diagnostics_1.DiagnosticCode.Unexpected_end_of_text, tn.range(startPos));
                }
                else {
                    this.error(diagnostics_1.DiagnosticCode.Expression_expected, tn.range());
                }
                return null;
            }
        }
    }
    tryParseTypeArgumentsBeforeArguments(tn) {
        // at '<': Type (',' Type)* '>' '('
        var state = tn.mark();
        if (!tn.skip(tokenizer_1.Token.LESSTHAN))
            return null;
        var typeArguments = null;
        do {
            if (tn.peek() === tokenizer_1.Token.GREATERTHAN) {
                break;
            }
            let type = this.parseType(tn, true, true);
            if (!type) {
                tn.reset(state);
                return null;
            }
            if (!typeArguments)
                typeArguments = [type];
            else
                typeArguments.push(type);
        } while (tn.skip(tokenizer_1.Token.COMMA));
        if (tn.skip(tokenizer_1.Token.GREATERTHAN) && tn.skip(tokenizer_1.Token.OPENPAREN)) {
            return typeArguments;
        }
        tn.reset(state);
        return null;
    }
    parseArguments(tn) {
        // at '(': (Expression (',' Expression)*)? ')'
        var args = new Array();
        while (!tn.skip(tokenizer_1.Token.CLOSEPAREN)) {
            let expr = this.parseExpression(tn, 1 /* COMMA */ + 1);
            if (!expr)
                return null;
            args.push(expr);
            if (!tn.skip(tokenizer_1.Token.COMMA)) {
                if (tn.skip(tokenizer_1.Token.CLOSEPAREN)) {
                    break;
                }
                else {
                    this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), ")");
                    return null;
                }
            }
        }
        return args;
    }
    parseExpression(tn, precedence = 1 /* COMMA */) {
        assert(precedence != 0 /* NONE */);
        var expr = this.parseExpressionStart(tn);
        if (!expr)
            return null;
        expr = this.maybeParseCallExpression(tn, expr); // simple call like on an Identifier
        var startPos = expr.range.start;
        var token;
        var next = null;
        var nextPrecedence;
        while ((nextPrecedence = determinePrecedence(token = tn.peek())) >= precedence) { // precedence climbing
            tn.next();
            switch (token) {
                // AssertionExpression
                case tokenizer_1.Token.AS: {
                    let toType = this.parseType(tn); // reports
                    if (!toType)
                        return null;
                    expr = ast_1.Node.createAssertionExpression(ast_1.AssertionKind.AS, expr, toType, tn.range(startPos, tn.pos));
                    break;
                }
                case tokenizer_1.Token.EXCLAMATION: {
                    expr = ast_1.Node.createAssertionExpression(ast_1.AssertionKind.NONNULL, expr, null, tn.range(startPos, tn.pos));
                    break;
                }
                // InstanceOfExpression
                case tokenizer_1.Token.INSTANCEOF: {
                    let isType = this.parseType(tn); // reports
                    if (!isType)
                        return null;
                    expr = ast_1.Node.createInstanceOfExpression(expr, isType, tn.range(startPos, tn.pos));
                    break;
                }
                // ElementAccessExpression
                case tokenizer_1.Token.OPENBRACKET: {
                    next = this.parseExpression(tn); // reports
                    if (!next)
                        return null;
                    if (!tn.skip(tokenizer_1.Token.CLOSEBRACKET)) {
                        this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), "]");
                        return null;
                    }
                    expr = ast_1.Node.createElementAccessExpression(expr, next, tn.range(startPos, tn.pos));
                    break;
                }
                // UnaryPostfixExpression
                case tokenizer_1.Token.PLUS_PLUS:
                case tokenizer_1.Token.MINUS_MINUS: {
                    if (expr.kind != ast_1.NodeKind.IDENTIFIER &&
                        expr.kind != ast_1.NodeKind.ELEMENTACCESS &&
                        expr.kind != ast_1.NodeKind.PROPERTYACCESS) {
                        this.error(diagnostics_1.DiagnosticCode.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access, expr.range);
                    }
                    expr = ast_1.Node.createUnaryPostfixExpression(token, expr, tn.range(startPos, tn.pos));
                    break;
                }
                // TernaryExpression
                case tokenizer_1.Token.QUESTION: {
                    let ifThen = this.parseExpression(tn);
                    if (!ifThen)
                        return null;
                    if (!tn.skip(tokenizer_1.Token.COLON)) {
                        this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), ":");
                        return null;
                    }
                    let ifElse = this.parseExpression(tn, precedence > 1 /* COMMA */
                        ? 1 /* COMMA */ + 1
                        : 1 /* COMMA */);
                    if (!ifElse)
                        return null;
                    expr = ast_1.Node.createTernaryExpression(expr, ifThen, ifElse, tn.range(startPos, tn.pos));
                    break;
                }
                // CommaExpression
                case tokenizer_1.Token.COMMA: {
                    let commaExprs = [expr];
                    do {
                        expr = this.parseExpression(tn, 1 /* COMMA */ + 1);
                        if (!expr)
                            return null;
                        commaExprs.push(expr);
                    } while (tn.skip(tokenizer_1.Token.COMMA));
                    expr = ast_1.Node.createCommaExpression(commaExprs, tn.range(startPos, tn.pos));
                    break;
                }
                default: {
                    // PropertyAccessExpression
                    if (token == tokenizer_1.Token.DOT) {
                        if (tn.skipIdentifier()) {
                            next = ast_1.Node.createIdentifierExpression(tn.readIdentifier(), tn.range());
                        }
                        else {
                            next = this.parseExpression(tn, isRightAssociative(token)
                                ? nextPrecedence
                                : nextPrecedence + 1);
                            if (!next)
                                return null;
                        }
                        if (next.kind == ast_1.NodeKind.IDENTIFIER) { // expr '.' Identifier
                            expr = ast_1.Node.createPropertyAccessExpression(expr, next, tn.range(startPos, tn.pos));
                        }
                        else if (next.kind == ast_1.NodeKind.CALL) { // expr '.' CallExpression
                            expr = this.joinPropertyCall(tn, startPos, expr, next);
                            if (!expr)
                                return null;
                        }
                        else {
                            this.error(diagnostics_1.DiagnosticCode.Identifier_expected, next.range);
                            return null;
                        }
                        // BinaryExpression
                    }
                    else {
                        next = this.parseExpression(tn, isRightAssociative(token)
                            ? nextPrecedence
                            : nextPrecedence + 1);
                        if (!next)
                            return null;
                        expr = ast_1.Node.createBinaryExpression(token, expr, next, tn.range(startPos, tn.pos));
                    }
                    break;
                }
            }
            expr = this.maybeParseCallExpression(tn, expr); // compound call like on an ElementAccess
        }
        return expr;
    }
    joinPropertyCall(tn, startPos, expr, call) {
        var callee = call.expression;
        switch (callee.kind) {
            case ast_1.NodeKind.IDENTIFIER: { // join property access and use as call target
                call.expression = ast_1.Node.createPropertyAccessExpression(expr, callee, tn.range(startPos, tn.pos));
                break;
            }
            case ast_1.NodeKind.CALL: { // join call target und wrap the original call around it
                let inner = this.joinPropertyCall(tn, startPos, expr, callee);
                if (!inner)
                    return null;
                call.expression = inner;
                call.range = tn.range(startPos, tn.pos);
                break;
            }
            default: {
                this.error(diagnostics_1.DiagnosticCode.Identifier_expected, call.range);
                return null;
            }
        }
        return call;
    }
    maybeParseCallExpression(tn, expr) {
        if (ast_1.nodeIsCallable(expr.kind)) {
            let typeArguments = null;
            while (tn.skip(tokenizer_1.Token.OPENPAREN)
                ||
                    ast_1.nodeIsGenericCallable(expr.kind) && (typeArguments = this.tryParseTypeArgumentsBeforeArguments(tn)) !== null) {
                let args = this.parseArguments(tn);
                if (!args)
                    break;
                expr = ast_1.Node.createCallExpression(// is again callable
                expr, typeArguments, args, tn.range(expr.range.start, tn.pos));
            }
        }
        return expr;
    }
    /** Skips over a statement on errors in an attempt to reduce unnecessary diagnostic noise. */
    skipStatement(tn) {
        tn.peek(true);
        if (tn.nextTokenOnNewLine)
            tn.next(); // if reset() to the previous line
        do {
            let nextToken = tn.peek(true);
            if (nextToken == tokenizer_1.Token.ENDOFFILE || // next step should handle this
                nextToken == tokenizer_1.Token.SEMICOLON // end of the statement for sure
            ) {
                tn.next();
                break;
            }
            if (tn.nextTokenOnNewLine)
                break; // end of the statement maybe
            switch (tn.next()) {
                case tokenizer_1.Token.IDENTIFIER: {
                    tn.readIdentifier();
                    break;
                }
                case tokenizer_1.Token.STRINGLITERAL: {
                    tn.readString();
                    break;
                }
                case tokenizer_1.Token.INTEGERLITERAL: {
                    tn.readInteger();
                    break;
                }
                case tokenizer_1.Token.FLOATLITERAL: {
                    tn.readFloat();
                    break;
                }
                case tokenizer_1.Token.OPENBRACE: {
                    this.skipBlock(tn);
                    break;
                }
            }
        } while (true);
    }
    /** Skips over a block on errors in an attempt to reduce unnecessary diagnostic noise. */
    skipBlock(tn) {
        // at '{': ... '}'
        var depth = 1;
        var again = true;
        do {
            switch (tn.next()) {
                case tokenizer_1.Token.ENDOFFILE: {
                    this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), "}");
                    again = false;
                    break;
                }
                case tokenizer_1.Token.OPENBRACE: {
                    ++depth;
                    break;
                }
                case tokenizer_1.Token.CLOSEBRACE: {
                    --depth;
                    if (!depth)
                        again = false;
                    break;
                }
                case tokenizer_1.Token.IDENTIFIER: {
                    tn.readIdentifier();
                    break;
                }
                case tokenizer_1.Token.STRINGLITERAL: {
                    tn.readString();
                    break;
                }
                case tokenizer_1.Token.INTEGERLITERAL: {
                    tn.readInteger();
                    break;
                }
                case tokenizer_1.Token.FLOATLITERAL: {
                    tn.readFloat();
                    break;
                }
            }
        } while (again);
    }
}
exports.Parser = Parser;
/** Operator precedence from least to largest. */
var Precedence;
(function (Precedence) {
    Precedence[Precedence["NONE"] = 0] = "NONE";
    Precedence[Precedence["COMMA"] = 1] = "COMMA";
    Precedence[Precedence["SPREAD"] = 2] = "SPREAD";
    Precedence[Precedence["YIELD"] = 3] = "YIELD";
    Precedence[Precedence["ASSIGNMENT"] = 4] = "ASSIGNMENT";
    Precedence[Precedence["CONDITIONAL"] = 5] = "CONDITIONAL";
    Precedence[Precedence["LOGICAL_OR"] = 6] = "LOGICAL_OR";
    Precedence[Precedence["LOGICAL_AND"] = 7] = "LOGICAL_AND";
    Precedence[Precedence["BITWISE_OR"] = 8] = "BITWISE_OR";
    Precedence[Precedence["BITWISE_XOR"] = 9] = "BITWISE_XOR";
    Precedence[Precedence["BITWISE_AND"] = 10] = "BITWISE_AND";
    Precedence[Precedence["EQUALITY"] = 11] = "EQUALITY";
    Precedence[Precedence["RELATIONAL"] = 12] = "RELATIONAL";
    Precedence[Precedence["SHIFT"] = 13] = "SHIFT";
    Precedence[Precedence["ADDITIVE"] = 14] = "ADDITIVE";
    Precedence[Precedence["MULTIPLICATIVE"] = 15] = "MULTIPLICATIVE";
    Precedence[Precedence["EXPONENTIATED"] = 16] = "EXPONENTIATED";
    Precedence[Precedence["UNARY_PREFIX"] = 17] = "UNARY_PREFIX";
    Precedence[Precedence["UNARY_POSTFIX"] = 18] = "UNARY_POSTFIX";
    Precedence[Precedence["CALL"] = 19] = "CALL";
    Precedence[Precedence["MEMBERACCESS"] = 20] = "MEMBERACCESS";
    Precedence[Precedence["GROUPING"] = 21] = "GROUPING";
})(Precedence = exports.Precedence || (exports.Precedence = {}));
/** Determines the precedence of a starting token. */
function determinePrecedenceStart(kind) {
    switch (kind) {
        case tokenizer_1.Token.DOT_DOT_DOT: return 2 /* SPREAD */;
        case tokenizer_1.Token.YIELD: return 3 /* YIELD */;
        case tokenizer_1.Token.EXCLAMATION:
        case tokenizer_1.Token.TILDE:
        case tokenizer_1.Token.PLUS:
        case tokenizer_1.Token.MINUS:
        case tokenizer_1.Token.PLUS_PLUS:
        case tokenizer_1.Token.MINUS_MINUS:
        case tokenizer_1.Token.TYPEOF:
        case tokenizer_1.Token.VOID:
        case tokenizer_1.Token.DELETE: return 17 /* UNARY_PREFIX */;
        case tokenizer_1.Token.NEW: return 20 /* MEMBERACCESS */;
    }
    return 0 /* NONE */;
}
/** Determines the precende of a non-starting token. */
function determinePrecedence(kind) {
    switch (kind) {
        case tokenizer_1.Token.COMMA: return 1 /* COMMA */;
        case tokenizer_1.Token.EQUALS:
        case tokenizer_1.Token.PLUS_EQUALS:
        case tokenizer_1.Token.MINUS_EQUALS:
        case tokenizer_1.Token.ASTERISK_ASTERISK_EQUALS:
        case tokenizer_1.Token.ASTERISK_EQUALS:
        case tokenizer_1.Token.SLASH_EQUALS:
        case tokenizer_1.Token.PERCENT_EQUALS:
        case tokenizer_1.Token.LESSTHAN_LESSTHAN_EQUALS:
        case tokenizer_1.Token.GREATERTHAN_GREATERTHAN_EQUALS:
        case tokenizer_1.Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS:
        case tokenizer_1.Token.AMPERSAND_EQUALS:
        case tokenizer_1.Token.CARET_EQUALS:
        case tokenizer_1.Token.BAR_EQUALS: return 4 /* ASSIGNMENT */;
        case tokenizer_1.Token.QUESTION: return 5 /* CONDITIONAL */;
        case tokenizer_1.Token.BAR_BAR: return 6 /* LOGICAL_OR */;
        case tokenizer_1.Token.AMPERSAND_AMPERSAND: return 7 /* LOGICAL_AND */;
        case tokenizer_1.Token.BAR: return 8 /* BITWISE_OR */;
        case tokenizer_1.Token.CARET: return 9 /* BITWISE_XOR */;
        case tokenizer_1.Token.AMPERSAND: return 10 /* BITWISE_AND */;
        case tokenizer_1.Token.EQUALS_EQUALS:
        case tokenizer_1.Token.EXCLAMATION_EQUALS:
        case tokenizer_1.Token.EQUALS_EQUALS_EQUALS:
        case tokenizer_1.Token.EXCLAMATION_EQUALS_EQUALS: return 11 /* EQUALITY */;
        case tokenizer_1.Token.AS:
        case tokenizer_1.Token.IN:
        case tokenizer_1.Token.INSTANCEOF:
        case tokenizer_1.Token.LESSTHAN:
        case tokenizer_1.Token.GREATERTHAN:
        case tokenizer_1.Token.LESSTHAN_EQUALS:
        case tokenizer_1.Token.GREATERTHAN_EQUALS: return 12 /* RELATIONAL */;
        case tokenizer_1.Token.LESSTHAN_LESSTHAN:
        case tokenizer_1.Token.GREATERTHAN_GREATERTHAN:
        case tokenizer_1.Token.GREATERTHAN_GREATERTHAN_GREATERTHAN: return 13 /* SHIFT */;
        case tokenizer_1.Token.PLUS:
        case tokenizer_1.Token.MINUS: return 14 /* ADDITIVE */;
        case tokenizer_1.Token.ASTERISK:
        case tokenizer_1.Token.SLASH:
        case tokenizer_1.Token.PERCENT: return 15 /* MULTIPLICATIVE */;
        case tokenizer_1.Token.ASTERISK_ASTERISK: return 16 /* EXPONENTIATED */;
        case tokenizer_1.Token.PLUS_PLUS:
        case tokenizer_1.Token.MINUS_MINUS: return 18 /* UNARY_POSTFIX */;
        case tokenizer_1.Token.DOT:
        case tokenizer_1.Token.NEW:
        case tokenizer_1.Token.OPENBRACKET:
        case tokenizer_1.Token.EXCLAMATION: return 20 /* MEMBERACCESS */;
    }
    return 0 /* NONE */;
}
/** Determines whether a non-starting token is right associative. */
function isRightAssociative(kind) {
    switch (kind) {
        case tokenizer_1.Token.EQUALS:
        case tokenizer_1.Token.PLUS_EQUALS:
        case tokenizer_1.Token.MINUS_EQUALS:
        case tokenizer_1.Token.ASTERISK_ASTERISK_EQUALS:
        case tokenizer_1.Token.ASTERISK_EQUALS:
        case tokenizer_1.Token.SLASH_EQUALS:
        case tokenizer_1.Token.PERCENT_EQUALS:
        case tokenizer_1.Token.LESSTHAN_LESSTHAN_EQUALS:
        case tokenizer_1.Token.GREATERTHAN_GREATERTHAN_EQUALS:
        case tokenizer_1.Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS:
        case tokenizer_1.Token.AMPERSAND_EQUALS:
        case tokenizer_1.Token.CARET_EQUALS:
        case tokenizer_1.Token.BAR_EQUALS:
        case tokenizer_1.Token.QUESTION:
        case tokenizer_1.Token.ASTERISK_ASTERISK: return true;
        default: return false;
    }
}


/***/ }),

/***/ "./src/program.ts":
/*!************************!*\
  !*** ./src/program.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * AssemblyScript's intermediate representation describing a program's elements.
 * @module program
 */ /***/
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = __webpack_require__(/*! ./common */ "./src/common.ts");
const diagnostics_1 = __webpack_require__(/*! ./diagnostics */ "./src/diagnostics.ts");
const types_1 = __webpack_require__(/*! ./types */ "./src/types.ts");
const ast_1 = __webpack_require__(/*! ./ast */ "./src/ast.ts");
const util_1 = __webpack_require__(/*! ./util */ "./src/util/index.ts");
const resolver_1 = __webpack_require__(/*! ./resolver */ "./src/resolver.ts");
const flow_1 = __webpack_require__(/*! ./flow */ "./src/flow.ts");
/** Represents a yet unresolved `import`. */
class QueuedImport {
    constructor(
    /** File being imported into. */
    localFile, 
    /** Identifier within the local file. */
    localIdentifier, 
    /** Identifier within the other file. Is an `import *` if not set. */
    foreignIdentifier, 
    /** Path to the other file. */
    foreignPath, 
    /** Alternative path to the other file. */
    foreignPathAlt) {
        this.localFile = localFile;
        this.localIdentifier = localIdentifier;
        this.foreignIdentifier = foreignIdentifier;
        this.foreignPath = foreignPath;
        this.foreignPathAlt = foreignPathAlt;
    }
}
/** Represents a yet unresolved `export`. */
class QueuedExport {
    constructor(
    /** Identifier within the local file. */
    localIdentifier, 
    /** Identifier within the other file. */
    foreignIdentifier, 
    /** Path to the other file if a re-export. */
    foreignPath, 
    /** Alternative path to the other file if a re-export. */
    foreignPathAlt) {
        this.localIdentifier = localIdentifier;
        this.foreignIdentifier = foreignIdentifier;
        this.foreignPath = foreignPath;
        this.foreignPathAlt = foreignPathAlt;
    }
}
/** Represents a yet unresolved `export *`. */
class QueuedExportStar {
    // stored in a map with localFile as the key
    constructor(
    /** Path to the other file. */
    foreignPath, 
    /** Alternative path to the other file. */
    foreignPathAlt, 
    /** Reference to the path literal for reporting. */
    pathLiteral) {
        this.foreignPath = foreignPath;
        this.foreignPathAlt = foreignPathAlt;
        this.pathLiteral = pathLiteral;
    }
}
/** Represents the kind of an operator overload. */
var OperatorKind;
(function (OperatorKind) {
    OperatorKind[OperatorKind["INVALID"] = 0] = "INVALID";
    // indexed access
    OperatorKind[OperatorKind["INDEXED_GET"] = 1] = "INDEXED_GET";
    OperatorKind[OperatorKind["INDEXED_SET"] = 2] = "INDEXED_SET";
    OperatorKind[OperatorKind["UNCHECKED_INDEXED_GET"] = 3] = "UNCHECKED_INDEXED_GET";
    OperatorKind[OperatorKind["UNCHECKED_INDEXED_SET"] = 4] = "UNCHECKED_INDEXED_SET";
    // binary
    OperatorKind[OperatorKind["ADD"] = 5] = "ADD";
    OperatorKind[OperatorKind["SUB"] = 6] = "SUB";
    OperatorKind[OperatorKind["MUL"] = 7] = "MUL";
    OperatorKind[OperatorKind["DIV"] = 8] = "DIV";
    OperatorKind[OperatorKind["REM"] = 9] = "REM";
    OperatorKind[OperatorKind["POW"] = 10] = "POW";
    OperatorKind[OperatorKind["BITWISE_AND"] = 11] = "BITWISE_AND";
    OperatorKind[OperatorKind["BITWISE_OR"] = 12] = "BITWISE_OR";
    OperatorKind[OperatorKind["BITWISE_XOR"] = 13] = "BITWISE_XOR";
    OperatorKind[OperatorKind["BITWISE_SHL"] = 14] = "BITWISE_SHL";
    OperatorKind[OperatorKind["BITWISE_SHR"] = 15] = "BITWISE_SHR";
    OperatorKind[OperatorKind["BITWISE_SHR_U"] = 16] = "BITWISE_SHR_U";
    OperatorKind[OperatorKind["EQ"] = 17] = "EQ";
    OperatorKind[OperatorKind["NE"] = 18] = "NE";
    OperatorKind[OperatorKind["GT"] = 19] = "GT";
    OperatorKind[OperatorKind["GE"] = 20] = "GE";
    OperatorKind[OperatorKind["LT"] = 21] = "LT";
    OperatorKind[OperatorKind["LE"] = 22] = "LE";
    // unary prefix
    OperatorKind[OperatorKind["PLUS"] = 23] = "PLUS";
    OperatorKind[OperatorKind["MINUS"] = 24] = "MINUS";
    OperatorKind[OperatorKind["NOT"] = 25] = "NOT";
    OperatorKind[OperatorKind["BITWISE_NOT"] = 26] = "BITWISE_NOT";
    OperatorKind[OperatorKind["PREFIX_INC"] = 27] = "PREFIX_INC";
    OperatorKind[OperatorKind["PREFIX_DEC"] = 28] = "PREFIX_DEC";
    // unary postfix
    OperatorKind[OperatorKind["POSTFIX_INC"] = 29] = "POSTFIX_INC";
    OperatorKind[OperatorKind["POSTFIX_DEC"] = 30] = "POSTFIX_DEC"; // a--
    // not overridable:
    // IDENTITY             // a === b
    // LOGICAL_AND          // a && b
    // LOGICAL_OR           // a || b
})(OperatorKind = exports.OperatorKind || (exports.OperatorKind = {}));
(function (OperatorKind) {
    /** Returns the operator kind represented by the specified decorator and string argument. */
    function fromDecorator(decoratorKind, arg) {
        assert(arg.length);
        switch (decoratorKind) {
            case ast_1.DecoratorKind.OPERATOR:
            case ast_1.DecoratorKind.OPERATOR_BINARY: {
                switch (arg.charCodeAt(0)) {
                    case 91 /* OPENBRACKET */: {
                        if (arg == "[]")
                            return OperatorKind.INDEXED_GET;
                        if (arg == "[]=")
                            return OperatorKind.INDEXED_SET;
                        break;
                    }
                    case 123 /* OPENBRACE */: {
                        if (arg == "{}")
                            return OperatorKind.UNCHECKED_INDEXED_GET;
                        if (arg == "{}=")
                            return OperatorKind.UNCHECKED_INDEXED_SET;
                        break;
                    }
                    case 43 /* PLUS */: {
                        if (arg == "+")
                            return OperatorKind.ADD;
                        break;
                    }
                    case 45 /* MINUS */: {
                        if (arg == "-")
                            return OperatorKind.SUB;
                        break;
                    }
                    case 42 /* ASTERISK */: {
                        if (arg == "*")
                            return OperatorKind.MUL;
                        if (arg == "**")
                            return OperatorKind.POW;
                        break;
                    }
                    case 47 /* SLASH */: {
                        if (arg == "/")
                            return OperatorKind.DIV;
                        break;
                    }
                    case 37 /* PERCENT */: {
                        if (arg == "%")
                            return OperatorKind.REM;
                        break;
                    }
                    case 38 /* AMPERSAND */: {
                        if (arg == "&")
                            return OperatorKind.BITWISE_AND;
                        break;
                    }
                    case 124 /* BAR */: {
                        if (arg == "|")
                            return OperatorKind.BITWISE_OR;
                        break;
                    }
                    case 94 /* CARET */: {
                        if (arg == "^")
                            return OperatorKind.BITWISE_XOR;
                        break;
                    }
                    case 61 /* EQUALS */: {
                        if (arg == "==")
                            return OperatorKind.EQ;
                        break;
                    }
                    case 33 /* EXCLAMATION */: {
                        if (arg == "!=")
                            return OperatorKind.NE;
                        break;
                    }
                    case 62 /* GREATERTHAN */: {
                        if (arg == ">")
                            return OperatorKind.GT;
                        if (arg == ">=")
                            return OperatorKind.GE;
                        if (arg == ">>")
                            return OperatorKind.BITWISE_SHR;
                        if (arg == ">>>")
                            return OperatorKind.BITWISE_SHR_U;
                        break;
                    }
                    case 60 /* LESSTHAN */: {
                        if (arg == "<")
                            return OperatorKind.LT;
                        if (arg == "<=")
                            return OperatorKind.LE;
                        if (arg == "<<")
                            return OperatorKind.BITWISE_SHL;
                        break;
                    }
                }
                break;
            }
            case ast_1.DecoratorKind.OPERATOR_PREFIX: {
                switch (arg.charCodeAt(0)) {
                    case 43 /* PLUS */: {
                        if (arg == "+")
                            return OperatorKind.PLUS;
                        if (arg == "++")
                            return OperatorKind.PREFIX_INC;
                        break;
                    }
                    case 45 /* MINUS */: {
                        if (arg == "-")
                            return OperatorKind.MINUS;
                        if (arg == "--")
                            return OperatorKind.PREFIX_DEC;
                        break;
                    }
                    case 33 /* EXCLAMATION */: {
                        if (arg == "!")
                            return OperatorKind.NOT;
                        break;
                    }
                    case 126 /* TILDE */: {
                        if (arg == "~")
                            return OperatorKind.BITWISE_NOT;
                        break;
                    }
                }
                break;
            }
            case ast_1.DecoratorKind.OPERATOR_POSTFIX: {
                switch (arg.charCodeAt(0)) {
                    case 43 /* PLUS */: {
                        if (arg == "++")
                            return OperatorKind.POSTFIX_INC;
                        break;
                    }
                    case 45 /* MINUS */: {
                        if (arg == "--")
                            return OperatorKind.POSTFIX_DEC;
                        break;
                    }
                }
                break;
            }
        }
        return OperatorKind.INVALID;
    }
    OperatorKind.fromDecorator = fromDecorator;
    /** Converts a binary operator token to the respective operator kind. */
    function fromBinaryToken(token) {
        switch (token) {
            case ast_1.Token.PLUS:
            case ast_1.Token.PLUS_EQUALS: return OperatorKind.ADD;
            case ast_1.Token.MINUS:
            case ast_1.Token.MINUS_EQUALS: return OperatorKind.SUB;
            case ast_1.Token.ASTERISK:
            case ast_1.Token.ASTERISK_EQUALS: return OperatorKind.MUL;
            case ast_1.Token.SLASH:
            case ast_1.Token.SLASH_EQUALS: return OperatorKind.DIV;
            case ast_1.Token.PERCENT:
            case ast_1.Token.PERCENT_EQUALS: return OperatorKind.REM;
            case ast_1.Token.ASTERISK_ASTERISK:
            case ast_1.Token.ASTERISK_ASTERISK_EQUALS: return OperatorKind.POW;
            case ast_1.Token.AMPERSAND:
            case ast_1.Token.AMPERSAND_EQUALS: return OperatorKind.BITWISE_AND;
            case ast_1.Token.BAR:
            case ast_1.Token.BAR_EQUALS: return OperatorKind.BITWISE_OR;
            case ast_1.Token.CARET:
            case ast_1.Token.CARET_EQUALS: return OperatorKind.BITWISE_XOR;
            case ast_1.Token.LESSTHAN_LESSTHAN:
            case ast_1.Token.LESSTHAN_LESSTHAN_EQUALS: return OperatorKind.BITWISE_SHL;
            case ast_1.Token.GREATERTHAN_GREATERTHAN:
            case ast_1.Token.GREATERTHAN_GREATERTHAN_EQUALS: return OperatorKind.BITWISE_SHR;
            case ast_1.Token.GREATERTHAN_GREATERTHAN_GREATERTHAN:
            case ast_1.Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS: return OperatorKind.BITWISE_SHR_U;
            case ast_1.Token.EQUALS_EQUALS: return OperatorKind.EQ;
            case ast_1.Token.EXCLAMATION_EQUALS: return OperatorKind.NE;
            case ast_1.Token.GREATERTHAN: return OperatorKind.GT;
            case ast_1.Token.GREATERTHAN_EQUALS: return OperatorKind.GE;
            case ast_1.Token.LESSTHAN: return OperatorKind.LT;
            case ast_1.Token.LESSTHAN_EQUALS: return OperatorKind.LE;
        }
        return OperatorKind.INVALID;
    }
    OperatorKind.fromBinaryToken = fromBinaryToken;
    /** Converts a unary prefix operator token to the respective operator kind. */
    function fromUnaryPrefixToken(token) {
        switch (token) {
            case ast_1.Token.PLUS: return OperatorKind.PLUS;
            case ast_1.Token.MINUS: return OperatorKind.MINUS;
            case ast_1.Token.EXCLAMATION: return OperatorKind.NOT;
            case ast_1.Token.TILDE: return OperatorKind.BITWISE_NOT;
            case ast_1.Token.PLUS_PLUS: return OperatorKind.PREFIX_INC;
            case ast_1.Token.MINUS_MINUS: return OperatorKind.PREFIX_DEC;
        }
        return OperatorKind.INVALID;
    }
    OperatorKind.fromUnaryPrefixToken = fromUnaryPrefixToken;
    /** Converts a unary postfix operator token to the respective operator kind. */
    function fromUnaryPostfixToken(token) {
        switch (token) {
            case ast_1.Token.PLUS_PLUS: return OperatorKind.POSTFIX_INC;
            case ast_1.Token.MINUS_MINUS: return OperatorKind.POSTFIX_DEC;
        }
        return OperatorKind.INVALID;
    }
    OperatorKind.fromUnaryPostfixToken = fromUnaryPostfixToken;
})(OperatorKind = exports.OperatorKind || (exports.OperatorKind = {}));
/** Represents an AssemblyScript program. */
class Program extends diagnostics_1.DiagnosticEmitter {
    /** Constructs a new program, optionally inheriting parser diagnostics. */
    constructor(
    /** Shared array of diagnostic messages (emitted so far). */
    diagnostics = null) {
        super(diagnostics);
        /** Array of sources. */
        this.sources = [];
        /** Diagnostic offset used where successively obtaining the next diagnostic. */
        this.diagnosticsOffset = 0;
        // lookup maps
        /** Files by unique internal name. */
        this.filesByName = new Map();
        /** Elements by unique internal name in element space. */
        this.elementsByName = new Map();
        /** Elements by declaration. */
        this.elementsByDeclaration = new Map();
        /** Element instances by unique internal name. */
        this.instancesByName = new Map();
        /** Classes wrapping basic types like `i32`. */
        this.wrapperClasses = new Map();
        /** Managed classes contained in the program, by id. */
        this.managedClasses = new Map();
        /** A set of unique function signatures contained in the program, by id. */
        this.uniqueSignatures = new Array(0);
        /** Next class id. */
        this.nextClassId = 0;
        /** Next signature id. */
        this.nextSignatureId = 0;
        // a dummy signature for programmatically generated native functions
        this.nativeDummySignature = null;
        var nativeSource = new ast_1.Source(common_1.LIBRARY_SUBST, "[native code]", ast_1.SourceKind.LIBRARY_ENTRY);
        this.nativeSource = nativeSource;
        var nativeFile = new File(this, nativeSource);
        this.nativeFile = nativeFile;
        this.filesByName.set(nativeFile.internalName, nativeFile);
        this.resolver = new resolver_1.Resolver(this);
    }
    /** Obtains the source matching the specified internal path. */
    getSource(internalPath) {
        var sources = this.sources;
        for (let i = 0; i < sources.length; ++i) {
            let source = sources[i];
            if (source.internalPath == internalPath)
                return source.text;
        }
        return null;
    }
    /** Writes a common runtime header to the specified buffer. */
    writeRuntimeHeader(buffer, offset, classInstance, payloadSize) {
        // BLOCK {
        //   mmInfo: usize // WASM64 TODO
        //   gcInfo: u32
        //   rtId: u32
        //   rtSize: u32
        // }
        assert(payloadSize < (1 << 28)); // 1 bit BUFFERED + 3 bits color
        util_1.writeI32(payloadSize, buffer, offset);
        util_1.writeI32(1, buffer, offset + 4); // RC=1
        util_1.writeI32(classInstance.id, buffer, offset + 8);
        util_1.writeI32(payloadSize, buffer, offset + 12);
    }
    /** Gets the size of a runtime header. */
    get runtimeHeaderSize() {
        return 16;
    }
    /** Creates a native variable declaration. */
    makeNativeVariableDeclaration(
    /** The simple name of the variable */
    name, 
    /** Flags indicating specific traits, e.g. `CONST`. */
    flags = common_1.CommonFlags.NONE) {
        var range = this.nativeSource.range;
        return ast_1.Node.createVariableDeclaration(ast_1.Node.createIdentifierExpression(name, range), null, null, null, flags, range);
    }
    /** Creates a native type declaration. */
    makeNativeTypeDeclaration(
    /** The simple name of the type. */
    name, 
    /** Flags indicating specific traits, e.g. `GENERIC`. */
    flags = common_1.CommonFlags.NONE) {
        var range = this.nativeSource.range;
        var identifier = ast_1.Node.createIdentifierExpression(name, range);
        return ast_1.Node.createTypeDeclaration(identifier, null, ast_1.Node.createOmittedType(range), null, flags, range);
    }
    /** Creates a native function declaration. */
    makeNativeFunctionDeclaration(
    /** The simple name of the function. */
    name, 
    /** Flags indicating specific traits, e.g. `DECLARE`. */
    flags = common_1.CommonFlags.NONE) {
        var range = this.nativeSource.range;
        return ast_1.Node.createFunctionDeclaration(ast_1.Node.createIdentifierExpression(name, range), null, this.nativeDummySignature || (this.nativeDummySignature = ast_1.Node.createFunctionType([], ast_1.Node.createNamedType(// ^ AST signature doesn't really matter, is overridden anyway
        ast_1.Node.createSimpleTypeName(common_1.CommonSymbols.void_, range), null, false, range), null, false, range)), null, null, flags, 0 /* NONE */, range);
    }
    /** Creates a native namespace declaration. */
    makeNativeNamespaceDeclaration(
    /** The simple name of the namespace. */
    name, 
    /** Flags indicating specific traits, e.g. `EXPORT`. */
    flags = common_1.CommonFlags.NONE) {
        var range = this.nativeSource.range;
        return ast_1.Node.createNamespaceDeclaration(ast_1.Node.createIdentifierExpression(name, range), [], null, flags, range);
    }
    /** Creates a native function. */
    makeNativeFunction(
    /** The simple name of the function. */
    name, 
    /** Concrete function signature. */
    signature, 
    /** Parent element, usually a file, class or namespace. */
    parent = this.nativeFile, 
    /** Flags indicating specific traits, e.g. `GENERIC`. */
    flags = common_1.CommonFlags.NONE, 
    /** Decorator flags representing built-in decorators. */
    decoratorFlags = DecoratorFlags.NONE) {
        return new Function(name, new FunctionPrototype(name, parent, this.makeNativeFunctionDeclaration(name, flags), decoratorFlags), signature);
    }
    /** Gets the (possibly merged) program element linked to the specified declaration. */
    getElementByDeclaration(declaration) {
        var elementsByDeclaration = this.elementsByDeclaration;
        return elementsByDeclaration.has(declaration)
            ? elementsByDeclaration.get(declaration)
            : null;
    }
    /** Initializes the program and its elements prior to compilation. */
    initialize(options) {
        this.options = options;
        // register native types
        this.registerNativeType(common_1.CommonSymbols.i8, types_1.Type.i8);
        this.registerNativeType(common_1.CommonSymbols.i16, types_1.Type.i16);
        this.registerNativeType(common_1.CommonSymbols.i32, types_1.Type.i32);
        this.registerNativeType(common_1.CommonSymbols.i64, types_1.Type.i64);
        this.registerNativeType(common_1.CommonSymbols.isize, options.isizeType);
        this.registerNativeType(common_1.CommonSymbols.u8, types_1.Type.u8);
        this.registerNativeType(common_1.CommonSymbols.u16, types_1.Type.u16);
        this.registerNativeType(common_1.CommonSymbols.u32, types_1.Type.u32);
        this.registerNativeType(common_1.CommonSymbols.u64, types_1.Type.u64);
        this.registerNativeType(common_1.CommonSymbols.usize, options.usizeType);
        this.registerNativeType(common_1.CommonSymbols.bool, types_1.Type.bool);
        this.registerNativeType(common_1.CommonSymbols.f32, types_1.Type.f32);
        this.registerNativeType(common_1.CommonSymbols.f64, types_1.Type.f64);
        this.registerNativeType(common_1.CommonSymbols.void_, types_1.Type.void);
        this.registerNativeType(common_1.CommonSymbols.number, types_1.Type.f64); // alias
        this.registerNativeType(common_1.CommonSymbols.boolean, types_1.Type.bool); // alias
        this.nativeFile.add(common_1.CommonSymbols.native, new TypeDefinition(common_1.CommonSymbols.native, this.nativeFile, this.makeNativeTypeDeclaration(common_1.CommonSymbols.native, common_1.CommonFlags.EXPORT | common_1.CommonFlags.GENERIC), DecoratorFlags.BUILTIN));
        this.nativeFile.add(common_1.CommonSymbols.indexof, new TypeDefinition(common_1.CommonSymbols.indexof, this.nativeFile, this.makeNativeTypeDeclaration(common_1.CommonSymbols.indexof, common_1.CommonFlags.EXPORT | common_1.CommonFlags.GENERIC), DecoratorFlags.BUILTIN));
        this.nativeFile.add(common_1.CommonSymbols.valueof, new TypeDefinition(common_1.CommonSymbols.valueof, this.nativeFile, this.makeNativeTypeDeclaration(common_1.CommonSymbols.valueof, common_1.CommonFlags.EXPORT | common_1.CommonFlags.GENERIC), DecoratorFlags.BUILTIN));
        this.nativeFile.add(common_1.CommonSymbols.returnof, new TypeDefinition(common_1.CommonSymbols.returnof, this.nativeFile, this.makeNativeTypeDeclaration(common_1.CommonSymbols.returnof, common_1.CommonFlags.EXPORT | common_1.CommonFlags.GENERIC), DecoratorFlags.BUILTIN));
        if (options.hasFeature(16 /* SIMD */))
            this.registerNativeType(common_1.CommonSymbols.v128, types_1.Type.v128);
        if (options.hasFeature(256 /* REFERENCE_TYPES */))
            this.registerNativeType(common_1.CommonSymbols.anyref, types_1.Type.anyref);
        // register compiler hints
        this.registerConstantInteger(common_1.CommonSymbols.ASC_TARGET, types_1.Type.i32, i64_new(options.isWasm64 ? common_1.Target.WASM64 : common_1.Target.WASM32));
        this.registerConstantInteger(common_1.CommonSymbols.ASC_NO_ASSERT, types_1.Type.bool, i64_new(options.noAssert ? 1 : 0, 0));
        this.registerConstantInteger(common_1.CommonSymbols.ASC_MEMORY_BASE, types_1.Type.i32, i64_new(options.memoryBase, 0));
        this.registerConstantInteger(common_1.CommonSymbols.ASC_OPTIMIZE_LEVEL, types_1.Type.i32, i64_new(options.optimizeLevelHint, 0));
        this.registerConstantInteger(common_1.CommonSymbols.ASC_SHRINK_LEVEL, types_1.Type.i32, i64_new(options.shrinkLevelHint, 0));
        // register feature hints
        this.registerConstantInteger(common_1.CommonSymbols.ASC_FEATURE_SIGN_EXTENSION, types_1.Type.bool, i64_new(options.hasFeature(1 /* SIGN_EXTENSION */) ? 1 : 0, 0));
        this.registerConstantInteger(common_1.CommonSymbols.ASC_FEATURE_MUTABLE_GLOBALS, types_1.Type.bool, i64_new(options.hasFeature(2 /* MUTABLE_GLOBALS */) ? 1 : 0, 0));
        this.registerConstantInteger(common_1.CommonSymbols.ASC_FEATURE_NONTRAPPING_F2I, types_1.Type.bool, i64_new(options.hasFeature(4 /* NONTRAPPING_F2I */) ? 1 : 0, 0));
        this.registerConstantInteger(common_1.CommonSymbols.ASC_FEATURE_BULK_MEMORY, types_1.Type.bool, i64_new(options.hasFeature(8 /* BULK_MEMORY */) ? 1 : 0, 0));
        this.registerConstantInteger(common_1.CommonSymbols.ASC_FEATURE_SIMD, types_1.Type.bool, i64_new(options.hasFeature(16 /* SIMD */) ? 1 : 0, 0));
        this.registerConstantInteger(common_1.CommonSymbols.ASC_FEATURE_THREADS, types_1.Type.bool, i64_new(options.hasFeature(32 /* THREADS */) ? 1 : 0, 0));
        this.registerConstantInteger(common_1.CommonSymbols.ASC_FEATURE_EXCEPTION_HANDLING, types_1.Type.bool, i64_new(options.hasFeature(64 /* EXCEPTION_HANDLING */) ? 1 : 0, 0));
        this.registerConstantInteger(common_1.CommonSymbols.ASC_FEATURE_TAIL_CALLS, types_1.Type.bool, i64_new(options.hasFeature(128 /* TAIL_CALLS */) ? 1 : 0, 0));
        this.registerConstantInteger(common_1.CommonSymbols.ASC_FEATURE_REFERENCE_TYPES, types_1.Type.bool, i64_new(options.hasFeature(256 /* REFERENCE_TYPES */) ? 1 : 0, 0));
        // remember deferred elements
        var queuedImports = new Array();
        var queuedExports = new Map();
        var queuedExportsStar = new Map();
        var queuedExtends = new Array();
        var queuedImplements = new Array();
        // initialize relevant declaration-like statements of the entire program
        for (let i = 0, k = this.sources.length; i < k; ++i) {
            let source = this.sources[i];
            let file = new File(this, source);
            this.filesByName.set(file.internalName, file);
            let statements = source.statements;
            for (let j = 0, l = statements.length; j < l; ++j) {
                let statement = statements[j];
                switch (statement.kind) {
                    case ast_1.NodeKind.EXPORT: {
                        this.initializeExports(statement, file, queuedExports, queuedExportsStar);
                        break;
                    }
                    case ast_1.NodeKind.EXPORTDEFAULT: {
                        this.initializeExportDefault(statement, file, queuedExtends, queuedImplements);
                        break;
                    }
                    case ast_1.NodeKind.IMPORT: {
                        this.initializeImports(statement, file, queuedImports, queuedExports);
                        break;
                    }
                    case ast_1.NodeKind.VARIABLE: {
                        this.initializeVariables(statement, file);
                        break;
                    }
                    case ast_1.NodeKind.CLASSDECLARATION: {
                        this.initializeClass(statement, file, queuedExtends, queuedImplements);
                        break;
                    }
                    case ast_1.NodeKind.ENUMDECLARATION: {
                        this.initializeEnum(statement, file);
                        break;
                    }
                    case ast_1.NodeKind.FUNCTIONDECLARATION: {
                        this.initializeFunction(statement, file);
                        break;
                    }
                    case ast_1.NodeKind.INTERFACEDECLARATION: {
                        this.initializeInterface(statement, file);
                        break;
                    }
                    case ast_1.NodeKind.NAMESPACEDECLARATION: {
                        this.initializeNamespace(statement, file, queuedExtends, queuedImplements);
                        break;
                    }
                    case ast_1.NodeKind.TYPEDECLARATION: {
                        this.initializeTypeDefinition(statement, file);
                        break;
                    }
                }
            }
        }
        // queued exports * should be linkable now that all files have been processed
        for (let [file, exportsStar] of queuedExportsStar) {
            for (let i = 0, k = exportsStar.length; i < k; ++i) {
                let exportStar = exportsStar[i];
                let foreignFile = this.lookupForeignFile(exportStar.foreignPath, exportStar.foreignPathAlt);
                if (!foreignFile) {
                    this.error(diagnostics_1.DiagnosticCode.File_0_not_found, exportStar.pathLiteral.range, exportStar.pathLiteral.value);
                    continue;
                }
                file.ensureExportStar(foreignFile);
            }
        }
        // queued imports should be resolvable now through traversing exports and queued exports
        for (let i = 0, k = queuedImports.length; i < k; ++i) {
            let queuedImport = queuedImports[i];
            let foreignIdentifier = queuedImport.foreignIdentifier;
            if (foreignIdentifier) { // i.e. import { foo [as bar] } from "./baz"
                let element = this.lookupForeign(foreignIdentifier.text, queuedImport.foreignPath, queuedImport.foreignPathAlt, queuedExports);
                if (element) {
                    queuedImport.localFile.add(queuedImport.localIdentifier.text, element, true // isImport
                    );
                }
                else {
                    // FIXME: file not found is not reported if this happens?
                    this.error(diagnostics_1.DiagnosticCode.Module_0_has_no_exported_member_1, foreignIdentifier.range, queuedImport.foreignPath, foreignIdentifier.text);
                }
            }
            else { // i.e. import * as bar from "./bar"
                let foreignFile = this.lookupForeignFile(queuedImport.foreignPath, queuedImport.foreignPathAlt);
                if (foreignFile) {
                    let localFile = queuedImport.localFile;
                    let localName = queuedImport.localIdentifier.text;
                    localFile.add(localName, foreignFile.asImportedNamespace(localName, localFile), true // isImport
                    );
                }
                else {
                    assert(false); // already reported by the parser not finding the file
                }
            }
        }
        // queued exports should be resolvable now that imports are finalized
        for (let [file, exports] of queuedExports) {
            for (let [exportName, queuedExport] of exports) {
                let localName = queuedExport.localIdentifier.text;
                let foreignPath = queuedExport.foreignPath;
                if (foreignPath) { // i.e. export { foo [as bar] } from "./baz"
                    let element = this.lookupForeign(localName, foreignPath, assert(queuedExport.foreignPathAlt), // must be set if foreignPath is
                    queuedExports);
                    if (element) {
                        file.ensureExport(exportName, element);
                    }
                    else {
                        this.error(diagnostics_1.DiagnosticCode.Module_0_has_no_exported_member_1, queuedExport.localIdentifier.range, foreignPath, localName);
                    }
                }
                else { // i.e. export { foo [as bar] }
                    let element = file.lookupInSelf(localName);
                    if (element) {
                        file.ensureExport(exportName, element);
                    }
                    else {
                        let globalElement = this.lookupGlobal(localName);
                        if (globalElement && globalElement instanceof DeclaredElement) { // export { memory }
                            file.ensureExport(exportName, globalElement);
                        }
                        else {
                            this.error(diagnostics_1.DiagnosticCode.Module_0_has_no_exported_member_1, queuedExport.foreignIdentifier.range, file.internalName, queuedExport.foreignIdentifier.text);
                        }
                    }
                }
            }
        }
        // register ArrayBuffer (id=0), String (id=1), ArrayBufferView (id=2)
        assert(this.nextClassId == 0);
        this.arrayBufferInstance = this.requireClass(common_1.CommonSymbols.ArrayBuffer);
        assert(this.arrayBufferInstance.id == 0);
        this.stringInstance = this.requireClass(common_1.CommonSymbols.String);
        assert(this.stringInstance.id == 1);
        this.arrayBufferViewInstance = this.requireClass(common_1.CommonSymbols.ArrayBufferView);
        assert(this.arrayBufferViewInstance.id == 2);
        // register classes backing basic types
        this.registerWrapperClass(types_1.Type.i8, common_1.CommonSymbols.I8);
        this.registerWrapperClass(types_1.Type.i16, common_1.CommonSymbols.I16);
        this.registerWrapperClass(types_1.Type.i32, common_1.CommonSymbols.I32);
        this.registerWrapperClass(types_1.Type.i64, common_1.CommonSymbols.I64);
        this.registerWrapperClass(options.isizeType, common_1.CommonSymbols.Isize);
        this.registerWrapperClass(types_1.Type.u8, common_1.CommonSymbols.U8);
        this.registerWrapperClass(types_1.Type.u16, common_1.CommonSymbols.U16);
        this.registerWrapperClass(types_1.Type.u32, common_1.CommonSymbols.U32);
        this.registerWrapperClass(types_1.Type.u64, common_1.CommonSymbols.U64);
        this.registerWrapperClass(options.usizeType, common_1.CommonSymbols.Usize);
        this.registerWrapperClass(types_1.Type.bool, common_1.CommonSymbols.Bool);
        this.registerWrapperClass(types_1.Type.f32, common_1.CommonSymbols.F32);
        this.registerWrapperClass(types_1.Type.f64, common_1.CommonSymbols.F64);
        if (options.hasFeature(16 /* SIMD */))
            this.registerWrapperClass(types_1.Type.v128, common_1.CommonSymbols.V128);
        if (options.hasFeature(256 /* REFERENCE_TYPES */))
            this.registerWrapperClass(types_1.Type.anyref, common_1.CommonSymbols.Anyref);
        // register views but don't instantiate them yet
        this.i8ArrayPrototype = this.require(common_1.CommonSymbols.Int8Array, ElementKind.CLASS_PROTOTYPE);
        this.i16ArrayPrototype = this.require(common_1.CommonSymbols.Int16Array, ElementKind.CLASS_PROTOTYPE);
        this.i32ArrayPrototype = this.require(common_1.CommonSymbols.Int32Array, ElementKind.CLASS_PROTOTYPE);
        this.i64ArrayPrototype = this.require(common_1.CommonSymbols.Int64Array, ElementKind.CLASS_PROTOTYPE);
        this.u8ArrayPrototype = this.require(common_1.CommonSymbols.Uint8Array, ElementKind.CLASS_PROTOTYPE);
        this.u8ClampedArrayPrototype = this.require(common_1.CommonSymbols.Uint8ClampedArray, ElementKind.CLASS_PROTOTYPE);
        this.u16ArrayPrototype = this.require(common_1.CommonSymbols.Uint16Array, ElementKind.CLASS_PROTOTYPE);
        this.u32ArrayPrototype = this.require(common_1.CommonSymbols.Uint32Array, ElementKind.CLASS_PROTOTYPE);
        this.u64ArrayPrototype = this.require(common_1.CommonSymbols.Uint64Array, ElementKind.CLASS_PROTOTYPE);
        this.f32ArrayPrototype = this.require(common_1.CommonSymbols.Float32Array, ElementKind.CLASS_PROTOTYPE);
        this.f64ArrayPrototype = this.require(common_1.CommonSymbols.Float64Array, ElementKind.CLASS_PROTOTYPE);
        // resolve base prototypes of derived classes
        var resolver = this.resolver;
        for (let i = 0, k = queuedExtends.length; i < k; ++i) {
            let thisPrototype = queuedExtends[i];
            let extendsNode = assert(thisPrototype.extendsNode); // must be present if in queuedExtends
            let baseElement = resolver.resolveTypeName(extendsNode.name, thisPrototype.parent); // reports
            if (!baseElement)
                continue;
            if (baseElement.kind == ElementKind.CLASS_PROTOTYPE) {
                let basePrototype = baseElement;
                if (basePrototype.hasDecorator(DecoratorFlags.SEALED)) {
                    this.error(diagnostics_1.DiagnosticCode.Class_0_is_sealed_and_cannot_be_extended, extendsNode.range, baseElement.identifierNode.text);
                }
                if (basePrototype.hasDecorator(DecoratorFlags.UNMANAGED) !=
                    thisPrototype.hasDecorator(DecoratorFlags.UNMANAGED)) {
                    this.error(diagnostics_1.DiagnosticCode.Unmanaged_classes_cannot_extend_managed_classes_and_vice_versa, ast_1.Range.join(thisPrototype.identifierNode.range, extendsNode.range));
                }
                thisPrototype.basePrototype = basePrototype;
            }
            else {
                this.error(diagnostics_1.DiagnosticCode.A_class_may_only_extend_another_class, extendsNode.range);
            }
        }
        // set up global aliases
        {
            let globalAliases = options.globalAliases;
            if (globalAliases) {
                for (let [alias, name] of globalAliases) {
                    if (!name.length)
                        continue; // explicitly disabled
                    let firstChar = name.charCodeAt(0);
                    if (firstChar >= 48 /* _0 */ && firstChar <= 57 /* _9 */) {
                        this.registerConstantInteger(alias, types_1.Type.i32, i64_new(parseInt(name, 10)));
                    }
                    else {
                        let elementsByName = this.elementsByName;
                        let element = elementsByName.get(name);
                        if (element) {
                            if (elementsByName.has(alias))
                                throw new Error("duplicate global element: " + name);
                            elementsByName.set(alias, element);
                        }
                        else
                            throw new Error("no such global element: " + name);
                    }
                }
            }
        }
        // register stdlib components
        this.arrayPrototype = this.require(common_1.CommonSymbols.Array, ElementKind.CLASS_PROTOTYPE);
        this.fixedArrayPrototype = this.require(common_1.CommonSymbols.FixedArray, ElementKind.CLASS_PROTOTYPE);
        this.setPrototype = this.require(common_1.CommonSymbols.Set, ElementKind.CLASS_PROTOTYPE);
        this.mapPrototype = this.require(common_1.CommonSymbols.Map, ElementKind.CLASS_PROTOTYPE);
        this.abortInstance = this.lookupFunction(common_1.CommonSymbols.abort); // can be disabled
        this.allocInstance = this.requireFunction(common_1.CommonSymbols.alloc);
        this.reallocInstance = this.requireFunction(common_1.CommonSymbols.realloc);
        this.freeInstance = this.requireFunction(common_1.CommonSymbols.free);
        this.retainInstance = this.requireFunction(common_1.CommonSymbols.retain);
        this.releaseInstance = this.requireFunction(common_1.CommonSymbols.release);
        this.collectInstance = this.requireFunction(common_1.CommonSymbols.collect);
        this.typeinfoInstance = this.requireFunction(common_1.CommonSymbols.typeinfo);
        this.instanceofInstance = this.requireFunction(common_1.CommonSymbols.instanceof_);
        this.visitInstance = this.requireFunction(common_1.CommonSymbols.visit);
        this.allocArrayInstance = this.requireFunction(common_1.CommonSymbols.allocArray);
        // mark module exports, i.e. to apply proper wrapping behavior on the boundaries
        for (let file of this.filesByName.values()) {
            let exports = file.exports;
            if (exports !== null && file.source.sourceKind == ast_1.SourceKind.USER_ENTRY) {
                for (let element of exports.values())
                    this.markModuleExport(element);
            }
        }
    }
    /** Requires that a global library element of the specified kind is present and returns it. */
    require(name, kind) {
        var element = this.lookupGlobal(name);
        if (!element)
            throw new Error("missing " + name);
        if (element.kind != kind)
            throw new Error("unexpected " + name);
        return element;
    }
    /** Requires that a non-generic global class is present and returns it. */
    requireClass(name) {
        var prototype = this.require(name, ElementKind.CLASS_PROTOTYPE);
        var resolved = this.resolver.resolveClass(prototype, null);
        if (!resolved)
            throw new Error("invalid " + name);
        return resolved;
    }
    /** Obtains a non-generic global function and returns it. Returns `null` if it does not exist. */
    lookupFunction(name) {
        var prototype = this.lookupGlobal(name);
        if (!prototype || prototype.kind != ElementKind.FUNCTION_PROTOTYPE)
            return null;
        return this.resolver.resolveFunction(prototype, null);
    }
    /** Requires that a global function is present and returns it. */
    requireFunction(name, typeArguments = null) {
        var prototype = this.require(name, ElementKind.FUNCTION_PROTOTYPE);
        var resolved = this.resolver.resolveFunction(prototype, typeArguments);
        if (!resolved)
            throw new Error("invalid " + name);
        return resolved;
    }
    /** Marks an element and its children as a module export. */
    markModuleExport(element) {
        element.set(common_1.CommonFlags.MODULE_EXPORT);
        switch (element.kind) {
            case ElementKind.CLASS_PROTOTYPE: {
                let instanceMembers = element.instanceMembers;
                if (instanceMembers)
                    for (let member of instanceMembers.values())
                        this.markModuleExport(member);
                break;
            }
            case ElementKind.PROPERTY_PROTOTYPE: {
                let getterPrototype = element.getterPrototype;
                if (getterPrototype)
                    this.markModuleExport(getterPrototype);
                let setterPrototype = element.setterPrototype;
                if (setterPrototype)
                    this.markModuleExport(setterPrototype);
                break;
            }
            case ElementKind.PROPERTY:
            case ElementKind.FUNCTION:
            case ElementKind.FIELD:
            case ElementKind.CLASS: assert(false); // assumes that there are no instances yet
        }
        {
            let members = element.members;
            if (members)
                for (let member of members.values())
                    this.markModuleExport(member);
        }
    }
    /** Registers a native type with the program. */
    registerNativeType(name, type) {
        var element = new TypeDefinition(name, this.nativeFile, this.makeNativeTypeDeclaration(name, common_1.CommonFlags.EXPORT), DecoratorFlags.BUILTIN);
        element.setType(type);
        this.nativeFile.add(name, element);
    }
    /** Registers the backing class of a native type. */
    registerWrapperClass(type, className) {
        var wrapperClasses = this.wrapperClasses;
        assert(!type.classReference && !wrapperClasses.has(type));
        var element = this.lookupGlobal(className);
        if (!element)
            return;
        assert(element.kind == ElementKind.CLASS_PROTOTYPE);
        var classElement = this.resolver.resolveClass(element, null);
        if (!classElement)
            return;
        classElement.wrappedType = type;
        wrapperClasses.set(type, classElement);
    }
    /** Registers a constant integer value within the global scope. */
    registerConstantInteger(name, type, value) {
        assert(type.is(4 /* INTEGER */)); // must be an integer type
        var global = new Global(name, this.nativeFile, DecoratorFlags.NONE, this.makeNativeVariableDeclaration(name, common_1.CommonFlags.CONST | common_1.CommonFlags.EXPORT));
        global.setConstantIntegerValue(value, type);
        this.nativeFile.add(name, global);
    }
    /** Registers a constant float value within the global scope. */
    registerConstantFloat(name, type, value) {
        assert(type.is(8 /* FLOAT */)); // must be a float type
        var global = new Global(name, this.nativeFile, DecoratorFlags.NONE, this.makeNativeVariableDeclaration(name, common_1.CommonFlags.CONST | common_1.CommonFlags.EXPORT));
        global.setConstantFloatValue(value, type);
        this.nativeFile.add(name, global);
    }
    /** Ensures that the given global element exists. Attempts to merge duplicates. */
    ensureGlobal(name, element) {
        var elementsByName = this.elementsByName;
        if (elementsByName.has(name)) {
            let existing = elementsByName.get(name);
            // NOTE: this is effectively only performed when merging native types with
            // their respective namespaces in std/builtins, but can also trigger when a
            // user has multiple global elements of the same name in different files,
            // which might result in unexpected shared symbols accross files. considering
            // this a wonky feature for now that we might want to revisit later.
            if (existing !== element) {
                let merged = tryMerge(existing, element);
                if (!merged) {
                    if (isDeclaredElement(existing.kind)) {
                        this.errorRelated(diagnostics_1.DiagnosticCode.Duplicate_identifier_0, element.identifierNode.range, existing.declaration.name.range, name);
                    }
                    else {
                        this.error(diagnostics_1.DiagnosticCode.Duplicate_identifier_0, element.identifierNode.range, name);
                    }
                    return element;
                }
                element = merged;
            }
        }
        elementsByName.set(name, element);
        return element;
    }
    /** Looks up the element of the specified name in the global scope. */
    lookupGlobal(name) {
        var elements = this.elementsByName;
        if (elements.has(name))
            return elements.get(name);
        return null;
    }
    /** Looks up the element of the specified name in the global scope. Errors if not present. */
    requireGlobal(name) {
        var elements = this.elementsByName;
        if (elements.has(name))
            return elements.get(name);
        throw new Error("missing global");
    }
    /** Tries to locate a foreign file given its normalized path. */
    lookupForeignFile(
    /** Normalized path to the other file. */
    foreignPath, 
    /** Alternative normalized path to the other file. */
    foreignPathAlt) {
        var filesByName = this.filesByName;
        return filesByName.has(foreignPath)
            ? filesByName.get(foreignPath)
            : filesByName.has(foreignPathAlt)
                ? filesByName.get(foreignPathAlt)
                : null;
    }
    /** Tries to locate a foreign element by traversing exports and queued exports. */
    lookupForeign(
    /** Identifier within the other file. */
    foreignName, 
    /** Normalized path to the other file. */
    foreignPath, 
    /** Alternative normalized path to the other file. */
    foreignPathAlt, 
    /** So far queued exports. */
    queuedExports) {
        do {
            let foreignFile = this.lookupForeignFile(foreignPath, foreignPathAlt);
            if (!foreignFile)
                return null; // no such file
            // search already resolved exports
            let element = foreignFile.lookupExport(foreignName);
            if (element)
                return element;
            // otherwise traverse queued exports
            if (queuedExports.has(foreignFile)) {
                let fileQueuedExports = queuedExports.get(foreignFile);
                if (fileQueuedExports.has(foreignName)) {
                    let queuedExport = fileQueuedExports.get(foreignName);
                    if (queuedExport.foreignPath) { // imported from another file
                        foreignName = queuedExport.localIdentifier.text;
                        foreignPath = queuedExport.foreignPath;
                        foreignPathAlt = assert(queuedExport.foreignPathAlt);
                        continue;
                    }
                    else { // local element of this file
                        element = foreignFile.lookupInSelf(queuedExport.localIdentifier.text);
                        if (element)
                            return element;
                    }
                }
            }
            break;
        } while (true);
        return null;
    }
    /** Validates that only supported decorators are present. */
    checkDecorators(
    /** Decorators present on an element. */
    decorators, 
    /** Accepted decorator flags. Emits diagnostics if any other decorators are present. */
    acceptedFlags) {
        var flags = DecoratorFlags.NONE;
        if (decorators) {
            for (let i = 0, k = decorators.length; i < k; ++i) {
                let decorator = decorators[i];
                let kind = ast_1.DecoratorKind.fromNode(decorator.name);
                let flag = DecoratorFlags.fromKind(kind);
                if (flag) {
                    if (flag == DecoratorFlags.BUILTIN) {
                        if (!(acceptedFlags & flag) && !decorator.range.source.isLibrary) {
                            this.error(diagnostics_1.DiagnosticCode.Decorator_0_is_not_valid_here, decorator.range, decorator.name.range.toString());
                        }
                        else {
                            flags |= flag;
                        }
                    }
                    else if (!(acceptedFlags & flag)) {
                        this.error(diagnostics_1.DiagnosticCode.Decorator_0_is_not_valid_here, decorator.range, decorator.name.range.toString());
                    }
                    else if (flags & flag) {
                        this.error(diagnostics_1.DiagnosticCode.Duplicate_decorator, decorator.range);
                    }
                    else {
                        flags |= flag;
                    }
                }
            }
        }
        return flags;
    }
    /** Initializes a class declaration. */
    initializeClass(
    /** The declaration to initialize. */
    declaration, 
    /** Parent element, usually a file or namespace. */
    parent, 
    /** So far queued `extends` clauses. */
    queuedExtends, 
    /** So far queued `implements` clauses. */
    queuedImplements) {
        var name = declaration.name.text;
        var element = new ClassPrototype(name, parent, declaration, this.checkDecorators(declaration.decorators, DecoratorFlags.GLOBAL |
            DecoratorFlags.SEALED |
            DecoratorFlags.UNMANAGED));
        if (!parent.add(name, element))
            return null;
        var implementsTypes = declaration.implementsTypes;
        if (implementsTypes) {
            let numImplementsTypes = implementsTypes.length;
            // cannot implement interfaces when unmanaged
            if (element.hasDecorator(DecoratorFlags.UNMANAGED)) {
                if (numImplementsTypes) {
                    this.error(diagnostics_1.DiagnosticCode.Unmanaged_classes_cannot_implement_interfaces, ast_1.Range.join(declaration.name.range, implementsTypes[numImplementsTypes - 1].range));
                }
            }
            else if (numImplementsTypes) {
                // remember classes that implement interfaces
                for (let i = 0; i < numImplementsTypes; ++i) {
                    this.warning(diagnostics_1.DiagnosticCode.Not_implemented, implementsTypes[i].range);
                }
                queuedImplements.push(element);
            }
        }
        // remember classes that extend another class
        if (declaration.extendsType)
            queuedExtends.push(element);
        // initialize members
        var memberDeclarations = declaration.members;
        for (let i = 0, k = memberDeclarations.length; i < k; ++i) {
            let memberDeclaration = memberDeclarations[i];
            switch (memberDeclaration.kind) {
                case ast_1.NodeKind.FIELDDECLARATION: {
                    this.initializeField(memberDeclaration, element);
                    break;
                }
                case ast_1.NodeKind.METHODDECLARATION: {
                    if (memberDeclaration.isAny(common_1.CommonFlags.GET | common_1.CommonFlags.SET)) {
                        this.initializeProperty(memberDeclaration, element);
                    }
                    else {
                        this.initializeMethod(memberDeclaration, element);
                    }
                    break;
                }
                case ast_1.NodeKind.INDEXSIGNATUREDECLARATION: break; // ignored for now
                default: assert(false); // class member expected
            }
        }
        return element;
    }
    /** Initializes a field of a class or interface. */
    initializeField(
    /** The declaration to initialize. */
    declaration, 
    /** Parent class. */
    parent) {
        var name = declaration.name.text;
        var decorators = declaration.decorators;
        var element;
        if (declaration.is(common_1.CommonFlags.STATIC)) { // global variable
            assert(parent.kind != ElementKind.INTERFACE_PROTOTYPE);
            element = new Global(name, parent, this.checkDecorators(decorators, (declaration.is(common_1.CommonFlags.READONLY)
                ? DecoratorFlags.INLINE
                : DecoratorFlags.NONE) | DecoratorFlags.LAZY | DecoratorFlags.UNSAFE), declaration);
            if (!parent.add(name, element))
                return;
        }
        else { // actual instance field
            assert(!declaration.isAny(common_1.CommonFlags.ABSTRACT | common_1.CommonFlags.GET | common_1.CommonFlags.SET));
            element = new FieldPrototype(name, parent, declaration, this.checkDecorators(decorators, DecoratorFlags.UNSAFE));
            if (!parent.addInstance(name, element))
                return;
        }
    }
    /** Initializes a method of a class or interface. */
    initializeMethod(
    /** The declaration to initialize. */
    declaration, 
    /** Parent class. */
    parent) {
        var name = declaration.name.text;
        var isStatic = declaration.is(common_1.CommonFlags.STATIC);
        var acceptedFlags = DecoratorFlags.INLINE | DecoratorFlags.UNSAFE;
        if (!declaration.is(common_1.CommonFlags.GENERIC)) {
            acceptedFlags |= DecoratorFlags.OPERATOR_BINARY
                | DecoratorFlags.OPERATOR_PREFIX
                | DecoratorFlags.OPERATOR_POSTFIX;
        }
        var element = new FunctionPrototype(name, parent, declaration, this.checkDecorators(declaration.decorators, acceptedFlags));
        if (isStatic) { // global function
            assert(declaration.name.kind != ast_1.NodeKind.CONSTRUCTOR);
            if (!parent.add(name, element))
                return;
        }
        else { // actual instance method
            if (!parent.addInstance(name, element))
                return;
        }
        this.checkOperatorOverloads(declaration.decorators, element, parent);
    }
    /** Checks that operator overloads are generally valid, if present. */
    checkOperatorOverloads(
    /** Decorators to check. */
    decorators, 
    /** Decorated method. */
    prototype, 
    /** Parent class. */
    classPrototype) {
        if (decorators) {
            for (let i = 0, k = decorators.length; i < k; ++i) {
                let decorator = decorators[i]; // FIXME: why does tsc want a type here?
                switch (decorator.decoratorKind) {
                    case ast_1.DecoratorKind.OPERATOR:
                    case ast_1.DecoratorKind.OPERATOR_BINARY:
                    case ast_1.DecoratorKind.OPERATOR_PREFIX:
                    case ast_1.DecoratorKind.OPERATOR_POSTFIX: {
                        let numArgs = decorator.arguments && decorator.arguments.length || 0;
                        if (numArgs == 1) {
                            let firstArg = decorator.arguments[0];
                            if (firstArg.kind == ast_1.NodeKind.LITERAL &&
                                firstArg.literalKind == ast_1.LiteralKind.STRING) {
                                let text = firstArg.value;
                                let kind = OperatorKind.fromDecorator(decorator.decoratorKind, text);
                                if (kind == OperatorKind.INVALID) {
                                    this.error(diagnostics_1.DiagnosticCode._0_is_not_a_valid_operator, firstArg.range, text);
                                }
                                else {
                                    let overloads = classPrototype.overloadPrototypes;
                                    if (overloads.has(kind)) {
                                        this.error(diagnostics_1.DiagnosticCode.Duplicate_function_implementation, firstArg.range);
                                    }
                                    else {
                                        prototype.operatorKind = kind;
                                        overloads.set(kind, prototype);
                                    }
                                }
                            }
                            else {
                                this.error(diagnostics_1.DiagnosticCode.String_literal_expected, firstArg.range);
                            }
                        }
                        else {
                            this.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, decorator.range, "1", numArgs.toString(10));
                        }
                    }
                }
            }
        }
    }
    /** Ensures that the property introduced by the specified getter or setter exists.*/
    ensureProperty(
    /** The declaration of the getter or setter introducing the property. */
    declaration, 
    /** Parent class. */
    parent) {
        var name = declaration.name.text;
        if (declaration.is(common_1.CommonFlags.STATIC)) {
            let parentMembers = parent.members;
            if (parentMembers && parentMembers.has(name)) {
                let element = parentMembers.get(name);
                if (element.kind == ElementKind.PROPERTY_PROTOTYPE)
                    return element;
            }
            else {
                let element = new PropertyPrototype(name, parent, declaration);
                if (!parent.add(name, element))
                    return null;
                return element;
            }
        }
        else {
            let parentMembers = parent.instanceMembers;
            if (parentMembers && parentMembers.has(name)) {
                let element = parentMembers.get(name);
                if (element.kind == ElementKind.PROPERTY_PROTOTYPE)
                    return element;
            }
            else {
                let element = new PropertyPrototype(name, parent, declaration);
                if (!parent.addInstance(name, element))
                    return null;
                return element;
            }
        }
        this.error(diagnostics_1.DiagnosticCode.Duplicate_property_0, declaration.name.range, name);
        return null;
    }
    /** Initializes a property of a class. */
    initializeProperty(
    /** The declaration of the getter or setter. */
    declaration, 
    /** Parent class. */
    parent) {
        var property = this.ensureProperty(declaration, parent);
        if (!property)
            return;
        var name = declaration.name.text;
        var isGetter = declaration.is(common_1.CommonFlags.GET);
        if (isGetter) {
            if (property.getterPrototype) {
                this.error(diagnostics_1.DiagnosticCode.Duplicate_property_0, declaration.name.range, name);
                return;
            }
        }
        else {
            if (property.setterPrototype) {
                this.error(diagnostics_1.DiagnosticCode.Duplicate_property_0, declaration.name.range, name);
                return;
            }
        }
        var element = new FunctionPrototype((isGetter ? common_1.GETTER_PREFIX : common_1.SETTER_PREFIX) + name, property, declaration, this.checkDecorators(declaration.decorators, DecoratorFlags.INLINE | DecoratorFlags.UNSAFE));
        if (isGetter) {
            property.getterPrototype = element;
        }
        else {
            property.setterPrototype = element;
        }
    }
    /** Initializes an enum. */
    initializeEnum(
    /** The declaration to initialize. */
    declaration, 
    /** Parent element, usually a file or namespace. */
    parent) {
        var name = declaration.name.text;
        var element = new Enum(name, parent, declaration, this.checkDecorators(declaration.decorators, DecoratorFlags.GLOBAL |
            DecoratorFlags.INLINE |
            DecoratorFlags.LAZY));
        if (!parent.add(name, element))
            return null;
        var values = declaration.values;
        for (let i = 0, k = values.length; i < k; ++i) {
            this.initializeEnumValue(values[i], element);
        }
        return element;
    }
    /** Initializes an enum value. */
    initializeEnumValue(
    /** The declaration to initialize. */
    declaration, 
    /** Parent enum. */
    parent) {
        var name = declaration.name.text;
        var element = new EnumValue(name, parent, declaration, this.checkDecorators(declaration.decorators, DecoratorFlags.NONE));
        if (!parent.add(name, element))
            return;
    }
    /** Initializes an `export` statement. */
    initializeExports(
    /** The statement to initialize. */
    statement, 
    /** Parent file. */
    parent, 
    /** So far queued `export`s. */
    queuedExports, 
    /** So far queued `export *`s. */
    queuedExportsStar) {
        var members = statement.members;
        if (members) { // export { foo, bar } [from "./baz"]
            for (let i = 0, k = members.length; i < k; ++i) {
                this.initializeExport(members[i], parent, statement.internalPath, queuedExports);
            }
        }
        else { // export * from "./baz"
            let queued;
            if (queuedExportsStar.has(parent))
                queued = queuedExportsStar.get(parent);
            else
                queuedExportsStar.set(parent, queued = []);
            let foreignPath = assert(statement.internalPath); // must be set for export *
            queued.push(new QueuedExportStar(foreignPath, foreignPath.endsWith(common_1.INDEX_SUFFIX) // strip or add index depending on what's already present
                ? foreignPath.substring(0, foreignPath.length - common_1.INDEX_SUFFIX.length)
                : foreignPath + common_1.INDEX_SUFFIX, assert(statement.path)));
        }
    }
    /** Initializes a single `export` member. Does not handle `export *`. */
    initializeExport(
    /** The member to initialize. */
    member, 
    /** Local file. */
    localFile, 
    /** Path to the other file, if present. */
    foreignPath, 
    /** So far queued `export`s. */
    queuedExports) {
        var localName = member.localName.text;
        var foreignName = member.exportedName.text;
        // check for duplicates
        var element = localFile.lookupExport(foreignName);
        if (element) {
            this.error(diagnostics_1.DiagnosticCode.Export_declaration_conflicts_with_exported_declaration_of_0, member.exportedName.range, foreignName);
            return;
        }
        // local element, i.e. export { foo [as bar] }
        if (foreignPath === null) {
            // resolve right away if the local element already exists
            if (element = localFile.lookupInSelf(localName)) {
                localFile.ensureExport(foreignName, element);
                // otherwise queue it
            }
            else {
                let queued;
                if (queuedExports.has(localFile))
                    queued = queuedExports.get(localFile);
                else
                    queuedExports.set(localFile, queued = new Map());
                queued.set(foreignName, new QueuedExport(member.localName, member.exportedName, null, null));
            }
            // foreign element, i.e. export { foo } from "./bar"
        }
        else {
            let queued;
            if (queuedExports.has(localFile))
                queued = queuedExports.get(localFile);
            else
                queuedExports.set(localFile, queued = new Map());
            queued.set(foreignName, new QueuedExport(member.localName, member.exportedName, foreignPath, foreignPath.endsWith(common_1.INDEX_SUFFIX) // strip or add index depending on what's already present
                ? foreignPath.substring(0, foreignPath.length - common_1.INDEX_SUFFIX.length)
                : foreignPath + common_1.INDEX_SUFFIX));
        }
    }
    initializeExportDefault(
    /** The statement to initialize. */
    statement, 
    /** Parent file. */
    parent, 
    /** So far queued `extends` clauses. */
    queuedExtends, 
    /** So far queued `implements` clauses. */
    queuedImplements) {
        var declaration = statement.declaration;
        var element = null;
        switch (declaration.kind) {
            case ast_1.NodeKind.ENUMDECLARATION: {
                element = this.initializeEnum(declaration, parent);
                break;
            }
            case ast_1.NodeKind.FUNCTIONDECLARATION: {
                element = this.initializeFunction(declaration, parent);
                break;
            }
            case ast_1.NodeKind.CLASSDECLARATION: {
                element = this.initializeClass(declaration, parent, queuedExtends, queuedImplements);
                break;
            }
            case ast_1.NodeKind.INTERFACEDECLARATION: {
                element = this.initializeInterface(declaration, parent);
                break;
            }
            case ast_1.NodeKind.NAMESPACEDECLARATION: {
                element = this.initializeNamespace(declaration, parent, queuedExtends, queuedImplements);
                break;
            }
            default: assert(false);
        }
        if (element) {
            let exports = parent.exports;
            if (!exports)
                parent.exports = exports = new Map();
            else {
                if (exports.has("default")) {
                    let existing = exports.get("default");
                    this.errorRelated(diagnostics_1.DiagnosticCode.Duplicate_identifier_0, declaration.name.range, existing.declaration.name.range, "default");
                    return;
                }
            }
            exports.set("default", element);
        }
    }
    /** Initializes an `import` statement. */
    initializeImports(
    /** The statement to initialize. */
    statement, 
    /** Parent file. */
    parent, 
    /** So far queued `import`s. */
    queuedImports, 
    /** So far queued `export`s. */
    queuedExports) {
        var declarations = statement.declarations;
        if (declarations) { // import { foo [as bar] } from "./baz"
            for (let i = 0, k = declarations.length; i < k; ++i) {
                this.initializeImport(declarations[i], parent, statement.internalPath, queuedImports, queuedExports);
            }
        }
        else if (statement.namespaceName) { // import * as foo from "./bar"
            queuedImports.push(new QueuedImport(parent, statement.namespaceName, null, // indicates import *
            statement.internalPath, statement.internalPath + common_1.INDEX_SUFFIX));
        }
        else {
            // import "./foo"
        }
    }
    /** Initializes a single `import` declaration. Does not handle `import *`. */
    initializeImport(// { foo [as bar] }
    /** The declaration to initialize. */
    declaration, 
    /** Parent file. */
    parent, 
    /** Path to the other file. */
    foreignPath, 
    /** So far queued `import`s. */
    queuedImports, 
    /** So far queued `export`s. */
    queuedExports) {
        var foreignPathAlt = foreignPath.endsWith(common_1.INDEX_SUFFIX) // strip or add index depending on what's already present
            ? foreignPath.substring(0, foreignPath.length - common_1.INDEX_SUFFIX.length)
            : foreignPath + common_1.INDEX_SUFFIX;
        // resolve right away if the element exists
        var element = this.lookupForeign(declaration.foreignName.text, foreignPath, foreignPathAlt, queuedExports);
        if (element) {
            parent.add(declaration.name.text, element, true);
            return;
        }
        // otherwise queue it
        queuedImports.push(new QueuedImport(parent, declaration.name, declaration.foreignName, foreignPath, foreignPathAlt));
    }
    /** Initializes a function. Does not handle methods. */
    initializeFunction(
    /** The declaration to initialize. */
    declaration, 
    /** Parent element, usually a file or namespace. */
    parent) {
        var name = declaration.name.text;
        var validDecorators = DecoratorFlags.UNSAFE | DecoratorFlags.BUILTIN;
        if (declaration.is(common_1.CommonFlags.AMBIENT)) {
            validDecorators |= DecoratorFlags.EXTERNAL;
        }
        else {
            validDecorators |= DecoratorFlags.INLINE;
        }
        if (!declaration.is(common_1.CommonFlags.INSTANCE)) {
            if (parent.kind != ElementKind.CLASS_PROTOTYPE) {
                validDecorators |= DecoratorFlags.GLOBAL;
            }
        }
        var element = new FunctionPrototype(name, parent, declaration, this.checkDecorators(declaration.decorators, validDecorators));
        if (!parent.add(name, element))
            return null;
        return element;
    }
    /** Initializes an interface. */
    initializeInterface(
    /** The declaration to initialize. */
    declaration, 
    /** Parent element, usually a file or namespace. */
    parent) {
        var name = declaration.name.text;
        var element = new InterfacePrototype(name, parent, declaration, this.checkDecorators(declaration.decorators, DecoratorFlags.GLOBAL));
        if (!parent.add(name, element))
            return null;
        var memberDeclarations = declaration.members;
        for (let i = 0, k = memberDeclarations.length; i < k; ++i) {
            let memberDeclaration = memberDeclarations[i];
            switch (memberDeclaration.kind) {
                case ast_1.NodeKind.FIELDDECLARATION: {
                    this.initializeField(memberDeclaration, element);
                    break;
                }
                case ast_1.NodeKind.METHODDECLARATION: {
                    if (memberDeclaration.isAny(common_1.CommonFlags.GET | common_1.CommonFlags.SET)) {
                        this.initializeProperty(memberDeclaration, element);
                    }
                    else {
                        this.initializeMethod(memberDeclaration, element);
                    }
                    break;
                }
                default: assert(false); // interface member expected
            }
        }
        return element;
    }
    /** Initializes a namespace. */
    initializeNamespace(
    /** The declaration to initialize. */
    declaration, 
    /** Parent element, usually a file or another namespace. */
    parent, 
    /** So far queued `extends` clauses. */
    queuedExtends, 
    /** So far queued `implements` clauses. */
    queuedImplements) {
        var name = declaration.name.text;
        var original = new Namespace(name, parent, declaration, this.checkDecorators(declaration.decorators, DecoratorFlags.GLOBAL));
        if (!parent.add(name, original))
            return null;
        var element = assert(parent.lookupInSelf(name)); // possibly merged
        var members = declaration.members;
        for (let i = 0, k = members.length; i < k; ++i) {
            let member = members[i];
            switch (member.kind) {
                case ast_1.NodeKind.CLASSDECLARATION: {
                    this.initializeClass(member, original, queuedExtends, queuedImplements);
                    break;
                }
                case ast_1.NodeKind.ENUMDECLARATION: {
                    this.initializeEnum(member, original);
                    break;
                }
                case ast_1.NodeKind.FUNCTIONDECLARATION: {
                    this.initializeFunction(member, original);
                    break;
                }
                case ast_1.NodeKind.INTERFACEDECLARATION: {
                    this.initializeInterface(member, original);
                    break;
                }
                case ast_1.NodeKind.NAMESPACEDECLARATION: {
                    this.initializeNamespace(member, original, queuedExtends, queuedImplements);
                    break;
                }
                case ast_1.NodeKind.TYPEDECLARATION: {
                    this.initializeTypeDefinition(member, original);
                    break;
                }
                case ast_1.NodeKind.VARIABLE: {
                    this.initializeVariables(member, original);
                    break;
                }
                default: assert(false); // namespace member expected
            }
        }
        if (original != element)
            copyMembers(original, element); // retain original parent
        return element;
    }
    /** Initializes a `type` definition. */
    initializeTypeDefinition(
    /** The declaration to initialize. */
    declaration, 
    /** Parent element, usually a file or namespace. */
    parent) {
        var name = declaration.name.text;
        var element = new TypeDefinition(name, parent, declaration, this.checkDecorators(declaration.decorators, DecoratorFlags.NONE));
        parent.add(name, element); // reports
    }
    /** Initializes a variable statement. */
    initializeVariables(
    /** The statement to initialize. */
    statement, 
    /** Parent element, usually a file or namespace. */
    parent) {
        var declarations = statement.declarations;
        for (let i = 0, k = declarations.length; i < k; ++i) {
            let declaration = declarations[i];
            let name = declaration.name.text;
            let acceptedFlags = DecoratorFlags.GLOBAL | DecoratorFlags.LAZY;
            if (declaration.is(common_1.CommonFlags.DECLARE)) {
                acceptedFlags |= DecoratorFlags.EXTERNAL;
            }
            if (declaration.is(common_1.CommonFlags.CONST)) {
                acceptedFlags |= DecoratorFlags.INLINE;
            }
            let element = new Global(name, parent, this.checkDecorators(declaration.decorators, acceptedFlags), declaration);
            if (!parent.add(name, element))
                continue; // reports
        }
    }
}
exports.Program = Program;
/** Indicates the specific kind of an {@link Element}. */
var ElementKind;
(function (ElementKind) {
    /** A {@link Global}. */
    ElementKind[ElementKind["GLOBAL"] = 0] = "GLOBAL";
    /** A {@link Local}. */
    ElementKind[ElementKind["LOCAL"] = 1] = "LOCAL";
    /** An {@link Enum}. */
    ElementKind[ElementKind["ENUM"] = 2] = "ENUM";
    /** An {@link EnumValue}. */
    ElementKind[ElementKind["ENUMVALUE"] = 3] = "ENUMVALUE";
    /** A {@link FunctionPrototype}. */
    ElementKind[ElementKind["FUNCTION_PROTOTYPE"] = 4] = "FUNCTION_PROTOTYPE";
    /** A {@link Function}. */
    ElementKind[ElementKind["FUNCTION"] = 5] = "FUNCTION";
    /** A {@link FunctionTarget}. */
    ElementKind[ElementKind["FUNCTION_TARGET"] = 6] = "FUNCTION_TARGET";
    /** A {@link ClassPrototype}. */
    ElementKind[ElementKind["CLASS_PROTOTYPE"] = 7] = "CLASS_PROTOTYPE";
    /** A {@link Class}. */
    ElementKind[ElementKind["CLASS"] = 8] = "CLASS";
    /** An {@link InterfacePrototype}. */
    ElementKind[ElementKind["INTERFACE_PROTOTYPE"] = 9] = "INTERFACE_PROTOTYPE";
    /** An {@link Interface}. */
    ElementKind[ElementKind["INTERFACE"] = 10] = "INTERFACE";
    /** A {@link FieldPrototype}. */
    ElementKind[ElementKind["FIELD_PROTOTYPE"] = 11] = "FIELD_PROTOTYPE";
    /** A {@link Field}. */
    ElementKind[ElementKind["FIELD"] = 12] = "FIELD";
    /** A {@link PropertyPrototype}.  */
    ElementKind[ElementKind["PROPERTY_PROTOTYPE"] = 13] = "PROPERTY_PROTOTYPE";
    /** A {@link Property}. */
    ElementKind[ElementKind["PROPERTY"] = 14] = "PROPERTY";
    /** A {@link Namespace}. */
    ElementKind[ElementKind["NAMESPACE"] = 15] = "NAMESPACE";
    /** A {@link File}. */
    ElementKind[ElementKind["FILE"] = 16] = "FILE";
    /** A {@link TypeDefinition}.  */
    ElementKind[ElementKind["TYPEDEFINITION"] = 17] = "TYPEDEFINITION";
    /** An {@link IndexSignature}. */
    ElementKind[ElementKind["INDEXSIGNATURE"] = 18] = "INDEXSIGNATURE";
})(ElementKind = exports.ElementKind || (exports.ElementKind = {}));
/** Indicates built-in decorators that are present. */
var DecoratorFlags;
(function (DecoratorFlags) {
    /** No flags set. */
    DecoratorFlags[DecoratorFlags["NONE"] = 0] = "NONE";
    /** Is a program global. */
    DecoratorFlags[DecoratorFlags["GLOBAL"] = 1] = "GLOBAL";
    /** Is a binary operator overload. */
    DecoratorFlags[DecoratorFlags["OPERATOR_BINARY"] = 2] = "OPERATOR_BINARY";
    /** Is a unary prefix operator overload. */
    DecoratorFlags[DecoratorFlags["OPERATOR_PREFIX"] = 4] = "OPERATOR_PREFIX";
    /** Is a unary postfix operator overload. */
    DecoratorFlags[DecoratorFlags["OPERATOR_POSTFIX"] = 8] = "OPERATOR_POSTFIX";
    /** Is an unmanaged class. */
    DecoratorFlags[DecoratorFlags["UNMANAGED"] = 16] = "UNMANAGED";
    /** Is a sealed class. */
    DecoratorFlags[DecoratorFlags["SEALED"] = 32] = "SEALED";
    /** Is always inlined. */
    DecoratorFlags[DecoratorFlags["INLINE"] = 64] = "INLINE";
    /** Is using a different external name. */
    DecoratorFlags[DecoratorFlags["EXTERNAL"] = 128] = "EXTERNAL";
    /** Is a builtin. */
    DecoratorFlags[DecoratorFlags["BUILTIN"] = 256] = "BUILTIN";
    /** Is compiled lazily. */
    DecoratorFlags[DecoratorFlags["LAZY"] = 512] = "LAZY";
    /** Is considered unsafe code. */
    DecoratorFlags[DecoratorFlags["UNSAFE"] = 1024] = "UNSAFE";
})(DecoratorFlags = exports.DecoratorFlags || (exports.DecoratorFlags = {}));
(function (DecoratorFlags) {
    /** Translates a decorator kind to the respective decorator flag. */
    function fromKind(kind) {
        switch (kind) {
            case ast_1.DecoratorKind.GLOBAL: return DecoratorFlags.GLOBAL;
            case ast_1.DecoratorKind.OPERATOR:
            case ast_1.DecoratorKind.OPERATOR_BINARY: return DecoratorFlags.OPERATOR_BINARY;
            case ast_1.DecoratorKind.OPERATOR_PREFIX: return DecoratorFlags.OPERATOR_PREFIX;
            case ast_1.DecoratorKind.OPERATOR_POSTFIX: return DecoratorFlags.OPERATOR_POSTFIX;
            case ast_1.DecoratorKind.UNMANAGED: return DecoratorFlags.UNMANAGED;
            case ast_1.DecoratorKind.SEALED: return DecoratorFlags.SEALED;
            case ast_1.DecoratorKind.INLINE: return DecoratorFlags.INLINE;
            case ast_1.DecoratorKind.EXTERNAL: return DecoratorFlags.EXTERNAL;
            case ast_1.DecoratorKind.BUILTIN: return DecoratorFlags.BUILTIN;
            case ast_1.DecoratorKind.LAZY: return DecoratorFlags.LAZY;
            case ast_1.DecoratorKind.UNSAFE: return DecoratorFlags.UNSAFE;
            default: return DecoratorFlags.NONE;
        }
    }
    DecoratorFlags.fromKind = fromKind;
})(DecoratorFlags = exports.DecoratorFlags || (exports.DecoratorFlags = {}));
/** Base class of all program elements. */
class Element {
    /** Constructs a new program element. */
    constructor(
    /** Specific element kind. */
    kind, 
    /** Simple name. */
    name, 
    /** Internal name referring to this element. */
    internalName, 
    /** Containing {@link Program}. */
    program, 
    /** Parent element. */
    parent) {
        this.kind = kind;
        this.name = name;
        this.internalName = internalName;
        this.program = program;
        /** Common flags indicating specific traits. */
        this.flags = common_1.CommonFlags.NONE;
        /** Decorator flags indicating annotated traits. */
        this.decoratorFlags = DecoratorFlags.NONE;
        /** Member elements. */
        this.members = null;
        /** Shadowing type in type space, if any. */
        this.shadowType = null;
        this.program = program;
        this.name = name;
        this.internalName = internalName;
        if (parent) {
            this.parent = parent;
        }
        else {
            assert(this.kind == ElementKind.FILE);
            this.parent = this; // special case to keep this.parent non-nullable
        }
    }
    /** Gets the enclosing file. */
    get file() {
        var current = this;
        do
            if ((current = current.parent).kind == ElementKind.FILE)
                return current;
        while (true);
    }
    /** Tests if this element has a specific flag or flags. */
    is(flag) { return (this.flags & flag) == flag; }
    /** Tests if this element has any of the specified flags. */
    isAny(flags) { return (this.flags & flags) != 0; }
    /** Sets a specific flag or flags. */
    set(flag) { this.flags |= flag; }
    /** Unsets the specific flag or flags. */
    unset(flag) { this.flags &= ~flag; }
    /** Tests if this element has a specific decorator flag or flags. */
    hasDecorator(flag) { return (this.decoratorFlags & flag) == flag; }
    /** Looks up the element with the specified name within this element. */
    lookupInSelf(name) {
        var members = this.members;
        if (members && members.has(name))
            return members.get(name);
        return null;
    }
    /** Adds an element as a member of this one. Reports and returns `false` if a duplicate. */
    add(name, element) {
        var originalDeclaration = element.declaration;
        var members = this.members;
        if (!members)
            this.members = members = new Map();
        else if (members.has(name)) {
            let existing = members.get(name);
            if (existing.parent !== this) {
                // override non-own element
            }
            else {
                let merged = tryMerge(existing, element);
                if (merged) {
                    element = merged; // use merged element
                }
                else {
                    if (isDeclaredElement(existing.kind)) {
                        this.program.errorRelated(diagnostics_1.DiagnosticCode.Duplicate_identifier_0, element.identifierNode.range, existing.declaration.name.range, element.identifierNode.text);
                    }
                    else {
                        this.program.error(diagnostics_1.DiagnosticCode.Duplicate_identifier_0, element.identifierNode.range, element.identifierNode.text);
                    }
                    return false;
                }
            }
        }
        members.set(name, element);
        var program = this.program;
        if (element.kind != ElementKind.FUNCTION_PROTOTYPE || !element.isBound) {
            // prefer unbound prototypes in global lookup maps
            program.elementsByName.set(element.internalName, element);
            program.elementsByDeclaration.set(originalDeclaration, element);
        }
        return true;
    }
    /** Returns a string representation of this element. */
    toString() {
        return ElementKind[this.kind] + ":" + this.internalName;
    }
}
exports.Element = Element;
// Kinds of all declared elements
var declaredElements = new Set();
/** Tests if the specified element kind indicates a declared element. */
function isDeclaredElement(kind) {
    return declaredElements.has(kind);
}
exports.isDeclaredElement = isDeclaredElement;
/** Base class of elements with an associated declaration statement. */
class DeclaredElement extends Element {
    /** Constructs a new declared program element. */
    constructor(
    /** Specific element kind. */
    kind, 
    /** Simple name. */
    name, 
    /** Internal name referring to this element. */
    internalName, 
    /** Containing {@link Program}. */
    program, 
    /** Parent element. */
    parent, 
    /** Declaration reference. */
    declaration) {
        super(kind, name, internalName, program, parent);
        this.declaration = declaration;
        declaredElements.add(kind);
        // It is necessary to have access to identifiers of all members and exports
        // for reporting purposes and this is the lowest common denominator. Comes
        // at the expense of not having more specific type information in derived
        // classes, though. Instead, derived classes implement getters for other
        // important AST nodes directly through manual casting, allowing the resolver
        // etc. to not worry about actual declarations.
        this.declaration = declaration;
        this.flags = declaration.flags; // inherit
    }
    /** Tests if this element is a library element. */
    get isDeclaredInLibrary() {
        return this.declaration.range.source.isLibrary;
    }
    /** Gets the associated identifier node. */
    get identifierNode() {
        return this.declaration.name;
    }
    /** Gets the assiciated decorator nodes. */
    get decoratorNodes() {
        return this.declaration.decorators;
    }
}
exports.DeclaredElement = DeclaredElement;
// Kinds of all typed elements
var typedElements = new Set();
/** Checks if the specified element kind indicates a typed element. */
function isTypedElement(kind) {
    return typedElements.has(kind);
}
exports.isTypedElement = isTypedElement;
/** Base class of elements that can be resolved to a concrete type. */
class TypedElement extends DeclaredElement {
    constructor(
    /** Specific element kind. */
    kind, 
    /** Simple name. */
    name, 
    /** Internal name referring to this element. */
    internalName, 
    /** Containing {@link Program}. */
    program, 
    /** Parent element. */
    parent, 
    /** Declaration reference. */
    declaration) {
        super(kind, name, internalName, program, parent, declaration);
        /** Resolved type. Set once `is(RESOLVED)`, otherwise void. */
        this.type = types_1.Type.void;
        typedElements.add(kind);
    }
    /** Sets the resolved type of this element. */
    setType(type) {
        assert(!this.is(common_1.CommonFlags.RESOLVED));
        this.type = type;
        this.set(common_1.CommonFlags.RESOLVED);
    }
}
exports.TypedElement = TypedElement;
/** A file representing the implicit top-level namespace of a source. */
class File extends Element {
    /** Constructs a new file. */
    constructor(
    /** Program this file belongs to. */
    program, 
    /** Source of this file. */
    source) {
        super(ElementKind.FILE, source.normalizedPath, source.internalPath, program, null // special case for files
        );
        this.source = source;
        /** File exports. */
        this.exports = null;
        /** File re-exports. */
        this.exportsStar = null;
        this.source = source;
        assert(!program.filesByName.has(this.internalName));
        program.filesByName.set(this.internalName, this);
        var startFunction = this.program.makeNativeFunction("start:" + this.internalName, new types_1.Signature(program, null, types_1.Type.void), this);
        startFunction.internalName = startFunction.name;
        this.startFunction = startFunction;
    }
    /* @override */
    add(name, element, isImport = false) {
        if (element.hasDecorator(DecoratorFlags.GLOBAL)) {
            element = this.program.ensureGlobal(name, element); // possibly merged globally
        }
        if (!super.add(name, element))
            return false;
        element = assert(this.lookupInSelf(name)); // possibly merged locally
        if (element.is(common_1.CommonFlags.EXPORT) && !isImport) {
            this.ensureExport(element.name, element);
        }
        return true;
    }
    /* @override */
    lookupInSelf(name) {
        var element = super.lookupInSelf(name);
        if (element)
            return element;
        var exportsStar = this.exportsStar;
        if (exportsStar) {
            for (let i = 0, k = exportsStar.length; i < k; ++i) {
                if (element = exportsStar[i].lookupInSelf(name))
                    return element;
            }
        }
        return null;
    }
    /* @override */
    lookup(name) {
        var element = this.lookupInSelf(name);
        if (element)
            return element;
        return this.program.lookupGlobal(name);
    }
    /** Ensures that an element is an export of this file. */
    ensureExport(name, element) {
        var exports = this.exports;
        if (!exports)
            this.exports = exports = new Map();
        exports.set(name, element);
        if (this.source.sourceKind == ast_1.SourceKind.LIBRARY_ENTRY)
            this.program.ensureGlobal(name, element);
    }
    /** Ensures that another file is a re-export of this file. */
    ensureExportStar(file) {
        var exportsStar = this.exportsStar;
        if (!exportsStar)
            this.exportsStar = exportsStar = [];
        else if (exportsStar.includes(file))
            return;
        exportsStar.push(file);
    }
    /** Looks up the export of the specified name. */
    lookupExport(name) {
        var exports = this.exports;
        if (exports && exports.has(name))
            return exports.get(name);
        var exportsStar = this.exportsStar;
        if (exportsStar) {
            for (let i = 0, k = exportsStar.length; i < k; ++i) {
                let element = exportsStar[i].lookupExport(name);
                if (element)
                    return element;
            }
        }
        return null;
    }
    /** Creates an imported namespace from this file. */
    asImportedNamespace(name, parent) {
        var ns = new Namespace(name, parent, this.program.makeNativeNamespaceDeclaration(name));
        var exports = this.exports;
        if (exports) {
            for (let [memberName, member] of exports) {
                ns.add(memberName, member);
            }
        }
        return ns;
    }
}
exports.File = File;
/** A type definition. */
class TypeDefinition extends TypedElement {
    /** Constructs a new type definition. */
    constructor(
    /** Simple name. */
    name, 
    /** Parent element, usually a file or namespace. */
    parent, 
    /** Declaration reference. */
    declaration, 
    /** Pre-checked flags indicating built-in decorators. */
    decoratorFlags = DecoratorFlags.NONE) {
        super(ElementKind.TYPEDEFINITION, name, mangleInternalName(name, parent, false), parent.program, parent, declaration);
        this.decoratorFlags = decoratorFlags;
    }
    /** Gets the associated type parameter nodes. */
    get typeParameterNodes() {
        return this.declaration.typeParameters;
    }
    /** Gets the associated type node. */
    get typeNode() {
        return this.declaration.type;
    }
    /* @override */
    lookup(name) {
        return this.parent.lookup(name);
    }
}
exports.TypeDefinition = TypeDefinition;
/** A namespace that differs from a file in being user-declared with a name. */
class Namespace extends DeclaredElement {
    /** Constructs a new namespace. */
    constructor(
    /** Simple name. */
    name, 
    /** Parent element, usually a file or another namespace. */
    parent, 
    /** Declaration reference. */
    declaration, 
    /** Pre-checked flags indicating built-in decorators. */
    decoratorFlags = DecoratorFlags.NONE) {
        super(ElementKind.NAMESPACE, name, mangleInternalName(name, parent, false), parent.program, parent, declaration);
        this.decoratorFlags = decoratorFlags;
    }
    /* @override */
    lookup(name) {
        return this.lookupInSelf(name)
            || this.parent.lookup(name);
    }
}
exports.Namespace = Namespace;
/** An enum. */
class Enum extends TypedElement {
    /** Constructs a new enum. */
    constructor(
    /** Simple name. */
    name, 
    /** Parent element, usually a file or namespace. */
    parent, 
    /** Declaration reference. */
    declaration, 
    /** Pre-checked flags indicating built-in decorators. */
    decoratorFlags = DecoratorFlags.NONE) {
        super(ElementKind.ENUM, name, mangleInternalName(name, parent, false), parent.program, parent, declaration);
        this.decoratorFlags = decoratorFlags;
        this.setType(types_1.Type.i32);
    }
    /* @override */
    lookup(name) {
        return this.lookupInSelf(name)
            || this.parent.lookup(name);
    }
}
exports.Enum = Enum;
/** Indicates the kind of an inlined constant value. */
var ConstantValueKind;
(function (ConstantValueKind) {
    /** No constant value. */
    ConstantValueKind[ConstantValueKind["NONE"] = 0] = "NONE";
    /** Constant integer value. */
    ConstantValueKind[ConstantValueKind["INTEGER"] = 1] = "INTEGER";
    /** Constant float value. */
    ConstantValueKind[ConstantValueKind["FLOAT"] = 2] = "FLOAT";
})(ConstantValueKind = exports.ConstantValueKind || (exports.ConstantValueKind = {}));
/** Base class of all variable-like program elements. */
class VariableLikeElement extends TypedElement {
    /** Constructs a new variable-like element. */
    constructor(
    /** Specific element kind. */
    kind, 
    /** Simple name. */
    name, 
    /** Parent element, usually a file, namespace or class. */
    parent, 
    /** Declaration reference. Creates a native declaration if omitted. */
    declaration = parent.program.makeNativeVariableDeclaration(name)) {
        super(kind, name, mangleInternalName(name, parent, false), parent.program, parent, declaration);
        /** Constant value kind. */
        this.constantValueKind = 0 /* NONE */;
        this.flags = declaration.flags;
    }
    /** Gets the associated type node.s */
    get typeNode() {
        return this.declaration.type;
    }
    /** Gets the associated initializer node. */
    get initializerNode() {
        return this.declaration.initializer;
    }
    /** Applies a constant integer value to this element. */
    setConstantIntegerValue(value, type) {
        assert(type.is(4 /* INTEGER */));
        this.type = type;
        this.constantValueKind = 1 /* INTEGER */;
        this.constantIntegerValue = value;
        this.set(common_1.CommonFlags.CONST | common_1.CommonFlags.INLINED | common_1.CommonFlags.RESOLVED);
    }
    /** Applies a constant float value to this element. */
    setConstantFloatValue(value, type) {
        assert(type.is(8 /* FLOAT */));
        this.type = type;
        this.constantValueKind = 2 /* FLOAT */;
        this.constantFloatValue = value;
        this.set(common_1.CommonFlags.CONST | common_1.CommonFlags.INLINED | common_1.CommonFlags.RESOLVED);
    }
    /** @override */
    lookup(name) {
        return this.parent.lookup(name);
    }
}
exports.VariableLikeElement = VariableLikeElement;
/** An enum value. */
class EnumValue extends VariableLikeElement {
    /** Constructs a new enum value. */
    constructor(
    /** Simple name. */
    name, 
    /** Parent enum. */
    parent, 
    /** Declaration reference. */
    declaration, 
    /** Pre-checked flags indicating built-in decorators. */
    decoratorFlags = DecoratorFlags.NONE) {
        super(ElementKind.ENUMVALUE, name, parent, declaration);
        /** Whether this enum value is immutable. */
        this.isImmutable = false;
        this.decoratorFlags = decoratorFlags;
        this.setType(types_1.Type.i32);
    }
    /** Gets the associated value node. */
    get valueNode() {
        return this.declaration.value;
    }
    /* @override */
    lookup(name) {
        return this.parent.lookup(name);
    }
}
exports.EnumValue = EnumValue;
/** A global variable. */
class Global extends VariableLikeElement {
    /** Constructs a new global variable. */
    constructor(
    /** Simple name. */
    name, 
    /** Parent element, usually a file, namespace or static class. */
    parent, 
    /** Pre-checked flags indicating built-in decorators. */
    decoratorFlags, 
    /** Declaration reference. Creates a native declaration if omitted. */
    declaration = parent.program.makeNativeVariableDeclaration(name)) {
        super(ElementKind.GLOBAL, name, parent, declaration);
        this.decoratorFlags = decoratorFlags;
    }
}
exports.Global = Global;
/** A function parameter. */
class Parameter {
    /** Constructs a new function parameter. */
    constructor(
    /** Parameter name. */
    name, 
    /** Parameter type. */
    type, 
    /** Parameter initializer, if present. */
    initializer = null) {
        this.name = name;
        this.type = type;
        this.initializer = initializer;
    }
}
exports.Parameter = Parameter;
/** A local variable. */
class Local extends VariableLikeElement {
    /** Constructs a new local variable. */
    constructor(
    /** Simple name. */
    name, 
    /** Zero-based index within the enclosing function. `-1` indicates a virtual local. */
    index, 
    /** Resolved type. */
    type, 
    /** Parent function. */
    parent, 
    /** Declaration reference. */
    declaration = parent.program.makeNativeVariableDeclaration(name)) {
        super(ElementKind.LOCAL, name, parent, declaration);
        this.index = index;
        this.index = index;
        assert(type != types_1.Type.void);
        this.setType(type);
    }
}
exports.Local = Local;
/** A yet unresolved function prototype. */
class FunctionPrototype extends DeclaredElement {
    /** Constructs a new function prototype. */
    constructor(
    /** Simple name */
    name, 
    /** Parent element, usually a file, namespace or class (if a method). */
    parent, 
    /** Declaration reference. */
    declaration, 
    /** Pre-checked flags indicating built-in decorators. */
    decoratorFlags = DecoratorFlags.NONE) {
        super(ElementKind.FUNCTION_PROTOTYPE, name, mangleInternalName(name, parent, declaration.is(common_1.CommonFlags.INSTANCE)), parent.program, parent, declaration);
        /** Operator kind, if an overload. */
        this.operatorKind = OperatorKind.INVALID;
        /** Already resolved instances. */
        this.instances = null;
        /** Clones of this prototype that are bounds to specific classes. */
        this.boundPrototypes = null;
        this.decoratorFlags = decoratorFlags;
    }
    /** Gets the associated type parameter nodes. */
    get typeParameterNodes() {
        return this.declaration.typeParameters;
    }
    /** Gets the associated function type node. */
    get functionTypeNode() {
        return this.declaration.signature;
    }
    /** Gets the associated body node. */
    get bodyNode() {
        return this.declaration.body;
    }
    /** Gets the arrow function kind. */
    get arrowKind() {
        return this.declaration.arrowKind;
    }
    /** Tests if this prototype is bound to a class. */
    get isBound() {
        var parent = this.parent;
        return parent.kind == ElementKind.CLASS
            || parent.kind == ElementKind.PROPERTY_PROTOTYPE && parent.parent.kind == ElementKind.CLASS;
    }
    /** Creates a clone of this prototype that is bound to a concrete class instead. */
    toBound(classInstance) {
        assert(this.is(common_1.CommonFlags.INSTANCE));
        assert(!this.isBound);
        var boundPrototypes = this.boundPrototypes;
        if (!boundPrototypes)
            this.boundPrototypes = boundPrototypes = new Map();
        else if (boundPrototypes.has(classInstance))
            return boundPrototypes.get(classInstance);
        var declaration = this.declaration;
        assert(declaration.kind == ast_1.NodeKind.METHODDECLARATION);
        var bound = new FunctionPrototype(this.name, classInstance, // !
        declaration, this.decoratorFlags);
        bound.flags = this.flags;
        bound.operatorKind = this.operatorKind;
        // NOTE: this.instances holds instances per bound class / unbound
        boundPrototypes.set(classInstance, bound);
        return bound;
    }
    /** Gets the resolved instance for the specified instance key, if already resolved. */
    getResolvedInstance(instanceKey) {
        var instances = this.instances;
        if (instances && instances.has(instanceKey))
            return instances.get(instanceKey);
        return null;
    }
    /** Sets the resolved instance for the specified instance key. */
    setResolvedInstance(instanceKey, instance) {
        var instances = this.instances;
        if (!instances)
            this.instances = instances = new Map();
        else
            assert(!instances.has(instanceKey));
        instances.set(instanceKey, instance);
    }
    /* @override */
    lookup(name) {
        return this.parent.lookup(name);
    }
}
exports.FunctionPrototype = FunctionPrototype;
/** A resolved function. */
class Function extends TypedElement {
    /** Constructs a new concrete function. */
    constructor(
    /** Name incl. type parameters, i.e. `foo<i32>`. */
    nameInclTypeParameters, 
    /** Respective function prototype. */
    prototype, 
    /** Concrete signature. */
    signature, // pre-resolved
    /** Contextual type arguments inherited from its parent class, if any. */
    contextualTypeArguments = null) {
        super(ElementKind.FUNCTION, nameInclTypeParameters, mangleInternalName(nameInclTypeParameters, prototype.parent, prototype.is(common_1.CommonFlags.INSTANCE)), prototype.program, prototype.parent, prototype.declaration);
        /** Map of locals by name. */
        this.localsByName = new Map();
        /** Array of locals by index. */
        this.localsByIndex = [];
        /** List of additional non-parameter locals. */
        this.additionalLocals = [];
        /** Remembered debug locations. */
        this.debugLocations = [];
        /** Function reference, if compiled. */
        this.ref = 0;
        /** Function table index, if any. */
        this.functionTableIndex = -1;
        /** Trampoline function for calling with omitted arguments. */
        this.trampoline = null;
        /** Counting id of inline operations involving this function. */
        this.nextInlineId = 0;
        /** Counting id of anonymous inner functions. */
        this.nextAnonymousId = 0;
        /** Counting id of autorelease variables. */
        this.nextAutoreleaseId = 0;
        // used by flows to keep track of temporary locals
        this.tempI32s = null;
        this.tempI64s = null;
        this.tempF32s = null;
        this.tempF64s = null;
        this.tempV128s = null;
        this.tempAnyrefs = null;
        // used by flows to keep track of break labels
        this.nextBreakId = 0;
        this.breakStack = null;
        this.breakLabel = null;
        this.prototype = prototype;
        this.signature = signature;
        this.flags = prototype.flags | common_1.CommonFlags.RESOLVED;
        this.decoratorFlags = prototype.decoratorFlags;
        this.contextualTypeArguments = contextualTypeArguments;
        this.type = types_1.Type.u32.asFunction(signature);
        if (!prototype.is(common_1.CommonFlags.AMBIENT)) {
            let localIndex = 0;
            if (this.is(common_1.CommonFlags.INSTANCE)) {
                let local = new Local(common_1.CommonSymbols.this_, localIndex++, assert(signature.thisType), this);
                this.localsByName.set(common_1.CommonSymbols.this_, local);
                this.localsByIndex[local.index] = local;
            }
            let parameterTypes = signature.parameterTypes;
            for (let i = 0, k = parameterTypes.length; i < k; ++i) {
                let parameterType = parameterTypes[i];
                let parameterName = signature.getParameterName(i);
                let local = new Local(parameterName, localIndex++, parameterType, this);
                this.localsByName.set(parameterName, local);
                this.localsByIndex[local.index] = local;
            }
        }
        this.flow = flow_1.Flow.create(this);
        registerConcreteElement(this.program, this);
    }
    /** Adds a local of the specified type, with an optional name. */
    addLocal(type, name = null, declaration = null) {
        // if it has a name, check previously as this method will throw otherwise
        var localIndex = this.signature.parameterTypes.length + this.additionalLocals.length;
        if (this.is(common_1.CommonFlags.INSTANCE))
            ++localIndex;
        var localName = name !== null
            ? name
            : "var$" + localIndex.toString();
        var local = new Local(localName, localIndex, type, this, declaration || this.program.makeNativeVariableDeclaration(localName));
        if (name) {
            if (this.localsByName.has(name))
                throw new Error("duplicate local name");
            this.localsByName.set(name, local);
        }
        this.localsByIndex[local.index] = local;
        this.additionalLocals.push(type);
        return local;
    }
    /* @override */
    lookup(name) {
        var locals = this.localsByName;
        if (locals.has(name))
            return locals.get(name);
        return this.parent.lookup(name);
    }
    /** Finalizes the function once compiled, releasing no longer needed resources. */
    finalize(module, ref) {
        this.ref = ref;
        assert(!this.breakStack || !this.breakStack.length); // internal error
        this.breakStack = null;
        this.breakLabel = null;
        this.tempI32s = this.tempI64s = this.tempF32s = this.tempF64s = null;
        if (this.program.options.sourceMap) {
            let debugLocations = this.debugLocations;
            for (let i = 0, k = debugLocations.length; i < k; ++i) {
                let debugLocation = debugLocations[i];
                module.setDebugLocation(ref, debugLocation.debugInfoRef, debugLocation.source.debugInfoIndex, debugLocation.line, debugLocation.column);
            }
        }
    }
}
exports.Function = Function;
/** A resolved function target, that is a function called indirectly by an index and signature. */
class FunctionTarget extends Element {
    /** Constructs a new function target. */
    constructor(
    /** Concrete signature. */
    signature, 
    /** Program reference. */
    program, __s = "" // FIXME: current TS limitation workaround, but a fix seems underway
    ) {
        super(ElementKind.FUNCTION_TARGET, __s = "sig:" + signature.toSignatureString(), __s, program, program.nativeFile);
        this.signature = signature;
        this.flags = common_1.CommonFlags.RESOLVED;
        this.type = types_1.Type.u32.asFunction(signature);
    }
    /* @override */
    lookup(name) {
        return null;
    }
}
exports.FunctionTarget = FunctionTarget;
/** A yet unresolved instance field prototype. */
class FieldPrototype extends DeclaredElement {
    /** Constructs a new field prototype. */
    constructor(
    /** Simple name. */
    name, 
    /** Parent class. */
    parent, 
    /** Declaration reference. */
    declaration, 
    /** Pre-checked flags indicating built-in decorators. */
    decoratorFlags = DecoratorFlags.NONE) {
        super(ElementKind.FIELD_PROTOTYPE, name, mangleInternalName(name, parent, assert(declaration.is(common_1.CommonFlags.INSTANCE))), parent.program, parent, declaration);
        this.decoratorFlags = decoratorFlags;
    }
    /** Gets the associated type node. */
    get typeNode() {
        return this.declaration.type;
    }
    /** Gets the associated initializer node. */
    get initializerNode() {
        return this.declaration.initializer;
    }
    /** Gets the associated parameter index. Set if declared as a constructor parameter, otherwise `-1`. */
    get parameterIndex() {
        return this.declaration.parameterIndex;
    }
    /* @override */
    lookup(name) {
        return this.parent.lookup(name);
    }
}
exports.FieldPrototype = FieldPrototype;
/** A resolved instance field. */
class Field extends VariableLikeElement {
    /** Constructs a new field. */
    constructor(
    /** Respective field prototype. */
    prototype, 
    /** Parent class. */
    parent, 
    /** Concrete type. */
    type) {
        super(ElementKind.FIELD, prototype.name, parent, prototype.declaration);
        /** Field memory offset, if an instance field. */
        this.memoryOffset = -1;
        this.prototype = prototype;
        this.flags = prototype.flags;
        this.decoratorFlags = prototype.decoratorFlags;
        assert(type != types_1.Type.void);
        this.setType(type);
        registerConcreteElement(this.program, this);
    }
}
exports.Field = Field;
/** A property comprised of a getter and a setter function. */
class PropertyPrototype extends DeclaredElement {
    /** Constructs a new property prototype. */
    constructor(
    /** Simple name. */
    name, 
    /** Parent class. */
    parent, 
    /** Declaration of the getter or setter introducing the property. */
    firstDeclaration) {
        super(ElementKind.PROPERTY_PROTOTYPE, name, mangleInternalName(name, parent, firstDeclaration.is(common_1.CommonFlags.INSTANCE)), parent.program, parent, firstDeclaration);
        /** Getter prototype. */
        this.getterPrototype = null;
        /** Setter prototype. */
        this.setterPrototype = null;
        this.flags &= ~(common_1.CommonFlags.GET | common_1.CommonFlags.SET);
    }
    /* @override */
    lookup(name) {
        return this.parent.lookup(name);
    }
}
exports.PropertyPrototype = PropertyPrototype;
/** A resolved property. */
class Property extends VariableLikeElement {
    /** Constructs a new property prototype. */
    constructor(
    /** Respective property prototype. */
    prototype, 
    /** Parent element, usually a static class prototype or class instance. */
    parent) {
        super(ElementKind.PROPERTY, prototype.name, parent, prototype.program.makeNativeVariableDeclaration(prototype.name, prototype.is(common_1.CommonFlags.INSTANCE)
            ? common_1.CommonFlags.INSTANCE
            : common_1.CommonFlags.NONE));
        /** Getter instance. */
        this.getterInstance = null;
        /** Setter instance. */
        this.setterInstance = null;
        this.prototype = prototype;
        this.flags = prototype.flags;
        this.decoratorFlags = prototype.decoratorFlags;
        registerConcreteElement(this.program, this);
    }
    /* @override */
    lookup(name) {
        return this.parent.lookup(name);
    }
}
exports.Property = Property;
/** An resolved index signature. */
class IndexSignature extends VariableLikeElement {
    /** Constructs a new index prototype. */
    constructor(
    /** Parent class. */
    parent) {
        super(ElementKind.INDEXSIGNATURE, parent.internalName + "[]", parent);
    }
    /** Obtains the getter instance. */
    getGetterInstance(isUnchecked) {
        return this.parent.lookupOverload(OperatorKind.INDEXED_GET, isUnchecked);
    }
    /** Obtains the setter instance. */
    getSetterInstance(isUnchecked) {
        return this.parent.lookupOverload(OperatorKind.INDEXED_SET, isUnchecked);
    }
    /* @override */
    lookup(name) {
        return this.parent.lookup(name);
    }
}
exports.IndexSignature = IndexSignature;
/** A yet unresolved class prototype. */
class ClassPrototype extends DeclaredElement {
    constructor(
    /** Simple name. */
    name, 
    /** Parent element, usually a file or namespace. */
    parent, 
    /** Declaration reference. */
    declaration, 
    /** Pre-checked flags indicating built-in decorators. */
    decoratorFlags = DecoratorFlags.NONE, _isInterface = false // FIXME
    ) {
        super(_isInterface ? ElementKind.INTERFACE_PROTOTYPE : ElementKind.CLASS_PROTOTYPE, name, mangleInternalName(name, parent, declaration.is(common_1.CommonFlags.INSTANCE)), parent.program, parent, declaration);
        /** Instance member prototypes. */
        this.instanceMembers = null;
        /** Base class prototype, if applicable. */
        this.basePrototype = null; // set in Program#initialize
        /** Constructor prototype. */
        this.constructorPrototype = null;
        /** Operator overload prototypes. */
        this.overloadPrototypes = new Map();
        /** Already resolved instances. */
        this.instances = null;
        this.decoratorFlags = decoratorFlags;
    }
    /** Gets the associated type parameter nodes. */
    get typeParameterNodes() {
        return this.declaration.typeParameters;
    }
    /** Gets the associated extends node. */
    get extendsNode() {
        return this.declaration.extendsType;
    }
    /** Gets the associated implements nodes. */
    get implementsNodes() {
        return this.declaration.implementsTypes;
    }
    /** Tests if this prototype is of a builtin array type (Array/TypedArray). */
    get isBuiltinArray() {
        var arrayBufferViewInstance = this.program.arrayBufferViewInstance;
        return arrayBufferViewInstance !== null
            && this.extends(arrayBufferViewInstance.prototype);
    }
    /** Tests if this prototype extends the specified. */
    extends(basePtototype) {
        var current = this;
        do
            if (current === basePtototype)
                return true;
        while (current = current.basePrototype);
        return false;
    }
    /** Adds an element as an instance member of this one. Returns the previous element if a duplicate. */
    addInstance(name, element) {
        var originalDeclaration = element.declaration;
        var instanceMembers = this.instanceMembers;
        if (!instanceMembers)
            this.instanceMembers = instanceMembers = new Map();
        else if (instanceMembers.has(name)) {
            let existing = instanceMembers.get(name);
            let merged = tryMerge(existing, element);
            if (!merged) {
                if (isDeclaredElement(existing.kind)) {
                    this.program.errorRelated(diagnostics_1.DiagnosticCode.Duplicate_identifier_0, element.identifierNode.range, existing.declaration.name.range, element.identifierNode.text);
                }
                else {
                    this.program.error(diagnostics_1.DiagnosticCode.Duplicate_identifier_0, element.identifierNode.range, element.identifierNode.text);
                }
                return false;
            }
            element = merged;
        }
        instanceMembers.set(name, element);
        if (element.is(common_1.CommonFlags.EXPORT) && this.is(common_1.CommonFlags.MODULE_EXPORT)) {
            element.set(common_1.CommonFlags.MODULE_EXPORT); // propagate
        }
        this.program.elementsByDeclaration.set(originalDeclaration, element);
        return true;
    }
    /** Gets the resolved instance for the specified instance key, if already resolved. */
    getResolvedInstance(instanceKey) {
        var instances = this.instances;
        if (instances && instances.has(instanceKey))
            return instances.get(instanceKey);
        return null;
    }
    /** Sets the resolved instance for the specified instance key. */
    setResolvedInstance(instanceKey, instance) {
        var instances = this.instances;
        if (!instances)
            this.instances = instances = new Map();
        else
            assert(!instances.has(instanceKey));
        instances.set(instanceKey, instance);
    }
    /* @override */
    lookup(name) {
        return this.parent.lookup(name);
    }
}
exports.ClassPrototype = ClassPrototype;
var AcyclicState;
(function (AcyclicState) {
    AcyclicState[AcyclicState["UNKNOWN"] = 0] = "UNKNOWN";
    AcyclicState[AcyclicState["ACYCLIC"] = 1] = "ACYCLIC";
    AcyclicState[AcyclicState["NOT_ACYCLIC"] = 2] = "NOT_ACYCLIC";
})(AcyclicState || (AcyclicState = {}));
/** A resolved class. */
class Class extends TypedElement {
    /** Constructs a new class. */
    constructor(
    /** Name incl. type parameters, i.e. `Foo<i32>`. */
    nameInclTypeParameters, 
    /** The respective class prototype. */
    prototype, 
    /** Concrete type arguments, if any. */
    typeArguments = null, 
    /** Base class, if derived. */
    base = null, _isInterface = false // FIXME
    ) {
        super(_isInterface ? ElementKind.INTERFACE : ElementKind.CLASS, nameInclTypeParameters, mangleInternalName(nameInclTypeParameters, prototype.parent, prototype.is(common_1.CommonFlags.INSTANCE)), prototype.program, prototype.parent, prototype.declaration);
        /** Contextual type arguments for fields and methods. */
        this.contextualTypeArguments = null;
        /** Current member memory offset. */
        this.currentMemoryOffset = 0;
        /** Constructor instance. */
        this.constructorInstance = null;
        /** Operator overloads. */
        this.overloads = null;
        /** Index signature, if present. */
        this.indexSignature = null;
        /** Unique class id. */
        this._id = 0;
        /** Remembers acyclic state. */
        this._acyclic = 0 /* UNKNOWN */;
        /** Runtime type information flags. */
        this.rttiFlags = 0;
        /** Wrapped type, if a wrapper for a basic type. */
        this.wrappedType = null;
        var program = this.program;
        this.prototype = prototype;
        this.flags = prototype.flags;
        this.decoratorFlags = prototype.decoratorFlags;
        this.typeArguments = typeArguments;
        this.setType(program.options.usizeType.asClass(this));
        this.base = base;
        if (!this.hasDecorator(DecoratorFlags.UNMANAGED)) {
            let id = program.nextClassId++;
            this._id = id;
            program.managedClasses.set(id, this);
        }
        // inherit static members and contextual type arguments from base class
        if (base) {
            let inheritedTypeArguments = base.contextualTypeArguments;
            if (inheritedTypeArguments) {
                let contextualTypeArguments = this.contextualTypeArguments;
                for (let [baseName, baseType] of inheritedTypeArguments) {
                    if (!contextualTypeArguments)
                        this.contextualTypeArguments = contextualTypeArguments = new Map();
                    contextualTypeArguments.set(baseName, baseType);
                }
            }
        }
        // apply pre-checked instance-specific contextual type arguments
        var typeParameters = prototype.typeParameterNodes;
        if (typeArguments) {
            let numTypeArguments = typeArguments.length;
            if (!typeParameters || numTypeArguments != typeParameters.length) {
                throw new Error("type argument count mismatch");
            }
            if (numTypeArguments) {
                if (!this.contextualTypeArguments)
                    this.contextualTypeArguments = new Map();
                for (let i = 0; i < numTypeArguments; ++i) {
                    this.contextualTypeArguments.set(typeParameters[i].name.text, typeArguments[i]);
                }
            }
        }
        else if (typeParameters && typeParameters.length) {
            throw new Error("type argument count mismatch");
        }
        registerConcreteElement(program, this);
    }
    /** Gets the unique runtime id of this class. */
    get id() {
        return this._id; // unmanaged remains 0 (=ArrayBuffer)
    }
    /** Tests if this class is of a builtin array type (Array/TypedArray). */
    get isBuiltinArray() {
        return this.prototype.isBuiltinArray;
    }
    /** Tests if this class is array-like. */
    get isArrayLike() {
        if (this.isBuiltinArray)
            return true;
        var lengthField = this.lookupInSelf("length");
        return lengthField !== null && (lengthField.kind == ElementKind.FIELD ||
            (lengthField.kind == ElementKind.PROPERTY &&
                lengthField.getterInstance !== null // TODO: resolve & check type?
            )) && (this.lookupOverload(OperatorKind.INDEXED_GET) !== null ||
            this.lookupOverload(OperatorKind.UNCHECKED_INDEXED_GET) !== null);
    }
    /** Tests if a value of this class type is assignable to a target of the specified class type. */
    isAssignableTo(target) {
        var current = this;
        do
            if (current == target)
                return true;
        while (current = current.base);
        return false;
    }
    /** Looks up the operator overload of the specified kind. */
    lookupOverload(kind, unchecked = false) {
        if (unchecked) {
            switch (kind) {
                case OperatorKind.INDEXED_GET: {
                    let uncheckedOverload = this.lookupOverload(OperatorKind.UNCHECKED_INDEXED_GET);
                    if (uncheckedOverload)
                        return uncheckedOverload;
                    break;
                }
                case OperatorKind.INDEXED_SET: {
                    let uncheckedOverload = this.lookupOverload(OperatorKind.UNCHECKED_INDEXED_SET);
                    if (uncheckedOverload)
                        return uncheckedOverload;
                    break;
                }
                default: assert(false);
            }
        }
        var instance = this;
        do {
            let overloads = instance.overloads;
            if (overloads) {
                let overload = overloads.get(kind);
                if (overload)
                    return overload;
            }
        } while (instance = instance.base);
        return null;
    }
    /* @override */
    lookup(name) {
        return this.parent.lookup(name);
    }
    /** Calculates the memory offset of the specified field. */
    offsetof(fieldName) {
        var members = assert(this.members);
        assert(members.has(fieldName));
        var field = members.get(fieldName);
        assert(field.kind == ElementKind.FIELD);
        return field.memoryOffset;
    }
    /** Writes a field value to a buffer and returns the number of bytes written. */
    writeField(name, value, buffer, baseOffset) {
        var field = this.lookupInSelf(name);
        if (field && field.kind == ElementKind.FIELD) {
            let offset = baseOffset + field.memoryOffset;
            switch (field.type.kind) {
                case 0 /* I8 */:
                case 5 /* U8 */: {
                    util_1.writeI8(i32(value), buffer, offset);
                    return 1;
                }
                case 1 /* I16 */:
                case 6 /* U16 */: {
                    util_1.writeI16(i32(value), buffer, offset);
                    return 2;
                }
                case 2 /* I32 */:
                case 7 /* U32 */: {
                    util_1.writeI32(i32(value), buffer, offset);
                    return 4;
                }
                case 4 /* ISIZE */:
                case 9 /* USIZE */: {
                    assert(!this.program.options.isWasm64); // TODO
                    util_1.writeI32(i32(value), buffer, offset);
                    return 4;
                }
                case 11 /* F32 */: {
                    util_1.writeF32(f32(value), buffer, offset);
                    return 4;
                }
                case 12 /* F64 */: {
                    util_1.writeF64(f64(value), buffer, offset);
                    return 8;
                }
            }
        }
        assert(false);
        return 0;
    }
    /** Tests if this class extends the specified prototype. */
    extends(prototype) {
        return this.prototype.extends(prototype);
    }
    /** Gets the concrete type arguments to the specified extendend prototype. */
    getTypeArgumentsTo(extendedPrototype) {
        var current = this;
        do
            if (current.prototype === extendedPrototype)
                return current.typeArguments;
        while (current = current.base);
        return null;
    }
    /** Gets the value type of an array. Must be an array. */
    getArrayValueType() {
        var current = this;
        var program = this.program;
        var abvInstance = program.arrayBufferViewInstance;
        while (current.base !== abvInstance) {
            current = assert(current.base);
        }
        switch (current.prototype) {
            case program.i8ArrayPrototype: return types_1.Type.i8;
            case program.i16ArrayPrototype: return types_1.Type.i16;
            case program.i32ArrayPrototype: return types_1.Type.i32;
            case program.i64ArrayPrototype: return types_1.Type.i64;
            case program.u8ArrayPrototype:
            case program.u8ClampedArrayPrototype: return types_1.Type.u8;
            case program.u16ArrayPrototype: return types_1.Type.u16;
            case program.u32ArrayPrototype: return types_1.Type.u32;
            case program.u64ArrayPrototype: return types_1.Type.u64;
            case program.f32ArrayPrototype: return types_1.Type.f32;
            case program.f64ArrayPrototype: return types_1.Type.f64;
            case program.arrayPrototype: return assert(this.getTypeArgumentsTo(program.arrayPrototype))[0];
            default: assert(false);
        }
        return types_1.Type.void;
    }
    /** Tests if this class is inherently acyclic. */
    get isAcyclic() {
        var acyclic = this._acyclic;
        if (acyclic == 0 /* UNKNOWN */) {
            let hasCycle = this.cyclesTo(this);
            if (hasCycle)
                this._acyclic = acyclic = 2 /* NOT_ACYCLIC */;
            else
                this._acyclic = acyclic = 1 /* ACYCLIC */;
        }
        return acyclic == 1 /* ACYCLIC */;
    }
    /** Tests if this class potentially forms a reference cycle to another one. */
    cyclesTo(other, except = new Set()) {
        // TODO: The pure RC paper describes acyclic data structures as classes that may contain
        //
        // - scalars
        // - references to classes that are both acyclic and final (here: Java); and
        // - arrays (in our case: also sets, maps) of either of the above
        //
        // Our implementation, however, treats all objects that do not reference themselves directly
        // or indirectly as acylic, allowing them to contain inner cycles of other non-acyclic objects.
        // This contradicts the second assumption and must be revisited when actually implementing RC.
        if (except.has(this))
            return false;
        except.add(this); // don't recurse indefinitely
        // Find out if any field references 'other' directly or indirectly
        var current;
        var members = this.members;
        if (members) {
            for (let member of members.values()) {
                if (member.kind == ElementKind.FIELD) {
                    let type = member.type;
                    if (type.is(256 /* REFERENCE */)) {
                        if ((current = type.classReference) !== null && (current === other ||
                            current.cyclesTo(other, except)))
                            return true;
                    }
                }
            }
        }
        // Do the same for non-field data
        var basePrototype;
        // Array<T->other?>
        if ((basePrototype = this.program.arrayPrototype) && this.prototype.extends(basePrototype)) {
            let typeArguments = assert(this.getTypeArgumentsTo(basePrototype));
            assert(typeArguments.length == 1);
            if ((current = typeArguments[0].classReference) !== null &&
                (current === other ||
                    current.cyclesTo(other, except)))
                return true;
            // Set<K->other?>
        }
        else if ((basePrototype = this.program.setPrototype) && this.prototype.extends(basePrototype)) {
            let typeArguments = assert(this.getTypeArgumentsTo(basePrototype));
            assert(typeArguments.length == 1);
            if ((current = typeArguments[0].classReference) !== null &&
                (current === other ||
                    current.cyclesTo(other, except)))
                return true;
            // Map<K->other?,V->other?>
        }
        else if ((basePrototype = this.program.mapPrototype) && this.prototype.extends(basePrototype)) {
            let typeArguments = assert(this.getTypeArgumentsTo(basePrototype));
            assert(typeArguments.length == 2);
            if ((current = typeArguments[0].classReference) !== null &&
                (current === other ||
                    current.cyclesTo(other, except)))
                return true;
            if ((current = typeArguments[1].classReference) !== null &&
                (current === other ||
                    current.cyclesTo(other, except)))
                return true;
        }
        return false;
    }
}
exports.Class = Class;
/** A yet unresolved interface. */
class InterfacePrototype extends ClassPrototype {
    /** Constructs a new interface prototype. */
    constructor(name, parent, declaration, decoratorFlags) {
        super(name, parent, declaration, decoratorFlags, true);
    }
}
exports.InterfacePrototype = InterfacePrototype;
/** A resolved interface. */
class Interface extends Class {
    /** Constructs a new interface. */
    constructor(nameInclTypeParameters, prototype, typeArguments = [], base = null) {
        super(nameInclTypeParameters, prototype, typeArguments, base, true);
    }
}
exports.Interface = Interface;
/** Registers a concrete element with a program. */
function registerConcreteElement(program, element) {
    assert(!program.instancesByName.has(element.internalName));
    program.instancesByName.set(element.internalName, element);
}
/** Attempts to merge two elements. Returns the merged element on success. */
function tryMerge(older, newer) {
    // NOTE: some of the following cases are not supported by TS, not sure why exactly.
    // suggesting to just merge what seems to be possible for now and revisit later.
    assert(older.program === newer.program);
    assert(!newer.members);
    var merged = null;
    switch (older.kind) {
        case ElementKind.FUNCTION_PROTOTYPE: {
            switch (newer.kind) {
                case ElementKind.NAMESPACE: {
                    copyMembers(newer, older);
                    merged = older;
                    break;
                }
                case ElementKind.TYPEDEFINITION: {
                    if (!older.shadowType) {
                        older.shadowType = newer;
                        copyMembers(newer, older);
                        merged = older;
                    }
                    break;
                }
            }
            break;
        }
        case ElementKind.CLASS_PROTOTYPE:
        case ElementKind.ENUM: {
            if (newer.kind == ElementKind.NAMESPACE) {
                copyMembers(newer, older);
                merged = older;
                break;
            }
            break;
        }
        case ElementKind.NAMESPACE: {
            switch (newer.kind) {
                case ElementKind.ENUM:
                case ElementKind.CLASS_PROTOTYPE: // TS2434
                case ElementKind.FUNCTION_PROTOTYPE: { // TS2434
                    copyMembers(older, newer);
                    merged = newer;
                    break;
                }
                case ElementKind.NAMESPACE: {
                    copyMembers(newer, older);
                    merged = older;
                    break;
                }
                case ElementKind.TYPEDEFINITION: {
                    if (!older.shadowType) {
                        older.shadowType = newer;
                        copyMembers(newer, older);
                        merged = older;
                    }
                    break;
                }
            }
            break;
        }
        case ElementKind.GLOBAL: {
            if (newer.kind == ElementKind.TYPEDEFINITION) {
                if (!older.shadowType) {
                    older.shadowType = newer;
                    copyMembers(newer, older);
                    merged = older;
                }
            }
            break;
        }
        case ElementKind.TYPEDEFINITION: {
            switch (newer.kind) {
                case ElementKind.GLOBAL:
                case ElementKind.FUNCTION_PROTOTYPE:
                case ElementKind.NAMESPACE: {
                    if (!newer.shadowType) {
                        newer.shadowType = older;
                        copyMembers(older, newer);
                        merged = newer;
                    }
                    break;
                }
            }
            break;
        }
    }
    if (merged) {
        let olderIsExport = older.is(common_1.CommonFlags.EXPORT) || older.hasDecorator(DecoratorFlags.GLOBAL);
        let newerIsExport = newer.is(common_1.CommonFlags.EXPORT) || newer.hasDecorator(DecoratorFlags.GLOBAL);
        if (olderIsExport != newerIsExport) {
            older.program.error(diagnostics_1.DiagnosticCode.Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local, merged.identifierNode.range, merged.identifierNode.text);
        }
    }
    return merged;
}
/** Copies the members of `src` to `dest`. */
function copyMembers(src, dest) {
    var srcMembers = src.members;
    if (srcMembers) {
        let destMembers = dest.members;
        if (!destMembers)
            dest.members = destMembers = new Map();
        for (let [memberName, member] of srcMembers) {
            destMembers.set(memberName, member);
        }
    }
}
/** Mangles the internal name of an element with the specified name that is a child of the given parent. */
function mangleInternalName(name, parent, isInstance, asGlobal = false) {
    switch (parent.kind) {
        case ElementKind.FILE: {
            if (asGlobal)
                return name;
            return parent.internalName + common_1.PATH_DELIMITER + name;
        }
        case ElementKind.FUNCTION: {
            if (asGlobal)
                return name;
            assert(!isInstance);
            return parent.internalName + common_1.INNER_DELIMITER + name;
        }
        default: {
            return mangleInternalName(parent.name, parent.parent, parent.is(common_1.CommonFlags.INSTANCE), asGlobal)
                + (isInstance ? common_1.INSTANCE_DELIMITER : common_1.STATIC_DELIMITER) + name;
        }
    }
}
exports.mangleInternalName = mangleInternalName;


/***/ }),

/***/ "./src/resolver.ts":
/*!*************************!*\
  !*** ./src/resolver.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Resolve infrastructure to obtain types and elements.
 * @module resolver
 */ /***/
Object.defineProperty(exports, "__esModule", { value: true });
const diagnostics_1 = __webpack_require__(/*! ./diagnostics */ "./src/diagnostics.ts");
const program_1 = __webpack_require__(/*! ./program */ "./src/program.ts");
const ast_1 = __webpack_require__(/*! ./ast */ "./src/ast.ts");
const types_1 = __webpack_require__(/*! ./types */ "./src/types.ts");
const common_1 = __webpack_require__(/*! ./common */ "./src/common.ts");
const util_1 = __webpack_require__(/*! ./util */ "./src/util/index.ts");
const tokenizer_1 = __webpack_require__(/*! ./tokenizer */ "./src/tokenizer.ts");
const builtins_1 = __webpack_require__(/*! ./builtins */ "./src/builtins.ts");
/** Indicates whether errors are reported or not. */
var ReportMode;
(function (ReportMode) {
    /** Report errors. */
    ReportMode[ReportMode["REPORT"] = 0] = "REPORT";
    /** Swallow errors. */
    ReportMode[ReportMode["SWALLOW"] = 1] = "SWALLOW";
})(ReportMode = exports.ReportMode || (exports.ReportMode = {}));
/** Provides tools to resolve types and expressions. */
class Resolver extends diagnostics_1.DiagnosticEmitter {
    /** Constructs the resolver for the specified program. */
    constructor(
    /** The program to construct a resolver for. */
    program) {
        super(program.diagnostics);
        /** Target expression of the previously resolved property or element access. */
        this.currentThisExpression = null;
        /** Element expression of the previously resolved element access. */
        this.currentElementExpression = null;
        this.program = program;
    }
    // ====================================================== Types ======================================================
    /** Resolves a {@link TypeNode} to a concrete {@link Type}. */
    resolveType(
    /** The type to resolve. */
    node, 
    /** Contextual element. */
    ctxElement, 
    /** Contextual types, i.e. `T`. */
    ctxTypes = null, 
    /** How to proceed with eventual diagnostics. */
    reportMode = ReportMode.REPORT) {
        switch (node.kind) {
            case ast_1.NodeKind.NAMEDTYPE: {
                return this.resolveNamedType(node, ctxElement, ctxTypes, reportMode);
            }
            case ast_1.NodeKind.FUNCTIONTYPE: {
                return this.resolveFunctionType(node, ctxElement, ctxTypes, reportMode);
            }
            default: assert(false);
        }
        return null;
    }
    /** Resolves a {@link NamedTypeNode} to a concrete {@link Type}. */
    resolveNamedType(
    /** The type to resolve. */
    node, 
    /** Contextual element. */
    ctxElement, 
    /** Contextual types, i.e. `T`. */
    ctxTypes = null, 
    /** How to proceed with eventual diagnostics. */
    reportMode = ReportMode.REPORT) {
        var nameNode = node.name;
        var typeArgumentNodes = node.typeArguments;
        var isSimpleType = !nameNode.next;
        // Look up in contextual types if a simple type
        if (isSimpleType) {
            let simpleName = nameNode.identifier.text;
            if (ctxTypes !== null && ctxTypes.has(simpleName)) {
                let type = ctxTypes.get(simpleName);
                if (typeArgumentNodes !== null && typeArgumentNodes.length) {
                    if (reportMode == ReportMode.REPORT) {
                        this.error(diagnostics_1.DiagnosticCode.Type_0_is_not_generic, node.range, type.toString());
                    }
                }
                if (node.isNullable) {
                    if (type.is(256 /* REFERENCE */))
                        return type.asNullable();
                    if (reportMode == ReportMode.REPORT) {
                        this.error(diagnostics_1.DiagnosticCode.Basic_type_0_cannot_be_nullable, node.range, type.toString());
                    }
                }
                return type;
            }
        }
        // Look up in context
        var element = this.resolveTypeName(nameNode, ctxElement, reportMode);
        if (!element)
            return null;
        // Use shadow type if present (i.e. namespace sharing a type)
        if (element.shadowType) {
            element = element.shadowType;
        }
        else {
            // Handle enums (become i32)
            if (element.kind == program_1.ElementKind.ENUM) {
                if (typeArgumentNodes !== null && typeArgumentNodes.length) {
                    if (reportMode == ReportMode.REPORT) {
                        this.error(diagnostics_1.DiagnosticCode.Type_0_is_not_generic, node.range, element.internalName);
                    }
                }
                if (node.isNullable) {
                    if (reportMode == ReportMode.REPORT) {
                        this.error(diagnostics_1.DiagnosticCode.Basic_type_0_cannot_be_nullable, node.range, element.name + "/i32");
                    }
                }
                return types_1.Type.i32;
            }
            // Handle classes
            if (element.kind == program_1.ElementKind.CLASS_PROTOTYPE) {
                let instance = this.resolveClassInclTypeArguments(element, typeArgumentNodes, ctxElement, util_1.makeMap(ctxTypes), // don't inherit
                node, reportMode);
                if (!instance)
                    return null;
                return node.isNullable ? instance.type.asNullable() : instance.type;
            }
        }
        // Handle type definitions
        if (element.kind == program_1.ElementKind.TYPEDEFINITION) {
            // Shortcut already resolved (mostly builtins)
            if (element.is(common_1.CommonFlags.RESOLVED)) {
                if (typeArgumentNodes !== null && typeArgumentNodes.length) {
                    if (reportMode == ReportMode.REPORT) {
                        this.error(diagnostics_1.DiagnosticCode.Type_0_is_not_generic, node.range, element.internalName);
                    }
                }
                let type = element.type;
                if (node.isNullable) {
                    if (!type.is(256 /* REFERENCE */)) {
                        if (reportMode == ReportMode.REPORT) {
                            this.error(diagnostics_1.DiagnosticCode.Basic_type_0_cannot_be_nullable, nameNode.range, nameNode.identifier.text);
                        }
                    }
                    else {
                        return type.asNullable();
                    }
                }
                return type;
            }
            // Handle special built-in types
            if (isSimpleType) {
                switch (nameNode.identifier.symbol) {
                    case common_1.CommonSymbols.native: return this.resolveBuiltinNativeType(node, ctxElement, ctxTypes, reportMode);
                    case common_1.CommonSymbols.indexof: return this.resolveBuiltinIndexofType(node, ctxElement, ctxTypes, reportMode);
                    case common_1.CommonSymbols.valueof: return this.resolveBuiltinValueofType(node, ctxElement, ctxTypes, reportMode);
                    case common_1.CommonSymbols.returnof: return this.resolveBuiltinReturnTypeType(node, ctxElement, ctxTypes, reportMode);
                }
            }
            // Resolve normally
            let typeParameterNodes = element.typeParameterNodes;
            let typeArguments = null;
            if (typeParameterNodes) {
                typeArguments = this.resolveTypeArguments(typeParameterNodes, typeArgumentNodes, ctxElement, ctxTypes = util_1.makeMap(ctxTypes), // inherit
                node, reportMode);
                if (!typeArguments)
                    return null;
            }
            else if (typeArgumentNodes && typeArgumentNodes.length) {
                this.error(diagnostics_1.DiagnosticCode.Type_0_is_not_generic, node.range, nameNode.identifier.text);
            }
            let type = this.resolveType(element.typeNode, element, ctxTypes, reportMode);
            if (!type)
                return null;
            if (node.isNullable) {
                if (!type.is(256 /* REFERENCE */)) {
                    if (reportMode == ReportMode.REPORT) {
                        this.error(diagnostics_1.DiagnosticCode.Basic_type_0_cannot_be_nullable, nameNode.range, nameNode.identifier.text);
                    }
                }
                else {
                    return type.asNullable();
                }
            }
            return type;
        }
        if (reportMode == ReportMode.REPORT) {
            this.error(diagnostics_1.DiagnosticCode.Cannot_find_name_0, nameNode.range, nameNode.identifier.text);
        }
        return null;
    }
    /** Resolves a {@link FunctionTypeNode} to a concrete {@link Type}. */
    resolveFunctionType(
    /** The type to resolve. */
    node, 
    /** Contextual element. */
    ctxElement, 
    /** Contextual types, i.e. `T`. */
    ctxTypes = null, 
    /** How to proceed with eventual diagnostics. */
    reportMode = ReportMode.REPORT) {
        var explicitThisType = node.explicitThisType;
        var thisType = null;
        if (explicitThisType) {
            thisType = this.resolveType(explicitThisType, ctxElement, ctxTypes, reportMode);
            if (!thisType)
                return null;
        }
        var parameterNodes = node.parameters;
        var numParameters = parameterNodes.length;
        var parameterTypes = new Array(numParameters);
        var parameterNames = new Array(numParameters);
        var requiredParameters = 0;
        var hasRest = false;
        for (let i = 0; i < numParameters; ++i) {
            let parameterNode = parameterNodes[i];
            switch (parameterNode.parameterKind) {
                case ast_1.ParameterKind.DEFAULT: {
                    requiredParameters = i + 1;
                    break;
                }
                case ast_1.ParameterKind.REST: {
                    assert(i == numParameters);
                    hasRest = true;
                    break;
                }
            }
            let parameterTypeNode = parameterNode.type;
            if (ast_1.isTypeOmitted(parameterTypeNode)) {
                if (reportMode == ReportMode.REPORT) {
                    this.error(diagnostics_1.DiagnosticCode.Type_expected, parameterTypeNode.range);
                }
                return null;
            }
            let parameterType = this.resolveType(parameterTypeNode, ctxElement, ctxTypes, reportMode);
            if (!parameterType)
                return null;
            parameterTypes[i] = parameterType;
            parameterNames[i] = parameterNode.name.text;
        }
        var returnTypeNode = node.returnType;
        var returnType;
        if (ast_1.isTypeOmitted(returnTypeNode)) {
            if (reportMode == ReportMode.REPORT) {
                this.error(diagnostics_1.DiagnosticCode.Type_expected, returnTypeNode.range);
            }
            returnType = types_1.Type.void;
        }
        else {
            returnType = this.resolveType(returnTypeNode, ctxElement, ctxTypes, reportMode);
            if (!returnType)
                return null;
        }
        var signature = new types_1.Signature(this.program, parameterTypes, returnType, thisType);
        signature.parameterNames = parameterNames;
        signature.requiredParameters = requiredParameters;
        signature.hasRest = hasRest;
        return node.isNullable ? signature.type.asNullable() : signature.type;
    }
    resolveBuiltinNativeType(
    /** The type to resolve. */
    node, 
    /** Contextual element. */
    ctxElement, 
    /** Contextual types, i.e. `T`. */
    ctxTypes = null, 
    /** How to proceed with eventual diagnostics. */
    reportMode = ReportMode.REPORT) {
        var typeArgumentNodes = node.typeArguments;
        if (!(typeArgumentNodes && typeArgumentNodes.length == 1)) {
            if (reportMode == ReportMode.REPORT) {
                this.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, node.range, "1", (typeArgumentNodes ? typeArgumentNodes.length : 1).toString(10));
            }
            return null;
        }
        var typeArgument = this.resolveType(typeArgumentNodes[0], ctxElement, ctxTypes, reportMode);
        if (!typeArgument)
            return null;
        switch (typeArgument.kind) {
            case 0 /* I8 */:
            case 1 /* I16 */:
            case 2 /* I32 */: return types_1.Type.i32;
            case 4 /* ISIZE */: if (!this.program.options.isWasm64)
                return types_1.Type.i32;
            case 3 /* I64 */: return types_1.Type.i64;
            case 5 /* U8 */:
            case 6 /* U16 */:
            case 7 /* U32 */:
            case 10 /* BOOL */: return types_1.Type.u32;
            case 9 /* USIZE */: if (!this.program.options.isWasm64)
                return types_1.Type.u32;
            case 8 /* U64 */: return types_1.Type.u64;
            case 11 /* F32 */: return types_1.Type.f32;
            case 12 /* F64 */: return types_1.Type.f64;
            case 13 /* V128 */: return types_1.Type.v128;
            case 15 /* VOID */: return types_1.Type.void;
            default: assert(false);
        }
        return null;
    }
    resolveBuiltinIndexofType(
    /** The type to resolve. */
    node, 
    /** Contextual element. */
    ctxElement, 
    /** Contextual types, i.e. `T`. */
    ctxTypes = null, 
    /** How to proceed with eventual diagnostics. */
    reportMode = ReportMode.REPORT) {
        var typeArgumentNodes = node.typeArguments;
        if (!(typeArgumentNodes && typeArgumentNodes.length == 1)) {
            if (reportMode == ReportMode.REPORT) {
                this.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, node.range, "1", (typeArgumentNodes ? typeArgumentNodes.length : 1).toString(10));
            }
            return null;
        }
        var typeArgument = this.resolveType(typeArgumentNodes[0], ctxElement, ctxTypes, reportMode);
        if (!typeArgument)
            return null;
        var classReference = typeArgument.classReference;
        if (!classReference) {
            if (reportMode == ReportMode.REPORT) {
                this.error(diagnostics_1.DiagnosticCode.Index_signature_is_missing_in_type_0, typeArgumentNodes[0].range, typeArgument.toString());
            }
            return null;
        }
        var overload = classReference.lookupOverload(program_1.OperatorKind.INDEXED_GET);
        if (overload) {
            if (overload.is(common_1.CommonFlags.STATIC)) {
                assert(overload.signature.parameterTypes.length == 2);
                return overload.signature.parameterTypes[1];
            }
            else {
                assert(overload.signature.parameterTypes.length == 1);
                return overload.signature.parameterTypes[0];
            }
        }
        if (reportMode == ReportMode.REPORT) {
            this.error(diagnostics_1.DiagnosticCode.Index_signature_is_missing_in_type_0, typeArgumentNodes[0].range, typeArgument.toString());
        }
        return null;
    }
    resolveBuiltinValueofType(
    /** The type to resolve. */
    node, 
    /** Contextual element. */
    ctxElement, 
    /** Contextual types, i.e. `T`. */
    ctxTypes = null, 
    /** How to proceed with eventual diagnostics. */
    reportMode = ReportMode.REPORT) {
        var typeArgumentNodes = node.typeArguments;
        if (!(typeArgumentNodes && typeArgumentNodes.length == 1)) {
            if (reportMode == ReportMode.REPORT) {
                this.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, node.range, "1", (typeArgumentNodes ? typeArgumentNodes.length : 1).toString(10));
            }
            return null;
        }
        var typeArgument = this.resolveType(typeArgumentNodes[0], ctxElement, ctxTypes, reportMode);
        if (!typeArgument)
            return null;
        var classReference = typeArgument.classReference;
        if (!classReference) {
            if (reportMode == ReportMode.REPORT) {
                this.error(diagnostics_1.DiagnosticCode.Index_signature_is_missing_in_type_0, typeArgumentNodes[0].range, typeArgument.toString());
            }
            return null;
        }
        var overload = classReference.lookupOverload(program_1.OperatorKind.INDEXED_GET);
        if (overload)
            return overload.signature.returnType;
        if (reportMode == ReportMode.REPORT) {
            this.error(diagnostics_1.DiagnosticCode.Index_signature_is_missing_in_type_0, typeArgumentNodes[0].range, typeArgument.toString());
        }
        return null;
    }
    resolveBuiltinReturnTypeType(
    /** The type to resolve. */
    node, 
    /** Contextual element. */
    ctxElement, 
    /** Contextual types, i.e. `T`. */
    ctxTypes = null, 
    /** How to proceed with eventualy diagnostics. */
    reportMode = ReportMode.REPORT) {
        var typeArgumentNodes = node.typeArguments;
        if (!(typeArgumentNodes && typeArgumentNodes.length == 1)) {
            if (reportMode == ReportMode.REPORT) {
                this.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, node.range, "1", (typeArgumentNodes ? typeArgumentNodes.length : 1).toString(10));
            }
            return null;
        }
        var typeArgument = this.resolveType(typeArgumentNodes[0], ctxElement, ctxTypes, reportMode);
        if (!typeArgument)
            return null;
        var signatureReference = typeArgument.signatureReference;
        if (!signatureReference) {
            if (reportMode == ReportMode.REPORT) {
                this.error(diagnostics_1.DiagnosticCode.Type_0_has_no_call_signatures, typeArgumentNodes[0].range, typeArgument.toString());
            }
            return null;
        }
        return signatureReference.returnType;
    }
    /** Resolves a type name to the program element it refers to. */
    resolveTypeName(
    /** The type name to resolve. */
    node, 
    /** Contextual element. */
    ctxElement, 
    /** How to proceed with eventual diagnostics. */
    reportMode = ReportMode.REPORT) {
        var element = ctxElement.lookup(node.identifier.text);
        if (!element) {
            if (reportMode == ReportMode.REPORT) {
                this.error(diagnostics_1.DiagnosticCode.Cannot_find_name_0, node.range, node.identifier.text);
            }
            return null;
        }
        var prev = node;
        var next = node.next;
        while (next) {
            if (!(element = element.lookupInSelf(next.identifier.text))) {
                if (reportMode == ReportMode.REPORT) {
                    this.error(diagnostics_1.DiagnosticCode.Property_0_does_not_exist_on_type_1, next.range, next.identifier.text, prev.identifier.text);
                }
                return null;
            }
            prev = next;
            next = next.next;
        }
        return element;
    }
    /** Resolves an array of type arguments to concrete types. */
    resolveTypeArguments(
    /** Type parameter nodes present. */
    typeParameters, 
    /** Type argument nodes provided. */
    typeArgumentNodes, 
    /** Contextual element. */
    ctxElement, 
    /** Contextual types, i.e. `T`. */
    ctxTypes = util_1.makeMap(), 
    /** Alternative report node in case of empty type arguments. */
    alternativeReportNode = null, 
    /** How to proceed with eventual diagnostics. */
    reportMode = ReportMode.REPORT) {
        var minParameterCount = 0;
        var maxParameterCount = 0;
        for (let i = 0, k = typeParameters.length; i < k; ++i) {
            if (!typeParameters[i].defaultType)
                ++minParameterCount;
            ++maxParameterCount;
        }
        var argumentCount = typeArgumentNodes ? typeArgumentNodes.length : 0;
        if (argumentCount < minParameterCount || argumentCount > maxParameterCount) {
            this.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, argumentCount
                ? ast_1.Range.join(typeArgumentNodes[0].range, typeArgumentNodes[argumentCount - 1].range)
                : assert(alternativeReportNode).range, (argumentCount < minParameterCount ? minParameterCount : maxParameterCount).toString(10), argumentCount.toString(10));
            return null;
        }
        var typeArguments = new Array(maxParameterCount);
        for (let i = 0; i < maxParameterCount; ++i) {
            let type = i < argumentCount
                ? this.resolveType(// reports
                typeArgumentNodes[i], ctxElement, ctxTypes, reportMode)
                : this.resolveType(// reports
                assert(typeParameters[i].defaultType), ctxElement, ctxTypes, reportMode);
            if (!type)
                return null;
            // TODO: check extendsType
            ctxTypes.set(typeParameters[i].name.text, type);
            typeArguments[i] = type;
        }
        return typeArguments;
    }
    /** Resolves respectively infers the concrete instance of a function by call context. */
    maybeInferCall(node, prototype, ctxFlow, reportMode = ReportMode.REPORT) {
        var typeArguments = node.typeArguments;
        // resolve generic call if type arguments have been provided
        if (typeArguments) {
            if (!prototype.is(common_1.CommonFlags.GENERIC)) {
                if (reportMode == ReportMode.REPORT) {
                    this.error(diagnostics_1.DiagnosticCode.Type_0_is_not_generic, node.expression.range, prototype.internalName);
                }
                return null;
            }
            return this.resolveFunctionInclTypeArguments(prototype, node.typeArguments, ctxFlow.actualFunction, util_1.makeMap(ctxFlow.contextualTypeArguments), // don't inherit
            node, reportMode);
        }
        // infer generic call if type arguments have been omitted
        if (prototype.is(common_1.CommonFlags.GENERIC)) {
            let contextualTypeArguments = util_1.makeMap(ctxFlow.contextualTypeArguments);
            // fill up contextual types with auto for each generic component
            let typeParameterNodes = assert(prototype.typeParameterNodes);
            let numTypeParameters = typeParameterNodes.length;
            let typeParameterNames = new Set();
            for (let i = 0; i < numTypeParameters; ++i) {
                let name = typeParameterNodes[i].name.text;
                contextualTypeArguments.set(name, types_1.Type.auto);
                typeParameterNames.add(name);
            }
            let parameterNodes = prototype.functionTypeNode.parameters;
            let numParameters = parameterNodes.length;
            let argumentNodes = node.arguments;
            let numArguments = argumentNodes.length;
            // infer types with generic components while updating contextual types
            for (let i = 0; i < numParameters; ++i) {
                let argumentExpression = i < numArguments ? argumentNodes[i] : parameterNodes[i].initializer;
                if (!argumentExpression) { // missing initializer -> too few arguments
                    if (reportMode == ReportMode.REPORT) {
                        this.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, node.range, numParameters.toString(10), numArguments.toString(10));
                    }
                    return null;
                }
                let typeNode = parameterNodes[i].type;
                if (typeNode.hasGenericComponent(typeParameterNodes)) {
                    let type = this.resolveExpression(argumentExpression, ctxFlow, types_1.Type.auto, ReportMode.SWALLOW);
                    if (type)
                        this.propagateInferredGenericTypes(typeNode, type, ctxFlow, contextualTypeArguments, typeParameterNames);
                }
            }
            // apply concrete types to the generic function signature
            let resolvedTypeArguments = new Array(numTypeParameters);
            for (let i = 0; i < numTypeParameters; ++i) {
                let name = typeParameterNodes[i].name.text;
                if (contextualTypeArguments.has(name)) {
                    let inferredType = contextualTypeArguments.get(name);
                    if (inferredType != types_1.Type.auto) {
                        resolvedTypeArguments[i] = inferredType;
                        continue;
                    }
                }
                // unused template, e.g. `function test<T>(): void {...}` called as `test()`
                // invalid because the type is effectively unknown inside the function body
                if (reportMode == ReportMode.REPORT) {
                    this.error(diagnostics_1.DiagnosticCode.Type_argument_expected, node.expression.range.atEnd);
                }
                return null;
            }
            return this.resolveFunction(prototype, resolvedTypeArguments, util_1.makeMap(ctxFlow.contextualTypeArguments), reportMode);
        }
        // otherwise resolve the non-generic call as usual
        return this.resolveFunction(prototype, null, util_1.makeMap(), reportMode);
    }
    /** Updates contextual types with a possibly encapsulated inferred type. */
    propagateInferredGenericTypes(
    /** The inferred type node. */
    node, 
    /** The inferred type. */
    type, 
    /** Contextual flow. */
    ctxFlow, 
    /** Contextual types, i.e. `T`, with unknown types initialized to `auto`. */
    ctxTypes, 
    /** The names of the type parameters being inferred. */
    typeParameterNames) {
        if (node.kind == ast_1.NodeKind.NAMEDTYPE) {
            let typeArgumentNodes = node.typeArguments;
            if (typeArgumentNodes !== null && typeArgumentNodes.length) { // foo<T>(bar: Array<T>)
                let classReference = type.classReference;
                if (classReference) {
                    let classPrototype = this.resolveTypeName(node.name, ctxFlow.actualFunction);
                    if (!classPrototype || classPrototype.kind != program_1.ElementKind.CLASS_PROTOTYPE)
                        return;
                    if (classReference.prototype == classPrototype) {
                        let typeArguments = classReference.typeArguments;
                        if (typeArguments !== null && typeArguments.length == typeArgumentNodes.length) {
                            for (let i = 0, k = typeArguments.length; i < k; ++i) {
                                this.propagateInferredGenericTypes(typeArgumentNodes[i], typeArguments[i], ctxFlow, ctxTypes, typeParameterNames);
                            }
                            return;
                        }
                    }
                }
            }
            else { // foo<T>(bar: T)
                let name = node.name.identifier.text;
                if (ctxTypes.has(name)) {
                    let currentType = ctxTypes.get(name);
                    if (currentType == types_1.Type.auto || (typeParameterNames.has(name) && currentType.isAssignableTo(type))) {
                        ctxTypes.set(name, type);
                    }
                }
            }
        }
        else if (node.kind == ast_1.NodeKind.FUNCTIONTYPE) { // foo<T>(bar: (baz: T) => i32))
            let parameterNodes = node.parameters;
            if (parameterNodes !== null && parameterNodes.length) {
                let signatureReference = type.signatureReference;
                if (signatureReference) {
                    let parameterTypes = signatureReference.parameterTypes;
                    let thisType = signatureReference.thisType;
                    if (parameterTypes.length == parameterNodes.length && !thisType == !node.explicitThisType) {
                        for (let i = 0, k = parameterTypes.length; i < k; ++i) {
                            this.propagateInferredGenericTypes(parameterNodes[i].type, parameterTypes[i], ctxFlow, ctxTypes, typeParameterNames);
                        }
                        this.propagateInferredGenericTypes(node.returnType, signatureReference.returnType, ctxFlow, ctxTypes, typeParameterNames);
                        if (thisType)
                            this.propagateInferredGenericTypes(node.explicitThisType, thisType, ctxFlow, ctxTypes, typeParameterNames);
                        return;
                    }
                }
            }
        }
    }
    /** Gets the concrete type of an element. */
    getTypeOfElement(element) {
        var kind = element.kind;
        if (kind == program_1.ElementKind.GLOBAL) {
            if (!this.ensureResolvedLazyGlobal(element, ReportMode.SWALLOW))
                return null;
        }
        if (program_1.isTypedElement(kind)) {
            let type = element.type;
            assert(type != types_1.Type.void);
            let classReference = type.classReference;
            if (classReference) {
                let wrappedType = classReference.wrappedType;
                if (wrappedType)
                    type = wrappedType;
            }
            return type;
        }
        if (kind == program_1.ElementKind.FUNCTION_TARGET)
            return element.type;
        return null;
    }
    /** Gets the element of a concrete type. */
    getElementOfType(type) {
        if (type.is(256 /* REFERENCE */)) {
            let classReference = type.classReference;
            if (classReference)
                return classReference;
            let signatureReference = assert(type.signatureReference);
            return signatureReference.asFunctionTarget(this.program);
        }
        else if (type != types_1.Type.void) {
            let wrapperClasses = this.program.wrapperClasses;
            assert(wrapperClasses.has(type));
            return wrapperClasses.get(type);
        }
        return null;
    }
    // =================================================== Expressions ===================================================
    /** Looks up the program element the specified expression refers to. */
    lookupExpression(
    /** The expression to look up. */
    node, 
    /** Contextual flow. */
    ctxFlow, 
    /** Contextual type. */
    ctxType = types_1.Type.auto, 
    /** How to proceed with eventual diagnostics. */
    reportMode = ReportMode.REPORT) {
        while (node.kind == ast_1.NodeKind.PARENTHESIZED) { // skip
            node = node.expression;
        }
        switch (node.kind) {
            case ast_1.NodeKind.ASSERTION: {
                return this.lookupAssertionExpression(node, ctxFlow, ctxType, reportMode);
            }
            case ast_1.NodeKind.BINARY: {
                return this.lookupBinaryExpression(node, ctxFlow, ctxType, reportMode);
            }
            case ast_1.NodeKind.CALL: {
                return this.lookupCallExpression(node, ctxFlow, ctxType, reportMode);
            }
            case ast_1.NodeKind.COMMA: {
                return this.lookupCommaExpression(node, ctxFlow, ctxType, reportMode);
            }
            case ast_1.NodeKind.ELEMENTACCESS: {
                return this.lookupElementAccessExpression(node, ctxFlow, ctxType, reportMode);
            }
            case ast_1.NodeKind.FUNCTION: {
                return this.lookupFunctionExpression(node, ctxFlow, ctxType, reportMode);
            }
            case ast_1.NodeKind.IDENTIFIER:
            case ast_1.NodeKind.FALSE:
            case ast_1.NodeKind.NULL:
            case ast_1.NodeKind.TRUE: {
                return this.lookupIdentifierExpression(node, ctxFlow, ctxFlow.actualFunction, reportMode);
            }
            case ast_1.NodeKind.THIS: {
                return this.lookupThisExpression(node, ctxFlow, ctxType, reportMode);
            }
            case ast_1.NodeKind.SUPER: {
                return this.lookupSuperExpression(node, ctxFlow, ctxType, reportMode);
            }
            case ast_1.NodeKind.INSTANCEOF: {
                return this.lookupInstanceOfExpression(node, ctxFlow, ctxType, reportMode);
            }
            case ast_1.NodeKind.LITERAL: {
                return this.lookupLiteralExpression(node, ctxFlow, ctxType, reportMode);
            }
            case ast_1.NodeKind.NEW: {
                return this.lookupNewExpression(node, ctxFlow, ctxType, reportMode);
            }
            case ast_1.NodeKind.PROPERTYACCESS: {
                return this.lookupPropertyAccessExpression(node, ctxFlow, ctxType, reportMode);
            }
            case ast_1.NodeKind.TERNARY: {
                return this.lookupTernaryExpression(node, ctxFlow, ctxType, reportMode);
            }
            case ast_1.NodeKind.UNARYPOSTFIX: {
                return this.lookupUnaryPostfixExpression(node, ctxFlow, ctxType, reportMode);
            }
            case ast_1.NodeKind.UNARYPREFIX: {
                return this.lookupUnaryPrefixExpression(node, ctxFlow, ctxType, reportMode);
            }
        }
        if (reportMode == ReportMode.REPORT) {
            this.error(diagnostics_1.DiagnosticCode.Not_implemented, node.range);
        }
        return null;
    }
    /** Resolves an expression to its static type. */
    resolveExpression(
    /** The expression to resolve. */
    node, 
    /** Contextual flow. */
    ctxFlow, 
    /** Contextual type. */
    ctxType = types_1.Type.auto, 
    /** How to proceed with eventual diagnostics. */
    reportMode = ReportMode.REPORT) {
        while (node.kind == ast_1.NodeKind.PARENTHESIZED) { // skip
            node = node.expression;
        }
        switch (node.kind) {
            case ast_1.NodeKind.ASSERTION: {
                return this.resolveAssertionExpression(node, ctxFlow, ctxType, reportMode);
            }
            case ast_1.NodeKind.BINARY: {
                return this.resolveBinaryExpression(node, ctxFlow, ctxType, reportMode);
            }
            case ast_1.NodeKind.CALL: {
                return this.resolveCallExpression(node, ctxFlow, ctxType, reportMode);
            }
            case ast_1.NodeKind.COMMA: {
                return this.resolveCommaExpression(node, ctxFlow, ctxType, reportMode);
            }
            case ast_1.NodeKind.ELEMENTACCESS: {
                return this.resolveElementAccessExpression(node, ctxFlow, ctxType, reportMode);
            }
            case ast_1.NodeKind.FUNCTION: {
                return this.resolveFunctionExpression(node, ctxFlow, ctxType, reportMode);
            }
            case ast_1.NodeKind.IDENTIFIER:
            case ast_1.NodeKind.FALSE:
            case ast_1.NodeKind.NULL:
            case ast_1.NodeKind.TRUE: {
                return this.resolveIdentifierExpression(node, ctxFlow, ctxType, ctxFlow.actualFunction, reportMode);
            }
            case ast_1.NodeKind.THIS: {
                return this.resolveThisExpression(node, ctxFlow, ctxType, reportMode);
            }
            case ast_1.NodeKind.SUPER: {
                return this.resolveSuperExpression(node, ctxFlow, ctxType, reportMode);
            }
            case ast_1.NodeKind.INSTANCEOF: {
                return this.resolveInstanceOfExpression(node, ctxFlow, ctxType, reportMode);
            }
            case ast_1.NodeKind.LITERAL: {
                return this.resolveLiteralExpression(node, ctxFlow, ctxType, reportMode);
            }
            case ast_1.NodeKind.NEW: {
                return this.resolveNewExpression(node, ctxFlow, ctxType, reportMode);
            }
            case ast_1.NodeKind.PROPERTYACCESS: {
                return this.resolvePropertyAccessExpression(node, ctxFlow, ctxType, reportMode);
            }
            case ast_1.NodeKind.TERNARY: {
                return this.resolveTernaryExpression(node, ctxFlow, ctxType, reportMode);
            }
            case ast_1.NodeKind.UNARYPOSTFIX: {
                return this.resolveUnaryPostfixExpression(node, ctxFlow, ctxType, reportMode);
            }
            case ast_1.NodeKind.UNARYPREFIX: {
                return this.resolveUnaryPrefixExpression(node, ctxFlow, ctxType, reportMode);
            }
        }
        if (reportMode == ReportMode.REPORT) {
            this.error(diagnostics_1.DiagnosticCode.Not_implemented, node.range);
        }
        return null;
    }
    /** Looks up the program element the specified identifier expression refers to. */
    lookupIdentifierExpression(
    /** The expression to look up. */
    node, 
    /** Flow to search for scoped locals. */
    ctxFlow, 
    /** Element to search. */
    ctxElement = ctxFlow.actualFunction, // differs for enums and namespaces
    /** How to proceed with eventual diagnostics. */
    reportMode = ReportMode.REPORT) {
        switch (node.kind) {
            case ast_1.NodeKind.TRUE:
            case ast_1.NodeKind.FALSE:
            case ast_1.NodeKind.NULL: {
                let type = this.resolveIdentifierExpression(node, ctxFlow, types_1.Type.auto, ctxElement, reportMode);
                return type ? this.getElementOfType(type) : null;
            }
        }
        var name = node.text;
        var element;
        if (element = ctxFlow.lookup(name)) {
            this.currentThisExpression = null;
            this.currentElementExpression = null;
            return element;
        }
        if (element = ctxElement.lookup(name)) {
            this.currentThisExpression = null;
            this.currentElementExpression = null;
            return element;
        }
        if (element = this.program.lookupGlobal(name)) {
            this.currentThisExpression = null;
            this.currentElementExpression = null;
            return element;
        }
        if (reportMode == ReportMode.REPORT) {
            this.error(diagnostics_1.DiagnosticCode.Cannot_find_name_0, node.range, name);
        }
        return null;
    }
    /** Resolves an identifier to its static type. */
    resolveIdentifierExpression(
    /** The expression to resolve. */
    node, 
    /** Flow to search for scoped locals. */
    ctxFlow, 
    /** Contextual type. */
    ctxType = types_1.Type.auto, 
    /** Element to search. */
    ctxElement = ctxFlow.actualFunction, // differs for enums and namespaces
    /** How to proceed with eventual diagnostics. */
    reportMode = ReportMode.REPORT) {
        switch (node.kind) {
            case ast_1.NodeKind.TRUE:
            case ast_1.NodeKind.FALSE: return types_1.Type.bool;
            case ast_1.NodeKind.NULL: {
                let classReference = ctxType.classReference;
                return ctxType.is(256 /* REFERENCE */) && classReference !== null
                    ? classReference.type.asNullable()
                    : this.program.options.usizeType; // TODO: anyref context?
            }
        }
        var element = this.lookupIdentifierExpression(node, ctxFlow, ctxElement, reportMode);
        if (!element)
            return null;
        if (element.kind == program_1.ElementKind.FUNCTION_PROTOTYPE) {
            let instance = this.resolveFunction(element, null, util_1.makeMap(), reportMode);
            if (!instance)
                return null;
            element = instance;
        }
        var type = this.getTypeOfElement(element);
        if (!type) {
            if (reportMode == ReportMode.REPORT) {
                this.error(diagnostics_1.DiagnosticCode.Expression_cannot_be_represented_by_a_type, node.range);
            }
        }
        return type;
    }
    /** Resolves a lazily compiled global, i.e. a static class field or annotated `@lazy`. */
    ensureResolvedLazyGlobal(global, reportMode = ReportMode.REPORT) {
        if (global.is(common_1.CommonFlags.RESOLVED))
            return true;
        var type;
        var typeNode = global.typeNode;
        if (typeNode) {
            type = this.resolveType(typeNode, global.parent, null, reportMode);
        }
        else {
            type = this.resolveExpression(assert(global.initializerNode), global.file.startFunction.flow, types_1.Type.auto, reportMode);
        }
        if (!type)
            return false;
        global.setType(type); // also sets resolved
        return true;
    }
    /** Looks up the program element the specified property access expression refers to. */
    lookupPropertyAccessExpression(
    /** The expression to look up. */
    node, 
    /** Contextual flow. */
    ctxFlow, 
    /** Contextual type. */
    ctxType, 
    /** How to proceed with eventual diagnostics. */
    reportMode = ReportMode.REPORT) {
        var targetNode = node.expression;
        var target = this.lookupExpression(targetNode, ctxFlow, ctxType, reportMode); // reports
        if (!target)
            return null;
        var propertyName = node.property.text;
        // Resolve variable-likes to their class type first
        switch (target.kind) {
            case program_1.ElementKind.GLOBAL: if (!this.ensureResolvedLazyGlobal(target, reportMode))
                return null;
            case program_1.ElementKind.ENUMVALUE:
            case program_1.ElementKind.LOCAL:
            case program_1.ElementKind.FIELD: { // someVar.prop
                let type = target.type;
                assert(type != types_1.Type.void);
                let classReference = type.classReference;
                if (!classReference) {
                    let wrapperClasses = this.program.wrapperClasses;
                    if (wrapperClasses.has(type)) {
                        classReference = wrapperClasses.get(type);
                    }
                    else {
                        if (reportMode == ReportMode.REPORT) {
                            this.error(diagnostics_1.DiagnosticCode.Property_0_does_not_exist_on_type_1, node.property.range, propertyName, target.type.toString());
                        }
                        return null;
                    }
                }
                target = classReference;
                break;
            }
            case program_1.ElementKind.PROPERTY_PROTOTYPE: { // SomeClass.prop
                let getterInstance = this.resolveFunction(// reports
                assert(target.getterPrototype), // must have a getter
                null, util_1.makeMap(), reportMode);
                if (!getterInstance)
                    return null;
                let type = getterInstance.signature.returnType;
                let classReference = type.classReference;
                if (!classReference) {
                    let wrapperClasses = this.program.wrapperClasses;
                    if (wrapperClasses.has(type)) {
                        classReference = wrapperClasses.get(type);
                    }
                    else {
                        if (reportMode == ReportMode.REPORT) {
                            this.error(diagnostics_1.DiagnosticCode.Property_0_does_not_exist_on_type_1, node.property.range, propertyName, type.toString());
                        }
                        return null;
                    }
                }
                target = classReference;
                break;
            }
            case program_1.ElementKind.PROPERTY: { // someInstance.prop
                let getterInstance = assert(target.getterInstance); // must have a getter
                let type = getterInstance.signature.returnType;
                let classReference = type.classReference;
                if (!classReference) {
                    let wrapperClasses = this.program.wrapperClasses;
                    if (wrapperClasses.has(type)) {
                        classReference = wrapperClasses.get(type);
                    }
                    else {
                        if (reportMode == ReportMode.REPORT) {
                            this.error(diagnostics_1.DiagnosticCode.Property_0_does_not_exist_on_type_1, node.property.range, propertyName, type.toString());
                        }
                        return null;
                    }
                }
                target = classReference;
                break;
            }
            case program_1.ElementKind.INDEXSIGNATURE: { // someInstance[x].prop
                let elementExpression = assert(this.currentElementExpression);
                let parent = target.parent;
                assert(parent.kind == program_1.ElementKind.CLASS);
                let indexedGet = parent.lookupOverload(program_1.OperatorKind.INDEXED_GET);
                if (!indexedGet) {
                    if (reportMode == ReportMode.REPORT) {
                        this.error(diagnostics_1.DiagnosticCode.Index_signature_is_missing_in_type_0, elementExpression.range, parent.internalName);
                    }
                    return null;
                }
                let returnType = indexedGet.signature.returnType;
                let classReference = returnType.classReference;
                if (!classReference) {
                    let wrapperClasses = this.program.wrapperClasses;
                    if (wrapperClasses.has(returnType)) {
                        classReference = wrapperClasses.get(returnType);
                    }
                    else {
                        if (reportMode == ReportMode.REPORT) {
                            this.error(diagnostics_1.DiagnosticCode.Property_0_does_not_exist_on_type_1, node.property.range, propertyName, returnType.toString());
                        }
                        return null;
                    }
                }
                target = classReference;
                break;
            }
            case program_1.ElementKind.FUNCTION_PROTOTYPE: { // function Symbol() + type Symbol = _Symbol
                let shadowType = target.shadowType;
                if (shadowType) {
                    if (!shadowType.is(common_1.CommonFlags.RESOLVED)) {
                        let resolvedType = this.resolveType(shadowType.typeNode, shadowType.parent, null, reportMode);
                        if (resolvedType)
                            shadowType.setType(resolvedType);
                    }
                    let classReference = shadowType.type.classReference;
                    if (classReference)
                        target = classReference.prototype;
                    break;
                }
            }
        }
        // Look up the member within
        switch (target.kind) {
            case program_1.ElementKind.CLASS_PROTOTYPE:
            case program_1.ElementKind.CLASS: {
                do {
                    let members = target.members;
                    if (members && members.has(propertyName)) {
                        this.currentThisExpression = targetNode;
                        this.currentElementExpression = null;
                        return members.get(propertyName); // instance FIELD, static GLOBAL, FUNCTION_PROTOTYPE...
                    }
                    // traverse inherited static members on the base prototype if target is a class prototype
                    if (target.kind == program_1.ElementKind.CLASS_PROTOTYPE) {
                        if (target.basePrototype) {
                            target = target.basePrototype;
                        }
                        else {
                            break;
                        }
                        // traverse inherited instance members on the base class if target is a class instance
                    }
                    else if (target.kind == program_1.ElementKind.CLASS) {
                        if (target.base) {
                            target = target.base;
                        }
                        else {
                            break;
                        }
                    }
                    else {
                        break;
                    }
                } while (true);
                break;
            }
            default: { // enums or other namespace-like elements
                let members = target.members;
                if (members && members.has(propertyName)) {
                    this.currentThisExpression = targetNode;
                    this.currentElementExpression = null;
                    return members.get(propertyName); // static ENUMVALUE, static GLOBAL, static FUNCTION_PROTOTYPE...
                }
                break;
            }
        }
        if (reportMode == ReportMode.REPORT) {
            this.error(diagnostics_1.DiagnosticCode.Property_0_does_not_exist_on_type_1, node.property.range, propertyName, target.internalName);
        }
        return null;
    }
    /** Resolves a property access expression to its static type. */
    resolvePropertyAccessExpression(
    /** The expression to resolve. */
    node, 
    /** Contextual flow. */
    ctxFlow, 
    /** Contextual type. */
    ctxType, 
    /** How to proceed with eventual diagnostics. */
    reportMode = ReportMode.REPORT) {
        var element = this.lookupPropertyAccessExpression(node, ctxFlow, ctxType, reportMode);
        if (!element)
            return null;
        var type = this.getTypeOfElement(element);
        if (!type) {
            if (reportMode == ReportMode.REPORT) {
                this.error(diagnostics_1.DiagnosticCode.Expression_cannot_be_represented_by_a_type, node.range);
            }
        }
        return type;
    }
    /** Looks up the program element the specified element access expression refers to. */
    lookupElementAccessExpression(
    /** The expression to look up. */
    node, 
    /** Contextual flow. */
    ctxFlow, 
    /** Contextual type. */
    ctxType, 
    /** How to proceed with eventual diagnostics. */
    reportMode = ReportMode.REPORT) {
        var targetExpression = node.expression;
        var targetType = this.resolveExpression(targetExpression, ctxFlow, ctxType, reportMode);
        if (!targetType)
            return null;
        if (targetType.is(256 /* REFERENCE */)) {
            let classReference = targetType.classReference;
            if (classReference) {
                let indexSignature = classReference.indexSignature;
                if (indexSignature) {
                    this.currentThisExpression = targetExpression;
                    this.currentElementExpression = node.elementExpression;
                    return indexSignature;
                }
            }
        }
        if (reportMode == ReportMode.REPORT) {
            this.error(diagnostics_1.DiagnosticCode.Index_signature_is_missing_in_type_0, targetExpression.range, targetType.toString());
        }
        return null;
    }
    /** Resolves an element access expression to its static type. */
    resolveElementAccessExpression(
    /** The expression to resolve. */
    node, 
    /** Contextual flow. */
    ctxFlow, 
    /** Contextual type. */
    ctxType, 
    /** How to proceed with eventual diagnostics. */
    reportMode = ReportMode.REPORT) {
        var element = this.lookupElementAccessExpression(node, ctxFlow, ctxType, reportMode);
        if (!element)
            return null;
        var type = this.getTypeOfElement(element);
        if (!type) {
            if (reportMode == ReportMode.REPORT) {
                this.error(diagnostics_1.DiagnosticCode.Expression_cannot_be_represented_by_a_type, node.range);
            }
        }
        return type;
    }
    /** Determines the final type of an integer literal given the specified contextual type. */
    determineIntegerLiteralType(
    /** Integer literal value. */
    intValue, 
    /** Contextual type. */
    ctxType) {
        if (!ctxType.is(256 /* REFERENCE */)) {
            // compile to contextual type if matching
            switch (ctxType.kind) {
                case 0 /* I8 */: {
                    if (i64_is_i8(intValue))
                        return types_1.Type.i8;
                    break;
                }
                case 5 /* U8 */: {
                    if (i64_is_u8(intValue))
                        return types_1.Type.u8;
                    break;
                }
                case 1 /* I16 */: {
                    if (i64_is_i16(intValue))
                        return types_1.Type.i16;
                    break;
                }
                case 6 /* U16 */: {
                    if (i64_is_u16(intValue))
                        return types_1.Type.u16;
                    break;
                }
                case 2 /* I32 */: {
                    if (i64_is_i32(intValue))
                        return types_1.Type.i32;
                    break;
                }
                case 7 /* U32 */: {
                    if (i64_is_u32(intValue))
                        return types_1.Type.u32;
                    break;
                }
                case 10 /* BOOL */: {
                    if (i64_is_bool(intValue))
                        return types_1.Type.bool;
                    break;
                }
                case 4 /* ISIZE */: {
                    if (!this.program.options.isWasm64) {
                        if (i64_is_i32(intValue))
                            return types_1.Type.isize32;
                        break;
                    }
                    return types_1.Type.isize64;
                }
                case 9 /* USIZE */: {
                    if (!this.program.options.isWasm64) {
                        if (i64_is_u32(intValue))
                            return types_1.Type.usize32;
                        break;
                    }
                    return types_1.Type.usize64;
                }
                case 3 /* I64 */: return types_1.Type.i64;
                case 8 /* U64 */: return types_1.Type.u64;
                case 11 /* F32 */: return types_1.Type.f32;
                case 12 /* F64 */: return types_1.Type.f64;
            }
        }
        // otherwise compile to best fitting native type
        if (i64_is_i32(intValue))
            return types_1.Type.i32;
        if (i64_is_u32(intValue))
            return types_1.Type.u32;
        return types_1.Type.i64; // TODO: u64 if positive and larger than i64?
    }
    /** Looks up the program element the specified assertion expression refers to. */
    lookupAssertionExpression(
    /** The expression to look up. */
    node, 
    /** Contextual flow. */
    ctxFlow, 
    /** Contextual type. */
    ctxType = types_1.Type.auto, 
    /** How to proceed with eventual diagnostics. */
    reportMode = ReportMode.REPORT) {
        if (node.assertionKind == ast_1.AssertionKind.NONNULL) {
            return this.lookupExpression(node.expression, ctxFlow, ctxType, reportMode);
        }
        var type = this.resolveType(assert(node.toType), // must be set if not NONNULL
        ctxFlow.actualFunction, ctxFlow.contextualTypeArguments, reportMode);
        if (!type)
            return null;
        var element = this.getElementOfType(type);
        if (element)
            return element;
        if (reportMode == ReportMode.REPORT) {
            this.error(diagnostics_1.DiagnosticCode.Type_0_is_illegal_in_this_context, node.range, type.toString());
        }
        this.currentThisExpression = null;
        this.currentElementExpression = null;
        return null;
    }
    /** Resolves an assertion expression to its static type. */
    resolveAssertionExpression(
    /** The expression to resolve. */
    node, 
    /** Contextual flow. */
    ctxFlow, 
    /** Contextual type. */
    ctxType = types_1.Type.auto, 
    /** How to proceed with eventual diagnostics. */
    reportMode = ReportMode.REPORT) {
        if (node.assertionKind == ast_1.AssertionKind.NONNULL) {
            let type = this.resolveExpression(node.expression, ctxFlow, ctxType, reportMode);
            return type ? type.nonNullableType : null;
        }
        return this.resolveType(assert(node.toType), // must be set if not NONNULL
        ctxFlow.actualFunction, ctxFlow.contextualTypeArguments, reportMode);
    }
    /** Looks up the program element the specified unary prefix expression refers to. */
    lookupUnaryPrefixExpression(
    /** The expression to look up. */
    node, 
    /** Contextual flow. */
    ctxFlow, 
    /** Contextual type. */
    ctxType = types_1.Type.auto, 
    /** How to proceed with eventual diagnostics. */
    reportMode = ReportMode.REPORT) {
        var type = this.resolveUnaryPrefixExpression(node, ctxFlow, ctxType, reportMode);
        if (!type)
            return null;
        var element = this.getElementOfType(type);
        if (!element) {
            if (reportMode == ReportMode.REPORT) {
                this.error(diagnostics_1.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1, node.range, tokenizer_1.operatorTokenToString(node.operator), type.toString());
            }
        }
        return element;
    }
    /** Resolves an unary prefix expression to its static type. */
    resolveUnaryPrefixExpression(
    /** The expression to resolve. */
    node, 
    /** Contextual flow. */
    ctxFlow, 
    /** Contextual type. */
    ctxType = types_1.Type.auto, 
    /** How to proceed with eventual diagnostics. */
    reportMode = ReportMode.REPORT) {
        var operand = node.operand;
        var operator = node.operator;
        switch (operator) {
            case tokenizer_1.Token.MINUS: {
                // implicitly negate if an integer literal to distinguish between i32/u32/i64
                if (operand.kind == ast_1.NodeKind.LITERAL && operand.literalKind == ast_1.LiteralKind.INTEGER) {
                    return this.determineIntegerLiteralType(i64_sub(i64_zero, operand.value), ctxType);
                }
                // fall-through
            }
            case tokenizer_1.Token.PLUS:
            case tokenizer_1.Token.PLUS_PLUS:
            case tokenizer_1.Token.MINUS_MINUS: {
                let type = this.resolveExpression(operand, ctxFlow, ctxType, reportMode);
                if (!type)
                    return null;
                if (type.is(256 /* REFERENCE */)) {
                    let classReference = type.classReference;
                    if (classReference) {
                        let overload = classReference.lookupOverload(program_1.OperatorKind.fromUnaryPrefixToken(operator));
                        if (overload)
                            return overload.signature.returnType;
                        let wrappedType = classReference.wrappedType;
                        if (wrappedType)
                            type = wrappedType;
                    }
                }
                if (!type.isAny(8 /* FLOAT */ | 4 /* INTEGER */) || type.is(256 /* REFERENCE */)) {
                    if (reportMode == ReportMode.REPORT) {
                        this.error(diagnostics_1.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1, node.range, tokenizer_1.operatorTokenToString(operator), type.toString());
                    }
                    return null;
                }
                return type;
            }
            case tokenizer_1.Token.EXCLAMATION: {
                let type = this.resolveExpression(operand, ctxFlow, ctxType, reportMode);
                if (!type)
                    return null;
                if (type.is(256 /* REFERENCE */)) {
                    let classReference = type.classReference;
                    if (classReference) {
                        let overload = classReference.lookupOverload(program_1.OperatorKind.NOT);
                        if (overload)
                            return overload.signature.returnType;
                    }
                }
                return types_1.Type.bool; // incl. references
            }
            case tokenizer_1.Token.TILDE: {
                let type = this.resolveExpression(operand, ctxFlow, ctxType, reportMode);
                if (!type)
                    return null;
                if (type.is(256 /* REFERENCE */)) {
                    let classReference = type.classReference;
                    if (classReference) {
                        let overload = classReference.lookupOverload(program_1.OperatorKind.BITWISE_NOT);
                        if (overload)
                            return overload.signature.returnType;
                    }
                }
                if (!type.isAny(8 /* FLOAT */ | 4 /* INTEGER */) || !type.is(128 /* VALUE */)) {
                    if (reportMode == ReportMode.REPORT) {
                        this.error(diagnostics_1.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1, node.range, "~", type.toString());
                    }
                    return null;
                }
                return type.intType;
            }
            default: assert(false);
        }
        return null;
    }
    /** Looks up the program element the specified unary postfix expression refers to. */
    lookupUnaryPostfixExpression(
    /** The expression to resolve. */
    node, 
    /** Contextual flow. */
    ctxFlow, 
    /** Contextual type. */
    ctxType = types_1.Type.auto, 
    /** How to proceed with eventual diagnostics. */
    reportMode = ReportMode.REPORT) {
        var type = this.resolveUnaryPostfixExpression(node, ctxFlow, ctxType, reportMode);
        if (!type)
            return null;
        var element = this.getElementOfType(type);
        if (!element) {
            if (reportMode == ReportMode.REPORT) {
                this.error(diagnostics_1.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1, node.range, tokenizer_1.operatorTokenToString(node.operator), type.toString());
            }
        }
        return element;
    }
    /** Resolves an unary postfix expression to its static type. */
    resolveUnaryPostfixExpression(
    /** The expression to resolve. */
    node, 
    /** Contextual flow. */
    ctxFlow, 
    /** Contextual type. */
    ctxType = types_1.Type.auto, 
    /** How to proceed with eventual diagnostics. */
    reportMode = ReportMode.REPORT) {
        var operator = node.operator;
        switch (operator) {
            case tokenizer_1.Token.PLUS_PLUS:
            case tokenizer_1.Token.MINUS_MINUS: {
                let type = this.resolveExpression(node.operand, ctxFlow, ctxType, reportMode);
                if (!type)
                    return null;
                if (type.is(256 /* REFERENCE */)) {
                    let classReference = type.classReference;
                    if (classReference) {
                        let overload = classReference.lookupOverload(program_1.OperatorKind.fromUnaryPostfixToken(operator));
                        if (overload)
                            return overload.signature.returnType;
                    }
                }
                if (!type.isAny(4 /* INTEGER */ | 8 /* FLOAT */) || !type.is(128 /* VALUE */)) {
                    if (reportMode == ReportMode.REPORT) {
                        this.error(diagnostics_1.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1, node.range, tokenizer_1.operatorTokenToString(operator), type.toString());
                    }
                    return null;
                }
                return type;
            }
        }
        if (reportMode == ReportMode.REPORT) {
            this.error(diagnostics_1.DiagnosticCode.Not_implemented, node.range);
        }
        return null;
    }
    /** Looks up the program element the specified binary expression refers to. */
    lookupBinaryExpression(
    /** The expression to look up. */
    node, 
    /** Contextual flow. */
    ctxFlow, 
    /** Contextual type. */
    ctxType = types_1.Type.auto, 
    /** How to proceed with eventual diagnostics. */
    reportMode = ReportMode.REPORT) {
        var type = this.resolveBinaryExpression(node, ctxFlow, ctxType, reportMode);
        if (!type)
            return null;
        var element = this.getElementOfType(type);
        if (element)
            return element; // otherwise void
        if (reportMode == ReportMode.REPORT) {
            this.error(diagnostics_1.DiagnosticCode.Type_0_is_illegal_in_this_context, node.range, type.toString());
        }
        return null;
    }
    /** Resolves a binary expression to its static type. */
    resolveBinaryExpression(
    /** The expression to resolve. */
    node, 
    /** Contextual flow. */
    ctxFlow, 
    /** Contextual type. */
    ctxType = types_1.Type.auto, 
    /** How to proceed with eventual diagnostics. */
    reportMode = ReportMode.REPORT) {
        var left = node.left;
        var right = node.right;
        var operator = node.operator;
        switch (operator) {
            // assignment: result is the target's type
            case tokenizer_1.Token.EQUALS:
            case tokenizer_1.Token.PLUS_EQUALS:
            case tokenizer_1.Token.MINUS_EQUALS:
            case tokenizer_1.Token.ASTERISK_EQUALS:
            case tokenizer_1.Token.ASTERISK_ASTERISK_EQUALS:
            case tokenizer_1.Token.SLASH_EQUALS:
            case tokenizer_1.Token.PERCENT_EQUALS:
            case tokenizer_1.Token.LESSTHAN_LESSTHAN_EQUALS:
            case tokenizer_1.Token.GREATERTHAN_GREATERTHAN_EQUALS:
            case tokenizer_1.Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS:
            case tokenizer_1.Token.AMPERSAND_EQUALS:
            case tokenizer_1.Token.BAR_EQUALS:
            case tokenizer_1.Token.CARET_EQUALS: {
                return this.resolveExpression(left, ctxFlow, ctxType, reportMode);
            }
            // comparison: result is Bool, preferring overloads, integer/float only
            case tokenizer_1.Token.LESSTHAN:
            case tokenizer_1.Token.GREATERTHAN:
            case tokenizer_1.Token.LESSTHAN_EQUALS:
            case tokenizer_1.Token.GREATERTHAN_EQUALS: {
                let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);
                if (!leftType)
                    return null;
                if (leftType.is(256 /* REFERENCE */)) {
                    let classReference = leftType.classReference;
                    if (classReference) {
                        let overload = classReference.lookupOverload(program_1.OperatorKind.fromBinaryToken(operator));
                        if (overload)
                            return overload.signature.returnType;
                    }
                }
                if (!leftType.isAny(4 /* INTEGER */ | 8 /* FLOAT */) || leftType.is(256 /* REFERENCE */)) {
                    if (reportMode == ReportMode.REPORT) {
                        this.error(diagnostics_1.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1, node.range, tokenizer_1.operatorTokenToString(operator), leftType.toString());
                    }
                    return null;
                }
                return types_1.Type.bool;
            }
            // equality: result is Bool, preferring overloads, incl. references
            case tokenizer_1.Token.EQUALS_EQUALS:
            case tokenizer_1.Token.EXCLAMATION_EQUALS: {
                let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);
                if (!leftType)
                    return null;
                if (leftType.is(256 /* REFERENCE */)) {
                    let classReference = leftType.classReference;
                    if (classReference) {
                        let overload = classReference.lookupOverload(program_1.OperatorKind.fromBinaryToken(operator));
                        if (overload)
                            return overload.signature.returnType;
                    }
                }
                return types_1.Type.bool;
            }
            // identity: result is Bool, not supporting overloads
            case tokenizer_1.Token.EQUALS_EQUALS_EQUALS:
            case tokenizer_1.Token.EXCLAMATION_EQUALS_EQUALS: {
                return types_1.Type.bool;
            }
            // arithmetics: result is common type of LHS and RHS, preferring overloads
            case tokenizer_1.Token.PLUS:
            case tokenizer_1.Token.MINUS:
            case tokenizer_1.Token.ASTERISK:
            case tokenizer_1.Token.SLASH:
            case tokenizer_1.Token.PERCENT: { // mod has special logic, but also behaves like this
                let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);
                if (!leftType)
                    return null;
                if (leftType.is(256 /* REFERENCE */)) {
                    let classReference = leftType.classReference;
                    if (classReference) {
                        let overload = classReference.lookupOverload(program_1.OperatorKind.fromBinaryToken(operator));
                        if (overload)
                            return overload.signature.returnType;
                    }
                }
                let rightType = this.resolveExpression(right, ctxFlow, leftType, reportMode);
                if (!rightType)
                    return null;
                let commonType = types_1.Type.commonDenominator(leftType, rightType, false);
                if (!commonType) {
                    if (reportMode == ReportMode.REPORT) {
                        this.error(diagnostics_1.DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2, node.range, leftType.toString(), rightType.toString());
                    }
                }
                return commonType;
            }
            // pow: result is f32 if LHS is f32, otherwise f64, preferring overloads
            case tokenizer_1.Token.ASTERISK_ASTERISK: {
                let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);
                if (!leftType)
                    return null;
                if (leftType.is(256 /* REFERENCE */)) {
                    let classReference = leftType.classReference;
                    if (classReference) {
                        let overload = classReference.lookupOverload(program_1.OperatorKind.POW);
                        if (overload)
                            return overload.signature.returnType;
                    }
                }
                return leftType == types_1.Type.f32 ? types_1.Type.f32 : types_1.Type.f64;
            }
            // shift: result is LHS (RHS is converted to LHS), preferring overloads
            case tokenizer_1.Token.LESSTHAN_LESSTHAN:
            case tokenizer_1.Token.GREATERTHAN_GREATERTHAN:
            case tokenizer_1.Token.GREATERTHAN_GREATERTHAN_GREATERTHAN: {
                let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);
                if (!leftType)
                    return null;
                if (leftType.is(256 /* REFERENCE */)) {
                    let classReference = leftType.classReference;
                    if (classReference) {
                        let overload = classReference.lookupOverload(program_1.OperatorKind.fromBinaryToken(operator));
                        if (overload)
                            return overload.signature.returnType;
                    }
                }
                if (!leftType.is(4 /* INTEGER */) || leftType.is(256 /* REFERENCE */)) {
                    if (reportMode == ReportMode.REPORT) {
                        this.error(diagnostics_1.DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1, node.range, tokenizer_1.operatorTokenToString(operator), leftType.toString());
                    }
                    return null;
                }
                return leftType;
            }
            // bitwise: result is common type of LHS and RHS with floats not being supported, preferring overloads
            case tokenizer_1.Token.AMPERSAND:
            case tokenizer_1.Token.BAR:
            case tokenizer_1.Token.CARET: {
                let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);
                if (!leftType)
                    return null;
                if (leftType.is(256 /* REFERENCE */)) {
                    let classReference = leftType.classReference;
                    if (classReference) {
                        let overload = classReference.lookupOverload(program_1.OperatorKind.fromBinaryToken(operator));
                        if (overload)
                            return overload.signature.returnType;
                    }
                }
                let rightType = this.resolveExpression(right, ctxFlow, ctxType, reportMode);
                if (!rightType)
                    return null;
                let commonType = types_1.Type.commonDenominator(leftType, rightType, false);
                if (!commonType || !commonType.is(4 /* INTEGER */) || commonType.is(256 /* REFERENCE */)) {
                    if (reportMode == ReportMode.REPORT) {
                        this.error(diagnostics_1.DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2, node.range, tokenizer_1.operatorTokenToString(operator), leftType.toString(), rightType.toString());
                    }
                }
                return commonType;
            }
            // logical: result is LHS (RHS is converted to LHS), not supporting overloads
            case tokenizer_1.Token.AMPERSAND_AMPERSAND:
            case tokenizer_1.Token.BAR_BAR: {
                return this.resolveExpression(left, ctxFlow, ctxType, reportMode);
            }
        }
        if (reportMode == ReportMode.REPORT) {
            this.error(diagnostics_1.DiagnosticCode.Not_implemented, node.range);
        }
        return null;
    }
    /** Looks up the program element the specified this expression refers to. */
    lookupThisExpression(
    /** The expression to look up. */
    node, 
    /** Contextual flow. */
    ctxFlow, 
    /** Contextual type. */
    ctxType = types_1.Type.auto, 
    /** How to proceed with eventual diagnostics. */
    reportMode = ReportMode.REPORT) {
        if (ctxFlow.is(32768 /* INLINE_CONTEXT */)) {
            let thisLocal = ctxFlow.lookupLocal(common_1.CommonSymbols.this_);
            if (thisLocal) {
                this.currentThisExpression = null;
                this.currentElementExpression = null;
                return thisLocal;
            }
        }
        var parent = ctxFlow.actualFunction.parent;
        if (parent) {
            this.currentThisExpression = null;
            this.currentElementExpression = null;
            return parent;
        }
        if (reportMode == ReportMode.REPORT) {
            this.error(diagnostics_1.DiagnosticCode._this_cannot_be_referenced_in_current_location, node.range);
        }
        return null;
    }
    /** Resolves a this expression to its static type. */
    resolveThisExpression(
    /** The expression to resolve. */
    node, 
    /** Contextual flow. */
    ctxFlow, 
    /** Contextual type. */
    ctxType = types_1.Type.auto, 
    /** How to proceed with eventual diagnostics. */
    reportMode = ReportMode.REPORT) {
        var element = this.lookupThisExpression(node, ctxFlow, ctxType, reportMode);
        if (!element)
            return null;
        var type = this.getTypeOfElement(element);
        if (!type) {
            if (reportMode == ReportMode.REPORT) {
                this.error(diagnostics_1.DiagnosticCode.Expression_cannot_be_represented_by_a_type, node.range);
            }
        }
        return type;
    }
    /** Looks up the program element the specified super expression refers to. */
    lookupSuperExpression(
    /** The expression to look up. */
    node, 
    /** Contextual flow. */
    ctxFlow, 
    /** Contextual type. */
    ctxType = types_1.Type.auto, 
    /** How to proceed with eventual diagnostics. */
    reportMode = ReportMode.REPORT) {
        if (ctxFlow.is(32768 /* INLINE_CONTEXT */)) {
            let superLocal = ctxFlow.lookupLocal(common_1.CommonSymbols.super_);
            if (superLocal) {
                this.currentThisExpression = null;
                this.currentElementExpression = null;
                return superLocal;
            }
        }
        var parent = ctxFlow.actualFunction.parent;
        if (parent && parent.kind == program_1.ElementKind.CLASS && (parent = parent.base)) {
            this.currentThisExpression = null;
            this.currentElementExpression = null;
            return parent;
        }
        if (reportMode == ReportMode.REPORT) {
            this.error(diagnostics_1.DiagnosticCode._super_can_only_be_referenced_in_a_derived_class, node.range);
        }
        return null;
    }
    /** Resolves a super expression to its static type. */
    resolveSuperExpression(
    /** The expression to resolve. */
    node, 
    /** Contextual flow. */
    ctxFlow, 
    /** Contextual type. */
    ctxType = types_1.Type.auto, 
    /** How to proceed with eventual diagnostics. */
    reportMode = ReportMode.REPORT) {
        var element = this.lookupSuperExpression(node, ctxFlow, ctxType, reportMode);
        if (!element)
            return null;
        var type = this.getTypeOfElement(element);
        if (!type) {
            if (reportMode == ReportMode.REPORT) {
                this.error(diagnostics_1.DiagnosticCode.Expression_cannot_be_represented_by_a_type, node.range);
            }
        }
        return type;
    }
    /** Looks up the program element the specified literal expression refers to. */
    lookupLiteralExpression(
    /** The expression to look up. */
    node, 
    /** Contextual flow. */
    ctxFlow, 
    /** Contextual type. */
    ctxType = types_1.Type.auto, 
    /** How to proceed with eventual diagnostics. */
    reportMode = ReportMode.REPORT) {
        switch (node.literalKind) {
            case ast_1.LiteralKind.INTEGER: {
                this.currentThisExpression = node;
                this.currentElementExpression = null;
                let intType = this.determineIntegerLiteralType(node.value, ctxType);
                let wrapperClasses = this.program.wrapperClasses;
                assert(wrapperClasses.has(intType));
                return wrapperClasses.get(intType);
            }
            case ast_1.LiteralKind.FLOAT: {
                this.currentThisExpression = node;
                this.currentElementExpression = null;
                let fltType = ctxType == types_1.Type.f32 ? types_1.Type.f32 : types_1.Type.f64;
                let wrapperClasses = this.program.wrapperClasses;
                assert(wrapperClasses.has(fltType));
                return wrapperClasses.get(fltType);
            }
            case ast_1.LiteralKind.STRING: {
                this.currentThisExpression = node;
                this.currentElementExpression = null;
                return this.program.stringInstance;
            }
            // TODO
            // case LiteralKind.ARRAY:
        }
        if (reportMode == ReportMode.REPORT) {
            this.error(diagnostics_1.DiagnosticCode.Not_implemented, node.range);
        }
        return null;
    }
    /** Resolves a literal expression to its static type. */
    resolveLiteralExpression(
    /** The expression to resolve. */
    node, 
    /** Contextual flow. */
    ctxFlow, 
    /** Contextual type. */
    ctxType = types_1.Type.auto, 
    /** How to proceed with eventual diagnostics. */
    reportMode = ReportMode.REPORT) {
        var element = this.lookupLiteralExpression(node, ctxFlow, ctxType, reportMode);
        if (!element)
            return null;
        var type = this.getTypeOfElement(element);
        if (!type) {
            if (reportMode == ReportMode.REPORT) {
                this.error(diagnostics_1.DiagnosticCode.Expression_cannot_be_represented_by_a_type, node.range);
            }
        }
        return type;
    }
    /** Looks up the program element the specified call expression refers to. */
    lookupCallExpression(
    /** The expression to look up. */
    node, 
    /** Contextual flow. */
    ctxFlow, 
    /** Contextual type. */
    ctxType = types_1.Type.void, 
    /** How to proceed with eventual diagnostics. */
    reportMode = ReportMode.REPORT) {
        var type = this.resolveCallExpression(node, ctxFlow, ctxType, reportMode);
        if (!type)
            return null;
        var element = this.getElementOfType(type);
        if (!element) {
            if (reportMode == ReportMode.REPORT) {
                this.error(diagnostics_1.DiagnosticCode.Type_0_is_illegal_in_this_context, node.range, type.toString());
            }
        }
        return element;
    }
    /** Resolves a call expression to its static type. */
    resolveCallExpression(
    /** The expression to resolve. */
    node, 
    /** Contextual flow. */
    ctxFlow, 
    /** Contextual type. */
    ctxType = types_1.Type.void, 
    /** How to proceed with eventual diagnostics. */
    reportMode = ReportMode.REPORT) {
        var targetExpression = node.expression;
        var target = this.lookupExpression(// reports
        targetExpression, ctxFlow, ctxType, reportMode);
        if (!target)
            return null;
        switch (target.kind) {
            case program_1.ElementKind.FUNCTION_PROTOTYPE: {
                // `unchecked` behaves like parenthesized
                if (target.internalName == builtins_1.BuiltinSymbols.unchecked &&
                    node.arguments.length > 0) {
                    return this.resolveExpression(node.arguments[0], ctxFlow, ctxType, reportMode);
                }
                let instance = this.maybeInferCall(node, target, ctxFlow, reportMode);
                if (!instance)
                    return null;
                return instance.signature.returnType;
            }
            case program_1.ElementKind.FUNCTION_TARGET: return target.signature.returnType;
        }
        if (reportMode == ReportMode.REPORT) {
            this.error(diagnostics_1.DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures, targetExpression.range, target.internalName);
        }
        return null;
    }
    /** Looks up the program element the specified comma expression refers to. */
    lookupCommaExpression(
    /** The expression to look up. */
    node, 
    /** Flow to search for scoped locals. */
    ctxFlow, 
    /** Contextual type. */
    ctxType = types_1.Type.auto, 
    /** How to proceed with eventual diagnostics. */
    reportMode = ReportMode.REPORT) {
        var expressions = node.expressions;
        return this.lookupExpression(expressions[assert(expressions.length) - 1], ctxFlow, ctxType, reportMode);
    }
    /** Resolves a comma expression to its static type. */
    resolveCommaExpression(
    /** The expression to resolve. */
    node, 
    /** Flow to search for scoped locals. */
    ctxFlow, 
    /** Contextual type. */
    ctxType = types_1.Type.auto, 
    /** How to proceed with eventual diagnostics. */
    reportMode = ReportMode.REPORT) {
        var expressions = node.expressions;
        return this.resolveExpression(expressions[assert(expressions.length) - 1], ctxFlow, ctxType, reportMode);
    }
    /** Looks up the program element the specified instanceof expression refers to. */
    lookupInstanceOfExpression(
    /** The expression to look up. */
    node, 
    /** Flow to search for scoped locals. */
    ctxFlow, 
    /** Contextual type. */
    ctxType = types_1.Type.auto, 
    /** How to proceed with eventual diagnostics. */
    reportMode = ReportMode.REPORT) {
        var wrapperClasses = this.program.wrapperClasses;
        assert(wrapperClasses.has(types_1.Type.bool));
        return wrapperClasses.get(types_1.Type.bool);
    }
    /** Resolves an instanceof expression to its static type. */
    resolveInstanceOfExpression(
    /** The expression to resolve. */
    node, 
    /** Flow to search for scoped locals. */
    ctxFlow, 
    /** Contextual type. */
    ctxType = types_1.Type.auto, 
    /** How to proceed with eventual diagnostics. */
    reportMode = ReportMode.REPORT) {
        return types_1.Type.bool;
    }
    /** Looks up the program element the specified ternary expression refers to. */
    lookupTernaryExpression(
    /** The expression to look up. */
    node, 
    /** Contextual flow. */
    ctxFlow, 
    /** Contextual type. */
    ctxType, 
    /** How to proceed with eventual diagnostics. */
    reportMode = ReportMode.REPORT) {
        var type = this.resolveTernaryExpression(node, ctxFlow, ctxType, reportMode);
        if (!type)
            return null;
        var element = this.getElementOfType(type);
        if (!element) {
            if (reportMode == ReportMode.REPORT) {
                this.error(diagnostics_1.DiagnosticCode.Type_0_is_illegal_in_this_context, node.range, type.toString());
            }
        }
        return element;
    }
    /** Resolves a ternary expression to its static type. */
    resolveTernaryExpression(
    /** The expression to resolve. */
    node, 
    /** Contextual flow. */
    ctxFlow, 
    /** Contextual type. */
    ctxType, 
    /** How to proceed with eventual diagnostics. */
    reportMode = ReportMode.REPORT) {
        var thenType = this.resolveExpression(node.ifThen, ctxFlow, ctxType, reportMode);
        if (!thenType)
            return null;
        var elseType = this.resolveExpression(node.ifElse, ctxFlow, thenType, reportMode);
        if (!elseType)
            return null;
        var commonType = types_1.Type.commonDenominator(thenType, elseType, false);
        if (!commonType) {
            if (reportMode == ReportMode.REPORT) {
                this.error(diagnostics_1.DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2, node.range, "?:", thenType.toString(), elseType.toString());
            }
        }
        return commonType;
    }
    /** Looks up the program element the specified new expression refers to. */
    lookupNewExpression(
    /** The expression to look up. */
    node, 
    /** Contextual flow. */
    ctxFlow, 
    /** Contextual type. */
    ctxType, 
    /** How to proceed with eventual diagnostics. */
    reportMode = ReportMode.REPORT) {
        var element = this.lookupExpression(node.expression, ctxFlow, ctxType, reportMode);
        if (!element)
            return null;
        if (element.kind == program_1.ElementKind.CLASS_PROTOTYPE) {
            return this.resolveClassInclTypeArguments(element, node.typeArguments, ctxFlow.actualFunction, util_1.makeMap(ctxFlow.contextualTypeArguments), node, reportMode);
        }
        if (reportMode == ReportMode.REPORT) {
            this.error(diagnostics_1.DiagnosticCode.This_expression_is_not_constructable, node.range);
        }
        return null;
    }
    /** Resolves a new expression to its static type. */
    resolveNewExpression(
    /** The expression to resolve. */
    node, 
    /** Contextual flow. */
    ctxFlow, 
    /** Contextual type. */
    ctxType, 
    /** How to proceed with eventual diagnostics. */
    reportMode = ReportMode.REPORT) {
        var element = this.lookupNewExpression(node, ctxFlow, ctxType, reportMode);
        if (!element)
            return null;
        var type = this.getTypeOfElement(element);
        if (!type) {
            if (reportMode == ReportMode.REPORT) {
                this.error(diagnostics_1.DiagnosticCode.Expression_cannot_be_represented_by_a_type, node.range);
            }
        }
        return type;
    }
    /** Looks up the program element the specified function expression refers to. */
    lookupFunctionExpression(
    /** The expression to look up. */
    node, 
    /** Contextual flow. */
    ctxFlow, 
    /** Contextual type. */
    ctxType, 
    /** How to proceed with eventual diagnostics. */
    reportMode = ReportMode.REPORT) {
        var type = this.resolveFunctionExpression(node, ctxFlow, ctxType, reportMode);
        if (!type)
            return null;
        var element = this.getElementOfType(type);
        if (!element) {
            if (reportMode == ReportMode.REPORT) {
                this.error(diagnostics_1.DiagnosticCode.Type_0_is_illegal_in_this_context, node.range, type.toString());
            }
        }
        return element;
    }
    /** Resolves a function expression to its static type. */
    resolveFunctionExpression(
    /** The expression to resolve. */
    node, 
    /** Contextual flow. */
    ctxFlow, 
    /** Contextual type. */
    ctxType, 
    /** How to proceed with eventual diagnostics. */
    reportMode = ReportMode.REPORT) {
        return this.resolveFunctionType(node.declaration.signature, ctxFlow.actualFunction, ctxFlow.contextualTypeArguments, reportMode);
    }
    // ==================================================== Elements =====================================================
    /** Resolves a function prototype using the specified concrete type arguments. */
    resolveFunction(
    /** The prototype of the function. */
    prototype, 
    /** Type arguments provided. */
    typeArguments, 
    /** Contextual types, i.e. `T`. */
    ctxTypes = util_1.makeMap(), 
    /** How to proceed with eventual diagnostics. */
    reportMode = ReportMode.REPORT) {
        var actualParent = prototype.parent.kind == program_1.ElementKind.PROPERTY_PROTOTYPE
            ? prototype.parent.parent
            : prototype.parent;
        var classInstance = null; // if an instance method
        var instanceKey = typeArguments ? types_1.typesToString(typeArguments) : "";
        // Instance method prototypes are pre-bound to their concrete class as their parent
        if (prototype.is(common_1.CommonFlags.INSTANCE)) {
            assert(actualParent.kind == program_1.ElementKind.CLASS);
            classInstance = actualParent;
            // check if this exact concrete class and function combination is known already
            let resolvedInstance = prototype.getResolvedInstance(instanceKey);
            if (resolvedInstance)
                return resolvedInstance;
            // inherit class specific type arguments
            let classTypeArguments = classInstance.typeArguments;
            if (classTypeArguments) {
                let classTypeParameters = assert(classInstance.prototype.typeParameterNodes);
                let numClassTypeArguments = classTypeParameters.length;
                assert(numClassTypeArguments == classTypeParameters.length);
                for (let i = 0; i < numClassTypeArguments; ++i) {
                    let classTypeParameterName = classTypeParameters[i].name.text;
                    if (!ctxTypes.has(classTypeParameterName)) {
                        ctxTypes.set(classTypeParameterName, classTypeArguments[i]);
                    }
                }
            }
        }
        else {
            assert(actualParent.kind != program_1.ElementKind.CLASS); // must not be pre-bound
            let resolvedInstance = prototype.getResolvedInstance(instanceKey);
            if (resolvedInstance)
                return resolvedInstance;
        }
        // override whatever is contextual with actual function type arguments
        var signatureNode = prototype.functionTypeNode;
        var typeParameterNodes = prototype.typeParameterNodes;
        var numFunctionTypeArguments;
        if (typeArguments && (numFunctionTypeArguments = typeArguments.length)) {
            assert(typeParameterNodes && numFunctionTypeArguments == typeParameterNodes.length);
            for (let i = 0; i < numFunctionTypeArguments; ++i) {
                ctxTypes.set(typeParameterNodes[i].name.text, typeArguments[i]);
            }
        }
        else {
            assert(!typeParameterNodes || typeParameterNodes.length == 0);
        }
        // resolve `this` type if applicable
        var thisType = null;
        var explicitThisType = signatureNode.explicitThisType;
        if (explicitThisType) {
            thisType = this.resolveType(explicitThisType, prototype.parent, // relative to function
            ctxTypes, reportMode);
            if (!thisType)
                return null;
            ctxTypes.set(common_1.CommonSymbols.this_, thisType);
        }
        else if (classInstance) {
            thisType = classInstance.type;
            ctxTypes.set(common_1.CommonSymbols.this_, thisType);
        }
        // resolve parameter types
        var signatureParameters = signatureNode.parameters;
        var numSignatureParameters = signatureParameters.length;
        var parameterTypes = new Array(numSignatureParameters);
        var parameterNames = new Array(numSignatureParameters);
        var requiredParameters = 0;
        for (let i = 0; i < numSignatureParameters; ++i) {
            let parameterDeclaration = signatureParameters[i];
            if (parameterDeclaration.parameterKind == ast_1.ParameterKind.DEFAULT) {
                requiredParameters = i + 1;
            }
            let typeNode = parameterDeclaration.type;
            if (ast_1.isTypeOmitted(typeNode)) {
                if (reportMode == ReportMode.REPORT) {
                    this.error(diagnostics_1.DiagnosticCode.Type_expected, typeNode.range);
                }
                return null;
            }
            let parameterType = this.resolveType(typeNode, prototype.parent, // relative to function
            ctxTypes, reportMode);
            if (!parameterType)
                return null;
            parameterTypes[i] = parameterType;
            parameterNames[i] = parameterDeclaration.name.text;
        }
        // resolve return type
        var returnType;
        if (prototype.is(common_1.CommonFlags.SET)) {
            returnType = types_1.Type.void; // not annotated
        }
        else if (prototype.is(common_1.CommonFlags.CONSTRUCTOR)) {
            returnType = assert(classInstance).type; // not annotated
        }
        else {
            let typeNode = signatureNode.returnType;
            if (ast_1.isTypeOmitted(typeNode)) {
                if (reportMode == ReportMode.REPORT) {
                    this.error(diagnostics_1.DiagnosticCode.Type_expected, typeNode.range);
                }
                return null;
            }
            let type = this.resolveType(typeNode, prototype.parent, // relative to function
            ctxTypes, reportMode);
            if (!type)
                return null;
            returnType = type;
        }
        var signature = new types_1.Signature(this.program, parameterTypes, returnType, thisType);
        signature.parameterNames = parameterNames;
        signature.requiredParameters = requiredParameters;
        var nameInclTypeParameters = prototype.name;
        if (instanceKey.length)
            nameInclTypeParameters += "<" + instanceKey + ">";
        var instance = new program_1.Function(nameInclTypeParameters, prototype, signature, ctxTypes);
        prototype.setResolvedInstance(instanceKey, instance);
        return instance;
    }
    /** Resolves a function prototypeby first resolving the specified type arguments. */
    resolveFunctionInclTypeArguments(
    /** The prototype of the function. */
    prototype, 
    /** Type arguments provided to be resolved. */
    typeArgumentNodes, 
    /** Contextual element. */
    ctxElement, 
    /** Contextual types, i.e. `T`. */
    ctxTypes, 
    /** The node to use when reporting intermediate errors. */
    reportNode, 
    /** How to proceed with eventual diagnostics. */
    reportMode = ReportMode.REPORT) {
        var actualParent = prototype.parent.kind == program_1.ElementKind.PROPERTY_PROTOTYPE
            ? prototype.parent.parent
            : prototype.parent;
        var resolvedTypeArguments = null;
        // Resolve type arguments if generic
        if (prototype.is(common_1.CommonFlags.GENERIC)) {
            // If this is an instance method, first apply the class's type arguments
            if (prototype.is(common_1.CommonFlags.INSTANCE)) {
                assert(actualParent.kind == program_1.ElementKind.CLASS);
                let classTypeArguments = actualParent.typeArguments;
                if (classTypeArguments) {
                    let typeParameterNodes = assert(actualParent.prototype.typeParameterNodes);
                    let numClassTypeArguments = classTypeArguments.length;
                    assert(numClassTypeArguments == typeParameterNodes.length);
                    for (let i = 0; i < numClassTypeArguments; ++i) {
                        ctxTypes.set(typeParameterNodes[i].name.text, classTypeArguments[i]);
                    }
                }
            }
            resolvedTypeArguments = this.resolveTypeArguments(// reports
            assert(prototype.typeParameterNodes), typeArgumentNodes, ctxElement, ctxTypes, reportNode, reportMode);
            if (!resolvedTypeArguments)
                return null;
            // Otherwise make sure that no type arguments have been specified
        }
        else {
            if (typeArgumentNodes !== null && typeArgumentNodes.length) {
                if (reportMode == ReportMode.REPORT) {
                    this.error(diagnostics_1.DiagnosticCode.Type_0_is_not_generic, reportNode.range, prototype.internalName);
                }
                return null;
            }
        }
        // Continue with concrete types
        return this.resolveFunction(prototype, resolvedTypeArguments, ctxTypes, reportMode);
    }
    /** Resolves a class prototype using the specified concrete type arguments. */
    resolveClass(
    /** The prototype of the class. */
    prototype, 
    /** Type arguments provided. */
    typeArguments, 
    /** Contextual types, i.e. `T`. */
    ctxTypes = util_1.makeMap(), 
    /** How to proceed with eventual diagnostics. */
    reportMode = ReportMode.REPORT) {
        var instanceKey = typeArguments ? types_1.typesToString(typeArguments) : "";
        // Check if this exact instance has already been resolved
        var instance = prototype.getResolvedInstance(instanceKey);
        if (instance)
            return instance;
        // Insert contextual type arguments for this operation. Internally, this method is always
        // called with matching type parameter / argument counts.
        if (typeArguments) {
            let typeParameterNodes = assert(prototype.typeParameterNodes);
            let numTypeParameters = typeParameterNodes.length;
            let numTypeArguments = typeArguments.length;
            assert(numTypeArguments == numTypeParameters);
            for (let i = 0; i < numTypeArguments; ++i) {
                ctxTypes.set(typeParameterNodes[i].name.text, typeArguments[i]);
            }
        }
        else {
            let typeParameterNodes = prototype.typeParameterNodes;
            assert(!(typeParameterNodes && typeParameterNodes.length));
        }
        // Resolve base class if applicable
        var basePrototype = prototype.basePrototype;
        var baseClass = null;
        if (basePrototype) {
            let extendsNode = assert(prototype.extendsNode); // must be present if it has a base prototype
            baseClass = this.resolveClassInclTypeArguments(basePrototype, extendsNode.typeArguments, prototype.parent, // relative to derived class
            util_1.makeMap(ctxTypes), // don't inherit
            extendsNode, reportMode);
            if (!baseClass)
                return null;
        }
        // Construct the instance and remember that it has been resolved already
        var nameInclTypeParamters = prototype.name;
        if (instanceKey.length)
            nameInclTypeParamters += "<" + instanceKey + ">";
        instance = new program_1.Class(nameInclTypeParamters, prototype, typeArguments, baseClass);
        instance.contextualTypeArguments = ctxTypes;
        prototype.setResolvedInstance(instanceKey, instance);
        // Inherit base class members and set up the initial memory offset for own fields
        var memoryOffset = 0;
        if (baseClass) {
            let baseMembers = baseClass.members;
            if (baseMembers) {
                let instanceMembers = instance.members;
                if (!instanceMembers)
                    instance.members = instanceMembers = new Map();
                for (let [baseMemberName, baseMember] of baseMembers) {
                    instanceMembers.set(baseMemberName, baseMember);
                }
            }
            memoryOffset = baseClass.currentMemoryOffset;
        }
        // Resolve instance members
        var instanceMemberPrototypes = prototype.instanceMembers;
        if (instanceMemberPrototypes) {
            for (let member of instanceMemberPrototypes.values()) {
                switch (member.kind) {
                    // Lay out fields in advance
                    case program_1.ElementKind.FIELD_PROTOTYPE: {
                        let instanceMembers = instance.members;
                        if (!instanceMembers)
                            instance.members = instanceMembers = new Map();
                        else if (instanceMembers.has(member.name)) {
                            let existing = instanceMembers.get(member.name);
                            this.errorRelated(diagnostics_1.DiagnosticCode.Duplicate_identifier_0, member.identifierNode.range, existing.declaration.name.range, member.name);
                            break;
                        }
                        let fieldTypeNode = member.typeNode;
                        let fieldType = null;
                        // TODO: handle duplicate non-private fields specifically?
                        if (!fieldTypeNode) {
                            if (baseClass) {
                                let baseMembers = baseClass.members;
                                if (baseMembers && baseMembers.has(member.name)) {
                                    let baseField = baseMembers.get(member.name);
                                    if (!baseField.is(common_1.CommonFlags.PRIVATE)) {
                                        assert(baseField.kind == program_1.ElementKind.FIELD);
                                        fieldType = baseField.type;
                                    }
                                }
                            }
                            if (!fieldType) {
                                if (reportMode == ReportMode.REPORT) {
                                    this.error(diagnostics_1.DiagnosticCode.Type_expected, member.identifierNode.range.atEnd);
                                }
                            }
                        }
                        else {
                            fieldType = this.resolveType(fieldTypeNode, prototype.parent, // relative to class
                            instance.contextualTypeArguments, reportMode);
                        }
                        if (!fieldType)
                            break; // did report above
                        let fieldInstance = new program_1.Field(member, instance, fieldType);
                        assert(util_1.isPowerOf2(fieldType.byteSize));
                        let mask = fieldType.byteSize - 1;
                        if (memoryOffset & mask)
                            memoryOffset = (memoryOffset | mask) + 1;
                        fieldInstance.memoryOffset = memoryOffset;
                        memoryOffset += fieldType.byteSize;
                        instance.add(member.name, fieldInstance); // reports
                        break;
                    }
                    case program_1.ElementKind.FUNCTION_PROTOTYPE: {
                        let boundPrototype = member.toBound(instance);
                        instance.add(boundPrototype.name, boundPrototype); // reports
                        break;
                    }
                    case program_1.ElementKind.PROPERTY_PROTOTYPE: {
                        let propertyInstance = new program_1.Property(member, instance);
                        let getterPrototype = member.getterPrototype;
                        if (getterPrototype) {
                            let getterInstance = this.resolveFunction(getterPrototype.toBound(instance), null, util_1.makeMap(instance.contextualTypeArguments), reportMode);
                            if (getterInstance) {
                                propertyInstance.getterInstance = getterInstance;
                                propertyInstance.setType(getterInstance.signature.returnType);
                            }
                        }
                        let setterPrototype = member.setterPrototype;
                        if (setterPrototype) {
                            let setterInstance = this.resolveFunction(setterPrototype.toBound(instance), null, util_1.makeMap(instance.contextualTypeArguments), reportMode);
                            if (setterInstance) {
                                propertyInstance.setterInstance = setterInstance;
                                if (!propertyInstance.is(common_1.CommonFlags.RESOLVED)) {
                                    assert(setterInstance.signature.parameterTypes.length == 1);
                                    propertyInstance.setType(setterInstance.signature.parameterTypes[0]);
                                }
                            }
                        }
                        instance.add(propertyInstance.name, propertyInstance); // reports
                        break;
                    }
                    default: assert(false);
                }
            }
        }
        // Finalize memory offset
        instance.currentMemoryOffset = memoryOffset;
        // Link _own_ constructor if present
        {
            let ctorPrototype = instance.lookupInSelf(common_1.CommonSymbols.constructor);
            if (ctorPrototype && ctorPrototype.parent === instance) {
                assert(ctorPrototype.kind == program_1.ElementKind.FUNCTION_PROTOTYPE);
                let ctorInstance = this.resolveFunction(ctorPrototype, null, instance.contextualTypeArguments, reportMode);
                if (ctorInstance)
                    instance.constructorInstance = ctorInstance;
            }
        }
        // Fully resolve operator overloads (don't have type parameters on their own)
        for (let [kind, overloadPrototype] of prototype.overloadPrototypes) {
            assert(kind != program_1.OperatorKind.INVALID);
            let operatorInstance;
            if (overloadPrototype.is(common_1.CommonFlags.INSTANCE)) {
                let boundPrototype = overloadPrototype.toBound(instance);
                operatorInstance = this.resolveFunction(boundPrototype, null, util_1.makeMap(), reportMode);
            }
            else {
                operatorInstance = this.resolveFunction(overloadPrototype, null, util_1.makeMap(), reportMode);
            }
            if (!operatorInstance)
                continue;
            let overloads = instance.overloads;
            if (!overloads)
                instance.overloads = overloads = new Map();
            // inc/dec are special in that an instance overload attempts to re-assign
            // the corresponding value, thus requiring a matching return type, while a
            // static overload works like any other overload.
            if (operatorInstance.is(common_1.CommonFlags.INSTANCE)) {
                switch (kind) {
                    case program_1.OperatorKind.PREFIX_INC:
                    case program_1.OperatorKind.PREFIX_DEC:
                    case program_1.OperatorKind.POSTFIX_INC:
                    case program_1.OperatorKind.POSTFIX_DEC: {
                        let returnType = operatorInstance.signature.returnType;
                        if (!returnType.isAssignableTo(instance.type)) {
                            if (reportMode == ReportMode.REPORT) {
                                this.error(diagnostics_1.DiagnosticCode.Type_0_is_not_assignable_to_type_1, overloadPrototype.functionTypeNode.returnType.range, returnType.toString(), instance.type.toString());
                            }
                        }
                    }
                }
            }
            if (!overloads.has(kind)) {
                overloads.set(kind, operatorInstance);
                if (kind == program_1.OperatorKind.INDEXED_GET || kind == program_1.OperatorKind.INDEXED_SET) {
                    let index = instance.indexSignature;
                    if (!index)
                        instance.indexSignature = index = new program_1.IndexSignature(instance);
                    if (kind == program_1.OperatorKind.INDEXED_GET) {
                        index.setType(operatorInstance.signature.returnType);
                    }
                }
            }
            else {
                if (reportMode == ReportMode.REPORT) {
                    this.error(diagnostics_1.DiagnosticCode.Duplicate_decorator, operatorInstance.declaration.range);
                }
            }
        }
        return instance;
    }
    /** Resolves a class prototype by first resolving the specified type arguments. */
    resolveClassInclTypeArguments(
    /** The prototype of the class. */
    prototype, 
    /** Type arguments provided to be resolved. */
    typeArgumentNodes, 
    /** Contextual element. */
    ctxElement, 
    /** Contextual types, i.e. `T`. */
    ctxTypes, 
    /** The node to use when reporting intermediate errors. */
    reportNode, 
    /** How to proceed with eventual diagnostics. */
    reportMode = ReportMode.REPORT) {
        var resolvedTypeArguments = null;
        // Resolve type arguments if generic
        if (prototype.is(common_1.CommonFlags.GENERIC)) {
            resolvedTypeArguments = this.resolveTypeArguments(// reports
            assert(prototype.typeParameterNodes), // must be present if generic
            typeArgumentNodes, ctxElement, ctxTypes, reportNode, reportMode);
            if (!resolvedTypeArguments)
                return null;
            // Otherwise make sure that no type arguments have been specified
        }
        else {
            if (typeArgumentNodes !== null && typeArgumentNodes.length) {
                if (reportMode == ReportMode.REPORT) {
                    this.error(diagnostics_1.DiagnosticCode.Type_0_is_not_generic, reportNode.range, prototype.internalName);
                }
                return null;
            }
        }
        // Continue with concrete types
        return this.resolveClass(prototype, resolvedTypeArguments, ctxTypes, reportMode);
    }
}
exports.Resolver = Resolver;


/***/ }),

/***/ "./src/tokenizer.ts":
/*!**************************!*\
  !*** ./src/tokenizer.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * A TypeScript tokenizer modified for AssemblyScript.
 *
 * Skips over trivia and provides a general mark/reset mechanism for the parser to utilize on
 * ambiguous tokens.
 *
 * @module tokenizer
 */ /***/
Object.defineProperty(exports, "__esModule", { value: true });
const diagnostics_1 = __webpack_require__(/*! ./diagnostics */ "./src/diagnostics.ts");
const ast_1 = __webpack_require__(/*! ./ast */ "./src/ast.ts");
const util_1 = __webpack_require__(/*! ./util */ "./src/util/index.ts");
/** Named token types. */
var Token;
(function (Token) {
    // keywords
    // discarded: ANY, BOOLEAN, NEVER, NUMBER, STRING, SYMBOL, UNDEFINED, LESSTHAN_SLASH
    Token[Token["ABSTRACT"] = 0] = "ABSTRACT";
    Token[Token["AS"] = 1] = "AS";
    Token[Token["ASYNC"] = 2] = "ASYNC";
    Token[Token["AWAIT"] = 3] = "AWAIT";
    Token[Token["BREAK"] = 4] = "BREAK";
    Token[Token["CASE"] = 5] = "CASE";
    Token[Token["CATCH"] = 6] = "CATCH";
    Token[Token["CLASS"] = 7] = "CLASS";
    Token[Token["CONST"] = 8] = "CONST";
    Token[Token["CONTINUE"] = 9] = "CONTINUE";
    Token[Token["CONSTRUCTOR"] = 10] = "CONSTRUCTOR";
    Token[Token["DEBUGGER"] = 11] = "DEBUGGER";
    Token[Token["DECLARE"] = 12] = "DECLARE";
    Token[Token["DEFAULT"] = 13] = "DEFAULT";
    Token[Token["DELETE"] = 14] = "DELETE";
    Token[Token["DO"] = 15] = "DO";
    Token[Token["ELSE"] = 16] = "ELSE";
    Token[Token["ENUM"] = 17] = "ENUM";
    Token[Token["EXPORT"] = 18] = "EXPORT";
    Token[Token["EXTENDS"] = 19] = "EXTENDS";
    Token[Token["FALSE"] = 20] = "FALSE";
    Token[Token["FINALLY"] = 21] = "FINALLY";
    Token[Token["FOR"] = 22] = "FOR";
    Token[Token["FROM"] = 23] = "FROM";
    Token[Token["FUNCTION"] = 24] = "FUNCTION";
    Token[Token["GET"] = 25] = "GET";
    Token[Token["IF"] = 26] = "IF";
    Token[Token["IMPLEMENTS"] = 27] = "IMPLEMENTS";
    Token[Token["IMPORT"] = 28] = "IMPORT";
    Token[Token["IN"] = 29] = "IN";
    Token[Token["INSTANCEOF"] = 30] = "INSTANCEOF";
    Token[Token["INTERFACE"] = 31] = "INTERFACE";
    Token[Token["IS"] = 32] = "IS";
    Token[Token["KEYOF"] = 33] = "KEYOF";
    Token[Token["LET"] = 34] = "LET";
    Token[Token["MODULE"] = 35] = "MODULE";
    Token[Token["NAMESPACE"] = 36] = "NAMESPACE";
    Token[Token["NEW"] = 37] = "NEW";
    Token[Token["NULL"] = 38] = "NULL";
    Token[Token["OF"] = 39] = "OF";
    Token[Token["PACKAGE"] = 40] = "PACKAGE";
    Token[Token["PRIVATE"] = 41] = "PRIVATE";
    Token[Token["PROTECTED"] = 42] = "PROTECTED";
    Token[Token["PUBLIC"] = 43] = "PUBLIC";
    Token[Token["READONLY"] = 44] = "READONLY";
    Token[Token["RETURN"] = 45] = "RETURN";
    Token[Token["SET"] = 46] = "SET";
    Token[Token["STATIC"] = 47] = "STATIC";
    Token[Token["SUPER"] = 48] = "SUPER";
    Token[Token["SWITCH"] = 49] = "SWITCH";
    Token[Token["THIS"] = 50] = "THIS";
    Token[Token["THROW"] = 51] = "THROW";
    Token[Token["TRUE"] = 52] = "TRUE";
    Token[Token["TRY"] = 53] = "TRY";
    Token[Token["TYPE"] = 54] = "TYPE";
    Token[Token["TYPEOF"] = 55] = "TYPEOF";
    Token[Token["VAR"] = 56] = "VAR";
    Token[Token["VOID"] = 57] = "VOID";
    Token[Token["WHILE"] = 58] = "WHILE";
    Token[Token["WITH"] = 59] = "WITH";
    Token[Token["YIELD"] = 60] = "YIELD";
    // punctuation
    Token[Token["OPENBRACE"] = 61] = "OPENBRACE";
    Token[Token["CLOSEBRACE"] = 62] = "CLOSEBRACE";
    Token[Token["OPENPAREN"] = 63] = "OPENPAREN";
    Token[Token["CLOSEPAREN"] = 64] = "CLOSEPAREN";
    Token[Token["OPENBRACKET"] = 65] = "OPENBRACKET";
    Token[Token["CLOSEBRACKET"] = 66] = "CLOSEBRACKET";
    Token[Token["DOT"] = 67] = "DOT";
    Token[Token["DOT_DOT_DOT"] = 68] = "DOT_DOT_DOT";
    Token[Token["SEMICOLON"] = 69] = "SEMICOLON";
    Token[Token["COMMA"] = 70] = "COMMA";
    Token[Token["LESSTHAN"] = 71] = "LESSTHAN";
    Token[Token["GREATERTHAN"] = 72] = "GREATERTHAN";
    Token[Token["LESSTHAN_EQUALS"] = 73] = "LESSTHAN_EQUALS";
    Token[Token["GREATERTHAN_EQUALS"] = 74] = "GREATERTHAN_EQUALS";
    Token[Token["EQUALS_EQUALS"] = 75] = "EQUALS_EQUALS";
    Token[Token["EXCLAMATION_EQUALS"] = 76] = "EXCLAMATION_EQUALS";
    Token[Token["EQUALS_EQUALS_EQUALS"] = 77] = "EQUALS_EQUALS_EQUALS";
    Token[Token["EXCLAMATION_EQUALS_EQUALS"] = 78] = "EXCLAMATION_EQUALS_EQUALS";
    Token[Token["EQUALS_GREATERTHAN"] = 79] = "EQUALS_GREATERTHAN";
    Token[Token["PLUS"] = 80] = "PLUS";
    Token[Token["MINUS"] = 81] = "MINUS";
    Token[Token["ASTERISK_ASTERISK"] = 82] = "ASTERISK_ASTERISK";
    Token[Token["ASTERISK"] = 83] = "ASTERISK";
    Token[Token["SLASH"] = 84] = "SLASH";
    Token[Token["PERCENT"] = 85] = "PERCENT";
    Token[Token["PLUS_PLUS"] = 86] = "PLUS_PLUS";
    Token[Token["MINUS_MINUS"] = 87] = "MINUS_MINUS";
    Token[Token["LESSTHAN_LESSTHAN"] = 88] = "LESSTHAN_LESSTHAN";
    Token[Token["GREATERTHAN_GREATERTHAN"] = 89] = "GREATERTHAN_GREATERTHAN";
    Token[Token["GREATERTHAN_GREATERTHAN_GREATERTHAN"] = 90] = "GREATERTHAN_GREATERTHAN_GREATERTHAN";
    Token[Token["AMPERSAND"] = 91] = "AMPERSAND";
    Token[Token["BAR"] = 92] = "BAR";
    Token[Token["CARET"] = 93] = "CARET";
    Token[Token["EXCLAMATION"] = 94] = "EXCLAMATION";
    Token[Token["TILDE"] = 95] = "TILDE";
    Token[Token["AMPERSAND_AMPERSAND"] = 96] = "AMPERSAND_AMPERSAND";
    Token[Token["BAR_BAR"] = 97] = "BAR_BAR";
    Token[Token["QUESTION"] = 98] = "QUESTION";
    Token[Token["COLON"] = 99] = "COLON";
    Token[Token["EQUALS"] = 100] = "EQUALS";
    Token[Token["PLUS_EQUALS"] = 101] = "PLUS_EQUALS";
    Token[Token["MINUS_EQUALS"] = 102] = "MINUS_EQUALS";
    Token[Token["ASTERISK_EQUALS"] = 103] = "ASTERISK_EQUALS";
    Token[Token["ASTERISK_ASTERISK_EQUALS"] = 104] = "ASTERISK_ASTERISK_EQUALS";
    Token[Token["SLASH_EQUALS"] = 105] = "SLASH_EQUALS";
    Token[Token["PERCENT_EQUALS"] = 106] = "PERCENT_EQUALS";
    Token[Token["LESSTHAN_LESSTHAN_EQUALS"] = 107] = "LESSTHAN_LESSTHAN_EQUALS";
    Token[Token["GREATERTHAN_GREATERTHAN_EQUALS"] = 108] = "GREATERTHAN_GREATERTHAN_EQUALS";
    Token[Token["GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS"] = 109] = "GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS";
    Token[Token["AMPERSAND_EQUALS"] = 110] = "AMPERSAND_EQUALS";
    Token[Token["BAR_EQUALS"] = 111] = "BAR_EQUALS";
    Token[Token["CARET_EQUALS"] = 112] = "CARET_EQUALS";
    Token[Token["AT"] = 113] = "AT";
    // literals
    Token[Token["IDENTIFIER"] = 114] = "IDENTIFIER";
    Token[Token["STRINGLITERAL"] = 115] = "STRINGLITERAL";
    Token[Token["INTEGERLITERAL"] = 116] = "INTEGERLITERAL";
    Token[Token["FLOATLITERAL"] = 117] = "FLOATLITERAL";
    // meta
    Token[Token["INVALID"] = 118] = "INVALID";
    Token[Token["ENDOFFILE"] = 119] = "ENDOFFILE";
})(Token = exports.Token || (exports.Token = {}));
var IdentifierHandling;
(function (IdentifierHandling) {
    IdentifierHandling[IdentifierHandling["DEFAULT"] = 0] = "DEFAULT";
    IdentifierHandling[IdentifierHandling["PREFER"] = 1] = "PREFER";
    IdentifierHandling[IdentifierHandling["ALWAYS"] = 2] = "ALWAYS";
})(IdentifierHandling = exports.IdentifierHandling || (exports.IdentifierHandling = {}));
function tokenFromKeyword(text) {
    assert(text.length);
    switch (text.charCodeAt(0)) {
        case 97 /* a */: {
            switch (text) {
                case "abstract": return Token.ABSTRACT;
                case "as": return Token.AS;
                case "async": return Token.ASYNC;
                case "await": return Token.AWAIT;
            }
            break;
        }
        case 98 /* b */: {
            switch (text) {
                case "break": return Token.BREAK;
            }
            break;
        }
        case 99 /* c */: {
            switch (text) {
                case "case": return Token.CASE;
                case "catch": return Token.CATCH;
                case "class": return Token.CLASS;
                case "continue": return Token.CONTINUE;
                case "const": return Token.CONST;
                case "constructor": return Token.CONSTRUCTOR;
            }
            break;
        }
        case 100 /* d */: {
            switch (text) {
                case "debugger": return Token.DEBUGGER;
                case "declare": return Token.DECLARE;
                case "default": return Token.DEFAULT;
                case "delete": return Token.DELETE;
                case "do": return Token.DO;
            }
            break;
        }
        case 101 /* e */: {
            switch (text) {
                case "else": return Token.ELSE;
                case "enum": return Token.ENUM;
                case "export": return Token.EXPORT;
                case "extends": return Token.EXTENDS;
            }
            break;
        }
        case 102 /* f */: {
            switch (text) {
                case "false": return Token.FALSE;
                case "finally": return Token.FINALLY;
                case "for": return Token.FOR;
                case "from": return Token.FROM;
                case "function": return Token.FUNCTION;
            }
            break;
        }
        case 103 /* g */: {
            switch (text) {
                case "get": return Token.GET;
            }
            break;
        }
        case 105 /* i */: {
            switch (text) {
                case "if": return Token.IF;
                case "implements": return Token.IMPLEMENTS;
                case "import": return Token.IMPORT;
                case "in": return Token.IN;
                case "instanceof": return Token.INSTANCEOF;
                case "interface": return Token.INTERFACE;
                case "is": return Token.IS;
            }
            break;
        }
        case 107 /* k */: {
            switch (text) {
                case "keyof": return Token.KEYOF;
            }
            break;
        }
        case 108 /* l */: {
            switch (text) {
                case "let": return Token.LET;
            }
            break;
        }
        case 109 /* m */: {
            switch (text) {
                case "module": return Token.MODULE;
            }
            break;
        }
        case 110 /* n */: {
            switch (text) {
                case "namespace": return Token.NAMESPACE;
                case "new": return Token.NEW;
                case "null": return Token.NULL;
            }
            break;
        }
        case 111 /* o */: {
            switch (text) {
                case "of": return Token.OF;
            }
            break;
        }
        case 112 /* p */: {
            switch (text) {
                case "package": return Token.PACKAGE;
                case "private": return Token.PRIVATE;
                case "protected": return Token.PROTECTED;
                case "public": return Token.PUBLIC;
            }
            break;
        }
        case 114 /* r */: {
            switch (text) {
                case "readonly": return Token.READONLY;
                case "return": return Token.RETURN;
            }
            break;
        }
        case 115 /* s */: {
            switch (text) {
                case "set": return Token.SET;
                case "static": return Token.STATIC;
                case "super": return Token.SUPER;
                case "switch": return Token.SWITCH;
            }
            break;
        }
        case 116 /* t */: {
            switch (text) {
                case "this": return Token.THIS;
                case "throw": return Token.THROW;
                case "true": return Token.TRUE;
                case "try": return Token.TRY;
                case "type": return Token.TYPE;
                case "typeof": return Token.TYPEOF;
            }
            break;
        }
        case 118 /* v */: {
            switch (text) {
                case "var": return Token.VAR;
                case "void": return Token.VOID;
            }
            break;
        }
        case 119 /* w */: {
            switch (text) {
                case "while": return Token.WHILE;
                case "with": return Token.WITH;
            }
            break;
        }
        case 121 /* y */: {
            switch (text) {
                case "yield": return Token.YIELD;
            }
            break;
        }
    }
    return Token.INVALID;
}
exports.tokenFromKeyword = tokenFromKeyword;
function tokenIsAlsoIdentifier(token) {
    switch (token) {
        case Token.ABSTRACT:
        case Token.AS:
        case Token.CONSTRUCTOR:
        case Token.DECLARE:
        case Token.DELETE:
        case Token.FROM:
        case Token.FOR:
        case Token.GET:
        case Token.INSTANCEOF:
        case Token.IS:
        case Token.KEYOF:
        case Token.MODULE:
        case Token.NAMESPACE:
        case Token.NULL:
        case Token.READONLY:
        case Token.SET:
        case Token.TYPE:
        case Token.VOID: return true;
        default: return false;
    }
}
exports.tokenIsAlsoIdentifier = tokenIsAlsoIdentifier;
function isIllegalVariableIdentifier(name) {
    assert(name.length);
    switch (name.charCodeAt(0)) {
        case 100 /* d */: return name == "delete";
        case 102 /* f */: return name == "for";
        case 105 /* i */: return name == "instanceof";
        case 110 /* n */: return name == "null";
        case 118 /* v */: return name == "void";
    }
    return false;
}
exports.isIllegalVariableIdentifier = isIllegalVariableIdentifier;
function operatorTokenToString(token) {
    switch (token) {
        case Token.DELETE: return "delete";
        case Token.IN: return "in";
        case Token.INSTANCEOF: return "instanceof";
        case Token.NEW: return "new";
        case Token.TYPEOF: return "typeof";
        case Token.VOID: return "void";
        case Token.YIELD: return "yield";
        case Token.DOT_DOT_DOT: return "...";
        case Token.COMMA: return ",";
        case Token.LESSTHAN: return "<";
        case Token.GREATERTHAN: return ">";
        case Token.LESSTHAN_EQUALS: return "<=";
        case Token.GREATERTHAN_EQUALS: return ">=";
        case Token.EQUALS_EQUALS: return "==";
        case Token.EXCLAMATION_EQUALS: return "!=";
        case Token.EQUALS_EQUALS_EQUALS: return "===";
        case Token.EXCLAMATION_EQUALS_EQUALS: return "!==";
        case Token.PLUS: return "+";
        case Token.MINUS: return "-";
        case Token.ASTERISK_ASTERISK: return "**";
        case Token.ASTERISK: return "*";
        case Token.SLASH: return "/";
        case Token.PERCENT: return "%";
        case Token.PLUS_PLUS: return "++";
        case Token.MINUS_MINUS: return "--";
        case Token.LESSTHAN_LESSTHAN: return "<<";
        case Token.GREATERTHAN_GREATERTHAN: return ">>";
        case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN: return ">>>";
        case Token.AMPERSAND: return "&";
        case Token.BAR: return "|";
        case Token.CARET: return "^";
        case Token.EXCLAMATION: return "!";
        case Token.TILDE: return "~";
        case Token.AMPERSAND_AMPERSAND: return "&&";
        case Token.BAR_BAR: return "||";
        case Token.EQUALS: return "=";
        case Token.PLUS_EQUALS: return "+=";
        case Token.MINUS_EQUALS: return "-=";
        case Token.ASTERISK_EQUALS: return "*=";
        case Token.ASTERISK_ASTERISK_EQUALS: return "**=";
        case Token.SLASH_EQUALS: return "/=";
        case Token.PERCENT_EQUALS: return "%=";
        case Token.LESSTHAN_LESSTHAN_EQUALS: return "<<=";
        case Token.GREATERTHAN_GREATERTHAN_EQUALS: return ">>=";
        case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS: return ">>>=";
        case Token.AMPERSAND_EQUALS: return "&=";
        case Token.BAR_EQUALS: return "|=";
        case Token.CARET_EQUALS: return "^=";
        default: {
            assert(false);
            return "";
        }
    }
}
exports.operatorTokenToString = operatorTokenToString;
class Range {
    // TODO: set these while tokenizing
    // line: i32;
    // column: i32;
    constructor(source, start, end) {
        this.debugInfoRef = 0;
        this.source = source;
        this.start = start;
        this.end = end;
    }
    static join(a, b) {
        if (a.source != b.source)
            throw new Error("source mismatch");
        return new Range(a.source, a.start < b.start ? a.start : b.start, a.end > b.end ? a.end : b.end);
    }
    get atStart() {
        return new Range(this.source, this.start, this.start);
    }
    get atEnd() {
        return new Range(this.source, this.end, this.end);
    }
    get line() {
        var text = this.source.text;
        var line = 1;
        for (let pos = this.start; pos >= 0; --pos) {
            if (text.charCodeAt(pos) == 10 /* LINEFEED */)
                line++;
        }
        return line;
    }
    get column() {
        var text = this.source.text;
        var column = 0;
        for (let pos = this.start - 1; pos >= 0; --pos) {
            if (text.charCodeAt(pos) == 10 /* LINEFEED */)
                break;
            ++column;
        }
        return column;
    }
    toString() {
        return this.source.text.substring(this.start, this.end);
    }
}
exports.Range = Range;
/** Tokenizes a source to individual {@link Token}s. */
class Tokenizer extends diagnostics_1.DiagnosticEmitter {
    /** Constructs a new tokenizer. */
    constructor(source, diagnostics = null) {
        super(diagnostics);
        this.end = 0;
        this.pos = 0;
        this.token = -1;
        this.tokenPos = 0;
        this.nextToken = -1;
        this.nextTokenPos = 0;
        this.nextTokenOnNewLine = false;
        this.onComment = null;
        this.source = source;
        this.pos = 0;
        this.end = source.text.length;
        this.diagnostics = diagnostics || new Array();
        var end = this.end;
        var text = source.text;
        // skip bom
        if (this.pos < end &&
            text.charCodeAt(this.pos) == 65279 /* BYTEORDERMARK */) {
            ++this.pos;
        }
        // skip shebang
        if (this.pos + 1 < end &&
            text.charCodeAt(this.pos) == 35 /* HASH */ &&
            text.charCodeAt(this.pos + 1) == 33 /* EXCLAMATION */) {
            this.pos += 2;
            while (this.pos < end &&
                text.charCodeAt(this.pos) != 10 /* LINEFEED */) {
                ++this.pos;
            }
            // 'next' now starts at lf or eof
        }
    }
    next(identifierHandling = IdentifierHandling.DEFAULT) {
        this.nextToken = -1;
        return this.token = this.unsafeNext(identifierHandling);
    }
    unsafeNext(identifierHandling = IdentifierHandling.DEFAULT, maxTokenLength = i32.MAX_VALUE) {
        var end = this.end;
        var text = this.source.text;
        while (this.pos < end) {
            this.tokenPos = this.pos;
            let c = text.charCodeAt(this.pos);
            switch (c) {
                case 13 /* CARRIAGERETURN */: {
                    if (!(++this.pos < end &&
                        text.charCodeAt(this.pos) == 10 /* LINEFEED */))
                        break;
                    // otherwise fall-through
                }
                case 10 /* LINEFEED */:
                case 9 /* TAB */:
                case 11 /* VERTICALTAB */:
                case 12 /* FORMFEED */:
                case 32 /* SPACE */: {
                    ++this.pos;
                    break;
                }
                case 33 /* EXCLAMATION */: {
                    ++this.pos;
                    if (maxTokenLength > 1 && this.pos < end &&
                        text.charCodeAt(this.pos) == 61 /* EQUALS */) {
                        ++this.pos;
                        if (maxTokenLength > 2 && this.pos < end &&
                            text.charCodeAt(this.pos) == 61 /* EQUALS */) {
                            ++this.pos;
                            return Token.EXCLAMATION_EQUALS_EQUALS;
                        }
                        return Token.EXCLAMATION_EQUALS;
                    }
                    return Token.EXCLAMATION;
                }
                case 34 /* DOUBLEQUOTE */:
                case 39 /* SINGLEQUOTE */:
                case 96 /* BACKTICK */: { // TODO
                    return Token.STRINGLITERAL; // expects a call to readString
                }
                case 37 /* PERCENT */: {
                    ++this.pos;
                    if (maxTokenLength > 1 && this.pos < end &&
                        text.charCodeAt(this.pos) == 61 /* EQUALS */) {
                        ++this.pos;
                        return Token.PERCENT_EQUALS;
                    }
                    return Token.PERCENT;
                }
                case 38 /* AMPERSAND */: {
                    ++this.pos;
                    if (maxTokenLength > 1 && this.pos < end) {
                        let chr = text.charCodeAt(this.pos);
                        if (chr == 38 /* AMPERSAND */) {
                            ++this.pos;
                            return Token.AMPERSAND_AMPERSAND;
                        }
                        if (chr == 61 /* EQUALS */) {
                            ++this.pos;
                            return Token.AMPERSAND_EQUALS;
                        }
                    }
                    return Token.AMPERSAND;
                }
                case 40 /* OPENPAREN */: {
                    ++this.pos;
                    return Token.OPENPAREN;
                }
                case 41 /* CLOSEPAREN */: {
                    ++this.pos;
                    return Token.CLOSEPAREN;
                }
                case 42 /* ASTERISK */: {
                    ++this.pos;
                    if (maxTokenLength > 1 && this.pos < end) {
                        let chr = text.charCodeAt(this.pos);
                        if (chr == 61 /* EQUALS */) {
                            ++this.pos;
                            return Token.ASTERISK_EQUALS;
                        }
                        if (chr == 42 /* ASTERISK */) {
                            ++this.pos;
                            if (maxTokenLength > 2 && this.pos < end &&
                                text.charCodeAt(this.pos) == 61 /* EQUALS */) {
                                ++this.pos;
                                return Token.ASTERISK_ASTERISK_EQUALS;
                            }
                            return Token.ASTERISK_ASTERISK;
                        }
                    }
                    return Token.ASTERISK;
                }
                case 43 /* PLUS */: {
                    ++this.pos;
                    if (maxTokenLength > 1 && this.pos < end) {
                        let chr = text.charCodeAt(this.pos);
                        if (chr == 43 /* PLUS */) {
                            ++this.pos;
                            return Token.PLUS_PLUS;
                        }
                        if (chr == 61 /* EQUALS */) {
                            ++this.pos;
                            return Token.PLUS_EQUALS;
                        }
                    }
                    return Token.PLUS;
                }
                case 44 /* COMMA */: {
                    ++this.pos;
                    return Token.COMMA;
                }
                case 45 /* MINUS */: {
                    ++this.pos;
                    if (maxTokenLength > 1 && this.pos < end) {
                        let chr = text.charCodeAt(this.pos);
                        if (chr == 45 /* MINUS */) {
                            ++this.pos;
                            return Token.MINUS_MINUS;
                        }
                        if (chr == 61 /* EQUALS */) {
                            ++this.pos;
                            return Token.MINUS_EQUALS;
                        }
                    }
                    return Token.MINUS;
                }
                case 46 /* DOT */: {
                    ++this.pos;
                    if (maxTokenLength > 1 && this.pos < end) {
                        let chr = text.charCodeAt(this.pos);
                        if (util_1.isDecimalDigit(chr)) {
                            --this.pos;
                            return Token.FLOATLITERAL; // expects a call to readFloat
                        }
                        if (maxTokenLength > 2 && this.pos + 1 < end &&
                            chr == 46 /* DOT */ &&
                            text.charCodeAt(this.pos + 1) == 46 /* DOT */) {
                            this.pos += 2;
                            return Token.DOT_DOT_DOT;
                        }
                    }
                    return Token.DOT;
                }
                case 47 /* SLASH */: {
                    let commentStartPos = this.pos;
                    ++this.pos;
                    if (maxTokenLength > 1 && this.pos < end) {
                        let chr = text.charCodeAt(this.pos);
                        if (chr == 47 /* SLASH */) { // single-line
                            let commentKind = ast_1.CommentKind.LINE;
                            if (this.pos + 1 < end &&
                                text.charCodeAt(this.pos + 1) == 47 /* SLASH */) {
                                ++this.pos;
                                commentKind = ast_1.CommentKind.TRIPLE;
                            }
                            while (++this.pos < end) {
                                if (text.charCodeAt(this.pos) == 10 /* LINEFEED */) {
                                    ++this.pos;
                                    break;
                                }
                            }
                            if (this.onComment) {
                                this.onComment(commentKind, text.substring(commentStartPos, this.pos), this.range(commentStartPos, this.pos));
                            }
                            break;
                        }
                        if (chr == 42 /* ASTERISK */) { // multi-line
                            let closed = false;
                            while (++this.pos < end) {
                                c = text.charCodeAt(this.pos);
                                if (c == 42 /* ASTERISK */ &&
                                    this.pos + 1 < end &&
                                    text.charCodeAt(this.pos + 1) == 47 /* SLASH */) {
                                    this.pos += 2;
                                    closed = true;
                                    break;
                                }
                            }
                            if (!closed) {
                                this.error(diagnostics_1.DiagnosticCode._0_expected, this.range(this.pos), "*/");
                            }
                            else if (this.onComment) {
                                this.onComment(ast_1.CommentKind.BLOCK, text.substring(commentStartPos, this.pos), this.range(commentStartPos, this.pos));
                            }
                            break;
                        }
                        if (chr == 61 /* EQUALS */) {
                            ++this.pos;
                            return Token.SLASH_EQUALS;
                        }
                    }
                    return Token.SLASH;
                }
                case 48 /* _0 */:
                case 49 /* _1 */:
                case 50 /* _2 */:
                case 51 /* _3 */:
                case 52 /* _4 */:
                case 53 /* _5 */:
                case 54 /* _6 */:
                case 55 /* _7 */:
                case 56 /* _8 */:
                case 57 /* _9 */: {
                    return this.testInteger()
                        ? Token.INTEGERLITERAL // expects a call to readInteger
                        : Token.FLOATLITERAL; // expects a call to readFloat
                }
                case 58 /* COLON */: {
                    ++this.pos;
                    return Token.COLON;
                }
                case 59 /* SEMICOLON */: {
                    ++this.pos;
                    return Token.SEMICOLON;
                }
                case 60 /* LESSTHAN */: {
                    ++this.pos;
                    if (maxTokenLength > 1 && this.pos < end) {
                        let chr = text.charCodeAt(this.pos);
                        if (chr == 60 /* LESSTHAN */) {
                            ++this.pos;
                            if (maxTokenLength > 2 &&
                                this.pos < end &&
                                text.charCodeAt(this.pos) == 61 /* EQUALS */) {
                                ++this.pos;
                                return Token.LESSTHAN_LESSTHAN_EQUALS;
                            }
                            return Token.LESSTHAN_LESSTHAN;
                        }
                        if (chr == 61 /* EQUALS */) {
                            ++this.pos;
                            return Token.LESSTHAN_EQUALS;
                        }
                    }
                    return Token.LESSTHAN;
                }
                case 61 /* EQUALS */: {
                    ++this.pos;
                    if (maxTokenLength > 1 && this.pos < end) {
                        let chr = text.charCodeAt(this.pos);
                        if (chr == 61 /* EQUALS */) {
                            ++this.pos;
                            if (maxTokenLength > 2 &&
                                this.pos < end &&
                                text.charCodeAt(this.pos) == 61 /* EQUALS */) {
                                ++this.pos;
                                return Token.EQUALS_EQUALS_EQUALS;
                            }
                            return Token.EQUALS_EQUALS;
                        }
                        if (chr == 62 /* GREATERTHAN */) {
                            ++this.pos;
                            return Token.EQUALS_GREATERTHAN;
                        }
                    }
                    return Token.EQUALS;
                }
                case 62 /* GREATERTHAN */: {
                    ++this.pos;
                    if (maxTokenLength > 1 && this.pos < end) {
                        let chr = text.charCodeAt(this.pos);
                        if (chr == 62 /* GREATERTHAN */) {
                            ++this.pos;
                            if (maxTokenLength > 2 && this.pos < end) {
                                chr = text.charCodeAt(this.pos);
                                if (chr == 62 /* GREATERTHAN */) {
                                    ++this.pos;
                                    if (maxTokenLength > 3 && this.pos < end &&
                                        text.charCodeAt(this.pos) == 61 /* EQUALS */) {
                                        ++this.pos;
                                        return Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS;
                                    }
                                    return Token.GREATERTHAN_GREATERTHAN_GREATERTHAN;
                                }
                                if (chr == 61 /* EQUALS */) {
                                    ++this.pos;
                                    return Token.GREATERTHAN_GREATERTHAN_EQUALS;
                                }
                            }
                            return Token.GREATERTHAN_GREATERTHAN;
                        }
                        if (chr == 61 /* EQUALS */) {
                            ++this.pos;
                            return Token.GREATERTHAN_EQUALS;
                        }
                    }
                    return Token.GREATERTHAN;
                }
                case 63 /* QUESTION */: {
                    ++this.pos;
                    return Token.QUESTION;
                }
                case 91 /* OPENBRACKET */: {
                    ++this.pos;
                    return Token.OPENBRACKET;
                }
                case 93 /* CLOSEBRACKET */: {
                    ++this.pos;
                    return Token.CLOSEBRACKET;
                }
                case 94 /* CARET */: {
                    ++this.pos;
                    if (maxTokenLength > 1 && this.pos < end &&
                        text.charCodeAt(this.pos) == 61 /* EQUALS */) {
                        ++this.pos;
                        return Token.CARET_EQUALS;
                    }
                    return Token.CARET;
                }
                case 123 /* OPENBRACE */: {
                    ++this.pos;
                    return Token.OPENBRACE;
                }
                case 124 /* BAR */: {
                    ++this.pos;
                    if (maxTokenLength > 1 && this.pos < end) {
                        let chr = text.charCodeAt(this.pos);
                        if (chr == 124 /* BAR */) {
                            ++this.pos;
                            return Token.BAR_BAR;
                        }
                        if (chr == 61 /* EQUALS */) {
                            ++this.pos;
                            return Token.BAR_EQUALS;
                        }
                    }
                    return Token.BAR;
                }
                case 125 /* CLOSEBRACE */: {
                    ++this.pos;
                    return Token.CLOSEBRACE;
                }
                case 126 /* TILDE */: {
                    ++this.pos;
                    return Token.TILDE;
                }
                case 64 /* AT */: {
                    ++this.pos;
                    return Token.AT;
                }
                default: {
                    if (util_1.isIdentifierStart(c)) {
                        if (util_1.isKeywordCharacter(c)) {
                            let posBefore = this.pos;
                            while (++this.pos < end &&
                                util_1.isIdentifierPart(c = text.charCodeAt(this.pos))) {
                                if (!util_1.isKeywordCharacter(c)) {
                                    this.pos = posBefore;
                                    return Token.IDENTIFIER;
                                }
                            }
                            let keywordText = text.substring(posBefore, this.pos);
                            let keywordToken = tokenFromKeyword(keywordText);
                            if (keywordToken !== Token.INVALID &&
                                identifierHandling !== IdentifierHandling.ALWAYS &&
                                !(identifierHandling === IdentifierHandling.PREFER &&
                                    tokenIsAlsoIdentifier(keywordToken))) {
                                return keywordToken;
                            }
                            this.pos = posBefore;
                        }
                        return Token.IDENTIFIER; // expects a call to readIdentifier
                    }
                    else if (util_1.isWhiteSpace(c)) {
                        ++this.pos;
                        break;
                    }
                    this.error(diagnostics_1.DiagnosticCode.Invalid_character, this.range(this.pos, this.pos + 1));
                    ++this.pos;
                    return Token.INVALID;
                }
            }
        }
        return Token.ENDOFFILE;
    }
    peek(checkOnNewLine = false, identifierHandling = IdentifierHandling.DEFAULT, maxCompoundLength = i32.MAX_VALUE) {
        var text = this.source.text;
        if (this.nextToken < 0) {
            let posBefore = this.pos;
            let tokenBefore = this.token;
            let tokenPosBefore = this.tokenPos;
            this.nextToken = this.unsafeNext(identifierHandling, maxCompoundLength);
            this.nextTokenPos = this.tokenPos;
            if (checkOnNewLine) {
                this.nextTokenOnNewLine = false;
                for (let pos = posBefore, end = this.nextTokenPos; pos < end; ++pos) {
                    if (util_1.isLineBreak(text.charCodeAt(pos))) {
                        this.nextTokenOnNewLine = true;
                        break;
                    }
                }
            }
            this.pos = posBefore;
            this.token = tokenBefore;
            this.tokenPos = tokenPosBefore;
        }
        return this.nextToken;
    }
    skipIdentifier(identifierHandling = IdentifierHandling.PREFER) {
        return this.skip(Token.IDENTIFIER, identifierHandling);
    }
    skip(token, identifierHandling = IdentifierHandling.DEFAULT) {
        var posBefore = this.pos;
        var tokenBefore = this.token;
        var tokenPosBefore = this.tokenPos;
        var maxCompoundLength = i32.MAX_VALUE;
        switch (token) {
            case Token.GREATERTHAN: { // where parsing type arguments
                maxCompoundLength = 1;
                break;
            }
        }
        this.token = this.unsafeNext(identifierHandling, maxCompoundLength);
        if (this.token == token) {
            this.nextToken = -1;
            return true;
        }
        else {
            this.pos = posBefore;
            this.token = tokenBefore;
            this.tokenPos = tokenPosBefore;
            return false;
        }
    }
    mark() {
        var state;
        if (reusableState) {
            state = reusableState;
            reusableState = null;
        }
        else {
            state = new State();
        }
        state.pos = this.pos;
        state.token = this.token;
        state.tokenPos = this.tokenPos;
        return state;
    }
    discard(state) {
        reusableState = state;
    }
    reset(state) {
        this.pos = state.pos;
        this.token = state.token;
        this.tokenPos = state.tokenPos;
        this.nextToken = -1;
    }
    range(start = -1, end = -1) {
        if (start < 0) {
            start = this.tokenPos;
            end = this.pos;
        }
        else if (end < 0) {
            end = start;
        }
        return new Range(this.source, start, end);
    }
    readIdentifier() {
        var text = this.source.text;
        var start = this.pos;
        var end = this.end;
        while (++this.pos < end &&
            util_1.isIdentifierPart(text.charCodeAt(this.pos)))
            ;
        return text.substring(start, this.pos);
    }
    readString() {
        var text = this.source.text;
        var quote = text.charCodeAt(this.pos++);
        var start = this.pos;
        var end = this.end;
        var result = "";
        while (true) {
            if (this.pos >= end) {
                result += text.substring(start, this.pos);
                this.error(diagnostics_1.DiagnosticCode.Unterminated_string_literal, this.range(start - 1, end));
                break;
            }
            let c = text.charCodeAt(this.pos);
            if (c == quote) {
                result += text.substring(start, this.pos++);
                break;
            }
            if (c == 92 /* BACKSLASH */) {
                result += text.substring(start, this.pos);
                result += this.readEscapeSequence();
                start = this.pos;
                continue;
            }
            if (util_1.isLineBreak(c) && quote != 96 /* BACKTICK */) {
                result += text.substring(start, this.pos);
                this.error(diagnostics_1.DiagnosticCode.Unterminated_string_literal, this.range(start - 1, this.pos));
                break;
            }
            ++this.pos;
        }
        return result;
    }
    readEscapeSequence() {
        var end = this.end;
        if (++this.pos >= end) {
            this.error(diagnostics_1.DiagnosticCode.Unexpected_end_of_text, this.range(end));
            return "";
        }
        var text = this.source.text;
        var c = text.charCodeAt(this.pos++);
        switch (c) {
            case 48 /* _0 */: return "\0";
            case 98 /* b */: return "\b";
            case 116 /* t */: return "\t";
            case 110 /* n */: return "\n";
            case 118 /* v */: return "\v";
            case 102 /* f */: return "\f";
            case 114 /* r */: return "\r";
            case 39 /* SINGLEQUOTE */: return "'";
            case 34 /* DOUBLEQUOTE */: return "\"";
            case 117 /* u */: {
                if (this.pos < end &&
                    text.charCodeAt(this.pos) == 123 /* OPENBRACE */) {
                    ++this.pos;
                    return this.readExtendedUnicodeEscape(); // \u{DDDDDDDD}
                }
                return this.readUnicodeEscape(); // \uDDDD
            }
            case 13 /* CARRIAGERETURN */: {
                if (this.pos < end &&
                    text.charCodeAt(this.pos) == 10 /* LINEFEED */) {
                    ++this.pos;
                }
                // fall through
            }
            case 10 /* LINEFEED */:
            case 8232 /* LINESEPARATOR */:
            case 8233 /* PARAGRAPHSEPARATOR */: return "";
            default: return String.fromCharCode(c);
        }
    }
    readRegexpPattern() {
        var text = this.source.text;
        var start = this.pos;
        var end = this.end;
        var escaped = false;
        while (true) {
            if (this.pos >= end) {
                this.error(diagnostics_1.DiagnosticCode.Unterminated_regular_expression_literal, this.range(start, end));
                break;
            }
            if (text.charCodeAt(this.pos) == 92 /* BACKSLASH */) {
                ++this.pos;
                escaped = true;
                continue;
            }
            let c = text.charCodeAt(this.pos);
            if (!escaped && c == 47 /* SLASH */)
                break;
            if (util_1.isLineBreak(c)) {
                this.error(diagnostics_1.DiagnosticCode.Unterminated_regular_expression_literal, this.range(start, this.pos));
                break;
            }
            ++this.pos;
            escaped = false;
        }
        return text.substring(start, this.pos);
    }
    readRegexpFlags() {
        var text = this.source.text;
        var start = this.pos;
        var end = this.end;
        var flags = 0;
        while (this.pos < end) {
            let c = text.charCodeAt(this.pos);
            if (!util_1.isIdentifierPart(c))
                break;
            ++this.pos;
            // make sure each supported flag is unique
            switch (c) {
                case 103 /* g */: {
                    flags |= flags & 1 ? -1 : 1;
                    break;
                }
                case 105 /* i */: {
                    flags |= flags & 2 ? -1 : 2;
                    break;
                }
                case 109 /* m */: {
                    flags |= flags & 4 ? -1 : 4;
                    break;
                }
                default: {
                    flags = -1;
                    break;
                }
            }
        }
        if (flags == -1) {
            this.error(diagnostics_1.DiagnosticCode.Invalid_regular_expression_flags, this.range(start, this.pos));
        }
        return text.substring(start, this.pos);
    }
    testInteger() {
        var end = this.end;
        var text = this.source.text;
        if (this.pos + 1 < end && text.charCodeAt(this.pos) == 48 /* _0 */) {
            switch (text.charCodeAt(this.pos + 2)) {
                case 120 /* x */:
                case 88 /* X */:
                case 98 /* b */:
                case 66 /* B */:
                case 111 /* o */:
                case 79 /* O */: return true;
            }
        }
        var pos = this.pos;
        while (pos < end) {
            let c = text.charCodeAt(pos);
            if (c == 46 /* DOT */ || c == 101 /* e */ || c == 69 /* E */)
                return false;
            if ((c < 48 /* _0 */ || c > 57 /* _9 */) && c != 95 /* _ */)
                break;
            // does not validate separator placement (this is done in readXYInteger)
            pos++;
        }
        return true;
    }
    readInteger() {
        var text = this.source.text;
        if (this.pos + 2 < this.end && text.charCodeAt(this.pos) == 48 /* _0 */) {
            switch (text.charCodeAt(this.pos + 1)) {
                case 120 /* x */:
                case 88 /* X */: {
                    this.pos += 2;
                    return this.readHexInteger();
                }
                case 98 /* b */:
                case 66 /* B */: {
                    this.pos += 2;
                    return this.readBinaryInteger();
                }
                case 111 /* o */:
                case 79 /* O */: {
                    this.pos += 2;
                    return this.readOctalInteger();
                }
            }
            if (util_1.isOctalDigit(text.charCodeAt(this.pos + 1))) {
                let start = this.pos;
                ++this.pos;
                let value = this.readOctalInteger();
                this.error(diagnostics_1.DiagnosticCode.Octal_literals_are_not_allowed_in_strict_mode, this.range(start, this.pos));
                return value;
            }
        }
        return this.readDecimalInteger();
    }
    readHexInteger() {
        var text = this.source.text;
        var start = this.pos;
        var value = i64_new(0);
        var i64_4 = i64_new(4);
        var sepEnd = start;
        var end = this.end;
        while (this.pos < end) {
            let pos = this.pos;
            let c = text.charCodeAt(pos);
            if (c >= 48 /* _0 */ && c <= 57 /* _9 */) {
                // value = (value << 4) + c - CharCode._0;
                value = i64_add(i64_shl(value, i64_4), i64_new(c - 48 /* _0 */));
            }
            else if (c >= 65 /* A */ && c <= 70 /* F */) {
                // value = (value << 4) + 10 + c - CharCode.A;
                value = i64_add(i64_shl(value, i64_4), i64_new(10 + c - 65 /* A */));
            }
            else if (c >= 97 /* a */ && c <= 102 /* f */) {
                // value = (value << 4) + 10 + c - CharCode.a;
                value = i64_add(i64_shl(value, i64_4), i64_new(10 + c - 97 /* a */));
            }
            else if (c == 95 /* _ */) {
                if (sepEnd == pos) {
                    this.error(sepEnd == start
                        ? diagnostics_1.DiagnosticCode.Numeric_separators_are_not_allowed_here
                        : diagnostics_1.DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted, this.range(pos));
                }
                sepEnd = pos + 1;
            }
            else {
                break;
            }
            this.pos = pos + 1;
        }
        if (this.pos == start) {
            this.error(diagnostics_1.DiagnosticCode.Hexadecimal_digit_expected, this.range(start));
        }
        else if (sepEnd == this.pos) {
            this.error(diagnostics_1.DiagnosticCode.Numeric_separators_are_not_allowed_here, this.range(sepEnd - 1));
        }
        return value;
    }
    readDecimalInteger() {
        var text = this.source.text;
        var start = this.pos;
        var end = this.end;
        var value = i64_new(0);
        var i64_10 = i64_new(10);
        var sepEnd = start;
        while (this.pos < end) {
            let pos = this.pos;
            let c = text.charCodeAt(pos);
            if (c >= 48 /* _0 */ && c <= 57 /* _9 */) {
                // value = value * 10 + c - CharCode._0;
                value = i64_add(i64_mul(value, i64_10), i64_new(c - 48 /* _0 */));
            }
            else if (c == 95 /* _ */) {
                if (sepEnd == pos) {
                    this.error(sepEnd == start
                        ? diagnostics_1.DiagnosticCode.Numeric_separators_are_not_allowed_here
                        : diagnostics_1.DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted, this.range(pos));
                }
                sepEnd = pos + 1;
            }
            else {
                break;
            }
            this.pos = pos + 1;
        }
        if (this.pos == start) {
            this.error(diagnostics_1.DiagnosticCode.Digit_expected, this.range(start));
        }
        else if (sepEnd == this.pos) {
            this.error(diagnostics_1.DiagnosticCode.Numeric_separators_are_not_allowed_here, this.range(sepEnd - 1));
        }
        return value;
    }
    readOctalInteger() {
        var text = this.source.text;
        var start = this.pos;
        var value = i64_new(0);
        var i64_3 = i64_new(3);
        var sepEnd = start;
        var end = this.end;
        while (this.pos < end) {
            let pos = this.pos;
            let c = text.charCodeAt(pos);
            if (c >= 48 /* _0 */ && c <= 55 /* _7 */) {
                // value = (value << 3) + c - CharCode._0;
                value = i64_add(i64_shl(value, i64_3), i64_new(c - 48 /* _0 */));
            }
            else if (c == 95 /* _ */) {
                if (sepEnd == pos) {
                    this.error(sepEnd == start
                        ? diagnostics_1.DiagnosticCode.Numeric_separators_are_not_allowed_here
                        : diagnostics_1.DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted, this.range(pos));
                }
                sepEnd = pos + 1;
            }
            else {
                break;
            }
            ++this.pos;
        }
        if (this.pos == start) {
            this.error(diagnostics_1.DiagnosticCode.Octal_digit_expected, this.range(start));
        }
        else if (sepEnd == this.pos) {
            this.error(diagnostics_1.DiagnosticCode.Numeric_separators_are_not_allowed_here, this.range(sepEnd - 1));
        }
        return value;
    }
    readBinaryInteger() {
        var text = this.source.text;
        var start = this.pos;
        var value = i64_new(0);
        var i64_1 = i64_new(1);
        var sepEnd = start;
        var end = this.end;
        while (this.pos < end) {
            let pos = this.pos;
            let c = text.charCodeAt(pos);
            if (c == 48 /* _0 */) {
                // value = (value << 1);
                value = i64_shl(value, i64_1);
            }
            else if (c == 49 /* _1 */) {
                // value = (value << 1) + 1;
                value = i64_add(i64_shl(value, i64_1), i64_1);
            }
            else if (c == 95 /* _ */) {
                if (sepEnd == pos) {
                    this.error(sepEnd == start
                        ? diagnostics_1.DiagnosticCode.Numeric_separators_are_not_allowed_here
                        : diagnostics_1.DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted, this.range(pos));
                }
                sepEnd = pos + 1;
            }
            else {
                break;
            }
            this.pos = pos + 1;
        }
        if (this.pos == start) {
            this.error(diagnostics_1.DiagnosticCode.Binary_digit_expected, this.range(start));
        }
        else if (sepEnd == this.pos) {
            this.error(diagnostics_1.DiagnosticCode.Numeric_separators_are_not_allowed_here, this.range(sepEnd - 1));
        }
        return value;
    }
    readFloat() {
        // var text = this.source.text;
        // if (text.charCodeAt(this.pos) == CharCode._0 && this.pos + 2 < this.end) {
        //   switch (text.charCodeAt(this.pos + 1)) {
        //     case CharCode.X:
        //     case CharCode.x: {
        //       this.pos += 2;
        //       return this.readHexFloat();
        //     }
        //   }
        // }
        return this.readDecimalFloat();
    }
    readDecimalFloat() {
        // TODO: numeric separators (parseFloat can't handle these)
        var start = this.pos;
        var end = this.end;
        var text = this.source.text;
        while (this.pos < end && util_1.isDecimalDigit(text.charCodeAt(this.pos))) {
            ++this.pos;
        }
        if (this.pos < end && text.charCodeAt(this.pos) == 46 /* DOT */) {
            ++this.pos;
            while (this.pos < end && util_1.isDecimalDigit(text.charCodeAt(this.pos))) {
                ++this.pos;
            }
        }
        if (this.pos < end) {
            let c = text.charCodeAt(this.pos);
            if (c == 101 /* e */ || c == 69 /* E */) {
                if (++this.pos < end &&
                    (c = text.charCodeAt(this.pos)) == 45 /* MINUS */ || c == 43 /* PLUS */ &&
                    util_1.isDecimalDigit(text.charCodeAt(this.pos + 1))) {
                    ++this.pos;
                }
                while (this.pos < end && util_1.isDecimalDigit(text.charCodeAt(this.pos))) {
                    ++this.pos;
                }
            }
        }
        return parseFloat(text.substring(start, this.pos));
    }
    readHexFloat() {
        throw new Error("not implemented"); // TBD
    }
    readUnicodeEscape() {
        var remain = 4;
        var value = 0;
        var end = this.end;
        var text = this.source.text;
        while (this.pos < end) {
            let c = text.charCodeAt(this.pos++);
            if (c >= 48 /* _0 */ && c <= 57 /* _9 */) {
                value = (value << 4) + c - 48 /* _0 */;
            }
            else if (c >= 65 /* A */ && c <= 70 /* F */) {
                value = (value << 4) + c + (10 - 65 /* A */);
            }
            else if (c >= 97 /* a */ && c <= 102 /* f */) {
                value = (value << 4) + c + (10 - 97 /* a */);
            }
            else {
                this.error(diagnostics_1.DiagnosticCode.Hexadecimal_digit_expected, this.range(this.pos - 1, this.pos));
                return "";
            }
            if (--remain == 0)
                break;
        }
        if (remain) {
            this.error(diagnostics_1.DiagnosticCode.Unexpected_end_of_text, this.range(this.pos));
            return "";
        }
        return String.fromCharCode(value);
    }
    readExtendedUnicodeEscape() {
        var start = this.pos;
        var value = this.readHexInteger();
        var value32 = i64_low(value);
        var invalid = false;
        assert(!i64_high(value));
        if (value32 > 0x10FFFF) {
            this.error(diagnostics_1.DiagnosticCode.An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive, this.range(start, this.pos));
            invalid = true;
        }
        var end = this.end;
        var text = this.source.text;
        if (this.pos >= end) {
            this.error(diagnostics_1.DiagnosticCode.Unexpected_end_of_text, this.range(start, end));
            invalid = true;
        }
        else if (text.charCodeAt(this.pos) == 125 /* CLOSEBRACE */) {
            ++this.pos;
        }
        else {
            this.error(diagnostics_1.DiagnosticCode.Unterminated_Unicode_escape_sequence, this.range(start, this.pos));
            invalid = true;
        }
        if (invalid)
            return "";
        return value32 < 65536
            ? String.fromCharCode(value32)
            : String.fromCharCode(((value32 - 65536) >>> 10) + 0xD800, ((value32 - 65536) & 1023) + 0xDC00);
    }
    finish() {
    }
}
exports.Tokenizer = Tokenizer;
/** Tokenizer state as returned by {@link Tokenizer#mark} and consumed by {@link Tokenizer#reset}. */
class State {
}
exports.State = State;
// Reusable state object to reduce allocations
var reusableState = null;


/***/ }),

/***/ "./src/types.ts":
/*!**********************!*\
  !*** ./src/types.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Mappings from AssemblyScript types to WebAssembly types.
 * @module types
 */ /***/
Object.defineProperty(exports, "__esModule", { value: true });
const program_1 = __webpack_require__(/*! ./program */ "./src/program.ts");
const module_1 = __webpack_require__(/*! ./module */ "./src/module.ts");
/** Indicates the kind of a type. */
var TypeKind;
(function (TypeKind) {
    // signed integers
    /** An 8-bit signed integer. */
    TypeKind[TypeKind["I8"] = 0] = "I8";
    /** A 16-bit signed integer. */
    TypeKind[TypeKind["I16"] = 1] = "I16";
    /** A 32-bit signed integer. */
    TypeKind[TypeKind["I32"] = 2] = "I32";
    /** A 64-bit signed integer. */
    TypeKind[TypeKind["I64"] = 3] = "I64";
    /** A 32-bit/64-bit signed integer, depending on the target. */
    TypeKind[TypeKind["ISIZE"] = 4] = "ISIZE";
    // unsigned integers
    /** An 8-bit unsigned integer. */
    TypeKind[TypeKind["U8"] = 5] = "U8";
    /** A 16-bit unsigned integer. */
    TypeKind[TypeKind["U16"] = 6] = "U16";
    /** A 32-bit unsigned integer. Also the base of function types. */
    TypeKind[TypeKind["U32"] = 7] = "U32";
    /** A 64-bit unsigned integer. */
    TypeKind[TypeKind["U64"] = 8] = "U64";
    /** A 32-bit/64-bit unsigned integer, depending on the target. Also the base of class types. */
    TypeKind[TypeKind["USIZE"] = 9] = "USIZE";
    /** A 1-bit unsigned integer. */
    TypeKind[TypeKind["BOOL"] = 10] = "BOOL";
    // floats
    /** A 32-bit float. */
    TypeKind[TypeKind["F32"] = 11] = "F32";
    /** A 64-bit double. */
    TypeKind[TypeKind["F64"] = 12] = "F64";
    // vectors
    /** A 128-bit vector. */
    TypeKind[TypeKind["V128"] = 13] = "V128";
    // references
    /** A host reference. */
    TypeKind[TypeKind["ANYREF"] = 14] = "ANYREF";
    // other
    /** No return type. */
    TypeKind[TypeKind["VOID"] = 15] = "VOID";
})(TypeKind = exports.TypeKind || (exports.TypeKind = {}));
/** Indicates capabilities of a type. */
var TypeFlags;
(function (TypeFlags) {
    TypeFlags[TypeFlags["NONE"] = 0] = "NONE";
    /** Is a signed type that can represent negative values. */
    TypeFlags[TypeFlags["SIGNED"] = 1] = "SIGNED";
    /** Is an unsigned type that cannot represent negative values. */
    TypeFlags[TypeFlags["UNSIGNED"] = 2] = "UNSIGNED";
    /** Is an integer type. */
    TypeFlags[TypeFlags["INTEGER"] = 4] = "INTEGER";
    /** Is a floating point type. */
    TypeFlags[TypeFlags["FLOAT"] = 8] = "FLOAT";
    /** Is a pointer type. */
    TypeFlags[TypeFlags["POINTER"] = 16] = "POINTER";
    /** Is smaller than 32-bits. */
    TypeFlags[TypeFlags["SHORT"] = 32] = "SHORT";
    /** Is larger than 32-bits. */
    TypeFlags[TypeFlags["LONG"] = 64] = "LONG";
    /** Is a value type. */
    TypeFlags[TypeFlags["VALUE"] = 128] = "VALUE";
    /** Is a reference type (either a class or a function type). */
    TypeFlags[TypeFlags["REFERENCE"] = 256] = "REFERENCE";
    /** Is a nullable type. */
    TypeFlags[TypeFlags["NULLABLE"] = 512] = "NULLABLE";
    /** Is a vector type. */
    TypeFlags[TypeFlags["VECTOR"] = 1024] = "VECTOR";
})(TypeFlags = exports.TypeFlags || (exports.TypeFlags = {}));
const v128_zero = new Uint8Array(16);
/** Represents a resolved type. */
class Type {
    /** Constructs a new resolved type. */
    constructor(kind, flags, size) {
        /** Cached nullable type, if non-nullable. */
        this.cachedNullableType = null;
        this.kind = kind;
        this.flags = flags;
        this.size = size;
        this.byteSize = ceil(size / 8);
        this.classReference = null;
        this.signatureReference = null;
        this.nonNullableType = this;
    }
    /** Returns the closest int type representing this type. */
    get intType() {
        switch (this.kind) {
            case 0 /* I8 */: return Type.i8;
            case 1 /* I16 */: return Type.i16;
            case 11 /* F32 */:
            case 2 /* I32 */: return Type.i32;
            case 12 /* F64 */:
            case 3 /* I64 */: return Type.i64;
            case 4 /* ISIZE */: return this.size == 64 ? Type.isize64 : Type.isize32;
            case 5 /* U8 */: return Type.u8;
            case 6 /* U16 */: return Type.u16;
            case 7 /* U32 */: return Type.u32;
            case 8 /* U64 */: return Type.u64;
            case 9 /* USIZE */: return this.size == 64 ? Type.usize64 : Type.usize32;
            case 10 /* BOOL */:
            default: return Type.i32;
        }
    }
    /** Substitutes this type with the auto type if this type is void. */
    get exceptVoid() {
        if (this.kind == 15 /* VOID */)
            return Type.auto;
        return this;
    }
    /** Gets this type's logarithmic alignment in memory. */
    get alignLog2() {
        return 31 - clz(this.byteSize);
    }
    /** Tests if this is a managed type that needs GC hooks. */
    get isManaged() {
        var classReference = this.classReference;
        return classReference !== null && !classReference.hasDecorator(program_1.DecoratorFlags.UNMANAGED);
    }
    /** Tests if this is a class type explicitly annotated as unmanaged. */
    get isUnmanaged() {
        var classReference = this.classReference;
        return classReference !== null && classReference.hasDecorator(program_1.DecoratorFlags.UNMANAGED);
    }
    /** Computes the sign-extending shift in the target type. */
    computeSmallIntegerShift(targetType) {
        return targetType.size - this.size;
    }
    /** Computes the truncating mask in the target type. */
    computeSmallIntegerMask(targetType) {
        var size = this.is(2 /* UNSIGNED */) ? this.size : this.size - 1;
        return ~0 >>> (targetType.size - size);
    }
    /** Tests if this type has (all of) the specified flags. */
    is(flags) { return (this.flags & flags) == flags; }
    /** Tests if this type has any of the specified flags. */
    isAny(flags) { return (this.flags & flags) != 0; }
    /** Composes a class type from this type and a class. */
    asClass(classType) {
        assert(this.kind == 9 /* USIZE */ && !this.classReference);
        var ret = new Type(this.kind, this.flags & ~128 /* VALUE */ | 256 /* REFERENCE */, this.size);
        ret.classReference = classType;
        return ret;
    }
    /** Composes a function type from this type and a function. */
    asFunction(signature) {
        assert(this.kind == 7 /* U32 */ && !this.signatureReference);
        var ret = new Type(this.kind, this.flags & ~128 /* VALUE */ | 256 /* REFERENCE */, this.size);
        ret.signatureReference = signature;
        return ret;
    }
    /** Composes the respective nullable type of this type. */
    asNullable() {
        assert(this.is(256 /* REFERENCE */));
        if (!this.cachedNullableType) {
            assert(!this.is(512 /* NULLABLE */));
            this.cachedNullableType = new Type(this.kind, this.flags | 512 /* NULLABLE */, this.size);
            this.cachedNullableType.nonNullableType = this;
            this.cachedNullableType.classReference = this.classReference; // either a class reference
            this.cachedNullableType.signatureReference = this.signatureReference; // or a function reference
        }
        return this.cachedNullableType;
    }
    /** Tests if a value of this type is assignable to the target type incl. implicit conversion. */
    isAssignableTo(target, signednessIsRelevant = false) {
        var currentClass;
        var targetClass;
        var currentFunction;
        var targetFunction;
        if (this.is(256 /* REFERENCE */)) {
            if (target.is(256 /* REFERENCE */)) {
                if (!this.is(512 /* NULLABLE */) || target.is(512 /* NULLABLE */)) {
                    if (currentClass = this.classReference) {
                        if (targetClass = target.classReference) {
                            return currentClass.isAssignableTo(targetClass);
                        }
                    }
                    else if (currentFunction = this.signatureReference) {
                        if (targetFunction = target.signatureReference) {
                            return currentFunction.isAssignableTo(targetFunction);
                        }
                    }
                    else if (this.kind == 14 /* ANYREF */ && target.kind == 14 /* ANYREF */) {
                        return true;
                    }
                }
            }
        }
        else if (!target.is(256 /* REFERENCE */)) {
            if (this.is(4 /* INTEGER */)) {
                if (target.is(4 /* INTEGER */)) {
                    if (!signednessIsRelevant ||
                        this == Type.bool || // a bool (0 or 1) can be safely assigned to all sorts of integers
                        this.is(1 /* SIGNED */) == target.is(1 /* SIGNED */)) {
                        return this.size <= target.size;
                    }
                }
                else if (target.kind == 11 /* F32 */) {
                    return this.size <= 23; // mantissa bits
                }
                else if (target.kind == 12 /* F64 */) {
                    return this.size <= 52; // ^
                }
            }
            else if (this.is(8 /* FLOAT */)) {
                if (target.is(8 /* FLOAT */)) {
                    return this.size <= target.size;
                }
            }
            else if (this.is(1024 /* VECTOR */)) {
                if (target.is(1024 /* VECTOR */)) {
                    return this.size == target.size;
                }
            }
        }
        return false;
    }
    /** Tests if a value of this type is assignable to the target type excl. implicit conversion. */
    isStrictlyAssignableTo(target, signednessIsRelevant = false) {
        if (this.is(256 /* REFERENCE */))
            return this.isAssignableTo(target);
        else if (target.is(256 /* REFERENCE */))
            return false;
        if (this.is(4 /* INTEGER */)) {
            return target.is(4 /* INTEGER */) && target.size == this.size && (!signednessIsRelevant || this.is(1 /* SIGNED */) == target.is(1 /* SIGNED */));
        }
        return this.kind == target.kind;
    }
    /** Tests if a value of this type can be changed to the target type using `changetype`. */
    isChangeableTo(target) {
        if (this.is(4 /* INTEGER */) && target.is(4 /* INTEGER */)) {
            let size = this.size;
            return size == target.size && (size >= 32 || this.is(1 /* SIGNED */) == target.is(1 /* SIGNED */));
        }
        return this.kind == target.kind;
    }
    /** Determines the common denominator type of two types, if there is any. */
    static commonDenominator(left, right, signednessIsImportant) {
        if (right.isAssignableTo(left, signednessIsImportant))
            return left;
        else if (left.isAssignableTo(right, signednessIsImportant))
            return right;
        return null;
    }
    /** Converts this type to a string. */
    toString() {
        if (this.is(256 /* REFERENCE */)) {
            let classReference = this.classReference;
            if (classReference) {
                return this.is(512 /* NULLABLE */)
                    ? classReference.internalName + " | null"
                    : classReference.internalName;
            }
            let signatureReference = this.signatureReference;
            if (signatureReference) {
                return this.is(512 /* NULLABLE */)
                    ? "(" + signatureReference.toString() + ") | null"
                    : signatureReference.toString();
            }
            // TODO: Reflect.apply(value, "toString", []) ?
            assert(this.kind == 14 /* ANYREF */);
            return "anyref";
        }
        switch (this.kind) {
            case 0 /* I8 */: return "i8";
            case 1 /* I16 */: return "i16";
            case 2 /* I32 */: return "i32";
            case 3 /* I64 */: return "i64";
            case 4 /* ISIZE */: return "isize";
            case 5 /* U8 */: return "u8";
            case 6 /* U16 */: return "u16";
            case 7 /* U32 */: return "u32";
            case 8 /* U64 */: return "u64";
            case 9 /* USIZE */: return "usize";
            case 10 /* BOOL */: return "bool";
            case 11 /* F32 */: return "f32";
            case 12 /* F64 */: return "f64";
            case 13 /* V128 */: return "v128";
            case 14 /* ANYREF */: return "anyref";
            default: assert(false);
            case 15 /* VOID */: return "void";
        }
    }
    // Binaryen specific
    /** Converts this type to its respective native type. */
    toNativeType() {
        switch (this.kind) {
            default: return module_1.NativeType.I32;
            case 3 /* I64 */:
            case 8 /* U64 */: return module_1.NativeType.I64;
            case 4 /* ISIZE */:
            case 9 /* USIZE */: return this.size == 64 ? module_1.NativeType.I64 : module_1.NativeType.I32;
            case 11 /* F32 */: return module_1.NativeType.F32;
            case 12 /* F64 */: return module_1.NativeType.F64;
            case 13 /* V128 */: return module_1.NativeType.V128;
            case 14 /* ANYREF */: return module_1.NativeType.Anyref;
            case 15 /* VOID */: return module_1.NativeType.None;
        }
    }
    /** Converts this type to its native `0` value. */
    toNativeZero(module) {
        switch (this.kind) {
            case 14 /* ANYREF */:
            case 15 /* VOID */: assert(false);
            default: return module.i32(0);
            case 4 /* ISIZE */:
            case 9 /* USIZE */: if (this.size != 64)
                return module.i32(0);
            case 3 /* I64 */:
            case 8 /* U64 */: return module.i64(0);
            case 11 /* F32 */: return module.f32(0);
            case 12 /* F64 */: return module.f64(0);
            case 13 /* V128 */: return module.v128(v128_zero);
        }
    }
    /** Converts this type to its native `1` value. */
    toNativeOne(module) {
        switch (this.kind) {
            case 13 /* V128 */:
            case 14 /* ANYREF */:
            case 15 /* VOID */: assert(false);
            default: return module.i32(1);
            case 4 /* ISIZE */:
            case 9 /* USIZE */: if (this.size != 64)
                return module.i32(1);
            case 3 /* I64 */:
            case 8 /* U64 */: return module.i64(1);
            case 11 /* F32 */: return module.f32(1);
            case 12 /* F64 */: return module.f64(1);
        }
    }
    /** Converts this type to its native `-1` value. */
    toNativeNegOne(module) {
        switch (this.kind) {
            case 13 /* V128 */:
            case 14 /* ANYREF */:
            case 15 /* VOID */: assert(false);
            default: return module.i32(-1);
            case 4 /* ISIZE */:
            case 9 /* USIZE */: if (this.size != 64)
                return module.i32(-1);
            case 3 /* I64 */:
            case 8 /* U64 */: return module.i64(-1, -1);
            case 11 /* F32 */: return module.f32(-1);
            case 12 /* F64 */: return module.f64(-1);
        }
    }
    /** Converts this type to its signature string. */
    toSignatureString() {
        switch (this.kind) {
            // same naming scheme as Binaryen
            case 0 /* I8 */:
            case 5 /* U8 */:
            case 1 /* I16 */:
            case 6 /* U16 */:
            case 2 /* I32 */:
            case 7 /* U32 */:
            case 10 /* BOOL */: return "i";
            case 3 /* I64 */:
            case 8 /* U64 */: return "j";
            case 4 /* ISIZE */:
            case 9 /* USIZE */: return this.size == 64 ? "j" : "i";
            case 11 /* F32 */: return "f";
            case 12 /* F64 */: return "d";
            case 13 /* V128 */: return "V";
            case 14 /* ANYREF */: return "a";
            case 15 /* VOID */: return "v";
            default: assert(false);
        }
        return "i";
    }
}
exports.Type = Type;
// Types
/** An 8-bit signed integer. */
Type.i8 = new Type(0 /* I8 */, 1 /* SIGNED */ |
    32 /* SHORT */ |
    4 /* INTEGER */ |
    128 /* VALUE */, 8);
/** A 16-bit signed integer. */
Type.i16 = new Type(1 /* I16 */, 1 /* SIGNED */ |
    32 /* SHORT */ |
    4 /* INTEGER */ |
    128 /* VALUE */, 16);
/** A 32-bit signed integer. */
Type.i32 = new Type(2 /* I32 */, 1 /* SIGNED */ |
    4 /* INTEGER */ |
    128 /* VALUE */, 32);
/** A 64-bit signed integer. */
Type.i64 = new Type(3 /* I64 */, 1 /* SIGNED */ |
    64 /* LONG */ |
    4 /* INTEGER */ |
    128 /* VALUE */, 64);
/** A 32-bit signed size. WASM32 only. */
Type.isize32 = new Type(4 /* ISIZE */, 1 /* SIGNED */ |
    4 /* INTEGER */ |
    16 /* POINTER */ |
    128 /* VALUE */, 32);
/** A 64-bit signed size. WASM64 only. */
Type.isize64 = new Type(4 /* ISIZE */, 1 /* SIGNED */ |
    64 /* LONG */ |
    4 /* INTEGER */ |
    16 /* POINTER */ |
    128 /* VALUE */, 64);
/** An 8-bit unsigned integer. */
Type.u8 = new Type(5 /* U8 */, 2 /* UNSIGNED */ |
    32 /* SHORT */ |
    4 /* INTEGER */ |
    128 /* VALUE */, 8);
/** A 16-bit unsigned integer. */
Type.u16 = new Type(6 /* U16 */, 2 /* UNSIGNED */ |
    32 /* SHORT */ |
    4 /* INTEGER */ |
    128 /* VALUE */, 16);
/** A 32-bit unsigned integer. */
Type.u32 = new Type(7 /* U32 */, 2 /* UNSIGNED */ |
    4 /* INTEGER */ |
    128 /* VALUE */, 32);
/** A 64-bit unsigned integer. */
Type.u64 = new Type(8 /* U64 */, 2 /* UNSIGNED */ |
    64 /* LONG */ |
    4 /* INTEGER */ |
    128 /* VALUE */, 64);
/** A 32-bit unsigned size. WASM32 only. */
Type.usize32 = new Type(9 /* USIZE */, 2 /* UNSIGNED */ |
    4 /* INTEGER */ |
    16 /* POINTER */ |
    128 /* VALUE */, 32);
/** A 64-bit unsigned size. WASM64 only. */
Type.usize64 = new Type(9 /* USIZE */, 2 /* UNSIGNED */ |
    64 /* LONG */ |
    4 /* INTEGER */ |
    16 /* POINTER */ |
    128 /* VALUE */, 64);
/** A 1-bit unsigned integer. */
Type.bool = new Type(10 /* BOOL */, 2 /* UNSIGNED */ |
    32 /* SHORT */ |
    4 /* INTEGER */ |
    128 /* VALUE */, 1);
/** A 32-bit float. */
Type.f32 = new Type(11 /* F32 */, 1 /* SIGNED */ |
    8 /* FLOAT */ |
    128 /* VALUE */, 32);
/** A 64-bit float. */
Type.f64 = new Type(12 /* F64 */, 1 /* SIGNED */ |
    64 /* LONG */ |
    8 /* FLOAT */ |
    128 /* VALUE */, 64);
/** A 128-bit vector. */
Type.v128 = new Type(13 /* V128 */, 1024 /* VECTOR */ |
    128 /* VALUE */, 128);
/** A host reference. */
Type.anyref = new Type(14 /* ANYREF */, 256 /* REFERENCE */, 0);
/** No return type. */
Type.void = new Type(15 /* VOID */, 0 /* NONE */, 0);
/** Alias of i32 indicating type inference of locals and globals with just an initializer. */
Type.auto = new Type(Type.i32.kind, Type.i32.flags, Type.i32.size);
/** Converts an array of types to an array of native types. */
function typesToNativeTypes(types) {
    var numTypes = types.length;
    var ret = new Array(numTypes);
    for (let i = 0; i < numTypes; ++i)
        ret[i] = types[i].toNativeType();
    return ret;
}
exports.typesToNativeTypes = typesToNativeTypes;
/** Converts an array of types to its combined string representation. */
function typesToString(types) {
    var numTypes = types.length;
    if (!numTypes)
        return "";
    var sb = new Array(numTypes);
    for (let i = 0; i < numTypes; ++i)
        sb[i] = types[i].toString();
    return sb.join(",");
}
exports.typesToString = typesToString;
/** Represents a fully resolved function signature. */
class Signature {
    /** Constructs a new signature. */
    constructor(program, parameterTypes = null, returnType = null, thisType = null) {
        /** The unique program id that represents this signature. */
        this.id = 0;
        /** Cached {@link FunctionTarget}. */
        this.cachedFunctionTarget = null;
        this.parameterTypes = parameterTypes ? parameterTypes : [];
        this.parameterNames = null;
        this.requiredParameters = 0;
        this.returnType = returnType ? returnType : Type.void;
        this.thisType = thisType;
        this.program = program;
        this.hasRest = false;
        this.type = Type.u32.asFunction(this);
        var signatureTypes = program.uniqueSignatures;
        var length = signatureTypes.length;
        for (let i = 0; i < length; i++) {
            let compare = signatureTypes[i];
            if (this.equals(compare)) {
                this.id = compare.id;
                return this;
            }
        }
        program.uniqueSignatures.push(this);
        this.id = program.nextSignatureId++;
    }
    asFunctionTarget(program) {
        var target = this.cachedFunctionTarget;
        if (!target)
            this.cachedFunctionTarget = target = new program_1.FunctionTarget(this, program);
        else
            assert(target.program == program);
        return target;
    }
    /** Gets the known or, alternatively, generic parameter name at the specified index. */
    getParameterName(index) {
        var parameterNames = this.parameterNames;
        return parameterNames && parameterNames.length > index
            ? parameterNames[index]
            : getDefaultParameterName(index);
    }
    /** Tests if a value of this function type is assignable to a target of the specified function type. */
    isAssignableTo(target) {
        return this.equals(target);
    }
    /** Tests to see if a signature equals another signature. */
    equals(value) {
        // TODO: maybe cache results?
        // check `this` type
        var thisThisType = this.thisType;
        var targetThisType = value.thisType;
        if (thisThisType) {
            if (!(targetThisType && thisThisType.isAssignableTo(targetThisType)))
                return false;
        }
        else if (targetThisType) {
            return false;
        }
        // check rest parameter
        if (this.hasRest != value.hasRest)
            return false; // TODO
        // check parameter types
        var thisParameterTypes = this.parameterTypes;
        var targetParameterTypes = value.parameterTypes;
        var numParameters = thisParameterTypes.length;
        if (numParameters != targetParameterTypes.length)
            return false;
        for (let i = 0; i < numParameters; ++i) {
            let thisParameterType = thisParameterTypes[i];
            let targetParameterType = targetParameterTypes[i];
            if (!thisParameterType.isAssignableTo(targetParameterType))
                return false;
        }
        // check return type
        var thisReturnType = this.returnType;
        var targetReturnType = value.returnType;
        return thisReturnType == targetReturnType || thisReturnType.isAssignableTo(targetReturnType);
    }
    /** Converts a signature to a function type string. */
    static makeSignatureString(parameterTypes, returnType, thisType = null) {
        var sb = [];
        sb.push(returnType.toSignatureString());
        if (thisType)
            sb.push(thisType.toSignatureString());
        if (parameterTypes) {
            for (let i = 0, k = parameterTypes.length; i < k; ++i)
                sb.push(parameterTypes[i].toSignatureString());
        }
        return "FUNCSIG$" + sb.join("");
    }
    /** Converts this signature to a function type string. */
    toSignatureString() {
        return Signature.makeSignatureString(this.parameterTypes, this.returnType, this.thisType);
    }
    /** Converts this signature to a string. */
    toString() {
        var sb = new Array();
        sb.push("(");
        var index = 0;
        var thisType = this.thisType;
        if (thisType) {
            sb.push("this: ");
            assert(!thisType.signatureReference);
            sb.push(thisType.toString());
            index = 1;
        }
        var parameters = this.parameterTypes;
        var numParameters = parameters.length;
        if (numParameters) {
            let names = this.parameterNames;
            let numNames = names ? names.length : 0;
            let optionalStart = this.requiredParameters;
            let restIndex = this.hasRest ? numParameters - 1 : -1;
            for (let i = 0; i < numParameters; ++i, ++index) {
                if (index)
                    sb.push(", ");
                if (i == restIndex)
                    sb.push("...");
                if (i < numNames)
                    sb.push(names[i]);
                else
                    sb.push(getDefaultParameterName(i));
                if (i >= optionalStart && i != restIndex)
                    sb.push("?: ");
                else
                    sb.push(": ");
                sb.push(parameters[i].toString());
            }
        }
        sb.push(") => ");
        sb.push(this.returnType.toString());
        return sb.join("");
    }
}
exports.Signature = Signature;
// helpers
// Cached default parameter names used where names are unknown.
var cachedDefaultParameterNames = null;
/** Gets the cached default parameter name for the specified index. */
function getDefaultParameterName(index) {
    if (!cachedDefaultParameterNames)
        cachedDefaultParameterNames = [];
    for (let i = cachedDefaultParameterNames.length; i <= index; ++i) {
        cachedDefaultParameterNames.push("arg$" + i.toString(10));
    }
    return cachedDefaultParameterNames[index - 1];
}
exports.getDefaultParameterName = getDefaultParameterName;


/***/ }),

/***/ "./src/util/binary.ts":
/*!****************************!*\
  !*** ./src/util/binary.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/** @module util */ /***/
Object.defineProperty(exports, "__esModule", { value: true });
/** Reads an 8-bit integer from the specified buffer. */
function readI8(buffer, offset) {
    return buffer[offset];
}
exports.readI8 = readI8;
/** Writes an 8-bit integer to the specified buffer. */
function writeI8(value, buffer, offset) {
    buffer[offset] = value;
}
exports.writeI8 = writeI8;
/** Reads a 16-bit integer from the specified buffer. */
function readI16(buffer, offset) {
    return buffer[offset]
        | buffer[offset + 1] << 8;
}
exports.readI16 = readI16;
/** Writes a 16-bit integer to the specified buffer. */
function writeI16(value, buffer, offset) {
    buffer[offset] = value;
    buffer[offset + 1] = value >>> 8;
}
exports.writeI16 = writeI16;
/** Reads a 32-bit integer from the specified buffer. */
function readI32(buffer, offset) {
    return buffer[offset]
        | buffer[offset + 1] << 8
        | buffer[offset + 2] << 16
        | buffer[offset + 3] << 24;
}
exports.readI32 = readI32;
/** Writes a 32-bit integer to the specified buffer. */
function writeI32(value, buffer, offset) {
    buffer[offset] = value;
    buffer[offset + 1] = value >>> 8;
    buffer[offset + 2] = value >>> 16;
    buffer[offset + 3] = value >>> 24;
}
exports.writeI32 = writeI32;
/** Reads a 64-bit integer from the specified buffer. */
function readI64(buffer, offset) {
    var lo = readI32(buffer, offset);
    var hi = readI32(buffer, offset + 4);
    return i64_new(lo, hi);
}
exports.readI64 = readI64;
/** Writes a 64-bit integer to the specified buffer. */
function writeI64(value, buffer, offset) {
    writeI32(i64_low(value), buffer, offset);
    writeI32(i64_high(value), buffer, offset + 4);
}
exports.writeI64 = writeI64;
/** Reads a 32-bit float from the specified buffer. */
function readF32(buffer, offset) {
    return i32_as_f32(readI32(buffer, offset));
}
exports.readF32 = readF32;
/** Writes a 32-bit float to the specified buffer. */
function writeF32(value, buffer, offset) {
    writeI32(f32_as_i32(value), buffer, offset);
}
exports.writeF32 = writeF32;
/** Reads a 64-bit float from the specified buffer. */
function readF64(buffer, offset) {
    return i64_as_f64(readI64(buffer, offset));
}
exports.readF64 = readF64;
/** Writes a 64-bit float to the specified buffer. */
function writeF64(value, buffer, offset) {
    var valueI64 = f64_as_i64(value);
    writeI32(i64_low(valueI64), buffer, offset);
    writeI32(i64_high(valueI64), buffer, offset + 4);
}
exports.writeF64 = writeF64;


/***/ }),

/***/ "./src/util/bitset.ts":
/*!****************************!*\
  !*** ./src/util/bitset.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/** @module util */ /***/
Object.defineProperty(exports, "__esModule", { value: true });
/** Tests if the bit at the specified index is set within a 64-bit map. */
function bitsetIs(map, index) {
    assert(index >= 0 && index < 64);
    return i64_ne(i64_and(map, i64_shl(i64_one, i64_new(index))), i64_zero);
}
exports.bitsetIs = bitsetIs;
/** Sets or unsets the bit at the specified index within a 64-bit map and returns the new map. */
function bitsetSet(map, index, isSet) {
    assert(index >= 0 && index < 64);
    return isSet
        ? i64_or(map, i64_shl(i64_one, i64_new(index)))
        : i64_and(map, i64_not(i64_shl(i64_one, i64_new(index))));
}
exports.bitsetSet = bitsetSet;


/***/ }),

/***/ "./src/util/charcode.ts":
/*!******************************!*\
  !*** ./src/util/charcode.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/** @module util */ /***/
Object.defineProperty(exports, "__esModule", { value: true });
/** An enum of named character codes. */
var CharCode;
(function (CharCode) {
    CharCode[CharCode["NULL"] = 0] = "NULL";
    CharCode[CharCode["LINEFEED"] = 10] = "LINEFEED";
    CharCode[CharCode["CARRIAGERETURN"] = 13] = "CARRIAGERETURN";
    CharCode[CharCode["LINESEPARATOR"] = 8232] = "LINESEPARATOR";
    CharCode[CharCode["PARAGRAPHSEPARATOR"] = 8233] = "PARAGRAPHSEPARATOR";
    CharCode[CharCode["NEXTLINE"] = 133] = "NEXTLINE";
    CharCode[CharCode["SPACE"] = 32] = "SPACE";
    CharCode[CharCode["NONBREAKINGSPACE"] = 160] = "NONBREAKINGSPACE";
    CharCode[CharCode["ENQUAD"] = 8192] = "ENQUAD";
    CharCode[CharCode["EMQUAD"] = 8193] = "EMQUAD";
    CharCode[CharCode["ENSPACE"] = 8194] = "ENSPACE";
    CharCode[CharCode["EMSPACE"] = 8195] = "EMSPACE";
    CharCode[CharCode["THREEPEREMSPACE"] = 8196] = "THREEPEREMSPACE";
    CharCode[CharCode["FOURPEREMSPACE"] = 8197] = "FOURPEREMSPACE";
    CharCode[CharCode["SIXPEREMSPACE"] = 8198] = "SIXPEREMSPACE";
    CharCode[CharCode["FIGURESPACE"] = 8199] = "FIGURESPACE";
    CharCode[CharCode["PUNCTUATIONSPACE"] = 8200] = "PUNCTUATIONSPACE";
    CharCode[CharCode["THINSPACE"] = 8201] = "THINSPACE";
    CharCode[CharCode["HAIRSPACE"] = 8202] = "HAIRSPACE";
    CharCode[CharCode["ZEROWIDTHSPACE"] = 8203] = "ZEROWIDTHSPACE";
    CharCode[CharCode["NARROWNOBREAKSPACE"] = 8239] = "NARROWNOBREAKSPACE";
    CharCode[CharCode["IDEOGRAPHICSPACE"] = 12288] = "IDEOGRAPHICSPACE";
    CharCode[CharCode["MATHEMATICALSPACE"] = 8287] = "MATHEMATICALSPACE";
    CharCode[CharCode["OGHAM"] = 5760] = "OGHAM";
    CharCode[CharCode["_"] = 95] = "_";
    CharCode[CharCode["_0"] = 48] = "_0";
    CharCode[CharCode["_1"] = 49] = "_1";
    CharCode[CharCode["_2"] = 50] = "_2";
    CharCode[CharCode["_3"] = 51] = "_3";
    CharCode[CharCode["_4"] = 52] = "_4";
    CharCode[CharCode["_5"] = 53] = "_5";
    CharCode[CharCode["_6"] = 54] = "_6";
    CharCode[CharCode["_7"] = 55] = "_7";
    CharCode[CharCode["_8"] = 56] = "_8";
    CharCode[CharCode["_9"] = 57] = "_9";
    CharCode[CharCode["a"] = 97] = "a";
    CharCode[CharCode["b"] = 98] = "b";
    CharCode[CharCode["c"] = 99] = "c";
    CharCode[CharCode["d"] = 100] = "d";
    CharCode[CharCode["e"] = 101] = "e";
    CharCode[CharCode["f"] = 102] = "f";
    CharCode[CharCode["g"] = 103] = "g";
    CharCode[CharCode["h"] = 104] = "h";
    CharCode[CharCode["i"] = 105] = "i";
    CharCode[CharCode["j"] = 106] = "j";
    CharCode[CharCode["k"] = 107] = "k";
    CharCode[CharCode["l"] = 108] = "l";
    CharCode[CharCode["m"] = 109] = "m";
    CharCode[CharCode["n"] = 110] = "n";
    CharCode[CharCode["o"] = 111] = "o";
    CharCode[CharCode["p"] = 112] = "p";
    CharCode[CharCode["q"] = 113] = "q";
    CharCode[CharCode["r"] = 114] = "r";
    CharCode[CharCode["s"] = 115] = "s";
    CharCode[CharCode["t"] = 116] = "t";
    CharCode[CharCode["u"] = 117] = "u";
    CharCode[CharCode["v"] = 118] = "v";
    CharCode[CharCode["w"] = 119] = "w";
    CharCode[CharCode["x"] = 120] = "x";
    CharCode[CharCode["y"] = 121] = "y";
    CharCode[CharCode["z"] = 122] = "z";
    CharCode[CharCode["A"] = 65] = "A";
    CharCode[CharCode["B"] = 66] = "B";
    CharCode[CharCode["C"] = 67] = "C";
    CharCode[CharCode["D"] = 68] = "D";
    CharCode[CharCode["E"] = 69] = "E";
    CharCode[CharCode["F"] = 70] = "F";
    CharCode[CharCode["G"] = 71] = "G";
    CharCode[CharCode["H"] = 72] = "H";
    CharCode[CharCode["I"] = 73] = "I";
    CharCode[CharCode["J"] = 74] = "J";
    CharCode[CharCode["K"] = 75] = "K";
    CharCode[CharCode["L"] = 76] = "L";
    CharCode[CharCode["M"] = 77] = "M";
    CharCode[CharCode["N"] = 78] = "N";
    CharCode[CharCode["O"] = 79] = "O";
    CharCode[CharCode["P"] = 80] = "P";
    CharCode[CharCode["Q"] = 81] = "Q";
    CharCode[CharCode["R"] = 82] = "R";
    CharCode[CharCode["S"] = 83] = "S";
    CharCode[CharCode["T"] = 84] = "T";
    CharCode[CharCode["U"] = 85] = "U";
    CharCode[CharCode["V"] = 86] = "V";
    CharCode[CharCode["W"] = 87] = "W";
    CharCode[CharCode["X"] = 88] = "X";
    CharCode[CharCode["Y"] = 89] = "Y";
    CharCode[CharCode["Z"] = 90] = "Z";
    CharCode[CharCode["AMPERSAND"] = 38] = "AMPERSAND";
    CharCode[CharCode["ASTERISK"] = 42] = "ASTERISK";
    CharCode[CharCode["AT"] = 64] = "AT";
    CharCode[CharCode["BACKSLASH"] = 92] = "BACKSLASH";
    CharCode[CharCode["BACKTICK"] = 96] = "BACKTICK";
    CharCode[CharCode["BAR"] = 124] = "BAR";
    CharCode[CharCode["CARET"] = 94] = "CARET";
    CharCode[CharCode["CLOSEBRACE"] = 125] = "CLOSEBRACE";
    CharCode[CharCode["CLOSEBRACKET"] = 93] = "CLOSEBRACKET";
    CharCode[CharCode["CLOSEPAREN"] = 41] = "CLOSEPAREN";
    CharCode[CharCode["COLON"] = 58] = "COLON";
    CharCode[CharCode["COMMA"] = 44] = "COMMA";
    CharCode[CharCode["DOLLAR"] = 36] = "DOLLAR";
    CharCode[CharCode["DOT"] = 46] = "DOT";
    CharCode[CharCode["DOUBLEQUOTE"] = 34] = "DOUBLEQUOTE";
    CharCode[CharCode["EQUALS"] = 61] = "EQUALS";
    CharCode[CharCode["EXCLAMATION"] = 33] = "EXCLAMATION";
    CharCode[CharCode["GREATERTHAN"] = 62] = "GREATERTHAN";
    CharCode[CharCode["HASH"] = 35] = "HASH";
    CharCode[CharCode["LESSTHAN"] = 60] = "LESSTHAN";
    CharCode[CharCode["MINUS"] = 45] = "MINUS";
    CharCode[CharCode["OPENBRACE"] = 123] = "OPENBRACE";
    CharCode[CharCode["OPENBRACKET"] = 91] = "OPENBRACKET";
    CharCode[CharCode["OPENPAREN"] = 40] = "OPENPAREN";
    CharCode[CharCode["PERCENT"] = 37] = "PERCENT";
    CharCode[CharCode["PLUS"] = 43] = "PLUS";
    CharCode[CharCode["QUESTION"] = 63] = "QUESTION";
    CharCode[CharCode["SEMICOLON"] = 59] = "SEMICOLON";
    CharCode[CharCode["SINGLEQUOTE"] = 39] = "SINGLEQUOTE";
    CharCode[CharCode["SLASH"] = 47] = "SLASH";
    CharCode[CharCode["TILDE"] = 126] = "TILDE";
    CharCode[CharCode["BACKSPACE"] = 8] = "BACKSPACE";
    CharCode[CharCode["FORMFEED"] = 12] = "FORMFEED";
    CharCode[CharCode["BYTEORDERMARK"] = 65279] = "BYTEORDERMARK";
    CharCode[CharCode["TAB"] = 9] = "TAB";
    CharCode[CharCode["VERTICALTAB"] = 11] = "VERTICALTAB";
})(CharCode = exports.CharCode || (exports.CharCode = {}));
/** Tests if the specified character code is some sort of line break. */
function isLineBreak(c) {
    switch (c) {
        case 10 /* LINEFEED */:
        case 13 /* CARRIAGERETURN */:
        case 8232 /* LINESEPARATOR */:
        case 8233 /* PARAGRAPHSEPARATOR */: {
            return true;
        }
        default: {
            return false;
        }
    }
}
exports.isLineBreak = isLineBreak;
/** Tests if the specified character code is some sort of white space. */
function isWhiteSpace(c) {
    switch (c) {
        case 32 /* SPACE */:
        case 9 /* TAB */:
        case 11 /* VERTICALTAB */:
        case 12 /* FORMFEED */:
        case 160 /* NONBREAKINGSPACE */:
        case 133 /* NEXTLINE */:
        case 5760 /* OGHAM */:
        case 8239 /* NARROWNOBREAKSPACE */:
        case 8287 /* MATHEMATICALSPACE */:
        case 12288 /* IDEOGRAPHICSPACE */:
        case 65279 /* BYTEORDERMARK */: {
            return true;
        }
        default: {
            return c >= 8192 /* ENQUAD */ && c <= 8203 /* ZEROWIDTHSPACE */;
        }
    }
}
exports.isWhiteSpace = isWhiteSpace;
/** Tests if the specified character code is a valid decimal digit. */
function isDecimalDigit(c) {
    return c >= 48 /* _0 */ && c <= 57 /* _9 */;
}
exports.isDecimalDigit = isDecimalDigit;
/** Tests if the specified character code is a valid octal digit. */
function isOctalDigit(c) {
    return c >= 48 /* _0 */ && c <= 55 /* _7 */;
}
exports.isOctalDigit = isOctalDigit;
/** Tests if the specified character code is a valid start of an identifier. */
function isIdentifierStart(c) {
    return c >= 97 /* a */ && c <= 122 /* z */
        || c >= 65 /* A */ && c <= 90 /* Z */
        || c == 95 /* _ */
        || c == 36 /* DOLLAR */
        || c > 0x7f && isUnicodeIdentifierStart(c);
}
exports.isIdentifierStart = isIdentifierStart;
/** Tests if the specified character code is a valid keyword character. */
function isKeywordCharacter(c) {
    return c >= 97 /* a */ && c <= 122 /* z */;
}
exports.isKeywordCharacter = isKeywordCharacter;
/** Tests if the specified character code is a valid part of an identifier. */
function isIdentifierPart(c) {
    return c >= 97 /* a */ && c <= 122 /* z */
        || c >= 65 /* A */ && c <= 90 /* Z */
        || c >= 48 /* _0 */ && c <= 57 /* _9 */
        || c == 95 /* _ */
        || c == 36 /* DOLLAR */
        || c > 0x7f && isUnicodeIdentifierPart(c);
}
exports.isIdentifierPart = isIdentifierPart;
// storing as u16 to save memory
const unicodeIdentifierStart = [
    170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736,
    740, 748, 748, 750, 750, 880, 884, 886, 887, 890, 893, 902, 902, 904, 906,
    908, 908, 910, 929, 931,
    1013, 1015, 1153, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514,
    1520, 1522, 1568, 1610, 1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774,
    1775, 1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957, 1969, 1969,
    1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069, 2074, 2074, 2084, 2084, 2088,
    2088, 2112, 2136, 2208, 2208, 2210, 2220, 2308, 2361, 2365, 2365, 2384, 2384,
    2392, 2401, 2417, 2423, 2425, 2431, 2437, 2444, 2447, 2448, 2451, 2472, 2474,
    2480, 2482, 2482, 2486, 2489, 2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529,
    2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613,
    2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2701, 2703, 2705,
    2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784,
    2785, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873,
    2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929, 2947, 2947, 2949, 2954, 2958,
    2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986,
    2990, 3001, 3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125,
    3129, 3133, 3133, 3160, 3161, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240,
    3242, 3251, 3253, 3257, 3261, 3261, 3294, 3294, 3296, 3297, 3313, 3314, 3333,
    3340, 3342, 3344, 3346, 3386, 3389, 3389, 3406, 3406, 3424, 3425, 3450, 3455,
    3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634,
    3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725,
    3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757,
    3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3807, 3840, 3840,
    3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138, 4159, 4159, 4176, 4181, 4186,
    4189, 4193, 4193, 4197, 4198, 4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293,
    4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696,
    4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798,
    4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4992,
    5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872,
    5888, 5900, 5902, 5905, 5920, 5937, 5952, 5969, 5984, 5996, 5998, 6000, 6016,
    6067, 6103, 6103, 6108, 6108, 6176, 6263, 6272, 6312, 6314, 6314, 6320, 6389,
    6400, 6428, 6480, 6509, 6512, 6516, 6528, 6571, 6593, 6599, 6656, 6678, 6688,
    6740, 6823, 6823, 6917, 6963, 6981, 6987, 7043, 7072, 7086, 7087, 7098, 7141,
    7168, 7203, 7245, 7247, 7258, 7293, 7401, 7404, 7406, 7409, 7413, 7414, 7424,
    7615, 7680, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025,
    8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130,
    8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188,
    8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455, 8458, 8467, 8469,
    8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505,
    8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584,
    11264, 11310, 11312, 11358, 11360, 11492, 11499, 11502, 11506, 11507, 11520,
    11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11648, 11670,
    11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720,
    11726, 11728, 11734, 11736, 11742, 11823, 11823, 12293, 12295, 12321, 12329,
    12337, 12341, 12344, 12348, 12353, 12438, 12445, 12447, 12449, 12538, 12540,
    12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893,
    19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42527, 42538,
    42539, 42560, 42606, 42623, 42647, 42656, 42735, 42775, 42783, 42786, 42888,
    42891, 42894, 42896, 42899, 42912, 42922, 43000, 43009, 43011, 43013, 43015,
    43018, 43020, 43042, 43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259,
    43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442, 43471, 43471, 43520,
    43560, 43584, 43586, 43588, 43595, 43616, 43638, 43642, 43642, 43648, 43695,
    43697, 43697, 43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714, 43739,
    43741, 43744, 43754, 43762, 43764, 43777, 43782, 43785, 43790, 43793, 43798,
    43808, 43814, 43816, 43822, 43968, 44002, 44032, 55203, 55216, 55238, 55243,
    55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64285,
    64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323,
    64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019,
    65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474,
    65479, 65482, 65487, 65490, 65495, 65498, 65500,
];
const unicodeIdentifierPart = [
    170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736,
    740, 748, 748, 750, 750, 768, 884, 886, 887, 890, 893, 902, 902, 904, 906,
    908, 908, 910, 929, 931,
    1013, 1015, 1153, 1155, 1159, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415,
    1425, 1469, 1471, 1471, 1473, 1474, 1476, 1477, 1479, 1479, 1488, 1514, 1520,
    1522, 1552, 1562, 1568, 1641, 1646, 1747, 1749, 1756, 1759, 1768, 1770, 1788,
    1791, 1791, 1808, 1866, 1869, 1969, 1984, 2037, 2042, 2042, 2048, 2093, 2112,
    2139, 2208, 2208, 2210, 2220, 2276, 2302, 2304, 2403, 2406, 2415, 2417, 2423,
    2425, 2431, 2433, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482,
    2482, 2486, 2489, 2492, 2500, 2503, 2504, 2507, 2510, 2519, 2519, 2524, 2525,
    2527, 2531, 2534, 2545, 2561, 2563, 2565, 2570, 2575, 2576, 2579, 2600, 2602,
    2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632,
    2635, 2637, 2641, 2641, 2649, 2652, 2654, 2654, 2662, 2677, 2689, 2691, 2693,
    2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757,
    2759, 2761, 2763, 2765, 2768, 2768, 2784, 2787, 2790, 2799, 2817, 2819, 2821,
    2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2876, 2884,
    2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2915, 2918, 2927, 2929,
    2929, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972,
    2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3006, 3010, 3014, 3016, 3018,
    3021, 3024, 3024, 3031, 3031, 3046, 3055, 3073, 3075, 3077, 3084, 3086, 3088,
    3090, 3112, 3114, 3123, 3125, 3129, 3133, 3140, 3142, 3144, 3146, 3149, 3157,
    3158, 3160, 3161, 3168, 3171, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216,
    3218, 3240, 3242, 3251, 3253, 3257, 3260, 3268, 3270, 3272, 3274, 3277, 3285,
    3286, 3294, 3294, 3296, 3299, 3302, 3311, 3313, 3314, 3330, 3331, 3333, 3340,
    3342, 3344, 3346, 3386, 3389, 3396, 3398, 3400, 3402, 3406, 3415, 3415, 3424,
    3427, 3430, 3439, 3450, 3455, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515,
    3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570,
    3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3719, 3720,
    3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751,
    3751, 3754, 3755, 3757, 3769, 3771, 3773, 3776, 3780, 3782, 3782, 3784, 3789,
    3792, 3801, 3804, 3807, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895,
    3895, 3897, 3897, 3902, 3911, 3913, 3948, 3953, 3972, 3974, 3991, 3993, 4028,
    4038, 4038, 4096, 4169, 4176, 4253, 4256, 4293, 4295, 4295, 4301, 4301, 4304,
    4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744,
    4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808,
    4822, 4824, 4880, 4882, 4885, 4888, 4954, 4957, 4959, 4992, 5007, 5024, 5108,
    5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902,
    5908, 5920, 5940, 5952, 5971, 5984, 5996, 5998, 6000, 6002, 6003, 6016, 6099,
    6103, 6103, 6108, 6109, 6112, 6121, 6155, 6157, 6160, 6169, 6176, 6263, 6272,
    6314, 6320, 6389, 6400, 6428, 6432, 6443, 6448, 6459, 6470, 6509, 6512, 6516,
    6528, 6571, 6576, 6601, 6608, 6617, 6656, 6683, 6688, 6750, 6752, 6780, 6783,
    6793, 6800, 6809, 6823, 6823, 6912, 6987, 6992, 7001, 7019, 7027, 7040, 7155,
    7168, 7223, 7232, 7241, 7245, 7293, 7376, 7378, 7380, 7414, 7424, 7654, 7676,
    7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027,
    8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134,
    8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8204, 8205,
    8255, 8256, 8276, 8276, 8305, 8305, 8319, 8319, 8336, 8348, 8400, 8412, 8417,
    8417, 8421, 8432, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477,
    8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517,
    8521, 8526, 8526, 8544, 8584,
    11264, 11310, 11312, 11358, 11360, 11492, 11499, 11507, 11520, 11557, 11559,
    11559, 11565, 11565, 11568, 11623, 11631, 11631, 11647, 11670, 11680, 11686,
    11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728,
    11734, 11736, 11742, 11744, 11775, 11823, 11823, 12293, 12295, 12321, 12335,
    12337, 12341, 12344, 12348, 12353, 12438, 12441, 12442, 12445, 12447, 12449,
    12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799,
    13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512,
    42539, 42560, 42607, 42612, 42621, 42623, 42647, 42655, 42737, 42775, 42783,
    42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43000, 43047, 43072,
    43123, 43136, 43204, 43216, 43225, 43232, 43255, 43259, 43259, 43264, 43309,
    43312, 43347, 43360, 43388, 43392, 43456, 43471, 43481, 43520, 43574, 43584,
    43597, 43600, 43609, 43616, 43638, 43642, 43643, 43648, 43714, 43739, 43741,
    43744, 43759, 43762, 43766, 43777, 43782, 43785, 43790, 43793, 43798, 43808,
    43814, 43816, 43822, 43968, 44010, 44012, 44013, 44016, 44025, 44032, 55203,
    55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275,
    64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321,
    64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008,
    65019, 65024, 65039, 65056, 65062, 65075, 65076, 65101, 65103, 65136, 65140,
    65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65382,
    65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500,
];
function lookupInUnicodeMap(code, map) {
    if (code < map[0])
        return false;
    var lo = 0;
    var hi = map.length;
    var mid;
    var midVal;
    while (lo + 1 < hi) {
        mid = lo + ((hi - lo) >> 1);
        mid -= (mid & 1);
        midVal = map[mid];
        if (midVal <= code && code <= map[mid + 1]) {
            return true;
        }
        if (code < midVal) {
            hi = mid;
        }
        else {
            lo = mid + 2;
        }
    }
    return false;
}
function isUnicodeIdentifierStart(code) {
    return code < 0 || code > 0xffff ? false
        : lookupInUnicodeMap(code, unicodeIdentifierStart);
}
function isUnicodeIdentifierPart(code) {
    return code < 0 || code > 0xffff ? false
        : lookupInUnicodeMap(code, unicodeIdentifierPart);
}


/***/ }),

/***/ "./src/util/collections.ts":
/*!*********************************!*\
  !*** ./src/util/collections.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function makeArray(original = null) {
    if (original) {
        let cloned = new Array(original.length);
        for (let i = 0, k = original.length; i < k; ++i)
            unchecked(cloned[i] = original[i]);
        return cloned;
    }
    return new Array();
}
exports.makeArray = makeArray;
function makeSet(original = null) {
    if (original) {
        let cloned = new Set();
        for (let v of original)
            cloned.add(v);
        return cloned;
    }
    return new Set();
}
exports.makeSet = makeSet;
function makeMap(original = null, overrides = null) {
    var cloned = new Map();
    if (original) {
        for (let [k, v] of original)
            cloned.set(k, v);
        if (overrides)
            for (let [k, v] of overrides)
                cloned.set(k, v);
    }
    else if (overrides) {
        for (let [k, v] of overrides)
            cloned.set(k, v);
    }
    return cloned;
}
exports.makeMap = makeMap;


/***/ }),

/***/ "./src/util/index.ts":
/*!***************************!*\
  !*** ./src/util/index.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Various compiler utilities.
 * @module util
 * @preferred
 */ /***/
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./bitset */ "./src/util/bitset.ts"));
__export(__webpack_require__(/*! ./charcode */ "./src/util/charcode.ts"));
__export(__webpack_require__(/*! ./collections */ "./src/util/collections.ts"));
__export(__webpack_require__(/*! ./path */ "./src/util/path.ts"));
__export(__webpack_require__(/*! ./text */ "./src/util/text.ts"));
__export(__webpack_require__(/*! ./binary */ "./src/util/binary.ts"));
/** Tests if `x` is a power of two. */
function isPowerOf2(x) {
    return x != 0 && (x & (x - 1)) == 0;
}
exports.isPowerOf2 = isPowerOf2;


/***/ }),

/***/ "./src/util/path.ts":
/*!**************************!*\
  !*** ./src/util/path.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/** @module util */ /***/
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = __webpack_require__(/*! ../common */ "./src/common.ts");
const separator = 47 /* SLASH */;
/**
 * Normalizes the specified path, removing interior placeholders.
 * Expects a posix-compatible relative path (not Windows compatible).
 */
function normalizePath(path) {
    var pos = 0;
    var len = path.length;
    // trim leading './'
    while (pos + 1 < len &&
        path.charCodeAt(pos) == 46 /* DOT */ &&
        path.charCodeAt(pos + 1) == separator) {
        pos += 2;
    }
    if (pos > 0 || len < path.length) {
        path = path.substring(pos, len);
        len -= pos;
        pos = 0;
    }
    var atEnd;
    while (pos + 1 < len) {
        atEnd = false;
        // we are only interested in '/.' sequences ...
        if (path.charCodeAt(pos) == separator &&
            path.charCodeAt(pos + 1) == 46 /* DOT */) {
            // '/.' ( '/' | $ )
            atEnd = pos + 2 == len;
            if (atEnd ||
                pos + 2 < len &&
                    path.charCodeAt(pos + 2) == separator) {
                path = atEnd
                    ? path.substring(0, pos)
                    : path.substring(0, pos) + path.substring(pos + 2);
                len -= 2;
                continue;
            }
            // '/.' ( './' | '.' $ )
            atEnd = pos + 3 == len;
            if (atEnd && path.charCodeAt(pos + 2) == 46 /* DOT */ ||
                pos + 3 < len &&
                    path.charCodeAt(pos + 2) == 46 /* DOT */ &&
                    path.charCodeAt(pos + 3) == separator) {
                // find preceeding '/'
                let ipos = pos;
                while (--ipos >= 0) {
                    if (path.charCodeAt(ipos) == separator) {
                        if (pos - ipos != 3 ||
                            path.charCodeAt(ipos + 1) != 46 /* DOT */ ||
                            path.charCodeAt(ipos + 2) != 46 /* DOT */) { // exclude '..' itself
                            path = atEnd
                                ? path.substring(0, ipos)
                                : path.substring(0, ipos) + path.substring(pos + 3);
                            len -= pos + 3 - ipos;
                            pos = ipos - 1; // incremented again at end of loop
                        }
                        break;
                    }
                }
                // if there's no preceeding '/', trim start if non-empty
                if (ipos < 0 && pos > 0) {
                    if (pos != 2 ||
                        path.charCodeAt(0) != 46 /* DOT */ ||
                        path.charCodeAt(1) != 46 /* DOT */) { // exclude '..' itself
                        path = path.substring(pos + 4);
                        len = path.length;
                        continue;
                    }
                }
            }
        }
        pos++;
    }
    return len > 0 ? path : ".";
}
exports.normalizePath = normalizePath;
/** Resolves the specified path relative to the specified origin. */
function resolvePath(normalizedPath, origin) {
    if (normalizedPath.startsWith("std/")) {
        return normalizedPath;
    }
    return normalizePath(dirname(origin) + common_1.PATH_DELIMITER + normalizedPath);
}
exports.resolvePath = resolvePath;
/** Obtains the directory portion of a normalized path. */
function dirname(normalizedPath) {
    var pos = normalizedPath.length;
    if (pos <= 1) {
        if (pos == 0)
            return ".";
        if (normalizedPath.charCodeAt(0) == separator) {
            return normalizedPath;
        }
    }
    while (--pos > 0) {
        if (normalizedPath.charCodeAt(pos) == separator) {
            return normalizedPath.substring(0, pos);
        }
    }
    return ".";
}
exports.dirname = dirname;


/***/ }),

/***/ "./src/util/text.ts":
/*!**************************!*\
  !*** ./src/util/text.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/** @module util */ /***/
Object.defineProperty(exports, "__esModule", { value: true });
const indentX1 = "  ";
const indentX2 = "    ";
const indentX4 = "        ";
/** Creates an indentation matching the number of specified levels. */
function indent(sb, level) {
    while (level >= 4) {
        sb.push(indentX4);
        level -= 4;
    }
    if (level >= 2) {
        sb.push(indentX2);
        level -= 2;
    }
    if (level) {
        sb.push(indentX1);
    }
}
exports.indent = indent;


/***/ }),

/***/ "./std/assembly/shared/feature.ts":
/*!****************************************!*\
  !*** ./std/assembly/shared/feature.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// This file is shared with the compiler and must remain portable
Object.defineProperty(exports, "__esModule", { value: true });
/** Indicates specific features to activate. */
var Feature;
(function (Feature) {
    /** No additional features. */
    Feature[Feature["NONE"] = 0] = "NONE";
    /** Sign extension operations. */
    Feature[Feature["SIGN_EXTENSION"] = 1] = "SIGN_EXTENSION";
    /** Mutable global imports and exports. */
    Feature[Feature["MUTABLE_GLOBALS"] = 2] = "MUTABLE_GLOBALS";
    /** Non-trapping float to integer operations. */
    Feature[Feature["NONTRAPPING_F2I"] = 4] = "NONTRAPPING_F2I";
    /** Bulk memory operations. */
    Feature[Feature["BULK_MEMORY"] = 8] = "BULK_MEMORY";
    /** SIMD types and operations. */
    Feature[Feature["SIMD"] = 16] = "SIMD";
    /** Threading and atomic operations. */
    Feature[Feature["THREADS"] = 32] = "THREADS";
    /** Exception handling operations. */
    Feature[Feature["EXCEPTION_HANDLING"] = 64] = "EXCEPTION_HANDLING";
    /** Tail call operations. */
    Feature[Feature["TAIL_CALLS"] = 128] = "TAIL_CALLS";
    /** Reference types. */
    Feature[Feature["REFERENCE_TYPES"] = 256] = "REFERENCE_TYPES"; // see: https://github.com/WebAssembly/reference-types
})(Feature = exports.Feature || (exports.Feature = {}));
/** Gets the name of the specified feature one would specify on the command line. */
function featureToString(feature) {
    switch (feature) {
        case 1 /* SIGN_EXTENSION */: return "sign-extension";
        case 2 /* MUTABLE_GLOBALS */: return "mutable-globals";
        case 4 /* NONTRAPPING_F2I */: return "nontrapping-f2i";
        case 8 /* BULK_MEMORY */: return "bulk-memory";
        case 16 /* SIMD */: return "simd";
        case 32 /* THREADS */: return "threads";
        case 64 /* EXCEPTION_HANDLING */: return "exception-handling";
        case 128 /* TAIL_CALLS */: return "tail-calls";
        case 256 /* REFERENCE_TYPES */: return "reference-types";
    }
    assert(false);
    return "";
}
exports.featureToString = featureToString;


/***/ }),

/***/ "./std/assembly/shared/target.ts":
/*!***************************************!*\
  !*** ./std/assembly/shared/target.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// This file is shared with the compiler and must remain portable
Object.defineProperty(exports, "__esModule", { value: true });
/** Compilation target. */
var Target;
(function (Target) {
    /** WebAssembly with 32-bit pointers. */
    Target[Target["WASM32"] = 0] = "WASM32";
    /** WebAssembly with 64-bit pointers. Experimental and not supported by any runtime yet. */
    Target[Target["WASM64"] = 1] = "WASM64";
    /** Portable. */
    Target[Target["JS"] = 2] = "JS";
})(Target = exports.Target || (exports.Target = {}));


/***/ }),

/***/ "./std/assembly/shared/typeinfo.ts":
/*!*****************************************!*\
  !*** ./std/assembly/shared/typeinfo.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// This file is shared with the compiler and must remain portable
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
// ╒═══════════════════ Typeinfo interpretation ═══════════════════╕
//    3                   2                   1
//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits
// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤ ◄─ __rtti_base
// │                             count                             │
// ╞═══════════════════════════════════════════════════════════════╡ ┐
// │                      Typeinfo#flags [id=0]                    │ id < count
// ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤
// │                      Typeinfo#base  [id=0]                    │
// ├───────────────────────────────────────────────────────────────┤
// │                              ...                              │
/** Runtime type information data structure. */
let Typeinfo = class Typeinfo {
};
Typeinfo = __decorate([
    unmanaged
], Typeinfo);
exports.Typeinfo = Typeinfo;
/** Runtime type information flags. */
var TypeinfoFlags;
(function (TypeinfoFlags) {
    /** No specific flags. */
    TypeinfoFlags[TypeinfoFlags["NONE"] = 0] = "NONE";
    /** Type is an `ArrayBufferView`. */
    TypeinfoFlags[TypeinfoFlags["ARRAYBUFFERVIEW"] = 1] = "ARRAYBUFFERVIEW";
    /** Type is an `Array`. */
    TypeinfoFlags[TypeinfoFlags["ARRAY"] = 2] = "ARRAY";
    /** Type is a `Set`. */
    TypeinfoFlags[TypeinfoFlags["SET"] = 4] = "SET";
    /** Type is a `Map`. */
    TypeinfoFlags[TypeinfoFlags["MAP"] = 8] = "MAP";
    /** Type is inherently acyclic. */
    TypeinfoFlags[TypeinfoFlags["ACYCLIC"] = 16] = "ACYCLIC";
    /** Value alignment of 1 byte. */
    TypeinfoFlags[TypeinfoFlags["VALUE_ALIGN_0"] = 32] = "VALUE_ALIGN_0";
    /** Value alignment of 2 bytes. */
    TypeinfoFlags[TypeinfoFlags["VALUE_ALIGN_1"] = 64] = "VALUE_ALIGN_1";
    /** Value alignment of 4 bytes. */
    TypeinfoFlags[TypeinfoFlags["VALUE_ALIGN_2"] = 128] = "VALUE_ALIGN_2";
    /** Value alignment of 8 bytes. */
    TypeinfoFlags[TypeinfoFlags["VALUE_ALIGN_3"] = 256] = "VALUE_ALIGN_3";
    /** Value alignment of 16 bytes. */
    TypeinfoFlags[TypeinfoFlags["VALUE_ALIGN_4"] = 512] = "VALUE_ALIGN_4";
    /** Value is a signed type. */
    TypeinfoFlags[TypeinfoFlags["VALUE_SIGNED"] = 1024] = "VALUE_SIGNED";
    /** Value is a float type. */
    TypeinfoFlags[TypeinfoFlags["VALUE_FLOAT"] = 2048] = "VALUE_FLOAT";
    /** Value type is nullable. */
    TypeinfoFlags[TypeinfoFlags["VALUE_NULLABLE"] = 4096] = "VALUE_NULLABLE";
    /** Value type is managed. */
    TypeinfoFlags[TypeinfoFlags["VALUE_MANAGED"] = 8192] = "VALUE_MANAGED";
    /** Key alignment of 1 byte. */
    TypeinfoFlags[TypeinfoFlags["KEY_ALIGN_0"] = 16384] = "KEY_ALIGN_0";
    /** Key alignment of 2 bytes. */
    TypeinfoFlags[TypeinfoFlags["KEY_ALIGN_1"] = 32768] = "KEY_ALIGN_1";
    /** Key alignment of 4 bytes. */
    TypeinfoFlags[TypeinfoFlags["KEY_ALIGN_2"] = 65536] = "KEY_ALIGN_2";
    /** Key alignment of 8 bytes. */
    TypeinfoFlags[TypeinfoFlags["KEY_ALIGN_3"] = 131072] = "KEY_ALIGN_3";
    /** Key alignment of 16 bytes. */
    TypeinfoFlags[TypeinfoFlags["KEY_ALIGN_4"] = 262144] = "KEY_ALIGN_4";
    /** Key is a signed type. */
    TypeinfoFlags[TypeinfoFlags["KEY_SIGNED"] = 524288] = "KEY_SIGNED";
    /** Key is a float type. */
    TypeinfoFlags[TypeinfoFlags["KEY_FLOAT"] = 1048576] = "KEY_FLOAT";
    /** Key type is nullable. */
    TypeinfoFlags[TypeinfoFlags["KEY_NULLABLE"] = 2097152] = "KEY_NULLABLE";
    /** Key type is managed. */
    TypeinfoFlags[TypeinfoFlags["KEY_MANAGED"] = 4194304] = "KEY_MANAGED";
})(TypeinfoFlags = exports.TypeinfoFlags || (exports.TypeinfoFlags = {}));


/***/ }),

/***/ "./std/portable/index.js":
/*!*******************************!*\
  !*** ./std/portable/index.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/** @module std/portable *//***/

var globalScope = typeof window !== "undefined" && window || typeof global !== "undefined" && global || self;

globalScope.ASC_TARGET = 2; // Target.JS
globalScope.ASC_NO_ASSERT = false;
globalScope.ASC_MEMORY_BASE = 0;
globalScope.ASC_OPTIMIZE_LEVEL = 3;
globalScope.ASC_SHRINK_LEVEL = 0;
globalScope.ASC_FEATURE_MUTABLE_GLOBAL = false;
globalScope.ASC_FEATURE_SIGN_EXTENSION = false;
globalScope.ASC_FEATURE_BULK_MEMORY = false;
globalScope.ASC_FEATURE_SIMD = false;
globalScope.ASC_FEATURE_THREADS = false;

var F64 = new Float64Array(1);
var U64 = new Uint32Array(F64.buffer);

Object.defineProperties(
  globalScope["i8"] = function i8(value) { return value << 24 >> 24; }
, {
  "MIN_VALUE": { value: -128, writable: false },
  "MAX_VALUE": { value:  127, writable: false }
});

Object.defineProperties(
  globalScope["i16"] = function i16(value) { return value << 16 >> 16; }
, {
  "MIN_VALUE": { value: -32768, writable: false },
  "MAX_VALUE": { value:  32767, writable: false }
});

Object.defineProperties(
  globalScope["i32"] = globalScope["isize"] = function i32(value) { return value | 0; }
, {
  "MIN_VALUE": { value: -2147483648, writable: false },
  "MAX_VALUE": { value:  2147483647, writable: false }
});

Object.defineProperties(
  globalScope["u8"] = function u8(value) { return value & 0xff; }
, {
  "MIN_VALUE": { value:   0, writable: false },
  "MAX_VALUE": { value: 255, writable: false }
});

Object.defineProperties(
  globalScope["u16"] = function u16(value) { return value & 0xffff; }
, {
  "MIN_VALUE": { value:     0, writable: false },
  "MAX_VALUE": { value: 65535, writable: false }
});

Object.defineProperties(
  globalScope["u32"] = globalScope["usize"] = function u32(value) { return value >>> 0; }
, {
  "MIN_VALUE": { value:          0, writable: false },
  "MAX_VALUE": { value: 4294967295, writable: false }
});

Object.defineProperties(
  globalScope["bool"] = function bool(value) { return !!value; }
, {
  "MIN_VALUE": { value: false, writable: false },
  "MAX_VALUE": { value: true,  writable: false }
});

Object.defineProperties(
  globalScope["f32"] = function f32(value) { return Math.fround(value); }
, {
  "EPSILON":   { value: Math.fround(1.1920929e-07), writable: false },
  "MIN_VALUE": { value: Math.fround(1.4012985e-45), writable: false },
  "MAX_VALUE": { value: Math.fround(3.4028235e+38), writable: false },
  "MIN_NORMAL_VALUE":  { value:  Math.fround(1.17549435e-38), writable: false },
  "MIN_SAFE_INTEGER":  { value: -16777215, writable: false },
  "MAX_SAFE_INTEGER":  { value:  16777215, writable: false }
});

Object.defineProperties(
  globalScope["f64"] = function f64(value) { return +value; }
, {
  "EPSILON":   { value: 2.2204460492503131e-16,  writable: false },
  "MIN_VALUE": { value:                  5e-324, writable: false },
  "MAX_VALUE": { value: 1.7976931348623157e+308, writable: false },
  "MIN_NORMAL_VALUE":  { value: 2.2250738585072014e-308 , writable: false },
  "MIN_SAFE_INTEGER":  { value: -9007199254740991, writable: false },
  "MAX_SAFE_INTEGER":  { value:  9007199254740991, writable: false }
});

globalScope["clz"] = Math.clz32;

globalScope["ctz"] = function ctz(value) {
  var c = Math.clz32(value & -value);
  return value ? 31 - c : c;
};

globalScope["popcnt"] = function popcnt(value) {
  value -= value >>> 1 & 0x55555555;
  value = (value & 0x33333333) + (value >>> 2 & 0x33333333);
  return (((value + (value >>> 4)) & 0x0F0F0F0F) * 0x01010101) >>> 24;
};

globalScope["rotl"] = function rotl(value, shift) {
  shift &= 31;
  return (value << shift) | (value >>> (32 - shift));
};

globalScope["rotr"] = function rotr(value, shift) {
  shift &= 31;
  return (value >>> shift) | (value << (32 - shift));
};

globalScope["abs"] = Math.abs;

globalScope["max"] = Math.max;

globalScope["min"] = Math.min;

globalScope["ceil"] = Math.ceil;

globalScope["floor"] = Math.floor;

// Adopt code from https://github.com/rfk/wasm-polyfill
globalScope["nearest"] = function nearest(value) {
  if (Math.abs(value - Math.trunc(value)) === 0.5) {
    return 2.0 * Math.round(value * 0.5);
  }
  return Math.round(value);
};

globalScope["select"] = function select(ifTrue, ifFalse, condition) {
  return condition ? ifTrue : ifFalse;
};

globalScope["sqrt"] = Math.sqrt;

globalScope["trunc"] = Math.trunc;

globalScope["copysign"] = function copysign(x, y) {
  return Math.abs(x) * Math.sign(y);
};

globalScope["bswap"] = function bswap(value) {
  var a = value >> 8 & 0x00FF00FF;
  var b = (value & 0x00FF00FF) << 8;
  value = a | b;
  a = value >> 16 & 0x0000FFFF;
  b = (value & 0x0000FFFF) << 16;
  return a | b;
};

globalScope["bswap16"] = function bswap16(value) {
  return ((value << 8) & 0xFF00) | ((value >> 8) & 0x00FF) | (value & 0xFFFF0000);
};

function UnreachableError() {
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, UnreachableError);
  } else {
    this.stack = this.name + ": " + this.message + "\n" + new Error().stack;
  }
}
UnreachableError.prototype = Object.create(Error.prototype);
UnreachableError.prototype.name = "UnreachableError";
UnreachableError.prototype.message = "unreachable";

globalScope["unreachable"] = function unreachable() {
  throw new UnreachableError();
};

function AssertionError(message) {
  this.message = message || "assertion failed";
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, AssertionError);
  } else {
    this.stack = this.name + ": " + this.message + "\n" + new Error().stack;
  }
}
AssertionError.prototype = Object.create(Error.prototype);
AssertionError.prototype.name = "AssertionError";

globalScope["assert"] = function assert(isTrueish, message) {
  if (isTrueish) return isTrueish;
  throw new AssertionError(message);
};

globalScope["changetype"] = function changetype(value) {
  return value;
};

String["fromCharCodes"] = function fromCharCodes(arr) {
  return String.fromCharCode.apply(String, arr);
};

String["fromCodePoints"] = function fromCodePoints(arr) {
  return String.fromCodePoint.apply(String, arr);
};

if (!String.prototype.replaceAll) {
  Object.defineProperty(String.prototype, "replaceAll", {
    value: function replaceAll(search, replacment) {
      var res = this.split(search).join(replacment);
      if (!search.length) res = replacment + res + replacment;
      return res;
    }
  });
}

function defaultComparator(a, b) {
  if (a === b) {
    if (a !== 0) return 0;
    a = 1 / a, b = 1 / b;
  } else {
    var nanA = a != a, nanB = b != b;
    if (nanA | nanB) return nanA - nanB;
    if (a == null) a = String(a);
    if (b == null) b = String(b);
  }
  return a > b ? 1 : -1;
}

const arraySort = Array.prototype.sort;
Array.prototype.sort = function sort(comparator) {
  return arraySort.call(this, comparator || defaultComparator);
};

globalScope["isInteger"] = Number.isInteger;

globalScope["isFloat"] = function isFloat(arg) {
  return typeof arg === "number";
};

globalScope["isNullable"] = function isNullable(arg) {
  return true;
}

globalScope["isReference"] = function isReference(arg) {
  return typeof arg === "object" || typeof arg === "string";
};

globalScope["isFunction"] = function isFunction(arg) {
  return typeof arg === "function";
}

globalScope["isString"] = function isString(arg) {
  return typeof arg === "string" || arg instanceof String;
};

globalScope["isArray"] = Array.isArray;
globalScope["isArrayLike"] = function isArrayLike(expr) {
  return expr
    && typeof expr === 'object'
    && typeof expr.length === 'number'
    && expr.length >= 0
    && Math.trunc(expr.length) === expr.length;
};

globalScope["isDefined"] = function isDefined(expr) {
  return typeof expr !== "undefined";
}

globalScope["isConstant"] = function isConstant(expr) {
  return false;
};

globalScope["unchecked"] = function unchecked(expr) {
  return expr;
};

globalScope["fmod"] = function fmod(x, y) {
  return x % y;
};

globalScope["fmodf"] = function fmodf(x, y) {
  return Math.fround(x % y);
};

globalScope["JSMath"] = Math;

Object.defineProperties(globalScope["JSMath"], {
  sincos_sin: { value: 0.0, writable: true },
  sincos_cos: { value: 0.0, writable: true },
  signbit: {
    value: function signbit(x) {
      F64[0] = x; return Boolean((U64[1] >>> 31) & (x == x));
    }
  },
  sincos: {
    value: function sincos(x) {
      this.sincos_sin = Math.sin(x);
      this.sincos_cos = Math.cos(x);
    }
  }
});

globalScope["memory"] = (() => {
  var HEAP = new Uint8Array(0);
  var HEAP_OFFSET = 0;
  return {
    allocate: globalScope["__memory_allocate"] || function allocate(size) {
      if (!(size >>>= 0)) return 0;
      if (HEAP_OFFSET + size > HEAP.length) {
        var oldHeap = HEAP;
        HEAP = new Uint8Array(Math.max(65536, HEAP.length + size, HEAP.length * 2));
        HEAP.set(oldHeap);
      }
      var ptr = HEAP_OFFSET;
      if ((HEAP_OFFSET += size) & 7) HEAP_OFFSET = (HEAP_OFFSET | 7) + 1;
      return ptr;
    },
    fill: globalScope["__memory_fill"] || function fill(dest, value, size) {
      HEAP.fill(value, dest, dest + size);
    },
    free: globalScope["__memory_free"] || function free(ptr) { },
    copy: globalScope["__memory_copy"] || function copy(dest, src, size) {
      HEAP.copyWithin(dest, src, src + size);
    },
    reset: globalScope["__memory_reset"] || function reset() {
      HEAP = new Uint8Array(0);
      HEAP_OFFSET = 0;
    }
  };
})();

globalScope["store"] = globalScope["__store"] || function store(ptr, value, offset) {
  HEAP[(ptr | 0) + (offset | 0)] = value;
};

globalScope["load"] = globalScope["__load"] || function load(ptr, offset) {
  return HEAP[(ptr | 0) + (offset | 0)];
};

globalScope["unmanaged"] = function() {};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ 0:
/*!******************************************!*\
  !*** multi ./src/glue/js ./src/index.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./src/glue/js */"./src/glue/js/index.ts");
module.exports = __webpack_require__(/*! ./src/index.ts */"./src/index.ts");


/***/ }),

/***/ "binaryen":
/*!***************************!*\
  !*** external "binaryen" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_binaryen__;

/***/ })

/******/ });
});
//# sourceMappingURL=assemblyscript.js.map